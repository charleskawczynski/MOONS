      module current_precision_mod
      implicit none

      private
      public :: cp,li
      public :: pow
      public :: equal
      public :: machine_epsilon

#ifdef _QUAD_PRECISION_
       integer,parameter :: cp = selected_real_kind(32) ! Quad precision
#else
#ifdef _SINGLE_PRECISION_
       integer,parameter :: cp = selected_real_kind(8)  ! Single precision
#else
       integer,parameter :: cp = selected_real_kind(14) ! Double precision (default)
#endif
#endif

       real(cp),parameter :: machine_epsilon = epsilon(1.0_cp)
       integer,parameter :: li = selected_int_kind(16)
       ! integer,parameter :: ip = selected_int_kind(8)  ! Short int

       ! integer,parameter :: cip = selected_int_kind(64)

       contains

       pure function pow(i) result(p)
         implicit none
         integer,intent(in) :: i
         real(cp) :: p
         p = 10.0_cp**(real(i,cp))
       end function

       pure function equal(A,B) result(L)
         implicit none
         real(cp),intent(in) :: A,B
         real(cp) :: tol
         logical :: L
         tol = 100.0_cp*machine_epsilon
         L = abs(A-B).lt.tol
       end function

      end module
       module even_odd_mod
       implicit none
       private
       public :: is_odd
       public :: is_even

       contains

       pure function is_odd(n) result(L)
         implicit none
         integer,intent(in) :: n
         logical :: L
         L = .not.is_even(n)
       end function

       pure function is_even(n) result(L)
         implicit none
         integer,intent(in) :: n
         logical :: L
         L = MOD(n,2).eq.0
       end function

       end module
      module exp_Tecplot_Header_mod
      implicit none

      private
      public :: exp_Header_3D_3C
      public :: exp_Header_2D_3C
      public :: exp_Header_1D_3C

      public :: exp_Header_3D_2C
      public :: exp_Header_2D_2C
      public :: exp_Header_1D_2C

      public :: exp_Header_3D_1C
      public :: exp_Header_2D_1C
      public :: exp_Header_1D_1C

      public :: exp_Header_0D_1C

      contains

      ! *****************************************************************
      ! ************************** 3 COMPONENT **************************
      ! *****************************************************************

      subroutine exp_Header_3D_3C(u,name)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: u
        write(u,*) 'TITLE = "3D Vector Field"'
        write(u,*) 'VARIABLES = "x","y","z","'//name//'_x","'//name//'_y","'//name//'_z"'
      end subroutine

      subroutine exp_Header_2D_3C(u,dir,name)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: u,dir
        write(u,*) 'TITLE = "2D Vector Field"'
        select case (dir)
        case (1); write(u,*) 'VARIABLES = "y","z","'//name//'_x","'//name//'_y","'//name//'_z"'
        case (2); write(u,*) 'VARIABLES = "x","z","'//name//'_x","'//name//'_y","'//name//'_z"'
        case (3); write(u,*) 'VARIABLES = "x","y","'//name//'_x","'//name//'_y","'//name//'_z"'
        case default; stop 'Error: dir must=1:3 in exp_Header_2D_3C in exp_Tec_Header.f90'
        end select
      end subroutine

      subroutine exp_Header_1D_3C(u,dir,name)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: u,dir
        write(u,*) 'TITLE = "1D Vector Field"'
        select case (dir)
        case (1); write(u,*) 'VARIABLES = "x","'//name//'_x","'//name//'_y","'//name//'_z"'
        case (2); write(u,*) 'VARIABLES = "y","'//name//'_x","'//name//'_y","'//name//'_z"'
        case (3); write(u,*) 'VARIABLES = "z","'//name//'_x","'//name//'_y","'//name//'_z"'
        case default; stop 'Error: dir must=1:3 in exp_Header_1D_3C in exp_Tec_Header.f90'
        end select
      end subroutine

      ! *****************************************************************
      ! ************************** 2 COMPONENT **************************
      ! *****************************************************************

      subroutine exp_Header_3D_2C(u,dir,name)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: u,dir
        write(u,*) 'TITLE = "3D Vector Field"'
        select case (dir)
        case (1); write(u,*) 'VARIABLES = "x","y","z","'//name//'_y","'//name//'_z"'
        case (2); write(u,*) 'VARIABLES = "x","y","z","'//name//'_x","'//name//'_z"'
        case (3); write(u,*) 'VARIABLES = "x","y","z","'//name//'_x","'//name//'_y"'
        case default; stop 'Error: dir must=1:3 in exp_Header_3D_2C in exp_Tec_Header.f90'
        end select
      end subroutine

      subroutine exp_Header_2D_2C(u,dir,name)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: u,dir
        write(u,*) 'TITLE = "2D Vector Field"'
        select case (dir)
        case (1); write(u,*) 'VARIABLES = "y","z","'//name//'_y","'//name//'_z"'
        case (2); write(u,*) 'VARIABLES = "x","z","'//name//'_x","'//name//'_z"'
        case (3); write(u,*) 'VARIABLES = "x","y","'//name//'_x","'//name//'_y"'
        case default; stop 'Error: dir must=1:3 in exp_Header_2D_2C in exp_Tec_Header.f90'
        end select
      end subroutine

      subroutine exp_Header_1D_2C(u,dir,name)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: u,dir
        write(u,*) 'TITLE = "1D Vector Field"'
        select case (dir)
        case (1); write(u,*) 'VARIABLES = "x","'//name//'_y","'//name//'_z"'
        case (2); write(u,*) 'VARIABLES = "y","'//name//'_x","'//name//'_z"'
        case (3); write(u,*) 'VARIABLES = "z","'//name//'_x","'//name//'_y"'
        case default; stop 'Error: dir must=1:3 in exp_Header_1D_2C in exp_Tec_Header.f90'
        end select
      end subroutine

      ! *****************************************************************
      ! ************************** 1 COMPONENT **************************
      ! *****************************************************************

      subroutine exp_Header_3D_1C(u,name)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: u
        write(u,*) 'TITLE = "3D Scalar Field"'
        write(u,*) 'VARIABLES = "x","y","z","'//name//'"'
      end subroutine

      subroutine exp_Header_2D_1C(u,dir,name)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: u,dir
        write(u,*) 'TITLE = "2D Scalar Field"'
        select case (dir)
        case (1); write(u,*) 'VARIABLES = "y","z","'//name//'_x"'
        case (2); write(u,*) 'VARIABLES = "x","z","'//name//'_y"'
        case (3); write(u,*) 'VARIABLES = "x","y","'//name//'_z"'
        case default; stop 'Error: dir must=1:3 in exp_Header_2D_1C in exp_Tec_Header.f90'
        end select
      end subroutine

      subroutine exp_Header_1D_1C(u,dir,name)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: u,dir
        write(u,*) 'TITLE = "1D Scalar Field"'
        select case (dir)
        case (1); write(u,*) 'VARIABLES = "x","'//name//'"'
        case (2); write(u,*) 'VARIABLES = "y","'//name//'"'
        case (3); write(u,*) 'VARIABLES = "z","'//name//'"'
        case default; stop 'Error: dir must=1:3 in exp_Header_1D_1C in exp_Tec_Header.f90'
        end select
      end subroutine

      subroutine exp_Header_0D_1C(u,name)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: u
        write(u,*) 'TITLE = "0D Scalar Field"'
        write(u,*) 'VARIABLES = "N","'//name//'"'
      end subroutine

      end module
      module string_mod
      implicit none
      ! Implimentation:

      ! program test_string
      ! use string_mod
      ! implicit none
      ! type(string) :: s
      ! call init(s,'This is');            write(*,*) 'string = ',str(s)
      ! call append(s,' a variable');      write(*,*) 'string = ',str(s)
      ! call append(s,' sized string!');   write(*,*) 'string = ',str(s)
      ! call compress(s);                  write(*,*) 'string, no spaces = ',str(s)
      ! call delete(s)
      ! end program

      private

      character(len=4),parameter :: dot_dat = '.dat'

      public :: string
      public :: init,delete,display,print,export,import ! Essentials
      public :: new

      public :: write_formatted
      public :: string_allocated
      public :: get_str,str ! str does not require length
      public :: len,match,match_index
      public :: compress,append,prepend
      public :: get_char,set_char
      public :: remove_element
      public :: identical

      public :: set_IO_dir
      public :: make_IO_dir
      public :: export_structured
      public :: import_structured
      public :: export_primitives
      public :: import_primitives

      interface new;                  module procedure init_string_new;                end interface
      interface init;                 module procedure init_size;                      end interface
      interface init;                 module procedure init_string;                    end interface
      interface init;                 module procedure init_copy;                      end interface
      interface delete;               module procedure delete_string;                  end interface
      interface display;              module procedure display_string;                 end interface
      interface print;                module procedure print_string;                   end interface
      interface export;               module procedure export_string;                  end interface
      interface import;               module procedure import_string;                  end interface

      interface write_formatted;      module procedure write_formatted_string;         end interface
      interface string_allocated;     module procedure string_allocated_string;        end interface

      interface append;               module procedure app_string_char;                end interface
      interface append;               module procedure app_string_string;              end interface
      interface prepend;              module procedure prep_string_char;               end interface
      interface prepend;              module procedure prep_string_string;             end interface
      interface compress;             module procedure compress_string;                end interface
      interface len;                  module procedure str_len_string;                 end interface
      interface str;                  module procedure get_str_short;                  end interface
      interface get_str;              module procedure get_str_string;                 end interface
      interface match;                module procedure substring_in_string;            end interface
      interface match_index;          module procedure index_substring_in_string;      end interface
      interface get_char;             module procedure get_char_string;                end interface
      interface set_char;             module procedure set_char_string;                end interface
      interface remove_element;       module procedure remove_element_string;          end interface
      interface identical;            module procedure identical_string_string;        end interface
      interface identical;            module procedure identical_string_char;          end interface

      interface insist_allocated;     module procedure insist_allocated_string;        end interface

      ! Copied from generated code:

      interface set_IO_dir;           module procedure set_IO_dir_string;              end interface
      interface make_IO_dir;          module procedure make_IO_dir_string;             end interface
      interface export_structured;    module procedure export_structured_D_string;     end interface
      interface import_structured;    module procedure import_structured_D_string;     end interface
      interface export_primitives;    module procedure export_primitives_string;       end interface
      interface import_primitives;    module procedure import_primitives_string;       end interface
      interface suppress_warnings;    module procedure suppress_warnings_string;       end interface

      type char
        private
        character(len=1) :: c
      end type

      type string
        private
        type(char),dimension(:),allocatable :: s ! string
        integer :: n = 0                         ! string length
      end type

      contains

      subroutine init_size(st,n)
        implicit none
        type(string),intent(inout) :: st
        integer,intent(in) :: n
        if (n.lt.1) stop 'Error: string must be of size > 1 in string.f90'
        call delete(st)
        allocate(st%s(n))
        st%n = n
      end subroutine

      subroutine init_string(st,s)
        implicit none
        type(string),intent(inout) :: st
        character(len=*),intent(in) :: s
        integer :: i
        call init(st,len(s))
        do i=1,st%n
          call init_char(st%s(i),s(i:i))
        enddo
      end subroutine

      function init_string_new(s) result(st)
        implicit none
        character(len=*),intent(in) :: s
        type(string) :: st
        call init(st,s)
      end function

      subroutine init_copy(a,b)
        implicit none
        type(string),intent(inout) :: a
        type(string),intent(in) :: b
        integer :: i
        call delete(a)
        ! call insist_allocated(b,'init_copy')
        if ((b%n.gt.0).and.(string_allocated(b))) then
          call init(a,b%n)
          do i=1,b%n
          call init_copy_char(a%s(i),b%s(i))
          enddo
          a%n = b%n
        endif
      end subroutine

      subroutine delete_string(st)
        implicit none
        type(string),intent(inout) :: st
        if (allocated(st%s)) deallocate(st%s)
        st%n = 0
      end subroutine

      subroutine display_string(st,un)
        implicit none
        type(string),intent(in) :: st
        integer,intent(in) :: un
        call export(st,un)
      end subroutine

      subroutine print_string(st)
        implicit none
        type(string),intent(in) :: st
        call display(st,6)
        write(6,*) ''
      end subroutine

      subroutine export_string(st,un)
        implicit none
        type(string),intent(in) :: st
        integer,intent(in) :: un
        ! call insist_allocated(st,'export_string')
        if (string_allocated(st)) then
          write(un,*) str(st)
        else
          write(un,*) 'string not allocated'
        endif
      end subroutine

      subroutine import_string(s,un)
        implicit none
        type(string),intent(inout) :: s
        integer,intent(in) :: un
        character(len=1) :: c
        logical :: first_iteration,continue_loop
        integer :: ReadCode
        ReadCode = 0; continue_loop = .true.
        call delete(s); first_iteration = .true.
        do while (continue_loop)
          if (ReadCode.eq.0) then
            read(un,'(A)',advance='no',iostat=ReadCode) c
            if (first_iteration) then; call init(s,c); else; call append(s,c); endif
          else; continue_loop = .false.; exit
          endif; first_iteration = .false.
        enddo
        if (s%s(s%n)%c.eq.' ') call remove_element(s,s%n)
        if (s%s(1)%c.eq.' ') call remove_element(s,1)
      end subroutine

      subroutine write_formatted_string(s,un)
        implicit none
        integer,intent(in) :: un
        type(string),intent(in) :: s
        write(un,'('//int2str(len(s))//'A)') str(s)
      end subroutine

      function int2Str(i) result(s)
        implicit none
        integer,intent(in) :: i
        character(len=15) :: s
        write(s,'(I15.15)') i
        s = trim(adjustl(s))
      end function

      ! **********************************************************
      ! **********************************************************
      ! **********************************************************

      subroutine app_string_char(st,s)
        implicit none
        type(string),intent(inout) :: st
        character(len=*),intent(in) :: s
        type(string) :: temp
        integer :: i,n
        n = len(s)
        call init(temp,st)
        call init(st,temp%n+n)
        do i=1,temp%n
          call init_copy_char(st%s(i),temp%s(i))
        enddo
        do i=1,n
          call init_char(st%s(temp%n+i),s(i:i))
        enddo
        call delete(temp)
      end subroutine

      subroutine app_string_string(a,b)
        implicit none
        type(string),intent(inout) :: a
        type(string),intent(in) :: b
        call append(a,str(b))
      end subroutine

      subroutine prep_string_char(a,b)
        implicit none
        type(string),intent(inout) :: a
        character(len=*),intent(in) :: b
        type(string) :: temp
        call init(temp,b)
        call append(temp,a)
        call init(a,temp)
        call delete(temp)
      end subroutine

      subroutine prep_string_string(a,b)
        implicit none
        type(string),intent(inout) :: a
        type(string),intent(in) :: b
        call prepend(a,str(b))
      end subroutine

      subroutine compress_string(st)
        implicit none
        type(string),intent(inout) :: st
        type(string) :: temp
        integer :: i,n_spaces,k
        if (st%n.lt.1) stop 'Error: input string must be > 1 in string.f90'
        n_spaces = 0
        do i=1,st%n
          if (st%s(i)%c.eq.' ') n_spaces = n_spaces + 1
        enddo
        if (n_spaces.ne.0) then
          if (st%n-n_spaces.lt.1) stop 'Error: only spaces in string in compress_string in string.f90'
          call init(temp,st%n-n_spaces)
          k = 0
          do i=1,st%n
            if (st%s(i)%c.ne.' ') then
              temp%s(i-k)%c = st%s(i)%c
            else; k = k+1
            endif
          enddo
          call init(st,temp)
          call delete(temp)
        endif
      end subroutine

      subroutine remove_element_string(st,i)
        implicit none
        type(string),intent(inout) :: st
        integer,intent(in) :: i
        type(string) :: temp
        integer :: j,k
        if (st%n.lt.1) stop 'Error: input string must be > 1 in remove_element_string in string.f90'
        if ((i.lt.1).or.(i.gt.st%n)) stop 'Error: element out of bounds in remove_element_string in string.f90'
        k = 0
        call init(temp,st%n-1)
        do j=1,st%n
          if (i.ne.j) then
            temp%s(j-k)%c = st%s(j)%c
          else; k = 1
          endif
        enddo
        call init(st,temp)
        call delete(temp)
      end subroutine

      function identical_string_string(A,B) result(L)
        implicit none
        type(string),intent(in) :: A,B
        logical :: L
        integer :: i
        call insist_allocated(A,'A identical_string_string')
        call insist_allocated(B,'B identical_string_string')
        L = .false.
        if (A%n.eq.B%n) then
          L = .true.
          do i=1,A%n
            if (A%s(i)%c.ne.B%s(i)%c) L = .false.
          enddo
        endif
      end function

      function identical_string_char(A,B) result(L)
        implicit none
        type(string),intent(in) :: A
        character(len=*),intent(in) :: B
        type(string) :: temp
        logical :: L
        call insist_allocated(A,'A identical_string_string')
        call init(temp,B)
        L = identical(A,temp)
        call delete(temp)
      end function

      function get_char_string(st,i) result(c)
        implicit none
        type(string),intent(in) :: st
        integer,intent(in) :: i
        character(len=1) :: c
        c = st%s(i)%c
      end function

      subroutine set_char_string(st,c,i)
        implicit none
        type(string),intent(inout) :: st
        integer,intent(in) :: i
        character(len=1),intent(in) :: c
        st%s(i)%c = c
      end subroutine

      function get_str_short(st) result(str)
        type(string),intent(in) :: st
        character(len=st%n) :: str
        str = get_str_string(st,st%n)
      end function

      pure function str_len_string(s) result(n)
        type(string),intent(in) :: s
        integer :: n
        n = s%n
      end function

      function get_str_string(st,n) result(str)
        implicit none
        type(string),intent(in) :: st
        integer,intent(in) :: n
        character(len=n) :: str
        integer :: i
        call insist_allocated(st,'get_str_string')
        if (st%n.lt.1) stop 'Error: st%n.lt.0 in get_str_string in string.f90'
        if (n.lt.1) stop 'Error: n.lt.1 in get_str_string in string.f90'
        do i=1,st%n
          str(i:i) = st%s(i)%c
        enddo
      end function

      function substring_in_string(str,substr) result(L)
        implicit none
        type(string),intent(in) :: str
        character(len=*),intent(in) :: substr
        logical :: L,cond
        integer :: i,j,s
        L = .false.
        s = len(substr)
        if (s.lt.1) stop 'Error: len(substr) must be > 1 in substring_in_string in string.f90'
        do i=1,len(str)-s
          cond = all((/(str%s(i+j-1:i+j-1)%c .eq. substr(j:j),j=1,s)/))
          if (cond) then
            L = .true.
            exit
          endif
        enddo
      end function

      function index_substring_in_string(str,substr) result(index)
        implicit none
        type(string),intent(in) :: str
        character(len=*),intent(in) :: substr
        logical :: cond
        integer :: index,i,j,s
        s = len(substr)
        cond = .false.
        index = 1
        if (s.lt.1) stop 'Error: len(substr) must be > 1 in index_substring_in_string in string.f90'
        do i=1,len(str)-s
          cond = all((/(str%s(i+j-1:i+j-1)%c .eq. substr(j:j),j=1,s)/))
          if (cond) then
            index = i
            exit
          endif
        enddo
        if (.not.cond) stop 'Error: substring not found in index_substring_in_string in string.f90'
      end function

      subroutine init_char(CH,c)
        implicit none
        type(char),intent(inout) :: CH
        character(len=1),intent(in) :: c
        CH%c = c
      end subroutine

      subroutine init_copy_char(a,b)
        implicit none
        type(char),intent(inout) :: a
        type(char),intent(in) :: b
        a%c = b%c
      end subroutine

      function string_allocated_string(st) result(L)
        implicit none
        type(string),intent(in) :: st
        logical :: L
        L = allocated(st%s)
      end function

      function valid_length(st) result(L)
        implicit none
        type(string),intent(in) :: st
        logical :: L
        L = st%n.gt.0
      end function

      ! function valid_string(st) result(L)
      !   implicit none
      !   type(string),intent(in) :: st
      !   logical :: L
      !   L = string_allocated(st).and.valid_length(st)
      ! end function

      subroutine insist_allocated_string(st,s)
        implicit none
        type(string),intent(in) :: st
        character(len=*),intent(in) :: s
        if (.not.string_allocated(st)) then
          write(*,*) 'Error: string must be allocated in '//s//' in string.f90'
          stop 'Done'
        elseif (.not.valid_length(st)) then
          write(*,*) 'Error: string must have a valid length in '//s//' in string.f90'
          stop 'Done'
        endif
      end subroutine

      ! --------------------------------------------------------------------------------
      ! ----------------------------- COPIED FROM IO TOOLS -----------------------------
      ! --------------------------------------------------------------------------------

      function open_to_read(dir,name) result(un)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer :: un
        type(string) :: s
        call init(s,dir//name//dot_dat)
        un = new_unit()
        open(un,file=str(s),status = 'old',action = 'read')
        call delete(s)
      end function

      function new_and_open(dir,name) result(un)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer :: un
        type(string) :: s
        call init(s,dir//name//dot_dat)
        un = new_unit()
        call attempt_to_open_to_write(un,s,dir,name)
        call delete(s)
      end function

      function new_unit() result(nu)
        implicit none
        integer,parameter :: lun_min=10,lun_max=1000
        integer :: lun,nu
        nu=-1
        do lun=lun_min,lun_max
          if (.not.unit_open(lun)) then; nu=lun; exit; endif
        enddo
      end function

      subroutine attempt_to_open_to_write(un,s,dir,name)
        implicit none
        integer,intent(in) :: un
        type(string),intent(in) :: s
        character(len=*),intent(in) :: dir,name
        integer :: n,i
        logical :: failed
        failed = .true.
        do n=1,100000
          open(un,file=str(s),pad='YES',action='readwrite',iostat=i)
          if (i.eq.0) then; failed = .false.; exit; endif
        enddo
        if (failed) then
          write(*,*) 'Error: tried to open file but failed!!'
          write(*,*) 'File = ',str(s)
          write(*,*) 'dir = ',dir
          write(*,*) 'name = ',name
          stop 'Done in attempt_to_open_to_write in IO_tools.f90'
        endif
      end subroutine

      function unit_open(un) result(op)
        implicit none
        integer,intent(in) :: un
        logical :: op
        inquire(unit=un,opened=op)
      end function

      ! subroutine make_dir(d)
      !   implicit none
      !   character(len=*),intent(in) :: d
      !   logical :: ex
      !   inquire (file=d, EXIST=ex)
      !   if (.not.ex) then
      !     call system('mkdir ' // d )
      !     write(*,*) 'Directory ' // d // ' created.'
      !   else
      !     write(*,*) 'Directory ' // d // ' already exists.'
      !   endif
      ! end subroutine

      subroutine make_dir_quiet(d)
        implicit none
        character(len=*),intent(in) :: d
        logical :: ex
        inquire (file=d, EXIST=ex)
        if (.not.ex) call system('mkdir ' // d )
      end subroutine

      ! --------------------------------------------------------------------------------
      ! -------------------------- COPIED FROM GENERATED CODE --------------------------
      ! --------------------------------------------------------------------------------

       subroutine set_IO_dir_string(this,dir)
         implicit none
         type(string),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_string(this,dir)
         implicit none
         type(string),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_structured_D_string(this,dir)
         implicit none
         type(string),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_string(this,dir)
         implicit none
         type(string),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import(this,un)
         close(un)
       end subroutine

       subroutine export_primitives_string(this,un)
         implicit none
         type(string),intent(in) :: this
         integer,intent(in) :: un
         call export(this,un)
       end subroutine

       subroutine import_primitives_string(this,un)
         implicit none
         type(string),intent(inout) :: this
         integer,intent(in) :: un
         call import(this,un)
       end subroutine

       subroutine suppress_warnings_string(this)
         implicit none
         type(string),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

      end module
       module apply_BCs_faces_raw_mod
       ! Compiler flags: (_PARALLELIZE_APPLY_BCS_FACES_RAW_)
       use current_precision_mod
       implicit none

       private
       public :: apply_assign

       public :: apply_Dirichlet_C
       public :: apply_Dirichlet_N

       public :: apply_Neumann_C
       public :: apply_Neumann_N

       public :: apply_Periodic_C
       public :: apply_Periodic_N

       public :: apply_Symmetric_C
       public :: apply_Symmetric_N

       public :: apply_antisymmetric_C
       public :: apply_antisymmetric_N

       public :: apply_Robin_C
       public :: apply_Robin_N

       contains

       subroutine apply_assign(u,bvals,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: u
         real(cp),dimension(x,y),intent(in) :: bvals
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         u(i,j) = bvals(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_Dirichlet_C(ug,ui,bvals,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui,bvals
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = 2.0_cp*bvals(i,j) - ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_Dirichlet_N(ug,ub,ui,bvals,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug,ub
         real(cp),dimension(x,y),intent(in) :: ui,bvals
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ub(i,j) = bvals(i,j); ug(i,j) = 2.0_cp*ub(i,j) - ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_Neumann_C(ug,ui,bvals,dh_nhat,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui,bvals
         real(cp),intent(in) :: dh_nhat
         integer :: i,j

#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j) + bvals(i,j)*dh_nhat
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_Neumann_N(ug,ui,bvals,dh_nhat,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui,bvals
         real(cp),intent(in) :: dh_nhat
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j) + 2.0_cp*bvals(i,j)*dh_nhat
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_Periodic_C(ug,ui_opp,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui_opp
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui_opp(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_Periodic_N(ug,ui_opp,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui_opp
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui_opp(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_Symmetric_C(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_Symmetric_N(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_antisymmetric_C(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = -ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_antisymmetric_N(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = -ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_Robin_C(ug,ui,bvals,dh,nhat,c_w,x,y,p)
         ! u + c du/dh = 0
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui,bvals ! c = bvals
         real(cp),intent(in) :: dh,nhat,c_w
         real(cp) :: coeff_1,coeff_2
         integer :: i,j
         coeff_1 = (2.0_cp*c_w*nhat/dh-1.0_cp)/(2.0_cp*c_w*nhat/dh+1.0_cp)
         coeff_2 =  2.0_cp/(2.0_cp*c_w*nhat/dh+1.0_cp)
         coeff_2 =  0.0_cp
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j)*coeff_1 + bvals(i,j)*coeff_2
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_Robin_N(ug,ui,ub,bvals,dh,nhat,c_w,x,y,p)
         ! u + c du/dh = 0
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui,ub,bvals ! c = bvals
         real(cp),intent(in) :: dh,nhat,c_w
         real(cp) :: coeff_1,coeff_2
         integer :: i,j
         coeff_1 = -2.0_cp*dh/c_w*nhat
         coeff_2 =  2.0_cp*dh/c_w*nhat
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j) + ub(i,j)*coeff_1 + bvals(i,j)*coeff_2
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       end module
       module apply_BCs_faces_raw_implicit_mod
       ! Compiler flags: (_PARALLELIZE_APPLY_BCS_FACES_RAW_)
       use current_precision_mod
       implicit none

       private
       public :: apply_Dirichlet_C_implicit
       public :: apply_Dirichlet_N_implicit

       public :: apply_Neumann_C_implicit
       public :: apply_Neumann_N_implicit

       public :: apply_Periodic_C_implicit
       public :: apply_Periodic_N_implicit

       public :: apply_Symmetric_C_implicit
       public :: apply_Symmetric_N_implicit

       public :: apply_antisymmetric_C_implicit
       public :: apply_antisymmetric_N_implicit

       public :: apply_Robin_C_implicit
       public :: apply_Robin_N_implicit

       contains

       subroutine apply_Dirichlet_C_implicit(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = - ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_Dirichlet_N_implicit(ug,ub,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug,ub
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ub(i,j) = 0.0_cp; ug(i,j) = - ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_Neumann_C_implicit(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j

#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_Neumann_N_implicit(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_Periodic_C_implicit(ug,ui_opp,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui_opp
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui_opp(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_Periodic_N_implicit(ug,ui_opp,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui_opp
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui_opp(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_Symmetric_C_implicit(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_Symmetric_N_implicit(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_antisymmetric_C_implicit(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = -ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_antisymmetric_N_implicit(ug,ui,x,y,p)
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui
         integer :: i,j
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = -ui(i,j)
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine apply_Robin_C_implicit(ug,ui,dh,nhat,c_w,x,y,p) ! not yet tested
         ! u + c du/dh = 0
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ui ! c = bvals
         real(cp),intent(in) :: dh,nhat,c_w
         real(cp) :: coeff_1
         integer :: i,j
         coeff_1 = (2.0_cp*c_w*nhat/dh-1.0_cp)/(2.0_cp*c_w*nhat/dh+1.0_cp)
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j)*coeff_1
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine
       subroutine apply_Robin_N_implicit(ug,ub,ui,dh,nhat,c_w,x,y,p) ! not yet tested
         ! u + c du/dh = 0
         implicit none
         integer,intent(in) :: x,y,p
         real(cp),dimension(x,y),intent(inout) :: ug
         real(cp),dimension(x,y),intent(in) :: ub,ui ! c = bvals
         real(cp),intent(in) :: dh,nhat,c_w
         real(cp) :: coeff_1
         integer :: i,j
         coeff_1 = -2.0_cp*dh*nhat/c_w
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP PARALLEL DO

#endif
         do j=1+p,y-p; do i=1+p,x-p
         ug(i,j) = ui(i,j) + ub(i,j)*coeff_1
         enddo; enddo
#ifdef _PARALLELIZE_APPLY_BCS_FACES_RAW_
        !$OMP END PARALLEL DO

#endif
       end subroutine

       end module
       module constants_mod
       use current_precision_mod
       implicit none
       private
       public :: PI
       real(cp),parameter :: PI = 3.141592653589793238462643383279502884197169399375105820974_cp
       ! real(cp),parameter :: PI = 4.0_cp*atan(1.0_cp)

       public :: mu_m0 ! Permeability of free space:
       real(cp),parameter :: mu_m0 = 4.0_cp*PI**10.0_cp**(-7.0_cp) ! [NA^-2]
       end module
       module coordinate_distribution_funcs_mod
       use current_precision_mod
       implicit none

       private
       public :: uniform
       public :: linspace
       public :: uniformLeft
       public :: uniformRight
       public :: robertsLeft
       public :: robertsRight
       public :: robertsBoth
       public :: cluster
       interface uniform;           module procedure uniform_func;           end interface
       interface linspace;          module procedure linspace_func;          end interface
       interface uniformLeft;       module procedure uniformLeft_func;       end interface
       interface uniformRight;      module procedure uniformRight_func;      end interface
       interface robertsLeft;       module procedure robertsLeft_func;       end interface
       interface robertsRight;      module procedure robertsRight_func;      end interface
       interface robertsBoth;       module procedure robertsBoth_func;       end interface
       interface cluster;           module procedure cluster_func;           end interface

       real(cp),parameter :: one = 1.0_cp
       real(cp),parameter :: two = 2.0_cp
       real(cp),parameter :: zero = 0.0_cp
       real(cp),parameter :: tol = 10.0_cp**(-12.0_cp)

       contains

       ! ***************************************************************
       ! *********************** UNIFORM GRIDS *************************
       ! ***************************************************************

       function uniform_func(hmin,hmax,N) result(hn)
         ! This routine returns a uniform grid from
         ! hmin to hmax using N+1 points.
         !
         ! NOTE: hmin and hmax are included in the result.
         !
         ! INPUT:
         !      hmin     = minimum value
         !      hmax     = maximum value
         !      N        = N segments of dh
         implicit none
         real(cp),intent(in) :: hmin,hmax
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         integer :: i
         real(cp) :: dh
         if (N.lt.0) stop 'Error: N < 0 in uniform in grid_distribution_funcs.f90'
         if (N.eq.0) then
           if (abs(hmax-hmin).lt.tol) then
             dh = 0.0_cp
             hn = hmin
             else; stop 'Error: N = 0 but hmin.ne.hmax in grid_distribution_funcs.f90'
           endif
         else
           dh = (hmax - hmin)/real(N,cp)
           hn = (/(hmin+real(i-1,cp)*dh,i=1,N+1)/)
         endif
       end function

       function linspace_func(hmin,hmax,N) result(hn)
         ! This routine returns a uniform grid from
         ! hmin to hmax using N+1 points.
         !
         ! NOTE: hmin and hmax are included in the result.
         !
         ! INPUT:
         !      hmin     = minimum value
         !      hmax     = maximum value
         !      N        = N segments of dh
         implicit none
         real(cp),intent(in) :: hmin,hmax
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         integer :: i
         real(cp) :: dh
         dh = (hmax - hmin)/real(N,cp)
         hn = (/(hmin+real(i-1,cp)*dh,i=1,N+1)/)
       end function

       function uniformDirection_func(hstart,dh,N,dir) result(hn)
         ! This routine returns a uniform grid beginning
         ! from hstart with uniform step size dh.
         ! The size of the segment depends on the size
         ! of hn. dir is the positive or negative direction.
         !
         ! NOTE: hstart is included in the result.
         !
         ! INPUT:
         !      hstart   = start value
         !      dh       = step size
         !      N        = N segments
         !      dir      = (1,-1)
         implicit none
         real(cp),intent(in) :: hstart,dh
         integer,intent(in) :: N,dir
         real(cp),dimension(N+1) :: hn
         integer :: i
         if (N.lt.0) stop 'Error: N < 0 in uniformDirection in grid_distribution_funcs.f90'
         if (N.eq.0) then
           if (dh.lt.tol) then
             hn = hstart
           else; stop 'Error: N = 0 but dh.gt.tol in uniformDirection in grid_distribution_funcs.f90'
           endif
         else
           hn = (/(hstart+real(dir,cp)*real(i-1,cp)*dh,i=1,N+1)/)
           if (dir.eq.-1) call reverseIndex(hn,N+1)
         endif
       end function

       function uniformLeft_func(hstart,dh,N) result(hn)
         ! Uses uniformDirection. Output:
         !
         !                     |
         !    --|--|--|--|--|--|
         !                     |
         !                   hstart
         implicit none
         real(cp),intent(in) :: hstart,dh
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         hn = uniformDirection_func(hstart,dh,N,-1)
       end function

       function uniformRight_func(hstart,dh,N) result(hn)
         ! Uses uniformDirection. Output:
         !
         !                     |
         !                     |--|--|--|--|--|--
         !                     |
         !                   hstart
         implicit none
         real(cp),intent(in) :: hstart,dh
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         hn = uniformDirection_func(hstart,dh,N,1)
       end function

       ! ***************************************************************
       ! ********************* STRETCHED GRIDS *************************
       ! ***************************************************************

       function transformation1(hmin,hmax,N,beta) result(hn)
         ! This function returns the coordinates and differences of a Robert's
         ! stretching function as described in section 5.6 (page 333) of
         ! Computational Fluid Mechanics and Heat Transfer,
         ! 2nd edition, J. Tannehill et al. (Transormation 1)
         !
         ! INPUT:
         !      hmin     = minimum value
         !      hmax     = maximum value
         !      N        = N segments of dh
         !      beta     = 1.0 <= beta <= infinity = stretching factor
         !               = larger -> less stretching
         !
         !    y=0                         y=h
         !                                 |
         !     |-|--|---|-------|----------|
         !     |------> y
         !
         ! NOTE: I have abused notation a bit to provide consistent notation
         ! with the reference as well as generalize the returned grid
         ! so that it need not start at y=0.
         !
         implicit none
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         real(cp),intent(in) :: hmin,hmax,beta
         real(cp),dimension(:),allocatable :: hnbar
         real(cp) :: dh ! Uniform dh
         integer :: i
         real(cp) :: a,b,g ! beta,gamma
         allocate(hnbar(N+1))
         a = 1.0_cp; b = beta
         g = (b+1.0_cp)/(b-1.0_cp)
         ! Where N is the number of cells
         dh = (hmax - hmin)/real(N,cp)
         ! Total coordinates (uniform)
         hnbar = (/(hmin+real(i-1,cp)*dh,i=1,N+1)/)
         ! Push coordinates to zero, and normalize for stretching
         hnbar = (hnbar - hmin)/(hmax-hmin)
         ! Total coordinates (non-uniform Roberts stretching function)
         hn = (/( ((b+a)-(b-a)*g**(a-hnbar(i)))/(g**(a-hnbar(i))+a),i=1,N+1)/)
         ! Return coordinates to original scale:
         call insist_monotonically_increasing(hn,hmin,hmax,beta,'transformation1')
         hn = hmin + (hmax - hmin)*hn
         deallocate(hnbar)
       end function

       function transformation2(hmin,hmax,N,alpha,beta) result(hn)
         ! This function returns the coordinates and differences of a Robert's
         ! stretching function as described in section 5.6 (page 333) of
         ! Computational Fluid Mechanics and Heat Transfer,
         ! 2nd edition, J. Tannehill et al.
         !
         ! INPUT:
         !      hmin     = minimum value
         !      hmax     = maximum value
         !      N        = N segments of dh
         !      alpha    = 0      stretching at y=h only
         !      alpha    = 0.5    stretching at y=0 and y=hmax
         !      beta     = 1.0 <= beta <= infinity = stretching factor
         !               = larger -> less stretching
         !
         ! Here is a picture illustration for alpha = 0:
         !
         !                                y=h
         !                                 |
         !     |----------|-------|---|--|-|
         !     |------> y
         !
         ! Note that this must be used in reverse for the lid driven
         ! cavity geometry for the 'front' and 'back' walls.
         !
         ! NOTE: I have abused notation a bit to provide consistent notation
         ! with the reference as well as generalize the returned grid
         ! so that it need not start at y=0.
         !
         implicit none
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         real(cp),intent(in) :: hmin,hmax,alpha,beta
         real(cp),dimension(:),allocatable :: hnbar
         real(cp) :: dh ! Uniform dh
         integer :: i
         real(cp) :: a,b,g ! alpha,beta,gamma
         allocate(hnbar(N+1))
         a = alpha; b = beta
         g = (b+one)/(b-one)
         ! Where N is the number of cells in the wall
         dh = (hmax - hmin)/real(N,cp)
         ! Total coordinates (uniform)
         hnbar = (/(hmin+real(i-1,cp)*dh,i=1,N+1)/)
         ! Push coordinates to zero, and normalize for stretching
         hnbar = (hnbar - hmin)/(hmax-hmin)
         ! Total coordinates (non-uniform Roberts stretching function)
         hn = (/( ((b+two*a)*(g)**((hnbar(i)-a)/(one-a))-&
         b+two*a)/((two*a+one)*(one+&
         g**((hnbar(i)-a)/(one-a)))),i=1,N+1)/)
         ! Return coordinates to original scale:
         if (abs(alpha).lt.10.0_cp**(-10.0_cp)) then
          call insist_monotonically_decreasing(hn,hmin,hmax,beta,'transformation2')
         endif
         hn = hmin + (hmax - hmin)*hn
         deallocate(hnbar)
       end function

       function transformation3(hmin,hmax,N,yc,tau) result(hn)
         ! This function returns the coordinates and differences of a Robert's
         ! stretching function as described in section 5.6 (page 333) of
         ! Computational Fluid Mechanics and Heat Transfer,
         ! 2nd edition, J. Tannehill et al. (Transormation 3)
         !
         ! INPUT:
         !      hmin     = minimum value
         !      hmax     = maximum value
         !      N        = N segments of dh
         !      tau      = 0.0_cp <= tau <= infinity = stretching factor
         !
         !      tau = 0            --> no stretching
         !      tau = large values --> strong stretching
         !
         ! Here is a picture illustration for alpha = 0:
         !
         !                                y=yc                        y=h
         !                                 |
         !     |----------|-------|---|--|-|-|--|---|-------|----------|
         !     |------> y
         !
         ! Note that this must be used in reverse for the lid driven
         ! cavity geometry for the 'front' and 'back' walls.
         !
         ! NOTE: I have abused notation a bit to provide consistent notation
         ! with the reference as well as generalize the returned grid
         ! so that it need not start at y=0.
         !
         implicit none
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         real(cp),intent(in) :: hmin,hmax,yc,tau
         real(cp),dimension(:),allocatable :: hnbar
         real(cp) :: dh ! Uniform dh
         integer :: i
         real(cp) :: a,B,c,d,e
         allocate(hnbar(N+1))
         a = 1.0_cp; c = 2.0_cp
         ! Where N is the number of cells
         dh = (hmax - hmin)/real(N,cp)
         ! Total coordinates (uniform)
         hnbar = (/(hmin+real(i-1,cp)*dh,i=1,N+1)/)
         ! Push coordinates to zero, and normalize for stretching
         hnbar = (hnbar - hmin)/(hmax-hmin)
         ! Define stretching parameters
         d = yc/(hmax-hmin); e = real(exp(tau),cp)
         B = a/(c*tau)*log((a+(e-a)*d)/(a+(a/e-a)*d))
         ! Total coordinates (non-uniform Roberts stretching function)
         hn = (/( d*(a+real(sinh(tau*(hnbar(i)-B)),cp)/real(sinh(tau*B),cp)),i=1,N+1)/)
         ! Return coordinates to original scale:
         hn = hmin + (hmax - hmin)*hn
         deallocate(hnbar)
       end function

       ! ***************************************************************
       ! ************************* ALIASES *****************************
       ! ***************************************************************

       function robertsLeft_func(hmin,hmax,N,beta) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         real(cp),intent(in) :: hmin,hmax,beta
         hn = transformation1(hmin,hmax,N,beta)
       end function

       function robertsRight_func(hmin,hmax,N,beta) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         real(cp),intent(in) :: hmin,hmax,beta
         hn = transformation2(hmin,hmax,N,0.0_cp,beta)
       end function

       function robertsBoth_func(hmin,hmax,N,beta) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         real(cp),intent(in) :: hmin,hmax,beta
         hn = transformation2(hmin,hmax,N,0.5_cp,beta)
       end function

       function cluster_func(hmin,hmax,N,yc,tau) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),dimension(N+1) :: hn
         real(cp),intent(in) :: hmin,hmax,yc,tau
         hn = transformation3(hmin,hmax,N,yc,tau)
       end function

       ! ***************************************************************
       ! *********************** OTHER TOOLS ***************************
       ! ***************************************************************

       subroutine reverseIndex(h,N)
         implicit none
         integer,intent(in) :: N
         real(cp),dimension(N),intent(inout) :: h
         real(cp),dimension(:),allocatable :: temp
         integer :: i
         allocate(temp(N))
         do i=1,N
          temp(N-i+1) = h(i)
         enddo
         h = temp
         deallocate(temp)
       end subroutine

       subroutine insist_monotonically_increasing(h,hmin,hmax,beta,caller)
         implicit none
         real(cp),dimension(:),intent(in) :: h
         real(cp),intent(in) :: hmin,hmax,beta
         character(len=*),intent(in) :: caller
         integer :: i,s
         real(cp) :: R
         s = size(h)
         do i=1,s-2
           R = (h(i+2)-h(i+1))/(h(i+1)-h(i))
           if (R.lt.1.0_cp) then
            write(*,*) 'Error: coordinates not monotonically increasing in '//caller
            write(*,*) 'in coordinate_distribution_funcs.f90'
            write(*,*) 'hmin,hmax,beta = ',hmin,hmax,beta
            write(*,*) 'R = ',R
            write(*,*) 'h = ',h
            stop 'Done'
           endif
         enddo
       end subroutine

       subroutine insist_monotonically_decreasing(h,hmin,hmax,beta,caller)
         implicit none
         real(cp),dimension(:),intent(in) :: h
         real(cp),intent(in) :: hmin,hmax,beta
         character(len=*),intent(in) :: caller
         integer :: i,s
         real(cp) :: R
         s = size(h)
         do i=1,s-2
           R = (h(i+2)-h(i+1))/(h(i+1)-h(i))
           if (R.gt.1.0_cp) then
            write(*,*) 'Error: coordinates not monotonically decreasing in '//caller
            write(*,*) 'in coordinate_distribution_funcs.f90'
            write(*,*) 'hmin,hmax,beta = ',hmin,hmax,beta
            write(*,*) 'R = ',R
            write(*,*) 'h = ',h
            stop 'Done'
           endif
         enddo
       end subroutine

       end module
       module coordinate_stretch_parameters_mod
       use current_precision_mod
       implicit none

       private
       public :: RobertsBL
       public :: HartmannBL
       public :: Hartmann_BL_1D
       public :: ReynoldsBL
       public :: Reynolds_BL_1D
       public :: Re_Ha_BL
       public :: Re_Ha_BL_1D

       contains

       function RobertsBL1D(delta,h) result (beta)
         ! RobertsBL1D returns the beta for a given boundary laryer
         ! as described in section 5.6 (page 333) of
         ! Computational Fluid Mechanics and Heat Transfer,
         ! 2nd edition, J. Tannehill et al.
         !
         ! INPUT:
         !      hmin     = wall boundary (minimum value)
         !      hmax     = wall boundary (maximum value)
         !      delta    = thickness of boundary layer
         implicit none
         real(cp),intent(in) :: h,delta
         real(cp) :: beta
         ! The 'if' statement protects against the case when
         ! Ha = 1 (delta=h), which leads to beta = infinity.
         ! HIMAG doesn't seem to protect against this.
         if (delta.lt.h*0.99_cp) then
           beta = (1.0_cp - delta/h)**(-0.5_cp)
         else; beta = 1000.0_cp
         endif
       end function

       function RobertsBL(delta,hmin,hmax) result(beta)
         ! RobertsBL returns the beta for a given boundary laryer
         ! as described in section 5.6 (page 333) of
         ! Computational Fluid Mechanics and Heat Transfer,
         ! 2nd edition, J. Tannehill et al.
         !
         ! INPUT:
         !      hmin     = wall boundary (minimum value)
         !      hmax     = wall boundary (maximum value)
         !      delta    = thickness of boundary layer
         implicit none
         real(cp),intent(in) :: hmin,hmax
         real(cp),intent(in) :: delta
         real(cp) :: beta
         beta = robertsBL1D(delta,hmax-hmin)
       end function

       function HartmannBL(Ha,hmin,hmax) result (beta)
         implicit none
         real(cp),dimension(3),intent(in) :: hmin,hmax
         real(cp),intent(in) :: Ha
         real(cp),dimension(3) :: beta
         integer :: i
         real(cp) :: tol
         tol = 10.0_cp**(-10.0_cp)
         if (Ha.lt.tol) then
          stop 'Error: Hartmann number is nearly zero in HartmannBL in coordinate_stretch_parameters.f90'
         endif
         do i = 1,3
            beta(i) = robertsBL((hmax(i)-hmin(i))/Ha,hmin(i),hmax(i))
         enddo
       end function

       function Hartmann_BL_1D(Ha,hmin,hmax) result (beta)
         implicit none
         real(cp),intent(in) :: hmin,hmax
         real(cp),intent(in) :: Ha
         real(cp) :: beta
         real(cp) :: tol
         tol = 10.0_cp**(-10.0_cp)
         if (Ha.lt.tol) then
          stop 'Error: Hartmann number is nearly zero in HartmannBL in coordinate_stretch_parameters.f90'
         endif
         beta = robertsBL((hmax-hmin)/Ha,hmin,hmax)
       end function

       function ReynoldsBL(Re,hmin,hmax) result (beta)
         implicit none
         real(cp),dimension(3),intent(in) :: hmin,hmax
         real(cp),intent(in) :: Re
         real(cp),dimension(3) :: beta
         integer :: i
         real(cp) :: tol
         tol = 10.0_cp**(-10.0_cp)
         if (Re.lt.tol) then
          stop 'Error: Reynolds number is nearly zero in ReynoldsBL in coordinate_stretch_parameters.f90'
         endif
         do i=1,3
            beta(i) = robertsBL((hmax(i)-hmin(i))/sqrt(Re),hmin(i),hmax(i))
         enddo
       end function

       function Reynolds_BL_1D(Re,hmin,hmax) result (beta)
         implicit none
         real(cp),intent(in) :: hmin,hmax
         real(cp),intent(in) :: Re
         real(cp) :: beta
         real(cp) :: tol
         tol = 10.0_cp**(-10.0_cp)
         if (Re.lt.tol) then
          stop 'Error: Reynolds number is nearly zero in ReynoldsBL in coordinate_stretch_parameters.f90'
         endif
         beta = robertsBL((hmax-hmin)/sqrt(Re),hmin,hmax)
       end function

       function Re_Ha_BL(Re,Ha,hmin,hmax) result (beta)
         implicit none
         real(cp),dimension(3),intent(in) :: hmin,hmax
         real(cp),intent(in) :: Re,Ha
         real(cp),dimension(3) :: beta,temp1,temp2
         integer :: i
         temp1 = ReynoldsBL(Re,hmin,hmax)
         temp2 = HartmannBL(Ha,hmin,hmax)
         do i=1,3
           beta(i) = minval((/temp1(i),temp2(i)/))
         enddo
       end function

       function Re_Ha_BL_1D(Re,Ha,hmin,hmax) result (beta)
         implicit none
         real(cp),intent(in) :: hmin,hmax
         real(cp),intent(in) :: Re,Ha
         real(cp) :: beta,temp1,temp2
         temp1 = Reynolds_BL_1D(Re,hmin,hmax)
         temp2 = Hartmann_BL_1D(Ha,hmin,hmax)
         beta = minval((/temp1,temp2/))
       end function

       end module
      module datatype_conversion_mod
      ! NOTE: the string length and the fmt must match!
      use current_precision_mod
      use string_mod
      implicit none

      private

      public :: log2Str
      public :: int2Str
      interface int2Str;      module procedure int2Str_li;       end interface
      interface int2Str;      module procedure int2Str_dynamic;  end interface
      ! interface int2Str;      module procedure int2Str_reg;      end interface

      public :: int2Str2
      public :: str2int
      public :: intLen
      public :: cp2str
      interface cp2str;      module procedure cp2Str_string;   end interface
      ! interface cp2Str;      module procedure cp2Str_raw;      end interface

      ! public :: int2Str,int2Str2,str2int,intLen ! change to this eventually

      contains

      function log2Str(L) result(s)
        implicit none
        logical,intent(in) :: L
        character(len=2) :: s
        write(s,'(L2)') L
        s = trim(adjustl(s))
      end function

      ! function int2Str_reg(i) result(s)
      !   implicit none
      !   integer,intent(in) :: i
      !   character(len=15) :: s
      !   write(s,'(I15.15)') i
      !   s = trim(adjustl(s))
      ! end function

      function int2Str_dynamic(i) result(s)
        implicit none
        integer,intent(in) :: i
        real(cp),parameter :: denom = log(10.0_cp)
        character(len=maxval((/ceiling(log(real(i+1,cp))/denom),1/))) :: s
        integer :: i_places
        i_places = maxval((/ceiling(log(real(i+1,cp))/denom),1/))
        write(s,'(I'//int2Str_dumn(i_places)//')') i
        s = trim(adjustl(s))
      end function

      function int2Str_dumn(i) result(s)
        implicit none
        integer,intent(in) :: i
        character(len=50) :: s
        write(s,'(I50)') i
        s = trim(adjustl(s))
      end function

      function int2Str_li(i) result(s)
        implicit none
        integer(li),intent(in) :: i
        character(len=15) :: s
        write(s,'(I15.15)') i
        s = trim(adjustl(s))
      end function

      ! function cp2Str_raw(f) result(s)
      !   implicit none
      !   real(cp),intent(in) :: f
      !   character(len=100) :: s
      !   write(s,'(F40.20)') f
      !   s = trim(adjustl(s))
      ! end function

      function cp2str_string(f) result(s)
        implicit none
        real(cp),intent(in) :: f
        type(string) :: s
        character(len=100) :: a
        write(a,'(F40.20)') f
        call init(s,trim(adjustl(a)))
      end function

      function int2Str2(i) result(s)
        implicit none
        integer,intent(in) :: i
        character(len=15) :: s
        write(s,'(I15)') i
        s = trim(adjustl(s))
      end function

      function str2int(s) result(i)
        implicit none
        character(len=*),intent(in) :: s
        integer :: i
        read(s,*) i
      end function

      function intLen(i) result(n)
        implicit none
        integer,intent(in) :: i
        integer :: n
        type(string) :: s
        call init(s,int2str(i))
        n = len(s)
      end function

      end module
       module face_edge_corner_indexing_mod
       ! This module provides routines to obtain indexes for various things.
       ! The figure at the bottom of this document illustrates the convention used.
       use current_precision_mod
       implicit none

       private
       public :: eye_given_dir
       public :: dir_given_eye

       public :: dir_given_face
       public :: dir_given_edge
       public :: adj_dir_given_dir
       public :: adj_dir_given_face
       public :: adj_dir_given_edge
       public :: orth_dir

       public :: adj_shape_given_dir

       public :: adj_faces_given_edge
       public :: adj_faces_given_corner
       public :: normal_faces_given_dir
       public :: adj_faces_given_dir
       public :: opp_face_given_face
       public :: min_face
       public :: max_face

       public :: edges_given_dir
       public :: edges_given_face

       public :: corners_given_face

       public :: nhat_given_face
       public :: nhat_given_edge
       public :: xyz_given_dir

       public :: insist_valid_dir,   valid_dir
       public :: insist_valid_face,  valid_face
       public :: insist_valid_edge,  valid_edge
       public :: insist_valid_corner,valid_corner

       contains

       ! *************************************************************************
       ! ******************************** GET EYE ********************************
       ! *************************************************************************

       function eye_given_dir(dir) result(eye)
         implicit none
         integer,intent(in) :: dir
         integer,dimension(3) :: eye
         select case (dir)
         case (1); eye = (/1,0,0/)
         case (2); eye = (/0,1,0/)
         case (3); eye = (/0,0,1/)
         case default; stop 'Error: dir must = 1:3 in eye_given_dir in face_edge_corner_indexing.f90'
         end select
       end function

       function dir_given_eye(eye) result(dir)
         implicit none
         integer,dimension(3),intent(in) :: eye
         integer :: dir
             if (all((/eye(1).eq.1,eye(2).eq.0,eye(3).eq.0/))) then; dir = 1
         elseif (all((/eye(1).eq.0,eye(2).eq.1,eye(3).eq.0/))) then; dir = 2
         elseif (all((/eye(1).eq.0,eye(2).eq.0,eye(3).eq.1/))) then; dir = 3
         else; stop 'Error: bad eye dir_given_eye in face_edge_corner_indexing.f90'
         endif
       end function

       ! *************************************************************************
       ! ******************************** GET DIR ********************************
       ! *************************************************************************

       function dir_given_face(face) result(dir)
         implicit none
         integer,intent(in) :: face
         integer :: dir
         select case (face)
         case (1,2); dir = 1
         case (3,4); dir = 2
         case (5,6); dir = 3
         case default; stop 'Error: face must = 1:6 in dir_given_face in face_edge_corner_indexing.f90'
         end select
       end function

       function dir_given_edge(edge) result(dir)
         implicit none
         integer,intent(in) :: edge
         integer :: dir
         select case (edge)
         case (1:4);  dir = 1
         case (5:8);  dir = 2
         case (9:12); dir = 3
         case default; stop 'Error: face must = 1:12 in dir_given_edge in face_edge_corner_indexing.f90'
         end select
       end function

       function adj_dir_given_dir(dir) result (a)
         implicit none
         integer,intent(in) :: dir
         integer,dimension(2) :: a
         select case (dir)
         case (1); a = (/2,3/)
         case (2); a = (/1,3/)
         case (3); a = (/1,2/)
         case default; stop 'Error: dir must = 1,2,3 in adj_dir_given_dir in face_edge_corner_indexing.f90'
         end select
       end function

       function adj_shape_given_dir(s,dir) result (a)
         implicit none
         integer,dimension(3),intent(in) :: s
         integer,intent(in) :: dir
         integer,dimension(2) :: a
         select case (dir)
         case (1); a = (/s(2),s(3)/)
         case (2); a = (/s(1),s(3)/)
         case (3); a = (/s(1),s(2)/)
         case default; stop 'Error: dir must = 1,2,3 in adj_shape_given_dir in face_edge_corner_indexing.f90'
         end select
       end function

       function adj_dir_given_face(face) result (a)
         implicit none
         integer,intent(in) :: face
         integer,dimension(2) :: a
         select case (face)
         case (1,2); a = (/2,3/)
         case (3,4); a = (/3,1/)
         case (5,6); a = (/1,2/)
         case default; stop 'Error: face must = 1:6 in adj_dir_given_face in face_edge_corner_indexing.f90'
         end select
       end function

       function adj_dir_given_edge(edge) result (dir)
         implicit none
         integer,intent(in) :: edge
         integer,dimension(2) :: dir
         select case (edge)
         case (1:4);  dir = (/2,3/)
         case (5:8);  dir = (/1,3/)
         case (9:12); dir = (/1,2/)
         case default; stop 'Error: edge must = 1:12 in adj_dir_given_edge in face_edge_corner_indexing.f90'
         end select
       end function

       function orth_dir(dir) result(d)
         implicit none
         integer,dimension(2),intent(in) :: dir
         integer :: d
         select case (dir(1))
         case (1); select case (dir(2))
                   case (2); d = 3
                   case (3); d = 2
                   case default; stop 'Error: dir(1)=1, but dir(2)!=2,3 in orth_dir in face_edge_corner_indexing.f90'
                   end select
         case (2); select case (dir(2))
                   case (1); d = 3
                   case (3); d = 1
                   case default; stop 'Error: dir(1)=2, but dir(2)!=1,3 in orth_dir in face_edge_corner_indexing.f90'
                   end select
         case (3); select case (dir(2))
                   case (1); d = 2
                   case (2); d = 1
                   case default; stop 'Error: dir(1)=3, but dir(2)!=1,2 in orth_dir in face_edge_corner_indexing.f90'
                   end select
         case default; stop 'Error: dir(1)!=1,2,3 in orth_dir in face_edge_corner_indexing.f90'
         end select
       end function

       ! *************************************************************************
       ! ******************************* GET FACE ********************************
       ! *************************************************************************

       function adj_faces_given_edge(edge) result (faces)
         implicit none
         integer,intent(in) :: edge
         integer,dimension(2) :: faces
         select case (edge)
         case (1);  faces = (/3,5/) ! x (ymin,zmin) (x)
         case (2);  faces = (/3,6/) ! x (ymin,zmax) (x)
         case (3);  faces = (/4,5/) ! x (ymax,zmin) (x)
         case (4);  faces = (/4,6/) ! x (ymax,zmax) (x)
         case (5);  faces = (/5,1/) ! y (zmin,xmin) (y)
         case (6);  faces = (/5,2/) ! y (zmin,xmax) (y)
         case (7);  faces = (/6,1/) ! y (zmax,xmin) (y)
         case (8);  faces = (/6,2/) ! y (zmax,xmax) (y)
         case (9);  faces = (/1,3/) ! z (xmin,ymin) (z)
         case (10); faces = (/1,4/) ! z (xmin,ymax) (z)
         case (11); faces = (/2,3/) ! z (xmax,ymin) (z)
         case (12); faces = (/2,4/) ! z (xmax,ymax) (z)
         case default; stop 'Error: edge must = 1:12 in adj_faces_given_edge in face_edge_corner_indexing.f90'
         end select
       end function

       function adj_faces_given_corner(corner) result(faces)
        implicit none
        integer,intent(in) :: corner
        integer,dimension(3) :: faces
        select case (corner)
        case (1); faces = (/1,3,5/)
        case (2); faces = (/2,3,5/)
        case (3); faces = (/1,4,5/)
        case (4); faces = (/1,3,6/)
        case (5); faces = (/1,4,6/)
        case (6); faces = (/2,3,6/)
        case (7); faces = (/2,4,5/)
        case (8); faces = (/2,4,6/)
        case default; stop 'Error: bad case in adj_faces_given_corner in face_edge_corner_indexing.f90'
        end select
       end function

       function normal_faces_given_dir(dir) result (faces)
         implicit none
         integer,intent(in) :: dir
         integer,dimension(2) :: faces
         select case (dir)
         case (1); faces = (/1,2/)
         case (2); faces = (/3,4/)
         case (3); faces = (/5,6/)
         case default; stop 'Error: dir must = 1,2,3 in normal_faces_given_dir in face_edge_corner_indexing.f90'
         end select
       end function

       function adj_faces_given_dir(dir) result (faces)
         implicit none
         integer,intent(in) :: dir
         integer,dimension(4) :: faces
         select case (dir)
         case (1); faces = (/3,4,5,6/)
         case (2); faces = (/1,2,5,6/)
         case (3); faces = (/1,2,3,4/)
         case default; stop 'Error: dir must = 1,2,3 in adj_faces_given_dir in face_edge_corner_indexing.f90'
         end select
       end function

       function opp_face_given_face(face) result (f_opp)
         implicit none
         integer,intent(in) :: face
         integer :: f_opp
         select case (face)
         case(1); f_opp = 2
         case(2); f_opp = 1
         case(3); f_opp = 4
         case(4); f_opp = 3
         case(5); f_opp = 6
         case(6); f_opp = 5
         case default; stop 'Error: bad case in opp_face_given_face in face_edge_corner_indexing.f90'
         end select
       end function

       function min_face(face) result(L)
        implicit none
        integer,intent(in) :: face
        logical :: L
        select case (face)
        case(1,3,5); L = .true.
        case(2,4,6); L = .false.
        case default; stop 'Error: bad case in min_face in face_edge_corner_indexing.f90'
        end select
       end function

       function max_face(face) result(L)
        implicit none
        integer,intent(in) :: face
        logical :: L
        select case (face)
        case(1,3,5); L = .false.
        case(2,4,6); L = .true.
        case default; stop 'Error: bad case in max_face in face_edge_corner_indexing.f90'
        end select
       end function

       ! *************************************************************************
       ! ******************************* GET EDGES *******************************
       ! *************************************************************************

       function edges_given_dir(dir) result (edges)
         implicit none
         integer,intent(in) :: dir
         integer,dimension(4) :: edges
         select case (dir)
         case (1); edges = (/1,2,3,4/)
         case (2); edges = (/5,6,7,8/)
         case (3); edges = (/9,10,11,12/)
         case default; stop 'Error: dir must = 1,2,3 in edges_given_dir in face_edge_corner_indexing.f90'
         end select
       end function

       function edges_given_face(face) result (edges)
         implicit none
         integer,intent(in) :: face
         integer,dimension(4) :: edges
         select case (face)
         case (1,2); edges = (/1,2,3,4/)
         case (3,4); edges = (/5,6,7,8/)
         case (5,6); edges = (/9,10,11,12/)
         case default; stop 'Error: face must = 1,2,3 in edges_given_face in face_edge_corner_indexing.f90'
         end select
       end function

       ! *************************************************************************
       ! ****************************** GET CORNERS ******************************
       ! *************************************************************************

       function corners_given_face(face) result (corners)
         implicit none
         integer,intent(in) :: face
         integer,dimension(4) :: corners
         select case (face)
         case (1); corners = (/1,4,3,5/)
         case (2); corners = (/2,6,7,8/)
         case (3); corners = (/1,2,4,6/)
         case (4); corners = (/3,7,5,8/)
         case (5); corners = (/1,3,2,7/)
         case (6); corners = (/4,5,6,8/)
         case default; stop 'Error: dir must = 1,2,3 in corners_given_face in face_edge_corner_indexing.f90'
         end select
       end function

       ! *************************************************************************
       ! ********************************* OTHER *********************************
       ! *************************************************************************

       function nhat_given_face(face) result (nhat)
         implicit none
         integer,intent(in) :: face
         real(cp) :: nhat
         select case (face)
         case(1); nhat = -1.0_cp
         case(2); nhat =  1.0_cp
         case(3); nhat = -1.0_cp
         case(4); nhat =  1.0_cp
         case(5); nhat = -1.0_cp
         case(6); nhat =  1.0_cp
         case default; stop 'Error: bad case in nhat_given_face in face_edge_corner_indexing.f90'
         end select
       end function

       function nhat_given_edge(edge) result (nhat)
         implicit none
         integer,intent(in) :: edge
         real(cp),dimension(2) :: nhat
         integer,dimension(2) :: faces
         faces = adj_faces_given_edge(edge)
         nhat = (/nhat_given_face(faces(1)),nhat_given_face(faces(2))/)
       end function

       function xyz_given_dir(dir) result(c)
         implicit none
         integer,intent(in) :: dir
         character(len=1) :: c
         select case (dir)
         case (1); c = 'x'
         case (2); c = 'y'
         case (3); c = 'z'
         case default; stop 'Error: dir must = 1:3 in face_edge_corner_indexing.f90'
         end select
       end function

       ! *************************************************************************
       ! ********************************* VALID *********************************
       ! *************************************************************************

       subroutine insist_valid_dir(dir,caller)
         implicit none
         integer,intent(in) :: dir
         character(len=*),intent(in) :: caller
         if (.not.valid_dir(dir)) then
         write(*,*) 'Error: invalid dir in ',caller,' in face_edge_corner_indexing.f90'
         write(*,*) 'dir = ',dir
         stop 'DONE'
         endif
       end subroutine

       subroutine insist_valid_face(face,caller)
         implicit none
         integer,intent(in) :: face
         character(len=*),intent(in) :: caller
         if (.not.valid_face(face)) then
         write(*,*) 'Error: invalid face in ',caller,' in face_edge_corner_indexing.f90'
         write(*,*) 'face = ',face
         stop 'DONE'
         endif
       end subroutine

       subroutine insist_valid_edge(edge,caller)
         implicit none
         integer,intent(in) :: edge
         character(len=*),intent(in) :: caller
         if (.not.valid_edge(edge)) then
         write(*,*) 'Error: invalid edge in ',caller,' in face_edge_corner_indexing.f90'
         write(*,*) 'edge = ',edge
         stop 'DONE'
         endif
       end subroutine

       subroutine insist_valid_corner(corner,caller)
         implicit none
         integer,intent(in) :: corner
         character(len=*),intent(in) :: caller
         if (.not.valid_corner(corner)) then
         write(*,*) 'Error: invalid corner in ',caller,' in face_edge_corner_indexing.f90'
         write(*,*) 'corner = ',corner
         stop 'DONE'
         endif
       end subroutine

       function valid_dir(dir) result(L)
         implicit none
         integer,intent(in) :: dir
         logical :: L
         select case (dir)
         case (1:3); L = .true.
         case default; L = .false.
         end select
       end function

       function valid_face(face) result(L)
         implicit none
         integer,intent(in) :: face
         logical :: L
         select case (face)
         case (1:6); L = .true.
         case default; L = .false.
         end select
       end function

       function valid_edge(edge) result(L)
         implicit none
         integer,intent(in) :: edge
         logical :: L
         select case (edge)
         case (1:12); L = .true.
         case default; L = .false.
         end select
       end function

       function valid_corner(corner) result(L)
         implicit none
         integer,intent(in) :: corner
         logical :: L
         select case (corner)
         case (1:8); L = .true.
         case default; L = .false.
         end select
       end function

         ! This module provides routines to obtain indexes for BC
         ! and stitch data structures so that consistent indexing
         ! is used. A figure below illustrates the convention used.
         !
         ! ************************************* DIRECTION *************************************
         ! SLICE PATTERN:
         ! Direction 1: x
         ! Direction 2: y
         ! Direction 3: z
         !
         ! ID NUMBERS:
         !            2
         !            y
         !            ^
         !            |
         !            |
         !            ------------------------
         !           /|                     /|
         !          / |                    / |
         !         /  |                   /  |
         !        ------------------------   |
         !        |   |                  |   |
         !        |   |                  |   |
         !        |   |                  |   |
         !        |   |------------------|---|---->x 1
         !        |  /                   |  /
         !        | /                    | /
         !        |/                     |/
         !        ------------------------
         !       /
         !      /
         !     z
         !    3
         !
         ! ************************************* FACES *************************************
         ! SLICE PATTERN:
         ! Face 1: X(1,:,:)
         ! Face 2: X(N,:,:)
         ! Face 3: X(:,1,:)
         ! Face 4: X(:,N,:)
         ! Face 5: X(:,:,1)
         ! Face 6: X(:,:,N)
         !
         ! ID NUMBERS:
         !            y
         !            ^
         !            |
         !            |
         !            ------------------------
         !           /|                     /|
         !          / |       4            / |
         !         /  |                   /  |
         !        ------------------------   |
         !        |   |          5       |   |
         !        | 1 |                  | 2 |
         !        |   |       6          |   |
         !        |   |------------------|---|---->x
         !        |  /                   |  /
         !        | /         3          | /
         !        |/                     |/
         !        ------------------------
         !       /
         !      /
         !     z
         !
         ! ************************************ EDGES ************************************
         ! SLICE PATTERN:
         ! Edge 1:  X(:,1,1)
         ! Edge 2:  X(:,1,N)
         ! Edge 3:  X(:,N,1)
         ! Edge 4:  X(:,N,N)
         ! Edge 5:  X(1,:,1)
         ! Edge 6:  X(N,:,1)
         ! Edge 7:  X(1,:,N)
         ! Edge 8:  X(N,:,N)
         ! Edge 9:  X(1,1,:)
         ! Edge 10: X(1,N,:)
         ! Edge 11: X(N,1,:)
         ! Edge 12: X(N,N,:)
         !
         ! ID NUMBERS:
         !            y
         !            ^
         !            |
         !            |
         !            ----------3-------------
         !           /|                     /|
         !         10 |                   12 |
         !         /  |                   /  |
         !        ------------4-----------   |
         !        |   5                  |   6
         !        |   |                  |   |
         !        |   |                  |   |
         !        7   |                  8   |
         !        |   |----------1-------|---|---->x
         !        |  /                   |  /
         !        | 9                    | 11
         !        |/                     |/
         !        -----------2------------
         !       /
         !      /
         !     z
         !
         ! ALTERNATIVE, 2D VIEW
         !        z                          x                          y
         !        ^    6                     ^    2                     ^    4
         !        2---------4                2---------4                2---------4
         !        |         |                |         |                |         |
         !      3 |  dir=1  | 4            5 |  dir=2  | 6            1 |  dir=3  | 2
         !        |         |                |         |                |         |
         !        1---------3-> y            1---------3-> z            1---------3-> x
         !             5                          1                          3
         !
         !          e_pad=0                    e_pad=4                     e_pad=8
         !
         ! OR, IN GENERAL,
         !
         !        d2
         !        ^
         !        2---------4
         !        |         |
         !        |   dir   |
         !        |         |
         !        1---------3-> d1
         !
         ! ************************************ CORNERS ************************************
         ! SLICE PATTERN:
         ! Corner 1: X(1,1,1)
         ! Corner 2: X(N,1,1) ! N eye amongst 1's
         ! Corner 3: X(1,N,1) ! N eye amongst 1's
         ! Corner 4: X(1,1,N) ! N eye amongst 1's
         ! Corner 5: X(1,N,N) ! 1 eye amongst N's
         ! Corner 6: X(N,1,N) ! 1 eye amongst N's
         ! Corner 7: X(N,N,1) ! 1 eye amongst N's
         ! Corner 8: X(N,N,N)
         !
         ! ID NUMBERS:
         !            y
         !            ^
         !            |
         !            |
         !            3----------------------7
         !           /|                     /|
         !          / |                    / |
         !         /  |                   /  |
         !        5----------------------8   |
         !        |   |                  |   |
         !        |   |                  |   |
         !        |   |                  |   |
         !        |   1------------------|---2---->x
         !        |  /                   |  /
         !        | /                    | /
         !        |/                     |/
         !        4----------------------6
         !       /
         !      /
         !     z
         !
         ! *********************************************************************************
       end module
      module inquire_funcs_mod
      use string_mod
      implicit none

      private

      public :: file_exists,unit_exists
      public :: file_open,  unit_open
      public :: file_closed,unit_closed
      public :: file_iostat_error,unit_iostat_error
      public :: file_iostat,unit_iostat

      character(len=4),parameter :: dot_dat = '.dat'

      contains

      function file_exists(dir,name) result(ex)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(string) :: s
        logical :: ex
        call init(s,dir//name//dot_dat)
        inquire(file=str(s),exist=ex)
        call delete(s)
      end function

      function unit_exists(un) result(ex)
        implicit none
        integer,intent(in) :: un
        logical :: ex
        inquire(unit=un,exist=ex)
      end function

      function file_open(dir,name) result(op)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(string) :: s
        logical :: op
        call init(s,dir//name//dot_dat)
        inquire(file=str(s),opened=op)
        call delete(s)
      end function

      function unit_open(un) result(op)
        implicit none
        integer,intent(in) :: un
        logical :: op
        inquire(unit=un,opened=op)
      end function

      function file_closed(dir,name) result(not_op)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(string) :: s
        logical :: op,not_op
        call init(s,dir//name//dot_dat)
        inquire(file=str(s),opened=op)
        call delete(s)
        not_op = .not.op
      end function

      function unit_closed(un) result(not_op)
        implicit none
        integer,intent(in) :: un
        logical :: op,not_op
        inquire(unit=un,opened=op)
        not_op = .not.op
      end function

      function file_iostat_error(dir,name) result(L)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(string) :: s
        logical :: L
        integer :: i
        call init(s,dir//name//dot_dat)
        inquire(file=str(s),iostat=i)
        call delete(s)
        L = .not.i.eq.0
      end function

      function unit_iostat_error(un) result(L)
        implicit none
        integer,intent(in) :: un
        logical :: L
        integer :: i
        inquire(unit=un,iostat=i)
        L = .not.i.eq.0
      end function

      function file_iostat(dir,name) result(i)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(string) :: s
        integer :: i
        call init(s,dir//name//dot_dat)
        inquire(file=str(s),iostat=i)
        call delete(s)
      end function

      function unit_iostat(un) result(i)
        implicit none
        integer,intent(in) :: un
        integer :: i
        inquire(unit=un,iostat=i)
      end function

      end module
       module is_nan_mod
       use current_precision_mod
       implicit none

       private
       public :: is_nan

       contains

#ifdef _ISNAN_USE_HACK_
       function is_nan(f) result(L)
         implicit none
         real(cp),intent(in) :: f
         logical :: L
         L = f.ne.f.or.is_huge(f)
       end function
#else
       function is_nan(f) result(L)
         implicit none
         real(cp),intent(in) :: f
         logical :: L
         L = isnan(f).or.is_huge(f)
       end function
#endif

       function is_huge(f) result(L)
         implicit none
         real(cp),intent(in) :: f
         logical :: L
         L = f.gt.huge(1.0_cp)
       end function

      ! subroutine check_nans_nans(f,caller)
      !   implicit none
      !   real(cp),intent(in) :: f
      !   character(len=*),intent(in) :: caller
      !   if (is_nan(f)) then
      !     write(*,*) 'Error: NaN in ',caller,' in nan.f90'
      !     write(*,*) 'f = ',f
      !     stop 'Done'
      !   endif
      ! end subroutine

       end module
      module string_aux_mod
      use string_mod
      implicit none

      private

      public :: read_line
      public :: remove_substring

      public :: get_first_int
      public :: remove_leading_zeros
      public :: get_first_int_indexes

      interface read_line;                   module procedure read_line_string;               end interface
      interface remove_substring;            module procedure remove_substring_string;        end interface

      interface get_first_int;               module procedure get_first_int_string;           end interface
      interface remove_leading_zeros;        module procedure remove_leading_zeros_string;    end interface
      interface get_first_int_indexes;       module procedure get_first_int_indexes_string;   end interface

      contains

      function read_line_string(un,n_chars) result(line)
        ! Returns a string of the line, in file unit=un, up to n_chars or EOL.
        implicit none
        integer,intent(in) :: un,n_chars
        character(len=1) :: c
        type(string) :: line
        integer :: i,ReadCode
        ReadCode = 0
        do i=1,n_chars
          if (ReadCode.eq.0) then
            read(un,'(A)',advance='no',iostat=ReadCode) c
            if (i.eq.1) then; call init(line,c); else; call append(line,c); endif
          else; exit
          endif
        enddo
      end function

      function remove_substring_string(st,substr) result(s)
        implicit none
        type(string),intent(in) :: st
        character(len=*),intent(in) :: substr
        type(string) :: s
        integer :: j,first_index
        call init(s,st)
        if (match(st,substr)) then
        first_index = match_index(st,substr)
        do j=1,len(substr)
        call remove_element(s,first_index)
        enddo
        else; call init(s,st)
        endif
      end function

      ! ************************************************************************************
      ! ************************************************************************************
      ! ************************************************************************************

      function is_element_09(st,j) result(L)
        implicit none
        type(string),intent(in) :: st
        integer,intent(in) :: j
        logical,dimension(10) :: any_num
        logical :: L
        any_num(1)  = get_char(st,j).eq.'0'
        any_num(2)  = get_char(st,j).eq.'1'
        any_num(3)  = get_char(st,j).eq.'2'
        any_num(4)  = get_char(st,j).eq.'3'
        any_num(5)  = get_char(st,j).eq.'4'
        any_num(6)  = get_char(st,j).eq.'5'
        any_num(7)  = get_char(st,j).eq.'6'
        any_num(8)  = get_char(st,j).eq.'7'
        any_num(9)  = get_char(st,j).eq.'8'
        any_num(10) = get_char(st,j).eq.'9'
        L = any(any_num)
      end function

      ! ************************************************************************************
      ! ************************************************************************************
      ! ************************************************************************************

      subroutine remove_leading_zeros_string(st)
        implicit none
        type(string),intent(inout) :: st
        type(string) :: temp
        integer :: i,n_zeros,n
        n = len(st)
        if (n.lt.1) stop 'Error: input string must be > 1 in string.f90'
        n_zeros = 0
        do i=1,n-1 ! do not remove the last character even if zero
          if (get_char(st,i).eq.'0') then; n_zeros = n_zeros + 1; else; exit; endif
        enddo
        call init(temp,n-n_zeros)
        do i=1+n_zeros,n
          call set_char(temp,get_char(st,i),i-n_zeros)
        enddo
        call init(st,temp)
        call delete(temp)
      end subroutine

      function get_first_int_string(st) result(i)
        implicit none
        type(string),intent(in) :: st
        type(string) :: i
        integer j,k,n
        logical :: active_number
        active_number = .false.
        n = len(st)
        do j=1,n
          if (is_element_09(st,j)) then
            call init(i,get_char(st,j))
            if (j.lt.n) then
              do k=j+1,n
                if (is_element_09(st,k)) then
                  call append(i,get_char(st,k))
                else; exit
                endif
              enddo
            else; exit
            endif
            exit
          endif
        enddo
      end function

      function get_first_int_indexes_string(st) result(i)
        implicit none
        type(string),intent(in) :: st
        integer,dimension(2) :: firstLast
        type(string) :: i
        integer j,k,n
        logical :: active_number
        active_number = .false.
        n = len(st)
        firstLast(1) = 1
        firstLast(2) = n
        do j=1,n
          if (is_element_09(st,j)) then
            firstLast(1) = j
            if (j.lt.n) then
              do k=j+1,n
                if (is_element_09(st,k)) then
                  call append(i,get_char(st,k))
                else; firstLast(2) = k;exit
                endif
              enddo
              firstLast(2) = n
            else; firstLast(2) = n;exit
            endif
            exit
          endif
        enddo
      end function

      end module
      module IO_check_mod
      use string_mod
      use inquire_funcs_mod
      implicit none

      private

      public :: check_file_exists,check_unit_exists
      public :: check_file_open,  check_unit_open
      public :: check_file_closed,check_unit_closed

      contains

      ! ************************* DEBUGGING *************************
      ! ************************* DEBUGGING *************************
      ! ************************* DEBUGGING *************************

      subroutine check_file_exists(dir,name,caller)
        implicit none
        character(len=*),intent(in) :: dir,name,caller
        if ((.not.file_exists(dir,name)).or.file_iostat_error(dir,name)) then
          write(*,*) 'Error: file does not exist in '//caller//' in IO_tools.f90'
          write(*,*) 'dir = ',dir
          write(*,*) 'name = ',name
          write(*,*) 'len(dir) = ',len(dir)
          write(*,*) 'len(name) = ',len(name)
          write(*,*) 'ex = ',file_exists(dir,name)
          write(*,*) 'ios = ',file_iostat(dir,name)
          stop 'Terminating execution.'
        endif
      end subroutine

      subroutine check_unit_exists(un,caller)
        implicit none
        integer,intent(in) :: un
        character(len=*),intent(in) :: caller
        if ((.not.unit_exists(un)).or.unit_iostat_error(un)) then
          write(*,*) 'Error: unit does not exist in '//caller//' in IO_tools.f90'
          write(*,*) 'ex = ',unit_exists(un)
          write(*,*) 'ios = ',unit_iostat(un)
          stop 'Terminating execution.'
        endif
      end subroutine

      subroutine check_file_open(dir,name,caller)
        implicit none
        character(len=*),intent(in) :: dir,name,caller
        if ((.not.file_open(dir,name)).or.file_iostat_error(dir,name)) then
          write(*,*) 'Error: file not open in '//caller//' in IO_tools.f90'
          write(*,*) 'dir = ',dir
          write(*,*) 'name = ',name
          write(*,*) 'len(dir) = ',len(dir)
          write(*,*) 'len(name) = ',len(name)
          write(*,*) 'ex = ',file_exists(dir,name)
          write(*,*) 'ios = ',file_iostat(dir,name)
          stop 'Terminating execution.'
        endif
      end subroutine

      subroutine check_unit_open(un,caller)
        implicit none
        integer,intent(in) :: un
        character(len=*),intent(in) :: caller
        if ((.not.unit_open(un)).or.unit_iostat_error(un)) then
          write(*,*) 'Error: unit not open in '//caller//' in IO_tools.f90'
          write(*,*) 'ex = ',unit_exists(un)
          write(*,*) 'ios = ',unit_iostat(un)
          stop 'Terminating execution.'
        endif
      end subroutine

      subroutine check_file_closed(dir,name,caller)
        implicit none
        character(len=*),intent(in) :: dir,name,caller
        if ((.not.file_closed(dir,name)).or.file_iostat_error(dir,name)) then
          write(*,*) 'Error: file not closed in '//caller//' in IO_tools.f90'
          write(*,*) 'dir = ',dir
          write(*,*) 'name = ',name
          write(*,*) 'len(dir) = ',len(dir)
          write(*,*) 'len(name) = ',len(name)
          write(*,*) 'ex = ',file_exists(dir,name)
          write(*,*) 'ios = ',file_iostat(dir,name)
          stop 'Terminating execution.'
        endif
      end subroutine

      subroutine check_unit_closed(un,caller)
        implicit none
        integer,intent(in) :: un
        character(len=*),intent(in) :: caller
        if ((.not.unit_closed(un)).or.unit_iostat_error(un)) then
          write(*,*) 'Error: unit not closed in '//caller//' in IO_tools.f90'
          write(*,*) 'ex = ',unit_exists(un)
          write(*,*) 'ios = ',unit_iostat(un)
          stop 'Terminating execution.'
        endif
      end subroutine

      end module
      module IO_tools_mod
      use current_precision_mod
      use string_mod
      use inquire_funcs_mod
      use IO_check_mod
      implicit none

      private

      public :: get_file_unit
      public :: new_and_open,close_and_message,delete_file
      public :: rewind_unit
      public :: open_to_read,open_to_write,open_to_read_write
      public :: open_to_append
      public :: safe_read
      public :: dot_dat
      public :: get_n_lines_of_file

      interface safe_read;      module procedure safe_read_int_IO;      end interface
      interface safe_read;      module procedure safe_read_log_IO;      end interface
      interface safe_read;      module procedure safe_read_cp_IO;       end interface
      interface open_to_append; module procedure open_to_append_at_EOF; end interface
      interface open_to_append; module procedure open_to_append_at_pos; end interface

      character(len=4),parameter :: dot_dat = '.dat'

      contains

      function get_file_unit(dir,name) result(un)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer :: un
        type(string) :: s
#ifdef _DEBUG_IO_TOOLS_
        call check_file_exists(dir,name,'get_file_unit')
#endif
        call init(s,dir//name//dot_dat)
        inquire(file=str(s),number=un)
        call delete(s)
      end function

      ! ************************* NEW UNIT *************************
      ! ************************* NEW UNIT *************************
      ! ************************* NEW UNIT *************************

      function new_unit() result(nu)
        implicit none
        integer,parameter :: lun_min=10,lun_max=1000
        integer :: lun,nu
        nu=-1
        do lun=lun_min,lun_max
          if (.not.unit_open(lun)) then; nu=lun; exit; endif
        enddo
      end function

      function new_and_open(dir,name) result(un)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer :: un
        type(string) :: s
        call init(s,dir//name//dot_dat)
        un = new_unit()
        ! open(un,file=str(s),pad='YES',action='readwrite')
        call attempt_to_open_to_write(un,s,dir,name)
        call delete(s)
      end function

      subroutine attempt_to_open_to_write(un,s,dir,name)
        implicit none
        integer,intent(in) :: un
        type(string),intent(in) :: s
        character(len=*),intent(in) :: dir,name
        integer :: n,i
        logical :: failed
        failed = .true.
        do n=1,100000
          open(un,file=str(s),pad='YES',action='readwrite',iostat=i)
          if (i.eq.0) then; failed = .false.; exit; endif
        enddo
        if (failed) then
          write(*,*) 'Error: tried to open file but failed!!'
          write(*,*) 'File = ',str(s)
          write(*,*) 'dir = ',dir
          write(*,*) 'name = ',name
          stop 'Done in attempt_to_open_to_write in IO_tools.f90'
        endif
      end subroutine

      ! ************************* CLOSE UNIT *************************
      ! ************************* CLOSE UNIT *************************
      ! ************************* CLOSE UNIT *************************

      subroutine close_and_message(un,dir,name)
        implicit none
        integer,intent(in) :: un
        character(len=*),intent(in) :: dir,name
#ifdef _DEBUG_IO_TOOLS_
        call check_file_exists(dir,name,'close_and_message')
        call check_file_open(dir,name,'close_and_message')
#endif
        close(un)
#ifndef _OPTIMIZE_IO_TOOLS_
        write(*,*) '+++ Closed file ' // dir // name
#endif
      end subroutine

      subroutine delete_file(dir,name)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer :: un
        if (file_exists(dir,name)) then
          un = open_to_read(dir,name)
          close(un, status='delete')
        endif
#ifndef _OPTIMIZE_IO_TOOLS_
        write(*,*) '+++ deleted file ' // dir // name
#endif
      end subroutine

      ! **************************** REWIND ****************************
      ! **************************** REWIND ****************************
      ! **************************** REWIND ****************************

      subroutine rewind_unit(un)
        implicit none
        integer,intent(in) :: un
#ifdef _DEBUG_IO_TOOLS_
        call check_unit_exists(un,'rewind_unit')
        call check_unit_open(un,'rewind_unit')
#endif
        rewind(un)
      end subroutine

      ! *************************** OPEN UNIT ***************************
      ! *************************** OPEN UNIT ***************************
      ! *************************** OPEN UNIT ***************************

      function open_to_read(dir,name) result(un)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer :: un
        type(string) :: s
        call init(s,dir//name//dot_dat)
        un = new_unit()
#ifdef _DEBUG_IO_TOOLS_
        call check_file_exists(dir,name,'open_to_read')
        call check_file_closed(dir,name,'open_to_read')
#endif
        open(un,file=str(s),status = 'old',action = 'read')
        call delete(s)
      end function

      function open_to_write(dir,name) result(un)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer :: un
        type(string) :: s
        call init(s,dir//name//dot_dat)
#ifdef _DEBUG_IO_TOOLS_
        call check_file_exists(dir,name,'open_to_write')
        call check_file_closed(dir,name,'open_to_write')
#endif
        un = new_unit()
        open(un,file=str(s),status='old',action='write')
        call delete(s)
      end function

      function open_to_read_write(dir,name) result(un)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer :: un
        type(string) :: s
        call init(s,dir//name//dot_dat)
#ifdef _DEBUG_IO_TOOLS_
        call check_file_exists(dir,name,'open_to_write')
        call check_file_closed(dir,name,'open_to_write')
#endif
        un = new_unit()
        open(un,file=str(s),status='old',action='readwrite')
        call delete(s)
      end function

      function open_to_append_at_EOF(dir,name) result(un)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer :: un
        type(string) :: s
        call init(s,dir//name//dot_dat)
#ifdef _DEBUG_IO_TOOLS_
        call check_file_exists(dir,name,'open_to_append')
        call check_file_closed(dir,name,'open_to_append')
#endif
        un = new_unit()
        open(unit=un,file=str(s),status='old',action='write',position='append')
      end function

      function open_to_append_at_pos(dir,name,pos) result(un)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer,intent(in) :: pos
        integer :: un
        integer :: i
        un = open_to_append(dir,name)
        rewind(un)
        do i=1,pos-1; read(un,*); enddo
      end function

      function get_n_lines_of_file(dir,name) result(n_lines)
        implicit none
        character(len=*),intent(in) :: dir,name
        integer(li) :: n_lines
        integer :: un,stat
        logical :: not_EOF
        un = open_to_read(dir,name)
        n_lines = 0
        not_EOF = .true.
        do while (not_EOF)
          read(un,*,iostat=stat)
          if (stat .lt. 0) then
            not_EOF = .false.
          else
            n_lines = n_lines + 1
          endif
        enddo
        close(un)
      end function

      subroutine safe_read_int_IO(i,un,caller)
        implicit none
        integer,intent(inout) :: i
        integer,intent(in) :: un
        character(len=*),intent(in) :: caller
        integer :: temp
        integer :: ReadStatus
        read(un,*, iostat=ReadStatus) temp
        if ( ReadStatus.eq.0 ) then; i = temp
        else; call print_error_message('Error: read bad integer input in '//caller)
        endif
      end subroutine

      subroutine safe_read_log_IO(L,un,caller)
        implicit none
        logical,intent(inout) :: L
        integer,intent(in) :: un
        character(len=*),intent(in) :: caller
        logical :: temp
        integer :: ReadStatus
        read(un,*, iostat=ReadStatus) temp
        if ( ReadStatus.eq.0 ) then; L = temp
        else; call print_error_message('Error: read bad logical input in '//caller)
        endif
      end subroutine

      subroutine safe_read_cp_IO(R,un,caller)
        implicit none
        real(cp),intent(inout) :: R
        integer,intent(in) :: un
        character(len=*),intent(in) :: caller
        real(cp) :: temp
        integer :: ReadStatus
        read(un,*, iostat=ReadStatus) temp
        if ( ReadStatus.eq.0 ) then; R = temp
        else; call print_error_message('Error: read bad logical input in '//caller)
        endif
      end subroutine

      subroutine print_error_message(m)
        implicit none
        character(len=*),intent(in) :: m
        write (*,*) ' ----------------------- '
        write (*,*) ' ----------------------- '
        write (*,*) ' ----------------------- '
        write (*,*) m
        write (*,*) ' ----------------------- '
        write (*,*) ' ----------------------- '
        write (*,*) ' ----------------------- '
      end subroutine

      end module
       module coordinate_stretch_param_match_mod
       ! Compiler flag (_DEBUG_COORDINATE_STRETCH_PARAM_MATCH_)
       use is_nan_mod
       use IO_tools_mod
       use current_precision_mod
       implicit none

       private

       real(cp),parameter :: one = 1.0_cp
       real(cp),parameter :: two = 2.0_cp
       real(cp),parameter :: four = 4.0_cp
       real(cp),parameter :: zero = 0.0_cp

       abstract interface
         function func(beta,hmin,hmax,alpha,N,dh) result(f)
           import cp
           real(cp),intent(in) :: beta,hmin,hmax,alpha,dh
           integer,intent(in) :: N
           real(cp) :: f
         end function
       end interface

       abstract interface
         function func_prime(beta,alpha,N) result(f)
           import cp
           real(cp),intent(in) :: beta,alpha
           integer,intent(in) :: N
           real(cp) :: f
         end function
       end interface

       public :: beta_dh_small
       public :: beta_dh_big
       public :: beta_dh_both

       contains

       ! ***************************************************************
       ! ********************** TRANSFORMATION 1 ***********************
       ! ***************************************************************

       ! ***************************************************************
       ! ********************** TRANSFORMATION 2 ***********************
       ! ***************************************************************

       ! NOTE: For more info, see documentation for equation.
       !       Also see python stretch_parameter_matching

       function T2_h_i(beta,alpha,i,N) result(f)
         real(cp),intent(in) :: beta,alpha
         integer,intent(in) :: i,N
         real(cp) :: f,t,a,b,g
         a = alpha; b = beta
         g = (b+one)/(b-one)
         t = (real(i,cp)/real(N,cp) - a)/(one-a) ! theta
         f = ((b+two*a)*g**t - b + two*a)/((two*a+one)*(one+g**t))
       end function

       function T2_prime_h_i(beta,alpha,i,N) result(f)
         real(cp),intent(in) :: beta,alpha
         integer,intent(in) :: i,N
         real(cp) :: f,t,a,b,g
         a = alpha; b = beta
         g = (b+one)/(b-one)
         t = (real(i,cp)/real(N,cp) - a)/(one-a) ! theta
         f = -(-b**two*g**(two*t) + b**two + four*b*g**t*t + &
         g**(two*t) - one)/((two*a + one)*(b - one)*(b + one)*(g**t + one)**two)
       end function

       ! ---------------------------------------------------------------

       function T2_root_dh_near_hmax(beta,hmin,hmax,alpha,N,dh) result(f)
         real(cp),intent(in) :: beta,hmin,hmax,alpha,dh
         integer,intent(in) :: N
         real(cp) :: f
         f = T2_h_i(beta,alpha,N,N) - T2_h_i(beta,alpha,N-1,N) - dh/(hmax-hmin)
       end function

       function T2_prime_dh_near_hmax(beta,alpha,N) result(f)
         real(cp),intent(in) :: beta,alpha
         integer,intent(in) :: N
         real(cp) :: f
         f = T2_prime_h_i(beta,alpha,N,N) - T2_prime_h_i(beta,alpha,N-1,N)
       end function

       function T2_root_dh_near_hmin(beta,hmin,hmax,alpha,N,dh) result(f)
         real(cp),intent(in) :: beta,hmin,hmax,alpha,dh
         integer,intent(in) :: N
         real(cp) :: f
         f = T2_h_i(beta,alpha,1,N) - T2_h_i(beta,alpha,0,N) - dh/(hmax-hmin)
       end function

       function T2_prime_dh_near_hmin(beta,alpha,N) result(f)
         real(cp),intent(in) :: beta,alpha
         integer,intent(in) :: N
         real(cp) :: f
         f = T2_prime_h_i(beta,alpha,1,N) - T2_prime_h_i(beta,alpha,0,N)
       end function

       ! ---------------------------------------------------------------

#ifdef _DEBUG_COORDINATE_STRETCH_PARAM_MATCH_
       subroutine newtonT2_debug(T_root,T_prime,beta,hmin,hmax,alpha,N,dh,debug)
         ! Estimate the zero of T_root(beta) using Newton's method.
         ! Input:
         !   T_root:  the function to find a root of
         !   T_prime: function returning the derivative T_root'
         !   debug: logical, prints iterations if debug=.true.
         ! Returns:
         !   the estimate beta satisfying T_root(beta)=0 (assumes Newton converged!)
         !   the number of iterations iters
         implicit none
         real(cp),intent(inout) :: beta
         procedure(func) :: T_root
         procedure(func_prime) :: T_prime
         real(cp),intent(in) :: hmin,hmax,alpha,dh
         integer,intent(in) :: N
         logical,intent(in) :: debug

         real(cp) :: dbeta, fbeta, fbetaprime,beta0 ! local variables
         integer,parameter :: maxiter = 1000000
         real(cp),parameter :: tol = 10.0_cp*machine_epsilon
         real(cp),parameter :: err = 10.0_cp**(-10.0_cp) ! We may have a problem
         integer :: k
         beta0 = beta
         if (debug) write(*,*) '****************************************'
         if (debug) write(*,*) '****************************************'
         if (debug) write(*,*) '****************************************'
         if (debug) write(*,*) 'Initial guess: beta = ',beta
         if (debug) write(*,*) 'alpha,N = ',alpha,N
         if (debug) write(*,*) 'dh = ',dh
         if (debug) write(*,*) 'hmin,hmax = ',hmin,hmax
         if (debug) write(*,*) '****************************************'
         if (debug) write(*,*) '****************************************'

         if (debug) write(*,*) 'beta = ',beta
         do k=1,maxiter ! Newton iteration to find a zero of T_root(beta)
           if (debug) write(*,*) '****************************************'
           if (debug) write(*,*) 'iteration = ',k
           fbeta = T_root(beta,hmin,hmax,alpha,N,dh) ! evaluate function and its derivative:
           if (debug) write(*,*) 'f = ',fbeta
           fbetaprime = T_prime(beta,alpha,N)
           if (debug) write(*,*) 'f_prime = ',fbetaprime
           if (abs(fbeta) .lt. tol) exit  ! jump out of do loop
           ! if (beta .gt. 1.0000001_cp) exit  ! jump out of do loop
           if (beta .gt. 100.0_cp) exit  ! jump out of do loop
           if (beta .lt. beta0) then
             beta = beta0
             exit  ! jump out of do loop
           endif
           dbeta = fbeta/fbetaprime ! compute Newton increment beta:
           if (debug) write(*,*) 'dbeta = ',dbeta
           beta = beta - dbeta ! update beta:
           if (debug) write(*,*) 'beta = ',beta
           if (debug) write(*,*) 'updated beta = ',beta
           if (is_nan(beta)) then
             write(*,*) 'beta = ',beta
             write(*,*) 'Error: Divergent stretch parameter matching.'
             write(*,*) 'Consider decreasing tol in beta Roberts functions.'
             write(*,*) 'Or check mesh config.'
             stop 'Done in newtonT2_debug in coordinate_stretch_param_match.f90'
           endif
         enddo

         if (k.gt.maxiter) then ! might not have converged
           fbeta = T_root(beta,hmin,hmax,alpha,N,dh)
           if (abs(fbeta).gt.err) then
            write(*,*) '*** Warning: has not yet converged'
            write(*,*) '(Iterations,beta) = ',k,beta
            write(*,*) 'tol = ',tol
            write(*,*) 'fbeta = ',fbeta
            ! stop 'Error: matchGridStretching has failed in matchGridStretching.f90'
           endif
         endif
         if (debug) write(*,*) 'max(iter) = ',k-1 ! number of iterations taken
         ! if (debug) then; stop 'Done in newtonT2_debug'; endif
       end subroutine
#endif

       subroutine newtonT2(T_root,T_prime,beta,hmin,hmax,alpha,N,dh)
         implicit none
         real(cp),intent(inout) :: beta
         procedure(func) :: T_root
         procedure(func_prime) :: T_prime
         real(cp),intent(in) :: hmin,hmax,alpha,dh
         integer,intent(in) :: N
         real(cp) :: dbeta,fbeta,fbetaprime,beta_low ! local variables
         integer,parameter :: maxiter = 1000000
         real(cp),parameter :: tol = 10.0_cp*machine_epsilon
         integer :: k
         logical :: err
         beta_low = one + 10.0_cp**(-10.0_cp)
         err = .false.
         do k=1,maxiter ! Newton iteration to find a zero of T_root(beta)
           fbeta = T_root(beta,hmin,hmax,alpha,N,dh) ! evaluate function and its derivative:
           fbetaprime = T_prime(beta,alpha,N)
           if (abs(fbeta) .lt. tol) exit                              ! success!
           if (beta .gt. 1000.0_cp) exit                              ! big enough!
           if (beta .lt. beta_low) then; beta = 1.1_cp; exit; endif   ! oops!
           dbeta = fbeta/fbetaprime                                   ! compute beta increment
           beta = beta - dbeta                                        ! update
         enddo
         if (is_nan(beta).or.(abs(fbeta).gt.tol)) then ! oops, gracefully handle
           err = .true.; beta = 1.1_cp
         endif
         if (err) call write_error_message_to_file(beta,fbeta,tol)

#ifdef _DEBUG_COORDINATE_STRETCH_PARAM_MATCH_
         call newtonT2_debug(T_root,T_prime,beta,hmin,hmax,alpha,N,dh,err)
#endif
       end subroutine

       subroutine write_error_message_to_file(beta,fbeta,tol)
         implicit none
         real(cp),intent(in) :: fbeta,beta,tol
         integer :: un
         un = new_and_open('','mesh_generation_error')
         write(un,*) 'Error: newtonT2 not converged, gracefully handling.'
         write(un,*) 'fbeta = ',fbeta
         write(un,*) 'beta = ',beta
         write(un,*) 'tol = ',tol
         write(un,*) 'cond_1 = ',is_nan(beta)
         write(un,*) 'cond_2 = ',(abs(fbeta).gt.tol)
         close(un)
       end subroutine

       ! ***************************************************************
       ! ********************** TRANSFORMATION 3 ***********************
       ! ***************************************************************

       ! ***************************************************************
       ! ******************** SOLUTIONS OF ROOTS ***********************
       ! ***************************************************************

       function beta_dh_small(hmin,hmax,N,dh) result(beta)
         implicit none
         real(cp),intent(in) :: hmin,hmax,dh
         integer,intent(in) :: N
         real(cp) :: beta,tol
         tol = 10.0_cp**(-10.0_cp)
         beta = one + tol ! Initial guess
         call newtonT2(T2_root_dh_near_hmax,T2_prime_dh_near_hmax,beta,hmin,hmax,0.0_cp,N,dh)
       end function

       function beta_dh_big(hmin,hmax,N,dh) result(beta)
         implicit none
         real(cp),intent(in) :: hmin,hmax,dh
         integer,intent(in) :: N
         real(cp) :: beta,tol
         tol = 10.0_cp**(-10.0_cp)
         beta = one + tol ! Initial guess
         call newtonT2(T2_root_dh_near_hmin,T2_prime_dh_near_hmin,beta,hmin,hmax,0.0_cp,N,dh)
       end function

       function beta_dh_both(hmin,hmax,N,dh) result(beta)
         implicit none
         real(cp),intent(in) :: hmin,hmax,dh
         integer,intent(in) :: N
         real(cp) :: beta,tol
         tol = 10.0_cp**(-10.0_cp)
         beta = one + tol ! Initial guess
         call newtonT2(T2_root_dh_near_hmax,T2_prime_dh_near_hmax,beta,hmin,hmax,0.5_cp,N,dh)
       end function

       end module
      module dir_manip_mod
      use string_mod
      use IO_tools_mod
      ! Make a buildDirectory routine:
      ! http://homepages.wmich.edu/~korista/README-fortran.html
      ! Using buff(10) = "last modification time"
      ! Ref: https://gcc.gnu.org/onlinedocs/gfortran/STAT.html
      implicit none

#ifdef _OS_LINUX_
      public :: fortran_PS
      character(len=1),parameter :: fortran_PS = '/'
#else
      public :: fortran_PS
      character(len=1),parameter :: fortran_PS = '\'
#endif

      private
      public :: least_recently_modified
      public :: most_recently_modified
      public :: make_dir
      public :: make_dir_quiet
      public :: remove_dir

      interface least_recently_modified; module procedure least_recently_modified_DM;      end interface
      interface most_recently_modified;  module procedure most_recently_modified_DM;       end interface
      interface least_recently_modified; module procedure least_recently_modified_DM_wrap; end interface
      interface most_recently_modified;  module procedure most_recently_modified_DM_wrap;  end interface
      interface make_dir;                module procedure make_dir_DM;                     end interface
      interface make_dir_quiet;          module procedure make_dir_quiet_DM;               end interface
      interface remove_dir;              module procedure remove_dir_DM;                   end interface

      contains

      subroutine least_recently_modified_DM_wrap(folder,folder1,folder2,file_name)
        implicit none
        type(string),intent(inout) :: folder
        character(len=*),intent(in) :: folder1,folder2,file_name
        call least_recently_modified(folder,&
        folder1//file_name//dot_dat,&
        folder2//file_name//dot_dat)
      end subroutine

      subroutine most_recently_modified_DM_wrap(folder,folder1,folder2,file_name)
        implicit none
        type(string),intent(inout) :: folder
        character(len=*),intent(in) :: folder1,folder2,file_name
        call most_recently_modified(folder,&
        folder1//file_name//dot_dat,&
        folder2//file_name//dot_dat)
      end subroutine

      subroutine least_recently_modified_DM(f,f1,f2)
        implicit none
        type(string),intent(inout) :: f
        character(len=*),intent(in) :: f1,f2
        integer, dimension(13) :: buff
        integer :: status1,status2,i1,i2
        call init(f,f1)
        call stat(f1,buff,status1); i1 = buff(10)
        call stat(f2,buff,status2); i2 = buff(10)
        if ((status1.ne.0).and.(status2.ne.0)) then
          write(*,*) 'Error: The following files do not exist!'
          write(*,*) f1
          write(*,*) f2
          stop 'Done in least_recently_modified_DM in dir_manip.f90'
        endif
        if (status1.ne.0) then;     call init(f,f1) ! restart1 empty
        elseif (status2.ne.0) then; call init(f,f2) ! restart1 empty
        else ! Get latest one
          if (i2-i1.gt.0) then; call init(f,f1)
          else;                 call init(f,f2)
          endif
        endif
      end subroutine

      subroutine most_recently_modified_DM(f,f1,f2)
        implicit none
        type(string),intent(inout) :: f
        character(len=*),intent(in) :: f1,f2
        integer, dimension(13) :: buff
        integer :: status1,status2,i1,i2
        call init(f,f1)
        call stat(f1,buff,status1); i1 = buff(10)
        call stat(f2,buff,status2); i2 = buff(10)
        if ((status1.ne.0).and.(status2.ne.0)) then
          write(*,*) 'Error: The following files do not exist!'
          write(*,*) f1
          write(*,*) f2
          stop 'Done in most_recently_modified_DM in dir_manip.f90'
        endif
        if (status1.ne.0) then;     call init(f,f2) ! restart1 empty
        elseif (status2.ne.0) then; call init(f,f1) ! restart1 empty
        else ! Get latest one
          if (i2-i1.gt.0) then; call init(f,f2)
          else;                 call init(f,f1)
          endif
        endif
      end subroutine

      subroutine make_dir_DM(d)
        implicit none
        character(len=*),intent(in) :: d
        logical :: ex
        inquire (file=d, EXIST=ex)
        if (.not.ex) then
          call system('mkdir ' // d )
          write(*,*) 'Directory ' // d // ' created.'
        else
          write(*,*) 'Directory ' // d // ' already exists.'
        endif
      end subroutine

      subroutine make_dir_quiet_DM(d)
        implicit none
        character(len=*),intent(in) :: d
        logical :: ex
        inquire (file=d, EXIST=ex)
        if (.not.ex) call system('mkdir ' // d )
      end subroutine

      subroutine remove_dir_DM(d)
        implicit none
        character(len=*),intent(in) :: d
        logical :: ex
        inquire (file=d, EXIST=ex)
        if (ex) then
          call system('rm -r /' // d )
          write(*,*) 'Directory ' // d // ' deleted.'
        else
          write(*,*) 'Directory ' // d // ' does not exist anyway.'
        endif
      end subroutine

      end module
      module exp_Tecplot_Zone_mod
      use current_precision_mod
      use string_mod
      use IO_tools_mod
      use datatype_conversion_mod
      implicit none

      private

      public :: exp_Zone_3I
      public :: exp_Zone_2I
      public :: exp_Zone_1I
      public :: exp_Zone_0I

      contains

      !*********************************************************************
      !************************ SCALAR FIELDS ******************************
      !*********************************************************************

      subroutine exp_Zone_3I(u,s,t)
        implicit none
        integer,intent(in),dimension(3) :: s
        integer,intent(in) :: u,t
        type(string) :: st
        call init(st,'ZONE ')
        call append(st,', T ="'//int2str(t)//'"')
        call append(st,', I ='//int2str(s(1)))
        call append(st,', J ='//int2str(s(2)))
        call append(st,', K ='//int2str(s(3)))
        call append(st,' DATAPACKING = POINT')
        write(u,*) str(st)
        call delete(st)
      end subroutine

      subroutine exp_Zone_2I(u,s,t)
        implicit none
        integer,intent(in) :: u,t
        integer,dimension(2),intent(in) :: s
        type(string) :: st
        call init(st,'ZONE ')
        call append(st,', T ="'//int2str(t)//'"')
        call append(st,', I ='//int2str(s(1)))
        call append(st,', J ='//int2str(s(2)))
        call append(st,' DATAPACKING = POINT')
        write(u,*) str(st)
        call delete(st)
      end subroutine

      subroutine exp_Zone_1I(u,s,t)
        implicit none
        integer,intent(in) :: s,u,t
        type(string) :: st
        call init(st,'ZONE ')
        call append(st,', T ="'//int2str(t)//'"')
        call append(st,', I ='//int2str(s))
        call append(st,' DATAPACKING = POINT')
        write(u,*) str(st)
        call delete(st)
      end subroutine

      subroutine exp_Zone_0I(u)
        implicit none
        integer,intent(in) :: u
        write(u,*) 'ZONE DATAPACKING = POINT'
      end subroutine

      end module
       module table_mod
       ! Helps export information in tabular format.
       !
       ! Example:
       !
       ! real(cp),dimension(6) :: f
       ! call export_table('Face:',f,number of spaces per column,unit)
       !
       !
       use current_precision_mod
       use string_mod
       use string_aux_mod
       use IO_tools_mod
       use datatype_conversion_mod
       implicit none

       private
       public :: export_table

       interface export_table;    module procedure export_table_CP;      end interface
       interface export_table;    module procedure export_table_INT;     end interface
       interface export_table;    module procedure export_table_LOG;     end interface
       interface export_table;    module procedure export_table_CHAR;    end interface

       contains

       subroutine export_table_CP(label,row,col_space,after_decimal,u)
         implicit none
         character(len=*),intent(in) :: label
         real(cp),dimension(:),intent(in) :: row
         integer,intent(in) :: col_space,after_decimal,u
         type(string) :: s_label,c_space,s_row,n_precision
         call init(n_precision,int2str(after_decimal))
         call init(s_label,int2str(len(label)))
         call init(c_space,int2str(col_space))
         call init(s_row,int2str(size(row)))
         call remove_leading_zeros(s_label)
         call remove_leading_zeros(c_space)
         call remove_leading_zeros(s_row)
         write(u,('(A'//str(s_label)//','//str(s_row)//'F'//str(c_space)//'.'//str(n_precision)//')')) label,row
       end subroutine

       subroutine export_table_INT(label,row,col_space,u)
         implicit none
         character(len=*),intent(in) :: label
         integer,dimension(:),intent(in) :: row
         integer,intent(in) :: col_space,u
         type(string) :: s_label,c_space,s_row
         call init(s_label,int2str(len(label)))
         call init(c_space,int2str(col_space))
         call init(s_row,int2str(size(row)))
         call remove_leading_zeros(s_label)
         call remove_leading_zeros(c_space)
         call remove_leading_zeros(s_row)
         write(u,('(A'//str(s_label)//','//str(s_row)//'I'//str(c_space)//')')) label,row
       end subroutine

       subroutine export_table_LOG(label,row,col_space,u)
         implicit none
         character(len=*),intent(in) :: label
         logical,dimension(:),intent(in) :: row
         integer,intent(in) :: col_space,u
         type(string) :: s_label,c_space,s_row
         call init(s_label,int2str(len(label)))
         call init(c_space,int2str(col_space))
         call init(s_row,int2str(size(row)))
         call remove_leading_zeros(s_label)
         call remove_leading_zeros(c_space)
         call remove_leading_zeros(s_row)
         write(u,('(A'//str(s_label)//','//str(s_row)//'L'//str(c_space)//')')) label,row
       end subroutine

       subroutine export_table_CHAR(label,row,col_space,u)
         implicit none
         character(len=*),intent(in) :: label
         character(len=1),dimension(:),intent(in) :: row
         integer,intent(in) :: col_space,u
         type(string) :: s_label,c_space,s_row
         call init(s_label,int2str(len(label)))
         call init(c_space,int2str(col_space))
         call init(s_row,int2str(size(row)))
         call remove_leading_zeros(s_label)
         call remove_leading_zeros(c_space)
         call remove_leading_zeros(s_row)
         write(u,('(A'//str(s_label)//','//str(s_row)//'A'//str(c_space)//')')) label,row
       end subroutine

       end module
       module version_mod
       use string_mod
       use IO_tools_mod
       implicit none

       private
       public :: export_version
       public :: print_version

       contains

       subroutine export_version(dir)
         implicit none
         character(len=*),intent(in) :: dir
         integer :: NewU
         NewU = new_and_open(dir,'version')
         call export_version_no_dir(newU)
         call close_and_message(newU,dir,'version')
       end subroutine

       subroutine print_version()
         implicit none
         call export_version_no_dir(6)
       end subroutine

       subroutine export_version_no_dir(u)
         implicit none
         integer,intent(in) :: u
         integer :: today(3), now(3)
         ! character(len=5) :: fmt
         write(u,*) '---------------------------------------'
         write(u,*) ' Magnetohydrodynamic Object-Oriented   '
         write(u,*) '    Numerical Solver (MOONS)           '
         write(u,*) '---------------------------------------'
         write(u,*) 'MOONS is a finite difference code that '
         write(u,*) 'solves Navier-Stokes and Maxwells      '
         write(u,*) 'equations in a 3D rectangular geometry.'
         write(u,*) ''
         write(u,*) 'For documentation, navigate to'
         write(u,*) '/MOONS/__documentation/MOONS.pdf'
         write(u,*) '---------------------------------------'

         ! Source: http://infohost.nmt.edu/tcc/help/lang/fortran/date.html

         call idate(today)   ! today(1)=day, (2)=month, (3)=year
         call itime(now)     ! now(1)=hour, (2)=minute, (3)=second
         write ( u, 1000 )  today(2), today(1), today(3), now
    1000 format ( ' Version: ', i2.2, '/', i2.2, '/', i4.4, '; time ',&
                 i2.2, ':', i2.2, ':', i2.2 )

         ! fmt = '(A10,i2.2,A,i2.2,A,i4.4,A6,i2.2,A,i2.2,A,i2.2)'

         ! write(u,fmt) ' Version: ',today(2),'/',today(1),'/',today(3),'; time',now
         write(u,*) '-------------------------------------'
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module BC_logicals_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: BC_logicals
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_BC_logicals;              end interface
       interface delete;                 module procedure delete_BC_logicals;                 end interface
       interface display;                module procedure display_BC_logicals;                end interface
       interface display_short;          module procedure display_short_BC_logicals;          end interface
       interface display;                module procedure display_wrap_BC_logicals;           end interface
       interface print;                  module procedure print_BC_logicals;                  end interface
       interface print_short;            module procedure print_short_BC_logicals;            end interface
       interface export;                 module procedure export_BC_logicals;                 end interface
       interface export_primitives;      module procedure export_primitives_BC_logicals;      end interface
       interface import;                 module procedure import_BC_logicals;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_BC_logicals;end interface
       interface export_structured;      module procedure export_structured_D_BC_logicals;    end interface
       interface import_structured;      module procedure import_structured_D_BC_logicals;    end interface
       interface import_primitives;      module procedure import_primitives_BC_logicals;      end interface
       interface export;                 module procedure export_wrap_BC_logicals;            end interface
       interface import;                 module procedure import_wrap_BC_logicals;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_BC_logicals;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_BC_logicals;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_BC_logicals;      end interface

       type BC_logicals
         logical :: defined = .false.
         logical :: GFs_defined = .false.
         logical :: BCT_defined = .false.
         logical :: vals_defined = .false.
         logical :: all_Dirichlet = .false.
         logical :: all_Neumann = .false.
         logical :: all_Robin = .false.
         logical :: all_symmetric = .false.
         logical :: all_antisymmetric = .false.
         logical :: any_Dirichlet = .false.
         logical :: any_Neumann = .false.
         logical :: any_Robin = .false.
         logical :: any_symmetric = .false.
         logical :: any_antisymmetric = .false.
         logical :: any_prescribed = .false.
       end type

       contains

       subroutine init_copy_BC_logicals(this,that)
         implicit none
         type(BC_logicals),intent(inout) :: this
         type(BC_logicals),intent(in) :: that
         call delete(this)
         this%defined = that%defined
         this%GFs_defined = that%GFs_defined
         this%BCT_defined = that%BCT_defined
         this%vals_defined = that%vals_defined
         this%all_Dirichlet = that%all_Dirichlet
         this%all_Neumann = that%all_Neumann
         this%all_Robin = that%all_Robin
         this%all_symmetric = that%all_symmetric
         this%all_antisymmetric = that%all_antisymmetric
         this%any_Dirichlet = that%any_Dirichlet
         this%any_Neumann = that%any_Neumann
         this%any_Robin = that%any_Robin
         this%any_symmetric = that%any_symmetric
         this%any_antisymmetric = that%any_antisymmetric
         this%any_prescribed = that%any_prescribed
       end subroutine

       subroutine delete_BC_logicals(this)
         implicit none
         type(BC_logicals),intent(inout) :: this
         this%defined = .false.
         this%GFs_defined = .false.
         this%BCT_defined = .false.
         this%vals_defined = .false.
         this%all_Dirichlet = .false.
         this%all_Neumann = .false.
         this%all_Robin = .false.
         this%all_symmetric = .false.
         this%all_antisymmetric = .false.
         this%any_Dirichlet = .false.
         this%any_Neumann = .false.
         this%any_Robin = .false.
         this%any_symmetric = .false.
         this%any_antisymmetric = .false.
         this%any_prescribed = .false.
       end subroutine

       subroutine display_BC_logicals(this,un)
         implicit none
         type(BC_logicals),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined           = ',this%defined
         write(un,*) 'GFs_defined       = ',this%GFs_defined
         write(un,*) 'BCT_defined       = ',this%BCT_defined
         write(un,*) 'vals_defined      = ',this%vals_defined
         write(un,*) 'all_Dirichlet     = ',this%all_Dirichlet
         write(un,*) 'all_Neumann       = ',this%all_Neumann
         write(un,*) 'all_Robin         = ',this%all_Robin
         write(un,*) 'all_symmetric     = ',this%all_symmetric
         write(un,*) 'all_antisymmetric = ',this%all_antisymmetric
         write(un,*) 'any_Dirichlet     = ',this%any_Dirichlet
         write(un,*) 'any_Neumann       = ',this%any_Neumann
         write(un,*) 'any_Robin         = ',this%any_Robin
         write(un,*) 'any_symmetric     = ',this%any_symmetric
         write(un,*) 'any_antisymmetric = ',this%any_antisymmetric
         write(un,*) 'any_prescribed    = ',this%any_prescribed
       end subroutine

       subroutine display_short_BC_logicals(this,un)
         implicit none
         type(BC_logicals),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined           = ',this%defined
         write(un,*) 'GFs_defined       = ',this%GFs_defined
         write(un,*) 'BCT_defined       = ',this%BCT_defined
         write(un,*) 'vals_defined      = ',this%vals_defined
         write(un,*) 'all_Dirichlet     = ',this%all_Dirichlet
         write(un,*) 'all_Neumann       = ',this%all_Neumann
         write(un,*) 'all_Robin         = ',this%all_Robin
         write(un,*) 'all_symmetric     = ',this%all_symmetric
         write(un,*) 'all_antisymmetric = ',this%all_antisymmetric
         write(un,*) 'any_Dirichlet     = ',this%any_Dirichlet
         write(un,*) 'any_Neumann       = ',this%any_Neumann
         write(un,*) 'any_Robin         = ',this%any_Robin
         write(un,*) 'any_symmetric     = ',this%any_symmetric
         write(un,*) 'any_antisymmetric = ',this%any_antisymmetric
         write(un,*) 'any_prescribed    = ',this%any_prescribed
       end subroutine

       subroutine display_wrap_BC_logicals(this,dir,name)
         implicit none
         type(BC_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_BC_logicals(this)
         implicit none
         type(BC_logicals),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_BC_logicals(this)
         implicit none
         type(BC_logicals),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_BC_logicals(this,un)
         implicit none
         type(BC_logicals),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_BC_logicals(this,un)
         implicit none
         type(BC_logicals),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_BC_logicals(this,un)
         implicit none
         type(BC_logicals),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined            = ';write(un,*) this%defined
         write(un,*) 'GFs_defined        = ';write(un,*) this%GFs_defined
         write(un,*) 'BCT_defined        = ';write(un,*) this%BCT_defined
         write(un,*) 'vals_defined       = ';write(un,*) this%vals_defined
         write(un,*) 'all_Dirichlet      = ';write(un,*) this%all_Dirichlet
         write(un,*) 'all_Neumann        = ';write(un,*) this%all_Neumann
         write(un,*) 'all_Robin          = ';write(un,*) this%all_Robin
         write(un,*) 'all_symmetric      = ';write(un,*) this%all_symmetric
         write(un,*) 'all_antisymmetric  = ';write(un,*) this%all_antisymmetric
         write(un,*) 'any_Dirichlet      = ';write(un,*) this%any_Dirichlet
         write(un,*) 'any_Neumann        = ';write(un,*) this%any_Neumann
         write(un,*) 'any_Robin          = ';write(un,*) this%any_Robin
         write(un,*) 'any_symmetric      = ';write(un,*) this%any_symmetric
         write(un,*) 'any_antisymmetric  = ';write(un,*) this%any_antisymmetric
         write(un,*) 'any_prescribed     = ';write(un,*) this%any_prescribed
       end subroutine

       subroutine import_primitives_BC_logicals(this,un)
         implicit none
         type(BC_logicals),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%defined
         read(un,*); read(un,*) this%GFs_defined
         read(un,*); read(un,*) this%BCT_defined
         read(un,*); read(un,*) this%vals_defined
         read(un,*); read(un,*) this%all_Dirichlet
         read(un,*); read(un,*) this%all_Neumann
         read(un,*); read(un,*) this%all_Robin
         read(un,*); read(un,*) this%all_symmetric
         read(un,*); read(un,*) this%all_antisymmetric
         read(un,*); read(un,*) this%any_Dirichlet
         read(un,*); read(un,*) this%any_Neumann
         read(un,*); read(un,*) this%any_Robin
         read(un,*); read(un,*) this%any_symmetric
         read(un,*); read(un,*) this%any_antisymmetric
         read(un,*); read(un,*) this%any_prescribed
       end subroutine

       subroutine export_wrap_BC_logicals(this,dir,name)
         implicit none
         type(BC_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_BC_logicals(this,dir,name)
         implicit none
         type(BC_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_BC_logicals(this,dir)
         implicit none
         type(BC_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_BC_logicals(this,dir)
         implicit none
         type(BC_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_BC_logicals(this,dir)
         implicit none
         type(BC_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_BC_logicals(this,dir)
         implicit none
         type(BC_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_BC_logicals(this,dir)
         implicit none
         type(BC_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_BC_logicals(this)
         implicit none
         type(BC_logicals),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module array_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: array
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_array;              end interface
       interface delete;                 module procedure delete_array;                 end interface
       interface display;                module procedure display_array;                end interface
       interface display_short;          module procedure display_short_array;          end interface
       interface display;                module procedure display_wrap_array;           end interface
       interface print;                  module procedure print_array;                  end interface
       interface print_short;            module procedure print_short_array;            end interface
       interface export;                 module procedure export_array;                 end interface
       interface export_primitives;      module procedure export_primitives_array;      end interface
       interface import;                 module procedure import_array;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_array;end interface
       interface export_structured;      module procedure export_structured_D_array;    end interface
       interface import_structured;      module procedure import_structured_D_array;    end interface
       interface import_primitives;      module procedure import_primitives_array;      end interface
       interface export;                 module procedure export_wrap_array;            end interface
       interface import;                 module procedure import_wrap_array;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_array;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_array;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_array;      end interface

       type array
         real(cp),dimension(:),allocatable :: f
         integer :: N = 0
       end type

       contains

       subroutine init_copy_array(this,that)
         implicit none
         type(array),intent(inout) :: this
         type(array),intent(in) :: that
         call delete(this)
         if (allocated(that%f)) then
           this%f = that%f
         endif
         this%N = that%N
       end subroutine

       subroutine delete_array(this)
         implicit none
         type(array),intent(inout) :: this
         if (allocated(this%f)) then
           deallocate(this%f)
         endif
         this%N = 0
       end subroutine

       subroutine display_array(this,un)
         implicit none
         type(array),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'f = ',this%f
         write(un,*) 'N = ',this%N
       end subroutine

       subroutine display_short_array(this,un)
         implicit none
         type(array),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'N = ',this%N
       end subroutine

       subroutine display_wrap_array(this,dir,name)
         implicit none
         type(array),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_array(this)
         implicit none
         type(array),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_array(this)
         implicit none
         type(array),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_array(this,un)
         implicit none
         type(array),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_array(this,un)
         implicit none
         type(array),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_array(this,un)
         implicit none
         type(array),intent(in) :: this
         integer,intent(in) :: un
         integer :: s_f
         if (allocated(this%f)) then
           s_f = size(this%f)
           write(un,*) s_f
           if (s_f.gt.0) then
             write(un,*) 'f  = ';write(un,*) this%f
           endif
         else
           write(un,*) 0
         endif
         write(un,*) 'N  = ';write(un,*) this%N
       end subroutine

       subroutine import_primitives_array(this,un)
         implicit none
         type(array),intent(inout) :: this
         integer,intent(in) :: un
         integer :: s_f
         read(un,*) s_f
         if (s_f.gt.0) then
           allocate(this%f(s_f))
           read(un,*); read(un,*) this%f
         endif
         read(un,*); read(un,*) this%N
       end subroutine

       subroutine export_wrap_array(this,dir,name)
         implicit none
         type(array),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_array(this,dir,name)
         implicit none
         type(array),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_array(this,dir)
         implicit none
         type(array),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_array(this,dir)
         implicit none
         type(array),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_array(this,dir)
         implicit none
         type(array),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_array(this,dir)
         implicit none
         type(array),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_array(this,dir)
         implicit none
         type(array),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_array(this)
         implicit none
         type(array),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module bctype_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: bctype
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_bctype;              end interface
       interface delete;                 module procedure delete_bctype;                 end interface
       interface display;                module procedure display_bctype;                end interface
       interface display_short;          module procedure display_short_bctype;          end interface
       interface display;                module procedure display_wrap_bctype;           end interface
       interface print;                  module procedure print_bctype;                  end interface
       interface print_short;            module procedure print_short_bctype;            end interface
       interface export;                 module procedure export_bctype;                 end interface
       interface export_primitives;      module procedure export_primitives_bctype;      end interface
       interface import;                 module procedure import_bctype;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_bctype;end interface
       interface export_structured;      module procedure export_structured_D_bctype;    end interface
       interface import_structured;      module procedure import_structured_D_bctype;    end interface
       interface import_primitives;      module procedure import_primitives_bctype;      end interface
       interface export;                 module procedure export_wrap_bctype;            end interface
       interface import;                 module procedure import_wrap_bctype;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_bctype;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_bctype;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_bctype;      end interface

       type bctype
         logical :: Dirichlet = .false.
         logical :: Neumann = .false.
         logical :: Robin = .false.
         logical :: Periodic = .false.
         logical :: symmetric = .false.
         logical :: antisymmetric = .false.
         logical :: prescribed = .false.
         logical :: defined = .false.
         real(cp) :: meanVal = 0.0_cp
         character(len=1) :: BCT = ' '
       end type

       contains

       subroutine init_copy_bctype(this,that)
         implicit none
         type(bctype),intent(inout) :: this
         type(bctype),intent(in) :: that
         call delete(this)
         this%Dirichlet = that%Dirichlet
         this%Neumann = that%Neumann
         this%Robin = that%Robin
         this%Periodic = that%Periodic
         this%symmetric = that%symmetric
         this%antisymmetric = that%antisymmetric
         this%prescribed = that%prescribed
         this%defined = that%defined
         this%meanVal = that%meanVal
         this%BCT = that%BCT
       end subroutine

       subroutine delete_bctype(this)
         implicit none
         type(bctype),intent(inout) :: this
         this%Dirichlet = .false.
         this%Neumann = .false.
         this%Robin = .false.
         this%Periodic = .false.
         this%symmetric = .false.
         this%antisymmetric = .false.
         this%prescribed = .false.
         this%defined = .false.
         this%meanVal = 0.0_cp
         this%BCT = ' '
       end subroutine

       subroutine display_bctype(this,un)
         implicit none
         type(bctype),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'Dirichlet     = ',this%Dirichlet
         write(un,*) 'Neumann       = ',this%Neumann
         write(un,*) 'Robin         = ',this%Robin
         write(un,*) 'Periodic      = ',this%Periodic
         write(un,*) 'symmetric     = ',this%symmetric
         write(un,*) 'antisymmetric = ',this%antisymmetric
         write(un,*) 'prescribed    = ',this%prescribed
         write(un,*) 'defined       = ',this%defined
         write(un,*) 'meanVal       = ',this%meanVal
         write(un,*) 'BCT           = ',this%BCT
       end subroutine

       subroutine display_short_bctype(this,un)
         implicit none
         type(bctype),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'Dirichlet     = ',this%Dirichlet
         write(un,*) 'Neumann       = ',this%Neumann
         write(un,*) 'Robin         = ',this%Robin
         write(un,*) 'Periodic      = ',this%Periodic
         write(un,*) 'symmetric     = ',this%symmetric
         write(un,*) 'antisymmetric = ',this%antisymmetric
         write(un,*) 'prescribed    = ',this%prescribed
         write(un,*) 'defined       = ',this%defined
         write(un,*) 'meanVal       = ',this%meanVal
         write(un,*) 'BCT           = ',this%BCT
       end subroutine

       subroutine display_wrap_bctype(this,dir,name)
         implicit none
         type(bctype),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_bctype(this)
         implicit none
         type(bctype),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_bctype(this)
         implicit none
         type(bctype),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_bctype(this,un)
         implicit none
         type(bctype),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_bctype(this,un)
         implicit none
         type(bctype),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_bctype(this,un)
         implicit none
         type(bctype),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'Dirichlet      = ';write(un,*) this%Dirichlet
         write(un,*) 'Neumann        = ';write(un,*) this%Neumann
         write(un,*) 'Robin          = ';write(un,*) this%Robin
         write(un,*) 'Periodic       = ';write(un,*) this%Periodic
         write(un,*) 'symmetric      = ';write(un,*) this%symmetric
         write(un,*) 'antisymmetric  = ';write(un,*) this%antisymmetric
         write(un,*) 'prescribed     = ';write(un,*) this%prescribed
         write(un,*) 'defined        = ';write(un,*) this%defined
         write(un,*) 'meanVal        = ';write(un,*) this%meanVal
         write(un,*) 'BCT            = ';write(un,*) this%BCT
       end subroutine

       subroutine import_primitives_bctype(this,un)
         implicit none
         type(bctype),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%Dirichlet
         read(un,*); read(un,*) this%Neumann
         read(un,*); read(un,*) this%Robin
         read(un,*); read(un,*) this%Periodic
         read(un,*); read(un,*) this%symmetric
         read(un,*); read(un,*) this%antisymmetric
         read(un,*); read(un,*) this%prescribed
         read(un,*); read(un,*) this%defined
         read(un,*); read(un,*) this%meanVal
         read(un,*); read(un,*) this%BCT
       end subroutine

       subroutine export_wrap_bctype(this,dir,name)
         implicit none
         type(bctype),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_bctype(this,dir,name)
         implicit none
         type(bctype),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_bctype(this,dir)
         implicit none
         type(bctype),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_bctype(this,dir)
         implicit none
         type(bctype),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_bctype(this,dir)
         implicit none
         type(bctype),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_bctype(this,dir)
         implicit none
         type(bctype),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_bctype(this,dir)
         implicit none
         type(bctype),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_bctype(this)
         implicit none
         type(bctype),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module clock_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: clock
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_clock;              end interface
       interface delete;                 module procedure delete_clock;                 end interface
       interface display;                module procedure display_clock;                end interface
       interface display_short;          module procedure display_short_clock;          end interface
       interface display;                module procedure display_wrap_clock;           end interface
       interface print;                  module procedure print_clock;                  end interface
       interface print_short;            module procedure print_short_clock;            end interface
       interface export;                 module procedure export_clock;                 end interface
       interface export_primitives;      module procedure export_primitives_clock;      end interface
       interface import;                 module procedure import_clock;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_clock;end interface
       interface export_structured;      module procedure export_structured_D_clock;    end interface
       interface import_structured;      module procedure import_structured_D_clock;    end interface
       interface import_primitives;      module procedure import_primitives_clock;      end interface
       interface export;                 module procedure export_wrap_clock;            end interface
       interface import;                 module procedure import_wrap_clock;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_clock;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_clock;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_clock;      end interface

       type clock
         real(cp) :: t_elapsed = 0.0_cp
         real(cp) :: t_elapsed_computational = 0.0_cp
         real(cp) :: t_start_computational = 0.0_cp
         real(cp) :: t_stop_computational = 0.0_cp
         real(cp) :: t_start = 0.0_cp
         real(cp) :: t_stop = 0.0_cp
         integer(li) :: i_start = 0
         integer(li) :: i_stop = 0
         integer(li) :: count_rate = 0
       end type

       contains

       subroutine init_copy_clock(this,that)
         implicit none
         type(clock),intent(inout) :: this
         type(clock),intent(in) :: that
         call delete(this)
         this%t_elapsed = that%t_elapsed
         this%t_elapsed_computational = that%t_elapsed_computational
         this%t_start_computational = that%t_start_computational
         this%t_stop_computational = that%t_stop_computational
         this%t_start = that%t_start
         this%t_stop = that%t_stop
         this%i_start = that%i_start
         this%i_stop = that%i_stop
         this%count_rate = that%count_rate
       end subroutine

       subroutine delete_clock(this)
         implicit none
         type(clock),intent(inout) :: this
         this%t_elapsed = 0.0_cp
         this%t_elapsed_computational = 0.0_cp
         this%t_start_computational = 0.0_cp
         this%t_stop_computational = 0.0_cp
         this%t_start = 0.0_cp
         this%t_stop = 0.0_cp
         this%i_start = 0
         this%i_stop = 0
         this%count_rate = 0
       end subroutine

       subroutine display_clock(this,un)
         implicit none
         type(clock),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 't_elapsed               = ',this%t_elapsed
         write(un,*) 't_elapsed_computational = ',&
         this%t_elapsed_computational
         write(un,*) 't_start_computational   = ',this%t_start_computational
         write(un,*) 't_stop_computational    = ',this%t_stop_computational
         write(un,*) 't_start                 = ',this%t_start
         write(un,*) 't_stop                  = ',this%t_stop
         write(un,*) 'i_start                 = ',this%i_start
         write(un,*) 'i_stop                  = ',this%i_stop
         write(un,*) 'count_rate              = ',this%count_rate
       end subroutine

       subroutine display_short_clock(this,un)
         implicit none
         type(clock),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 't_elapsed               = ',this%t_elapsed
         write(un,*) 't_elapsed_computational = ',&
         this%t_elapsed_computational
         write(un,*) 't_start_computational   = ',this%t_start_computational
         write(un,*) 't_stop_computational    = ',this%t_stop_computational
         write(un,*) 't_start                 = ',this%t_start
         write(un,*) 't_stop                  = ',this%t_stop
         write(un,*) 'i_start                 = ',this%i_start
         write(un,*) 'i_stop                  = ',this%i_stop
         write(un,*) 'count_rate              = ',this%count_rate
       end subroutine

       subroutine display_wrap_clock(this,dir,name)
         implicit none
         type(clock),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_clock(this)
         implicit none
         type(clock),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_clock(this)
         implicit none
         type(clock),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_clock(this,un)
         implicit none
         type(clock),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_clock(this,un)
         implicit none
         type(clock),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_clock(this,un)
         implicit none
         type(clock),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 't_elapsed                = ';write(un,*) this%t_elapsed
         write(un,*) 't_elapsed_computational  = ';write(un,*) this%t_elapsed_computational
         write(un,*) 't_start_computational    = ';write(un,*) this%t_start_computational
         write(un,*) 't_stop_computational     = ';write(un,*) this%t_stop_computational
         write(un,*) 't_start                  = ';write(un,*) this%t_start
         write(un,*) 't_stop                   = ';write(un,*) this%t_stop
         write(un,*) 'i_start                  = ';write(un,*) this%i_start
         write(un,*) 'i_stop                   = ';write(un,*) this%i_stop
         write(un,*) 'count_rate               = ';write(un,*) this%count_rate
       end subroutine

       subroutine import_primitives_clock(this,un)
         implicit none
         type(clock),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%t_elapsed
         read(un,*); read(un,*) this%t_elapsed_computational
         read(un,*); read(un,*) this%t_start_computational
         read(un,*); read(un,*) this%t_stop_computational
         read(un,*); read(un,*) this%t_start
         read(un,*); read(un,*) this%t_stop
         read(un,*); read(un,*) this%i_start
         read(un,*); read(un,*) this%i_stop
         read(un,*); read(un,*) this%count_rate
       end subroutine

       subroutine export_wrap_clock(this,dir,name)
         implicit none
         type(clock),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_clock(this,dir,name)
         implicit none
         type(clock),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_clock(this,dir)
         implicit none
         type(clock),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_clock(this,dir)
         implicit none
         type(clock),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_clock(this,dir)
         implicit none
         type(clock),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_clock(this,dir)
         implicit none
         type(clock),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_clock(this,dir)
         implicit none
         type(clock),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_clock(this)
         implicit none
         type(clock),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module data_location_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: data_location
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_data_location;              end interface
       interface delete;                 module procedure delete_data_location;                 end interface
       interface display;                module procedure display_data_location;                end interface
       interface display_short;          module procedure display_short_data_location;          end interface
       interface display;                module procedure display_wrap_data_location;           end interface
       interface print;                  module procedure print_data_location;                  end interface
       interface print_short;            module procedure print_short_data_location;            end interface
       interface export;                 module procedure export_data_location;                 end interface
       interface export_primitives;      module procedure export_primitives_data_location;      end interface
       interface import;                 module procedure import_data_location;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_data_location;end interface
       interface export_structured;      module procedure export_structured_D_data_location;    end interface
       interface import_structured;      module procedure import_structured_D_data_location;    end interface
       interface import_primitives;      module procedure import_primitives_data_location;      end interface
       interface export;                 module procedure export_wrap_data_location;            end interface
       interface import;                 module procedure import_wrap_data_location;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_data_location;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_data_location;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_data_location;      end interface

       type data_location
         logical :: C = .false.
         logical :: N = .false.
         logical :: E = .false.
         logical :: F = .false.
         logical :: defined = .false.
         integer :: face = 0
         integer :: edge = 0
         integer :: volume_ID = 0
         logical,dimension(3) :: CC_along = .false.
         logical,dimension(3) :: N_along = .false.
         integer,dimension(3) :: CC_eye = 0
         integer,dimension(3) :: N_eye = 0
       end type

       contains

       subroutine init_copy_data_location(this,that)
         implicit none
         type(data_location),intent(inout) :: this
         type(data_location),intent(in) :: that
         call delete(this)
         this%C = that%C
         this%N = that%N
         this%E = that%E
         this%F = that%F
         this%defined = that%defined
         this%face = that%face
         this%edge = that%edge
         this%volume_ID = that%volume_ID
         this%CC_along = that%CC_along
         this%N_along = that%N_along
         this%CC_eye = that%CC_eye
         this%N_eye = that%N_eye
       end subroutine

       subroutine delete_data_location(this)
         implicit none
         type(data_location),intent(inout) :: this
         this%C = .false.
         this%N = .false.
         this%E = .false.
         this%F = .false.
         this%defined = .false.
         this%face = 0
         this%edge = 0
         this%volume_ID = 0
         this%CC_along = .false.
         this%N_along = .false.
         this%CC_eye = 0
         this%N_eye = 0
       end subroutine

       subroutine display_data_location(this,un)
         implicit none
         type(data_location),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'C         = ',this%C
         write(un,*) 'N         = ',this%N
         write(un,*) 'E         = ',this%E
         write(un,*) 'F         = ',this%F
         write(un,*) 'defined   = ',this%defined
         write(un,*) 'face      = ',this%face
         write(un,*) 'edge      = ',this%edge
         write(un,*) 'volume_ID = ',this%volume_ID
         write(un,*) 'CC_along  = ',this%CC_along
         write(un,*) 'N_along   = ',this%N_along
         write(un,*) 'CC_eye    = ',this%CC_eye
         write(un,*) 'N_eye     = ',this%N_eye
       end subroutine

       subroutine display_short_data_location(this,un)
         implicit none
         type(data_location),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'C         = ',this%C
         write(un,*) 'N         = ',this%N
         write(un,*) 'E         = ',this%E
         write(un,*) 'F         = ',this%F
         write(un,*) 'defined   = ',this%defined
         write(un,*) 'face      = ',this%face
         write(un,*) 'edge      = ',this%edge
         write(un,*) 'volume_ID = ',this%volume_ID
         write(un,*) 'CC_along  = ',this%CC_along
         write(un,*) 'N_along   = ',this%N_along
         write(un,*) 'CC_eye    = ',this%CC_eye
         write(un,*) 'N_eye     = ',this%N_eye
       end subroutine

       subroutine display_wrap_data_location(this,dir,name)
         implicit none
         type(data_location),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_data_location(this)
         implicit none
         type(data_location),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_data_location(this)
         implicit none
         type(data_location),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_data_location(this,un)
         implicit none
         type(data_location),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_data_location(this,un)
         implicit none
         type(data_location),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_data_location(this,un)
         implicit none
         type(data_location),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'C          = ';write(un,*) this%C
         write(un,*) 'N          = ';write(un,*) this%N
         write(un,*) 'E          = ';write(un,*) this%E
         write(un,*) 'F          = ';write(un,*) this%F
         write(un,*) 'defined    = ';write(un,*) this%defined
         write(un,*) 'face       = ';write(un,*) this%face
         write(un,*) 'edge       = ';write(un,*) this%edge
         write(un,*) 'volume_ID  = ';write(un,*) this%volume_ID
         write(un,*) 'CC_along   = ';write(un,*) this%CC_along
         write(un,*) 'N_along    = ';write(un,*) this%N_along
         write(un,*) 'CC_eye     = ';write(un,*) this%CC_eye
         write(un,*) 'N_eye      = ';write(un,*) this%N_eye
       end subroutine

       subroutine import_primitives_data_location(this,un)
         implicit none
         type(data_location),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%C
         read(un,*); read(un,*) this%N
         read(un,*); read(un,*) this%E
         read(un,*); read(un,*) this%F
         read(un,*); read(un,*) this%defined
         read(un,*); read(un,*) this%face
         read(un,*); read(un,*) this%edge
         read(un,*); read(un,*) this%volume_ID
         read(un,*); read(un,*) this%CC_along
         read(un,*); read(un,*) this%N_along
         read(un,*); read(un,*) this%CC_eye
         read(un,*); read(un,*) this%N_eye
       end subroutine

       subroutine export_wrap_data_location(this,dir,name)
         implicit none
         type(data_location),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_data_location(this,dir,name)
         implicit none
         type(data_location),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_data_location(this,dir)
         implicit none
         type(data_location),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_data_location(this,dir)
         implicit none
         type(data_location),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_data_location(this,dir)
         implicit none
         type(data_location),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_data_location(this,dir)
         implicit none
         type(data_location),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_data_location(this,dir)
         implicit none
         type(data_location),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_data_location(this)
         implicit none
         type(data_location),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module dimensionless_params_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: dimensionless_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_dimensionless_params;              end interface
       interface delete;                 module procedure delete_dimensionless_params;                 end interface
       interface display;                module procedure display_dimensionless_params;                end interface
       interface display_short;          module procedure display_short_dimensionless_params;          end interface
       interface display;                module procedure display_wrap_dimensionless_params;           end interface
       interface print;                  module procedure print_dimensionless_params;                  end interface
       interface print_short;            module procedure print_short_dimensionless_params;            end interface
       interface export;                 module procedure export_dimensionless_params;                 end interface
       interface export_primitives;      module procedure export_primitives_dimensionless_params;      end interface
       interface import;                 module procedure import_dimensionless_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_dimensionless_params;end interface
       interface export_structured;      module procedure export_structured_D_dimensionless_params;    end interface
       interface import_structured;      module procedure import_structured_D_dimensionless_params;    end interface
       interface import_primitives;      module procedure import_primitives_dimensionless_params;      end interface
       interface export;                 module procedure export_wrap_dimensionless_params;            end interface
       interface import;                 module procedure import_wrap_dimensionless_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_dimensionless_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_dimensionless_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_dimensionless_params;      end interface
       interface export;                 module procedure export_DN_dimensionless_params;              end interface
       interface import;                 module procedure import_DN_dimensionless_params;              end interface
       interface export_structured;      module procedure export_structured_DN_dimensionless_params;   end interface
       interface import_structured;      module procedure import_structured_DN_dimensionless_params;   end interface

       type dimensionless_params
         real(cp) :: Re = 0.0_cp
         real(cp) :: Al = 0.0_cp
         real(cp) :: N = 0.0_cp
         real(cp) :: Ha = 0.0_cp
         real(cp) :: tau = 0.0_cp
         real(cp) :: Gr = 0.0_cp
         real(cp) :: Fr = 0.0_cp
         real(cp) :: Pr = 0.0_cp
         real(cp) :: Pe = 0.0_cp
         real(cp) :: Ec = 0.0_cp
         real(cp) :: Rem = 0.0_cp
         real(cp),dimension(6) :: c_w = 0.0_cp
         real(cp),dimension(6) :: Robin_coeff = 0.0_cp
         real(cp) :: Q = 0.0_cp
         real(cp) :: sig_local_over_sig_f = 0.0_cp
         real(cp) :: KE_scale = 0.0_cp
         real(cp) :: ME_scale = 0.0_cp
         real(cp) :: JE_scale = 0.0_cp
         real(cp) :: L_eta = 0.0_cp
         real(cp) :: U_eta = 0.0_cp
         real(cp) :: t_eta = 0.0_cp
         real(cp) :: t_start = 0.0_cp
         real(cp) :: dtime = 0.0_cp
         real(cp) :: t_final = 0.0_cp
         type(string) :: dir
         type(string) :: name
       end type

       contains

       subroutine init_copy_dimensionless_params(this,that)
         implicit none
         type(dimensionless_params),intent(inout) :: this
         type(dimensionless_params),intent(in) :: that
         call delete(this)
         this%Re = that%Re
         this%Al = that%Al
         this%N = that%N
         this%Ha = that%Ha
         this%tau = that%tau
         this%Gr = that%Gr
         this%Fr = that%Fr
         this%Pr = that%Pr
         this%Pe = that%Pe
         this%Ec = that%Ec
         this%Rem = that%Rem
         this%c_w = that%c_w
         this%Robin_coeff = that%Robin_coeff
         this%Q = that%Q
         this%sig_local_over_sig_f = that%sig_local_over_sig_f
         this%KE_scale = that%KE_scale
         this%ME_scale = that%ME_scale
         this%JE_scale = that%JE_scale
         this%L_eta = that%L_eta
         this%U_eta = that%U_eta
         this%t_eta = that%t_eta
         this%t_start = that%t_start
         this%dtime = that%dtime
         this%t_final = that%t_final
         call init(this%dir,that%dir)
         call init(this%name,that%name)
       end subroutine

       subroutine delete_dimensionless_params(this)
         implicit none
         type(dimensionless_params),intent(inout) :: this
         this%Re = 0.0_cp
         this%Al = 0.0_cp
         this%N = 0.0_cp
         this%Ha = 0.0_cp
         this%tau = 0.0_cp
         this%Gr = 0.0_cp
         this%Fr = 0.0_cp
         this%Pr = 0.0_cp
         this%Pe = 0.0_cp
         this%Ec = 0.0_cp
         this%Rem = 0.0_cp
         this%c_w = 0.0_cp
         this%Robin_coeff = 0.0_cp
         this%Q = 0.0_cp
         this%sig_local_over_sig_f = 0.0_cp
         this%KE_scale = 0.0_cp
         this%ME_scale = 0.0_cp
         this%JE_scale = 0.0_cp
         this%L_eta = 0.0_cp
         this%U_eta = 0.0_cp
         this%t_eta = 0.0_cp
         this%t_start = 0.0_cp
         this%dtime = 0.0_cp
         this%t_final = 0.0_cp
         call delete(this%dir)
         call delete(this%name)
       end subroutine

       subroutine display_dimensionless_params(this,un)
         implicit none
         type(dimensionless_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'Re                   = ',this%Re
         write(un,*) 'Al                   = ',this%Al
         write(un,*) 'N                    = ',this%N
         write(un,*) 'Ha                   = ',this%Ha
         write(un,*) 'tau                  = ',this%tau
         write(un,*) 'Gr                   = ',this%Gr
         write(un,*) 'Fr                   = ',this%Fr
         write(un,*) 'Pr                   = ',this%Pr
         write(un,*) 'Pe                   = ',this%Pe
         write(un,*) 'Ec                   = ',this%Ec
         write(un,*) 'Rem                  = ',this%Rem
         write(un,*) 'c_w                  = ',this%c_w
         write(un,*) 'Robin_coeff          = ',this%Robin_coeff
         write(un,*) 'Q                    = ',this%Q
         write(un,*) 'sig_local_over_sig_f = ',this%sig_local_over_sig_f
         write(un,*) 'KE_scale             = ',this%KE_scale
         write(un,*) 'ME_scale             = ',this%ME_scale
         write(un,*) 'JE_scale             = ',this%JE_scale
         write(un,*) 'L_eta                = ',this%L_eta
         write(un,*) 'U_eta                = ',this%U_eta
         write(un,*) 't_eta                = ',this%t_eta
         write(un,*) 't_start              = ',this%t_start
         write(un,*) 'dtime                = ',this%dtime
         write(un,*) 't_final              = ',this%t_final
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_short_dimensionless_params(this,un)
         implicit none
         type(dimensionless_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'Re                   = ',this%Re
         write(un,*) 'Al                   = ',this%Al
         write(un,*) 'N                    = ',this%N
         write(un,*) 'Ha                   = ',this%Ha
         write(un,*) 'tau                  = ',this%tau
         write(un,*) 'Gr                   = ',this%Gr
         write(un,*) 'Fr                   = ',this%Fr
         write(un,*) 'Pr                   = ',this%Pr
         write(un,*) 'Pe                   = ',this%Pe
         write(un,*) 'Ec                   = ',this%Ec
         write(un,*) 'Rem                  = ',this%Rem
         write(un,*) 'c_w                  = ',this%c_w
         write(un,*) 'Robin_coeff          = ',this%Robin_coeff
         write(un,*) 'Q                    = ',this%Q
         write(un,*) 'sig_local_over_sig_f = ',this%sig_local_over_sig_f
         write(un,*) 'KE_scale             = ',this%KE_scale
         write(un,*) 'ME_scale             = ',this%ME_scale
         write(un,*) 'JE_scale             = ',this%JE_scale
         write(un,*) 'L_eta                = ',this%L_eta
         write(un,*) 'U_eta                = ',this%U_eta
         write(un,*) 't_eta                = ',this%t_eta
         write(un,*) 't_start              = ',this%t_start
         write(un,*) 'dtime                = ',this%dtime
         write(un,*) 't_final              = ',this%t_final
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_wrap_dimensionless_params(this,dir,name)
         implicit none
         type(dimensionless_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_dimensionless_params(this)
         implicit none
         type(dimensionless_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_dimensionless_params(this)
         implicit none
         type(dimensionless_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_dimensionless_params(this,un)
         implicit none
         type(dimensionless_params),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_dimensionless_params(this,un)
         implicit none
         type(dimensionless_params),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_dimensionless_params(this,un)
         implicit none
         type(dimensionless_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'Re                    = ';write(un,*) this%Re
         write(un,*) 'Al                    = ';write(un,*) this%Al
         write(un,*) 'N                     = ';write(un,*) this%N
         write(un,*) 'Ha                    = ';write(un,*) this%Ha
         write(un,*) 'tau                   = ';write(un,*) this%tau
         write(un,*) 'Gr                    = ';write(un,*) this%Gr
         write(un,*) 'Fr                    = ';write(un,*) this%Fr
         write(un,*) 'Pr                    = ';write(un,*) this%Pr
         write(un,*) 'Pe                    = ';write(un,*) this%Pe
         write(un,*) 'Ec                    = ';write(un,*) this%Ec
         write(un,*) 'Rem                   = ';write(un,*) this%Rem
         write(un,*) 'c_w                   = ';write(un,*) this%c_w
         write(un,*) 'Robin_coeff           = ';write(un,*) this%Robin_coeff
         write(un,*) 'Q                     = ';write(un,*) this%Q
         write(un,*) 'sig_local_over_sig_f  = ';write(un,*) this%sig_local_over_sig_f
         write(un,*) 'KE_scale              = ';write(un,*) this%KE_scale
         write(un,*) 'ME_scale              = ';write(un,*) this%ME_scale
         write(un,*) 'JE_scale              = ';write(un,*) this%JE_scale
         write(un,*) 'L_eta                 = ';write(un,*) this%L_eta
         write(un,*) 'U_eta                 = ';write(un,*) this%U_eta
         write(un,*) 't_eta                 = ';write(un,*) this%t_eta
         write(un,*) 't_start               = ';write(un,*) this%t_start
         write(un,*) 'dtime                 = ';write(un,*) this%dtime
         write(un,*) 't_final               = ';write(un,*) this%t_final
       end subroutine

       subroutine import_primitives_dimensionless_params(this,un)
         implicit none
         type(dimensionless_params),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%Re
         read(un,*); read(un,*) this%Al
         read(un,*); read(un,*) this%N
         read(un,*); read(un,*) this%Ha
         read(un,*); read(un,*) this%tau
         read(un,*); read(un,*) this%Gr
         read(un,*); read(un,*) this%Fr
         read(un,*); read(un,*) this%Pr
         read(un,*); read(un,*) this%Pe
         read(un,*); read(un,*) this%Ec
         read(un,*); read(un,*) this%Rem
         read(un,*); read(un,*) this%c_w
         read(un,*); read(un,*) this%Robin_coeff
         read(un,*); read(un,*) this%Q
         read(un,*); read(un,*) this%sig_local_over_sig_f
         read(un,*); read(un,*) this%KE_scale
         read(un,*); read(un,*) this%ME_scale
         read(un,*); read(un,*) this%JE_scale
         read(un,*); read(un,*) this%L_eta
         read(un,*); read(un,*) this%U_eta
         read(un,*); read(un,*) this%t_eta
         read(un,*); read(un,*) this%t_start
         read(un,*); read(un,*) this%dtime
         read(un,*); read(un,*) this%t_final
       end subroutine

       subroutine export_wrap_dimensionless_params(this,dir,name)
         implicit none
         type(dimensionless_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_dimensionless_params(this,dir,name)
         implicit none
         type(dimensionless_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_dimensionless_params(this)
         implicit none
         type(dimensionless_params),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_dimensionless_params(this)
         implicit none
         type(dimensionless_params),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_dimensionless_params(this)
         implicit none
         type(dimensionless_params),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_dimensionless_params(this)
         implicit none
         type(dimensionless_params),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_dimensionless_params(this,dir)
         implicit none
         type(dimensionless_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_dimensionless_params(this,dir)
         implicit none
         type(dimensionless_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_dimensionless_params(this,dir)
         implicit none
         type(dimensionless_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_dimensionless_params(this,dir)
         implicit none
         type(dimensionless_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_dimensionless_params(this,dir)
         implicit none
         type(dimensionless_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_dimensionless_params(this)
         implicit none
         type(dimensionless_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module equation_term_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: equation_term
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_equation_term;              end interface
       interface delete;                 module procedure delete_equation_term;                 end interface
       interface display;                module procedure display_equation_term;                end interface
       interface display_short;          module procedure display_short_equation_term;          end interface
       interface display;                module procedure display_wrap_equation_term;           end interface
       interface print;                  module procedure print_equation_term;                  end interface
       interface print_short;            module procedure print_short_equation_term;            end interface
       interface export;                 module procedure export_equation_term;                 end interface
       interface export_primitives;      module procedure export_primitives_equation_term;      end interface
       interface import;                 module procedure import_equation_term;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_equation_term;end interface
       interface export_structured;      module procedure export_structured_D_equation_term;    end interface
       interface import_structured;      module procedure import_structured_D_equation_term;    end interface
       interface import_primitives;      module procedure import_primitives_equation_term;      end interface
       interface export;                 module procedure export_wrap_equation_term;            end interface
       interface import;                 module procedure import_wrap_equation_term;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_equation_term;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_equation_term;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_equation_term;      end interface

       type equation_term
         logical :: add = .false.
         real(cp) :: scale = 0.0_cp
       end type

       contains

       subroutine init_copy_equation_term(this,that)
         implicit none
         type(equation_term),intent(inout) :: this
         type(equation_term),intent(in) :: that
         call delete(this)
         this%add = that%add
         this%scale = that%scale
       end subroutine

       subroutine delete_equation_term(this)
         implicit none
         type(equation_term),intent(inout) :: this
         this%add = .false.
         this%scale = 0.0_cp
       end subroutine

       subroutine display_equation_term(this,un)
         implicit none
         type(equation_term),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'add   = ',this%add
         write(un,*) 'scale = ',this%scale
       end subroutine

       subroutine display_short_equation_term(this,un)
         implicit none
         type(equation_term),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'add   = ',this%add
         write(un,*) 'scale = ',this%scale
       end subroutine

       subroutine display_wrap_equation_term(this,dir,name)
         implicit none
         type(equation_term),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_equation_term(this)
         implicit none
         type(equation_term),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_equation_term(this)
         implicit none
         type(equation_term),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_equation_term(this,un)
         implicit none
         type(equation_term),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_equation_term(this,un)
         implicit none
         type(equation_term),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_equation_term(this,un)
         implicit none
         type(equation_term),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'add    = ';write(un,*) this%add
         write(un,*) 'scale  = ';write(un,*) this%scale
       end subroutine

       subroutine import_primitives_equation_term(this,un)
         implicit none
         type(equation_term),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%add
         read(un,*); read(un,*) this%scale
       end subroutine

       subroutine export_wrap_equation_term(this,dir,name)
         implicit none
         type(equation_term),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_equation_term(this,dir,name)
         implicit none
         type(equation_term),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_equation_term(this,dir)
         implicit none
         type(equation_term),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_equation_term(this,dir)
         implicit none
         type(equation_term),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_equation_term(this,dir)
         implicit none
         type(equation_term),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_equation_term(this,dir)
         implicit none
         type(equation_term),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_equation_term(this,dir)
         implicit none
         type(equation_term),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_equation_term(this)
         implicit none
         type(equation_term),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module exit_criteria_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: exit_criteria
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_exit_criteria;              end interface
       interface delete;                 module procedure delete_exit_criteria;                 end interface
       interface display;                module procedure display_exit_criteria;                end interface
       interface display_short;          module procedure display_short_exit_criteria;          end interface
       interface display;                module procedure display_wrap_exit_criteria;           end interface
       interface print;                  module procedure print_exit_criteria;                  end interface
       interface print_short;            module procedure print_short_exit_criteria;            end interface
       interface export;                 module procedure export_exit_criteria;                 end interface
       interface export_primitives;      module procedure export_primitives_exit_criteria;      end interface
       interface import;                 module procedure import_exit_criteria;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_exit_criteria;end interface
       interface export_structured;      module procedure export_structured_D_exit_criteria;    end interface
       interface import_structured;      module procedure import_structured_D_exit_criteria;    end interface
       interface import_primitives;      module procedure import_primitives_exit_criteria;      end interface
       interface export;                 module procedure export_wrap_exit_criteria;            end interface
       interface import;                 module procedure import_wrap_exit_criteria;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_exit_criteria;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_exit_criteria;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_exit_criteria;      end interface
       interface export;                 module procedure export_DN_exit_criteria;              end interface
       interface import;                 module procedure import_DN_exit_criteria;              end interface
       interface export_structured;      module procedure export_structured_DN_exit_criteria;   end interface
       interface import_structured;      module procedure import_structured_DN_exit_criteria;   end interface

       type exit_criteria
         type(string) :: dir
         type(string) :: name
         integer :: iter_max = 0
         real(cp) :: tol_abs = 0.0_cp
         real(cp) :: tol_rel = 0.0_cp
       end type

       contains

       subroutine init_copy_exit_criteria(this,that)
         implicit none
         type(exit_criteria),intent(inout) :: this
         type(exit_criteria),intent(in) :: that
         call delete(this)
         call init(this%dir,that%dir)
         call init(this%name,that%name)
         this%iter_max = that%iter_max
         this%tol_abs = that%tol_abs
         this%tol_rel = that%tol_rel
       end subroutine

       subroutine delete_exit_criteria(this)
         implicit none
         type(exit_criteria),intent(inout) :: this
         call delete(this%dir)
         call delete(this%name)
         this%iter_max = 0
         this%tol_abs = 0.0_cp
         this%tol_rel = 0.0_cp
       end subroutine

       subroutine display_exit_criteria(this,un)
         implicit none
         type(exit_criteria),intent(in) :: this
         integer,intent(in) :: un
         call display(this%dir,un)
         call display(this%name,un)
         write(un,*) 'iter_max = ',this%iter_max
         write(un,*) 'tol_abs  = ',this%tol_abs
         write(un,*) 'tol_rel  = ',this%tol_rel
       end subroutine

       subroutine display_short_exit_criteria(this,un)
         implicit none
         type(exit_criteria),intent(in) :: this
         integer,intent(in) :: un
         call display(this%dir,un)
         call display(this%name,un)
         write(un,*) 'iter_max = ',this%iter_max
         write(un,*) 'tol_abs  = ',this%tol_abs
         write(un,*) 'tol_rel  = ',this%tol_rel
       end subroutine

       subroutine display_wrap_exit_criteria(this,dir,name)
         implicit none
         type(exit_criteria),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_exit_criteria(this)
         implicit none
         type(exit_criteria),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_exit_criteria(this)
         implicit none
         type(exit_criteria),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_exit_criteria(this,un)
         implicit none
         type(exit_criteria),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_exit_criteria(this,un)
         implicit none
         type(exit_criteria),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_exit_criteria(this,un)
         implicit none
         type(exit_criteria),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'iter_max  = ';write(un,*) this%iter_max
         write(un,*) 'tol_abs   = ';write(un,*) this%tol_abs
         write(un,*) 'tol_rel   = ';write(un,*) this%tol_rel
       end subroutine

       subroutine import_primitives_exit_criteria(this,un)
         implicit none
         type(exit_criteria),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%iter_max
         read(un,*); read(un,*) this%tol_abs
         read(un,*); read(un,*) this%tol_rel
       end subroutine

       subroutine export_wrap_exit_criteria(this,dir,name)
         implicit none
         type(exit_criteria),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_exit_criteria(this,dir,name)
         implicit none
         type(exit_criteria),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_exit_criteria(this)
         implicit none
         type(exit_criteria),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_exit_criteria(this)
         implicit none
         type(exit_criteria),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_exit_criteria(this)
         implicit none
         type(exit_criteria),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_exit_criteria(this)
         implicit none
         type(exit_criteria),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_exit_criteria(this,dir)
         implicit none
         type(exit_criteria),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_exit_criteria(this,dir)
         implicit none
         type(exit_criteria),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_exit_criteria(this,dir)
         implicit none
         type(exit_criteria),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_exit_criteria(this,dir)
         implicit none
         type(exit_criteria),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_exit_criteria(this,dir)
         implicit none
         type(exit_criteria),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_exit_criteria(this)
         implicit none
         type(exit_criteria),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module export_field_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: export_field
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_export_field;              end interface
       interface delete;                 module procedure delete_export_field;                 end interface
       interface display;                module procedure display_export_field;                end interface
       interface display_short;          module procedure display_short_export_field;          end interface
       interface display;                module procedure display_wrap_export_field;           end interface
       interface print;                  module procedure print_export_field;                  end interface
       interface print_short;            module procedure print_short_export_field;            end interface
       interface export;                 module procedure export_export_field;                 end interface
       interface export_primitives;      module procedure export_primitives_export_field;      end interface
       interface import;                 module procedure import_export_field;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_export_field;end interface
       interface export_structured;      module procedure export_structured_D_export_field;    end interface
       interface import_structured;      module procedure import_structured_D_export_field;    end interface
       interface import_primitives;      module procedure import_primitives_export_field;      end interface
       interface export;                 module procedure export_wrap_export_field;            end interface
       interface import;                 module procedure import_wrap_export_field;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_export_field;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_export_field;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_export_field;      end interface

       type export_field
         logical :: export_ever = .false.
       end type

       contains

       subroutine init_copy_export_field(this,that)
         implicit none
         type(export_field),intent(inout) :: this
         type(export_field),intent(in) :: that
         call delete(this)
         this%export_ever = that%export_ever
       end subroutine

       subroutine delete_export_field(this)
         implicit none
         type(export_field),intent(inout) :: this
         this%export_ever = .false.
       end subroutine

       subroutine display_export_field(this,un)
         implicit none
         type(export_field),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever = ',this%export_ever
       end subroutine

       subroutine display_short_export_field(this,un)
         implicit none
         type(export_field),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever = ',this%export_ever
       end subroutine

       subroutine display_wrap_export_field(this,dir,name)
         implicit none
         type(export_field),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_export_field(this)
         implicit none
         type(export_field),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_export_field(this)
         implicit none
         type(export_field),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_export_field(this,un)
         implicit none
         type(export_field),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_export_field(this,un)
         implicit none
         type(export_field),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_export_field(this,un)
         implicit none
         type(export_field),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever  = ';write(un,*) this%export_ever
       end subroutine

       subroutine import_primitives_export_field(this,un)
         implicit none
         type(export_field),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%export_ever
       end subroutine

       subroutine export_wrap_export_field(this,dir,name)
         implicit none
         type(export_field),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_export_field(this,dir,name)
         implicit none
         type(export_field),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_export_field(this,dir)
         implicit none
         type(export_field),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_export_field(this,dir)
         implicit none
         type(export_field),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_export_field(this,dir)
         implicit none
         type(export_field),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_export_field(this,dir)
         implicit none
         type(export_field),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_export_field(this,dir)
         implicit none
         type(export_field),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_export_field(this)
         implicit none
         type(export_field),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module export_frequency_params_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: export_frequency_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_export_frequency_params;              end interface
       interface delete;                 module procedure delete_export_frequency_params;                 end interface
       interface display;                module procedure display_export_frequency_params;                end interface
       interface display_short;          module procedure display_short_export_frequency_params;          end interface
       interface display;                module procedure display_wrap_export_frequency_params;           end interface
       interface print;                  module procedure print_export_frequency_params;                  end interface
       interface print_short;            module procedure print_short_export_frequency_params;            end interface
       interface export;                 module procedure export_export_frequency_params;                 end interface
       interface export_primitives;      module procedure export_primitives_export_frequency_params;      end interface
       interface import;                 module procedure import_export_frequency_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_export_frequency_params;end interface
       interface export_structured;      module procedure export_structured_D_export_frequency_params;    end interface
       interface import_structured;      module procedure import_structured_D_export_frequency_params;    end interface
       interface import_primitives;      module procedure import_primitives_export_frequency_params;      end interface
       interface export;                 module procedure export_wrap_export_frequency_params;            end interface
       interface import;                 module procedure import_wrap_export_frequency_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_export_frequency_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_export_frequency_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_export_frequency_params;      end interface

       type export_frequency_params
         logical :: export_ever = .false.
         logical :: export_first_step = .false.
         logical :: export_now = .false.
         real(cp) :: t_window_start = 0.0_cp
         real(cp) :: t_window_stop = 0.0_cp
         integer :: N_points_in_window = 0
         integer :: left_point_export = 0
         integer :: right_point_export = 0
         real(cp) :: dt_star = 0.0_cp
         real(cp) :: dt_star_range = 0.0_cp
         real(cp) :: t_star_left = 0.0_cp
         real(cp) :: t_star_right = 0.0_cp
         real(cp) :: dt_window_factor = 0.0_cp
       end type

       contains

       subroutine init_copy_export_frequency_params(this,that)
         implicit none
         type(export_frequency_params),intent(inout) :: this
         type(export_frequency_params),intent(in) :: that
         call delete(this)
         this%export_ever = that%export_ever
         this%export_first_step = that%export_first_step
         this%export_now = that%export_now
         this%t_window_start = that%t_window_start
         this%t_window_stop = that%t_window_stop
         this%N_points_in_window = that%N_points_in_window
         this%left_point_export = that%left_point_export
         this%right_point_export = that%right_point_export
         this%dt_star = that%dt_star
         this%dt_star_range = that%dt_star_range
         this%t_star_left = that%t_star_left
         this%t_star_right = that%t_star_right
         this%dt_window_factor = that%dt_window_factor
       end subroutine

       subroutine delete_export_frequency_params(this)
         implicit none
         type(export_frequency_params),intent(inout) :: this
         this%export_ever = .false.
         this%export_first_step = .false.
         this%export_now = .false.
         this%t_window_start = 0.0_cp
         this%t_window_stop = 0.0_cp
         this%N_points_in_window = 0
         this%left_point_export = 0
         this%right_point_export = 0
         this%dt_star = 0.0_cp
         this%dt_star_range = 0.0_cp
         this%t_star_left = 0.0_cp
         this%t_star_right = 0.0_cp
         this%dt_window_factor = 0.0_cp
       end subroutine

       subroutine display_export_frequency_params(this,un)
         implicit none
         type(export_frequency_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever        = ',this%export_ever
         write(un,*) 'export_first_step  = ',this%export_first_step
         write(un,*) 'export_now         = ',this%export_now
         write(un,*) 't_window_start     = ',this%t_window_start
         write(un,*) 't_window_stop      = ',this%t_window_stop
         write(un,*) 'N_points_in_window = ',this%N_points_in_window
         write(un,*) 'left_point_export  = ',this%left_point_export
         write(un,*) 'right_point_export = ',this%right_point_export
         write(un,*) 'dt_star            = ',this%dt_star
         write(un,*) 'dt_star_range      = ',this%dt_star_range
         write(un,*) 't_star_left        = ',this%t_star_left
         write(un,*) 't_star_right       = ',this%t_star_right
         write(un,*) 'dt_window_factor   = ',this%dt_window_factor
       end subroutine

       subroutine display_short_export_frequency_params(this,un)
         implicit none
         type(export_frequency_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever        = ',this%export_ever
         write(un,*) 'export_first_step  = ',this%export_first_step
         write(un,*) 'export_now         = ',this%export_now
         write(un,*) 't_window_start     = ',this%t_window_start
         write(un,*) 't_window_stop      = ',this%t_window_stop
         write(un,*) 'N_points_in_window = ',this%N_points_in_window
         write(un,*) 'left_point_export  = ',this%left_point_export
         write(un,*) 'right_point_export = ',this%right_point_export
         write(un,*) 'dt_star            = ',this%dt_star
         write(un,*) 'dt_star_range      = ',this%dt_star_range
         write(un,*) 't_star_left        = ',this%t_star_left
         write(un,*) 't_star_right       = ',this%t_star_right
         write(un,*) 'dt_window_factor   = ',this%dt_window_factor
       end subroutine

       subroutine display_wrap_export_frequency_params(this,dir,name)
         implicit none
         type(export_frequency_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_export_frequency_params(this)
         implicit none
         type(export_frequency_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_export_frequency_params(this)
         implicit none
         type(export_frequency_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_export_frequency_params(this,un)
         implicit none
         type(export_frequency_params),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_export_frequency_params(this,un)
         implicit none
         type(export_frequency_params),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_export_frequency_params(this,un)
         implicit none
         type(export_frequency_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever         = ';write(un,*) this%export_ever
         write(un,*) 'export_first_step   = ';write(un,*) this%export_first_step
         write(un,*) 'export_now          = ';write(un,*) this%export_now
         write(un,*) 't_window_start      = ';write(un,*) this%t_window_start
         write(un,*) 't_window_stop       = ';write(un,*) this%t_window_stop
         write(un,*) 'N_points_in_window  = ';write(un,*) this%N_points_in_window
         write(un,*) 'left_point_export   = ';write(un,*) this%left_point_export
         write(un,*) 'right_point_export  = ';write(un,*) this%right_point_export
         write(un,*) 'dt_star             = ';write(un,*) this%dt_star
         write(un,*) 'dt_star_range       = ';write(un,*) this%dt_star_range
         write(un,*) 't_star_left         = ';write(un,*) this%t_star_left
         write(un,*) 't_star_right        = ';write(un,*) this%t_star_right
         write(un,*) 'dt_window_factor    = ';write(un,*) this%dt_window_factor
       end subroutine

       subroutine import_primitives_export_frequency_params(this,un)
         implicit none
         type(export_frequency_params),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%export_ever
         read(un,*); read(un,*) this%export_first_step
         read(un,*); read(un,*) this%export_now
         read(un,*); read(un,*) this%t_window_start
         read(un,*); read(un,*) this%t_window_stop
         read(un,*); read(un,*) this%N_points_in_window
         read(un,*); read(un,*) this%left_point_export
         read(un,*); read(un,*) this%right_point_export
         read(un,*); read(un,*) this%dt_star
         read(un,*); read(un,*) this%dt_star_range
         read(un,*); read(un,*) this%t_star_left
         read(un,*); read(un,*) this%t_star_right
         read(un,*); read(un,*) this%dt_window_factor
       end subroutine

       subroutine export_wrap_export_frequency_params(this,dir,name)
         implicit none
         type(export_frequency_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_export_frequency_params(this,dir,name)
         implicit none
         type(export_frequency_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_export_frequency_params(this,dir)
         implicit none
         type(export_frequency_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_export_frequency_params(this,dir)
         implicit none
         type(export_frequency_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_export_frequency_params(this,dir)
         implicit none
         type(export_frequency_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_export_frequency_params(this,dir)
         implicit none
         type(export_frequency_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_export_frequency_params(this,dir)
         implicit none
         type(export_frequency_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_export_frequency_params(this)
         implicit none
         type(export_frequency_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module export_line_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: export_line
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_export_line;              end interface
       interface delete;                 module procedure delete_export_line;                 end interface
       interface display;                module procedure display_export_line;                end interface
       interface display_short;          module procedure display_short_export_line;          end interface
       interface display;                module procedure display_wrap_export_line;           end interface
       interface print;                  module procedure print_export_line;                  end interface
       interface print_short;            module procedure print_short_export_line;            end interface
       interface export;                 module procedure export_export_line;                 end interface
       interface export_primitives;      module procedure export_primitives_export_line;      end interface
       interface import;                 module procedure import_export_line;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_export_line;end interface
       interface export_structured;      module procedure export_structured_D_export_line;    end interface
       interface import_structured;      module procedure import_structured_D_export_line;    end interface
       interface import_primitives;      module procedure import_primitives_export_line;      end interface
       interface export;                 module procedure export_wrap_export_line;            end interface
       interface import;                 module procedure import_wrap_export_line;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_export_line;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_export_line;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_export_line;      end interface

       type export_line
         logical :: export_ever = .false.
         integer :: dir = 0
         integer,dimension(2) :: line = 0
         character(len=1) :: suffix = ' '
       end type

       contains

       subroutine init_copy_export_line(this,that)
         implicit none
         type(export_line),intent(inout) :: this
         type(export_line),intent(in) :: that
         call delete(this)
         this%export_ever = that%export_ever
         this%dir = that%dir
         this%line = that%line
         this%suffix = that%suffix
       end subroutine

       subroutine delete_export_line(this)
         implicit none
         type(export_line),intent(inout) :: this
         this%export_ever = .false.
         this%dir = 0
         this%line = 0
         this%suffix = ' '
       end subroutine

       subroutine display_export_line(this,un)
         implicit none
         type(export_line),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever = ',this%export_ever
         write(un,*) 'dir         = ',this%dir
         write(un,*) 'line        = ',this%line
         write(un,*) 'suffix      = ',this%suffix
       end subroutine

       subroutine display_short_export_line(this,un)
         implicit none
         type(export_line),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever = ',this%export_ever
         write(un,*) 'dir         = ',this%dir
         write(un,*) 'line        = ',this%line
         write(un,*) 'suffix      = ',this%suffix
       end subroutine

       subroutine display_wrap_export_line(this,dir,name)
         implicit none
         type(export_line),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_export_line(this)
         implicit none
         type(export_line),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_export_line(this)
         implicit none
         type(export_line),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_export_line(this,un)
         implicit none
         type(export_line),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_export_line(this,un)
         implicit none
         type(export_line),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_export_line(this,un)
         implicit none
         type(export_line),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever  = ';write(un,*) this%export_ever
         write(un,*) 'dir          = ';write(un,*) this%dir
         write(un,*) 'line         = ';write(un,*) this%line
         write(un,*) 'suffix       = ';write(un,*) this%suffix
       end subroutine

       subroutine import_primitives_export_line(this,un)
         implicit none
         type(export_line),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%export_ever
         read(un,*); read(un,*) this%dir
         read(un,*); read(un,*) this%line
         read(un,*); read(un,*) this%suffix
       end subroutine

       subroutine export_wrap_export_line(this,dir,name)
         implicit none
         type(export_line),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_export_line(this,dir,name)
         implicit none
         type(export_line),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_export_line(this,dir)
         implicit none
         type(export_line),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_export_line(this,dir)
         implicit none
         type(export_line),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_export_line(this,dir)
         implicit none
         type(export_line),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_export_line(this,dir)
         implicit none
         type(export_line),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_export_line(this,dir)
         implicit none
         type(export_line),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_export_line(this)
         implicit none
         type(export_line),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module export_logicals_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: export_logicals
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_export_logicals;              end interface
       interface delete;                 module procedure delete_export_logicals;                 end interface
       interface display;                module procedure display_export_logicals;                end interface
       interface display_short;          module procedure display_short_export_logicals;          end interface
       interface display;                module procedure display_wrap_export_logicals;           end interface
       interface print;                  module procedure print_export_logicals;                  end interface
       interface print_short;            module procedure print_short_export_logicals;            end interface
       interface export;                 module procedure export_export_logicals;                 end interface
       interface export_primitives;      module procedure export_primitives_export_logicals;      end interface
       interface import;                 module procedure import_export_logicals;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_export_logicals;end interface
       interface export_structured;      module procedure export_structured_D_export_logicals;    end interface
       interface import_structured;      module procedure import_structured_D_export_logicals;    end interface
       interface import_primitives;      module procedure import_primitives_export_logicals;      end interface
       interface export;                 module procedure export_wrap_export_logicals;            end interface
       interface import;                 module procedure import_wrap_export_logicals;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_export_logicals;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_export_logicals;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_export_logicals;      end interface

       type export_logicals
         logical :: export_analytic = .false.
         logical :: export_meshes = .false.
         logical :: export_vort_SF = .false.
         logical :: export_mat_props = .false.
         logical :: export_cell_volume = .false.
         logical :: export_ICs = .false.
         logical :: export_planar = .false.
         logical :: export_symmetric = .false.
         logical :: export_mesh_block = .false.
         logical :: export_soln_only = .false.
         logical :: defined = .false.
       end type

       contains

       subroutine init_copy_export_logicals(this,that)
         implicit none
         type(export_logicals),intent(inout) :: this
         type(export_logicals),intent(in) :: that
         call delete(this)
         this%export_analytic = that%export_analytic
         this%export_meshes = that%export_meshes
         this%export_vort_SF = that%export_vort_SF
         this%export_mat_props = that%export_mat_props
         this%export_cell_volume = that%export_cell_volume
         this%export_ICs = that%export_ICs
         this%export_planar = that%export_planar
         this%export_symmetric = that%export_symmetric
         this%export_mesh_block = that%export_mesh_block
         this%export_soln_only = that%export_soln_only
         this%defined = that%defined
       end subroutine

       subroutine delete_export_logicals(this)
         implicit none
         type(export_logicals),intent(inout) :: this
         this%export_analytic = .false.
         this%export_meshes = .false.
         this%export_vort_SF = .false.
         this%export_mat_props = .false.
         this%export_cell_volume = .false.
         this%export_ICs = .false.
         this%export_planar = .false.
         this%export_symmetric = .false.
         this%export_mesh_block = .false.
         this%export_soln_only = .false.
         this%defined = .false.
       end subroutine

       subroutine display_export_logicals(this,un)
         implicit none
         type(export_logicals),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_analytic    = ',this%export_analytic
         write(un,*) 'export_meshes      = ',this%export_meshes
         write(un,*) 'export_vort_SF     = ',this%export_vort_SF
         write(un,*) 'export_mat_props   = ',this%export_mat_props
         write(un,*) 'export_cell_volume = ',this%export_cell_volume
         write(un,*) 'export_ICs         = ',this%export_ICs
         write(un,*) 'export_planar      = ',this%export_planar
         write(un,*) 'export_symmetric   = ',this%export_symmetric
         write(un,*) 'export_mesh_block  = ',this%export_mesh_block
         write(un,*) 'export_soln_only   = ',this%export_soln_only
         write(un,*) 'defined            = ',this%defined
       end subroutine

       subroutine display_short_export_logicals(this,un)
         implicit none
         type(export_logicals),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_analytic    = ',this%export_analytic
         write(un,*) 'export_meshes      = ',this%export_meshes
         write(un,*) 'export_vort_SF     = ',this%export_vort_SF
         write(un,*) 'export_mat_props   = ',this%export_mat_props
         write(un,*) 'export_cell_volume = ',this%export_cell_volume
         write(un,*) 'export_ICs         = ',this%export_ICs
         write(un,*) 'export_planar      = ',this%export_planar
         write(un,*) 'export_symmetric   = ',this%export_symmetric
         write(un,*) 'export_mesh_block  = ',this%export_mesh_block
         write(un,*) 'export_soln_only   = ',this%export_soln_only
         write(un,*) 'defined            = ',this%defined
       end subroutine

       subroutine display_wrap_export_logicals(this,dir,name)
         implicit none
         type(export_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_export_logicals(this)
         implicit none
         type(export_logicals),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_export_logicals(this)
         implicit none
         type(export_logicals),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_export_logicals(this,un)
         implicit none
         type(export_logicals),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_export_logicals(this,un)
         implicit none
         type(export_logicals),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_export_logicals(this,un)
         implicit none
         type(export_logicals),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_analytic     = ';write(un,*) this%export_analytic
         write(un,*) 'export_meshes       = ';write(un,*) this%export_meshes
         write(un,*) 'export_vort_SF      = ';write(un,*) this%export_vort_SF
         write(un,*) 'export_mat_props    = ';write(un,*) this%export_mat_props
         write(un,*) 'export_cell_volume  = ';write(un,*) this%export_cell_volume
         write(un,*) 'export_ICs          = ';write(un,*) this%export_ICs
         write(un,*) 'export_planar       = ';write(un,*) this%export_planar
         write(un,*) 'export_symmetric    = ';write(un,*) this%export_symmetric
         write(un,*) 'export_mesh_block   = ';write(un,*) this%export_mesh_block
         write(un,*) 'export_soln_only    = ';write(un,*) this%export_soln_only
         write(un,*) 'defined             = ';write(un,*) this%defined
       end subroutine

       subroutine import_primitives_export_logicals(this,un)
         implicit none
         type(export_logicals),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%export_analytic
         read(un,*); read(un,*) this%export_meshes
         read(un,*); read(un,*) this%export_vort_SF
         read(un,*); read(un,*) this%export_mat_props
         read(un,*); read(un,*) this%export_cell_volume
         read(un,*); read(un,*) this%export_ICs
         read(un,*); read(un,*) this%export_planar
         read(un,*); read(un,*) this%export_symmetric
         read(un,*); read(un,*) this%export_mesh_block
         read(un,*); read(un,*) this%export_soln_only
         read(un,*); read(un,*) this%defined
       end subroutine

       subroutine export_wrap_export_logicals(this,dir,name)
         implicit none
         type(export_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_export_logicals(this,dir,name)
         implicit none
         type(export_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_export_logicals(this,dir)
         implicit none
         type(export_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_export_logicals(this,dir)
         implicit none
         type(export_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_export_logicals(this,dir)
         implicit none
         type(export_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_export_logicals(this,dir)
         implicit none
         type(export_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_export_logicals(this,dir)
         implicit none
         type(export_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_export_logicals(this)
         implicit none
         type(export_logicals),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module export_plane_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: export_plane
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_export_plane;              end interface
       interface delete;                 module procedure delete_export_plane;                 end interface
       interface display;                module procedure display_export_plane;                end interface
       interface display_short;          module procedure display_short_export_plane;          end interface
       interface display;                module procedure display_wrap_export_plane;           end interface
       interface print;                  module procedure print_export_plane;                  end interface
       interface print_short;            module procedure print_short_export_plane;            end interface
       interface export;                 module procedure export_export_plane;                 end interface
       interface export_primitives;      module procedure export_primitives_export_plane;      end interface
       interface import;                 module procedure import_export_plane;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_export_plane;end interface
       interface export_structured;      module procedure export_structured_D_export_plane;    end interface
       interface import_structured;      module procedure import_structured_D_export_plane;    end interface
       interface import_primitives;      module procedure import_primitives_export_plane;      end interface
       interface export;                 module procedure export_wrap_export_plane;            end interface
       interface import;                 module procedure import_wrap_export_plane;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_export_plane;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_export_plane;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_export_plane;      end interface

       type export_plane
         logical :: export_ever = .false.
         integer :: dir = 0
         integer :: plane = 0
         character(len=1) :: suffix = ' '
       end type

       contains

       subroutine init_copy_export_plane(this,that)
         implicit none
         type(export_plane),intent(inout) :: this
         type(export_plane),intent(in) :: that
         call delete(this)
         this%export_ever = that%export_ever
         this%dir = that%dir
         this%plane = that%plane
         this%suffix = that%suffix
       end subroutine

       subroutine delete_export_plane(this)
         implicit none
         type(export_plane),intent(inout) :: this
         this%export_ever = .false.
         this%dir = 0
         this%plane = 0
         this%suffix = ' '
       end subroutine

       subroutine display_export_plane(this,un)
         implicit none
         type(export_plane),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever = ',this%export_ever
         write(un,*) 'dir         = ',this%dir
         write(un,*) 'plane       = ',this%plane
         write(un,*) 'suffix      = ',this%suffix
       end subroutine

       subroutine display_short_export_plane(this,un)
         implicit none
         type(export_plane),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever = ',this%export_ever
         write(un,*) 'dir         = ',this%dir
         write(un,*) 'plane       = ',this%plane
         write(un,*) 'suffix      = ',this%suffix
       end subroutine

       subroutine display_wrap_export_plane(this,dir,name)
         implicit none
         type(export_plane),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_export_plane(this)
         implicit none
         type(export_plane),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_export_plane(this)
         implicit none
         type(export_plane),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_export_plane(this,un)
         implicit none
         type(export_plane),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_export_plane(this,un)
         implicit none
         type(export_plane),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_export_plane(this,un)
         implicit none
         type(export_plane),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_ever  = ';write(un,*) this%export_ever
         write(un,*) 'dir          = ';write(un,*) this%dir
         write(un,*) 'plane        = ';write(un,*) this%plane
         write(un,*) 'suffix       = ';write(un,*) this%suffix
       end subroutine

       subroutine import_primitives_export_plane(this,un)
         implicit none
         type(export_plane),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%export_ever
         read(un,*); read(un,*) this%dir
         read(un,*); read(un,*) this%plane
         read(un,*); read(un,*) this%suffix
       end subroutine

       subroutine export_wrap_export_plane(this,dir,name)
         implicit none
         type(export_plane),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_export_plane(this,dir,name)
         implicit none
         type(export_plane),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_export_plane(this,dir)
         implicit none
         type(export_plane),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_export_plane(this,dir)
         implicit none
         type(export_plane),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_export_plane(this,dir)
         implicit none
         type(export_plane),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_export_plane(this,dir)
         implicit none
         type(export_plane),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_export_plane(this,dir)
         implicit none
         type(export_plane),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_export_plane(this)
         implicit none
         type(export_plane),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module export_safe_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: export_safe
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_export_safe;              end interface
       interface delete;                 module procedure delete_export_safe;                 end interface
       interface display;                module procedure display_export_safe;                end interface
       interface display_short;          module procedure display_short_export_safe;          end interface
       interface display;                module procedure display_wrap_export_safe;           end interface
       interface print;                  module procedure print_export_safe;                  end interface
       interface print_short;            module procedure print_short_export_safe;            end interface
       interface export;                 module procedure export_export_safe;                 end interface
       interface export_primitives;      module procedure export_primitives_export_safe;      end interface
       interface import;                 module procedure import_export_safe;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_export_safe;end interface
       interface export_structured;      module procedure export_structured_D_export_safe;    end interface
       interface import_structured;      module procedure import_structured_D_export_safe;    end interface
       interface import_primitives;      module procedure import_primitives_export_safe;      end interface
       interface export;                 module procedure export_wrap_export_safe;            end interface
       interface import;                 module procedure import_wrap_export_safe;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_export_safe;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_export_safe;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_export_safe;      end interface

       type export_safe
         logical :: export_now = .false.
         real(cp) :: export_period_sec = 0.0_cp
         real(cp) :: mod_period = 0.0_cp
         real(cp) :: mod_period_last = 0.0_cp
       end type

       contains

       subroutine init_copy_export_safe(this,that)
         implicit none
         type(export_safe),intent(inout) :: this
         type(export_safe),intent(in) :: that
         call delete(this)
         this%export_now = that%export_now
         this%export_period_sec = that%export_period_sec
         this%mod_period = that%mod_period
         this%mod_period_last = that%mod_period_last
       end subroutine

       subroutine delete_export_safe(this)
         implicit none
         type(export_safe),intent(inout) :: this
         this%export_now = .false.
         this%export_period_sec = 0.0_cp
         this%mod_period = 0.0_cp
         this%mod_period_last = 0.0_cp
       end subroutine

       subroutine display_export_safe(this,un)
         implicit none
         type(export_safe),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_now        = ',this%export_now
         write(un,*) 'export_period_sec = ',this%export_period_sec
         write(un,*) 'mod_period        = ',this%mod_period
         write(un,*) 'mod_period_last   = ',this%mod_period_last
       end subroutine

       subroutine display_short_export_safe(this,un)
         implicit none
         type(export_safe),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_now        = ',this%export_now
         write(un,*) 'export_period_sec = ',this%export_period_sec
         write(un,*) 'mod_period        = ',this%mod_period
         write(un,*) 'mod_period_last   = ',this%mod_period_last
       end subroutine

       subroutine display_wrap_export_safe(this,dir,name)
         implicit none
         type(export_safe),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_export_safe(this)
         implicit none
         type(export_safe),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_export_safe(this)
         implicit none
         type(export_safe),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_export_safe(this,un)
         implicit none
         type(export_safe),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_export_safe(this,un)
         implicit none
         type(export_safe),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_export_safe(this,un)
         implicit none
         type(export_safe),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_now         = ';write(un,*) this%export_now
         write(un,*) 'export_period_sec  = ';write(un,*) this%export_period_sec
         write(un,*) 'mod_period         = ';write(un,*) this%mod_period
         write(un,*) 'mod_period_last    = ';write(un,*) this%mod_period_last
       end subroutine

       subroutine import_primitives_export_safe(this,un)
         implicit none
         type(export_safe),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%export_now
         read(un,*); read(un,*) this%export_period_sec
         read(un,*); read(un,*) this%mod_period
         read(un,*); read(un,*) this%mod_period_last
       end subroutine

       subroutine export_wrap_export_safe(this,dir,name)
         implicit none
         type(export_safe),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_export_safe(this,dir,name)
         implicit none
         type(export_safe),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_export_safe(this,dir)
         implicit none
         type(export_safe),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_export_safe(this,dir)
         implicit none
         type(export_safe),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_export_safe(this,dir)
         implicit none
         type(export_safe),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_export_safe(this,dir)
         implicit none
         type(export_safe),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_export_safe(this,dir)
         implicit none
         type(export_safe),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_export_safe(this)
         implicit none
         type(export_safe),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module flow_control_logicals_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: flow_control_logicals
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_flow_control_logicals;              end interface
       interface delete;                 module procedure delete_flow_control_logicals;                 end interface
       interface display;                module procedure display_flow_control_logicals;                end interface
       interface display_short;          module procedure display_short_flow_control_logicals;          end interface
       interface display;                module procedure display_wrap_flow_control_logicals;           end interface
       interface print;                  module procedure print_flow_control_logicals;                  end interface
       interface print_short;            module procedure print_short_flow_control_logicals;            end interface
       interface export;                 module procedure export_flow_control_logicals;                 end interface
       interface export_primitives;      module procedure export_primitives_flow_control_logicals;      end interface
       interface import;                 module procedure import_flow_control_logicals;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_flow_control_logicals;end interface
       interface export_structured;      module procedure export_structured_D_flow_control_logicals;    end interface
       interface import_structured;      module procedure import_structured_D_flow_control_logicals;    end interface
       interface import_primitives;      module procedure import_primitives_flow_control_logicals;      end interface
       interface export;                 module procedure export_wrap_flow_control_logicals;            end interface
       interface import;                 module procedure import_wrap_flow_control_logicals;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_flow_control_logicals;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_flow_control_logicals;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_flow_control_logicals;      end interface

       type flow_control_logicals
         logical :: simulate_crash = .false.
         logical :: restart_simulated_crash = .false.
         logical :: post_process = .false.
         logical :: skip_solver_loop = .false.
         logical :: stop_before_solve = .false.
         logical :: stop_after_mesh_export = .false.
         logical :: Poisson_test = .false.
         logical :: Taylor_Green_Vortex_test = .false.
         logical :: temporal_convergence_test = .false.
         logical :: export_numerical_flow_rate = .false.
         logical :: export_Shercliff_Hunt_analytic_sol = .false.
         logical :: export_vorticity_streamfunction = .false.
         logical :: compute_export_E_K_Budget = .false.
         logical :: compute_export_E_M_budget = .false.
         logical :: operator_commute_test = .false.
         logical :: export_final_tec = .false.
         logical :: export_final_restart = .false.
         logical :: restart_meshes = .false.
         logical :: export_heavy = .false.
         logical :: print_every_MHD_step = .false.
         logical :: compute_surface_power = .false.
         logical :: print_mesh_before_solve = .false.
         logical :: fresh_restart_file = .false.
         logical :: matrix_visualization = .false.
         logical :: restart_all = .false.
       end type

       contains

       subroutine init_copy_flow_control_logicals(this,that)
         implicit none
         type(flow_control_logicals),intent(inout) :: this
         type(flow_control_logicals),intent(in) :: that
         call delete(this)
         this%simulate_crash = that%simulate_crash
         this%restart_simulated_crash = that%restart_simulated_crash
         this%post_process = that%post_process
         this%skip_solver_loop = that%skip_solver_loop
         this%stop_before_solve = that%stop_before_solve
         this%stop_after_mesh_export = that%stop_after_mesh_export
         this%Poisson_test = that%Poisson_test
         this%Taylor_Green_Vortex_test = that%Taylor_Green_Vortex_test
         this%temporal_convergence_test = that%temporal_convergence_test
         this%export_numerical_flow_rate = that%export_numerical_flow_rate
         this%export_Shercliff_Hunt_analytic_sol = that%export_Shercliff_Hunt_analytic_sol
         this%export_vorticity_streamfunction = that%export_vorticity_streamfunction
         this%compute_export_E_K_Budget = that%compute_export_E_K_Budget
         this%compute_export_E_M_budget = that%compute_export_E_M_budget
         this%operator_commute_test = that%operator_commute_test
         this%export_final_tec = that%export_final_tec
         this%export_final_restart = that%export_final_restart
         this%restart_meshes = that%restart_meshes
         this%export_heavy = that%export_heavy
         this%print_every_MHD_step = that%print_every_MHD_step
         this%compute_surface_power = that%compute_surface_power
         this%print_mesh_before_solve = that%print_mesh_before_solve
         this%fresh_restart_file = that%fresh_restart_file
         this%matrix_visualization = that%matrix_visualization
         this%restart_all = that%restart_all
       end subroutine

       subroutine delete_flow_control_logicals(this)
         implicit none
         type(flow_control_logicals),intent(inout) :: this
         this%simulate_crash = .false.
         this%restart_simulated_crash = .false.
         this%post_process = .false.
         this%skip_solver_loop = .false.
         this%stop_before_solve = .false.
         this%stop_after_mesh_export = .false.
         this%Poisson_test = .false.
         this%Taylor_Green_Vortex_test = .false.
         this%temporal_convergence_test = .false.
         this%export_numerical_flow_rate = .false.
         this%export_Shercliff_Hunt_analytic_sol = .false.
         this%export_vorticity_streamfunction = .false.
         this%compute_export_E_K_Budget = .false.
         this%compute_export_E_M_budget = .false.
         this%operator_commute_test = .false.
         this%export_final_tec = .false.
         this%export_final_restart = .false.
         this%restart_meshes = .false.
         this%export_heavy = .false.
         this%print_every_MHD_step = .false.
         this%compute_surface_power = .false.
         this%print_mesh_before_solve = .false.
         this%fresh_restart_file = .false.
         this%matrix_visualization = .false.
         this%restart_all = .false.
       end subroutine

       subroutine display_flow_control_logicals(this,un)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'simulate_crash                     = ',&
         this%simulate_crash
         write(un,*) 'restart_simulated_crash            = ',&
         this%restart_simulated_crash
         write(un,*) 'post_process                       = ',&
         this%post_process
         write(un,*) 'skip_solver_loop                   = ',&
         this%skip_solver_loop
         write(un,*) 'stop_before_solve                  = ',&
         this%stop_before_solve
         write(un,*) 'stop_after_mesh_export             = ',&
         this%stop_after_mesh_export
         write(un,*) 'Poisson_test                       = ',&
         this%Poisson_test
         write(un,*) 'Taylor_Green_Vortex_test           = ',&
         this%Taylor_Green_Vortex_test
         write(un,*) 'temporal_convergence_test          = ',&
         this%temporal_convergence_test
         write(un,*) 'export_numerical_flow_rate         = ',&
         this%export_numerical_flow_rate
         write(un,*) 'export_Shercliff_Hunt_analytic_sol = ',&
         this%export_Shercliff_Hunt_analytic_sol
         write(un,*) 'export_vorticity_streamfunction    = ',&
         this%export_vorticity_streamfunction
         write(un,*) 'compute_export_E_K_Budget          = ',&
         this%compute_export_E_K_Budget
         write(un,*) 'compute_export_E_M_budget          = ',&
         this%compute_export_E_M_budget
         write(un,*) 'operator_commute_test              = ',&
         this%operator_commute_test
         write(un,*) 'export_final_tec                   = ',&
         this%export_final_tec
         write(un,*) 'export_final_restart               = ',&
         this%export_final_restart
         write(un,*) 'restart_meshes                     = ',&
         this%restart_meshes
         write(un,*) 'export_heavy                       = ',&
         this%export_heavy
         write(un,*) 'print_every_MHD_step               = ',&
         this%print_every_MHD_step
         write(un,*) 'compute_surface_power              = ',&
         this%compute_surface_power
         write(un,*) 'print_mesh_before_solve            = ',&
         this%print_mesh_before_solve
         write(un,*) 'fresh_restart_file                 = ',&
         this%fresh_restart_file
         write(un,*) 'matrix_visualization               = ',&
         this%matrix_visualization
         write(un,*) 'restart_all                        = ',&
         this%restart_all
       end subroutine

       subroutine display_short_flow_control_logicals(this,un)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'simulate_crash                     = ',&
         this%simulate_crash
         write(un,*) 'restart_simulated_crash            = ',&
         this%restart_simulated_crash
         write(un,*) 'post_process                       = ',&
         this%post_process
         write(un,*) 'skip_solver_loop                   = ',&
         this%skip_solver_loop
         write(un,*) 'stop_before_solve                  = ',&
         this%stop_before_solve
         write(un,*) 'stop_after_mesh_export             = ',&
         this%stop_after_mesh_export
         write(un,*) 'Poisson_test                       = ',&
         this%Poisson_test
         write(un,*) 'Taylor_Green_Vortex_test           = ',&
         this%Taylor_Green_Vortex_test
         write(un,*) 'temporal_convergence_test          = ',&
         this%temporal_convergence_test
         write(un,*) 'export_numerical_flow_rate         = ',&
         this%export_numerical_flow_rate
         write(un,*) 'export_Shercliff_Hunt_analytic_sol = ',&
         this%export_Shercliff_Hunt_analytic_sol
         write(un,*) 'export_vorticity_streamfunction    = ',&
         this%export_vorticity_streamfunction
         write(un,*) 'compute_export_E_K_Budget          = ',&
         this%compute_export_E_K_Budget
         write(un,*) 'compute_export_E_M_budget          = ',&
         this%compute_export_E_M_budget
         write(un,*) 'operator_commute_test              = ',&
         this%operator_commute_test
         write(un,*) 'export_final_tec                   = ',&
         this%export_final_tec
         write(un,*) 'export_final_restart               = ',&
         this%export_final_restart
         write(un,*) 'restart_meshes                     = ',&
         this%restart_meshes
         write(un,*) 'export_heavy                       = ',&
         this%export_heavy
         write(un,*) 'print_every_MHD_step               = ',&
         this%print_every_MHD_step
         write(un,*) 'compute_surface_power              = ',&
         this%compute_surface_power
         write(un,*) 'print_mesh_before_solve            = ',&
         this%print_mesh_before_solve
         write(un,*) 'fresh_restart_file                 = ',&
         this%fresh_restart_file
         write(un,*) 'matrix_visualization               = ',&
         this%matrix_visualization
         write(un,*) 'restart_all                        = ',&
         this%restart_all
       end subroutine

       subroutine display_wrap_flow_control_logicals(this,dir,name)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_flow_control_logicals(this)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_flow_control_logicals(this)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_flow_control_logicals(this,un)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_flow_control_logicals(this,un)
         implicit none
         type(flow_control_logicals),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_flow_control_logicals(this,un)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'simulate_crash                      = ';write(un,*) this%simulate_crash
         write(un,*) 'restart_simulated_crash             = ';write(un,*) this%restart_simulated_crash
         write(un,*) 'post_process                        = ';write(un,*) this%post_process
         write(un,*) 'skip_solver_loop                    = ';write(un,*) this%skip_solver_loop
         write(un,*) 'stop_before_solve                   = ';write(un,*) this%stop_before_solve
         write(un,*) 'stop_after_mesh_export              = ';write(un,*) this%stop_after_mesh_export
         write(un,*) 'Poisson_test                        = ';write(un,*) this%Poisson_test
         write(un,*) 'Taylor_Green_Vortex_test            = ';write(un,*) this%Taylor_Green_Vortex_test
         write(un,*) 'temporal_convergence_test           = ';write(un,*) this%temporal_convergence_test
         write(un,*) 'export_numerical_flow_rate          = ';write(un,*) this%export_numerical_flow_rate
         write(un,*) 'export_Shercliff_Hunt_analytic_sol  = ';write(un,*) this%export_Shercliff_Hunt_analytic_sol
         write(un,*) 'export_vorticity_streamfunction     = ';write(un,*) this%export_vorticity_streamfunction
         write(un,*) 'compute_export_E_K_Budget           = ';write(un,*) this%compute_export_E_K_Budget
         write(un,*) 'compute_export_E_M_budget           = ';write(un,*) this%compute_export_E_M_budget
         write(un,*) 'operator_commute_test               = ';write(un,*) this%operator_commute_test
         write(un,*) 'export_final_tec                    = ';write(un,*) this%export_final_tec
         write(un,*) 'export_final_restart                = ';write(un,*) this%export_final_restart
         write(un,*) 'restart_meshes                      = ';write(un,*) this%restart_meshes
         write(un,*) 'export_heavy                        = ';write(un,*) this%export_heavy
         write(un,*) 'print_every_MHD_step                = ';write(un,*) this%print_every_MHD_step
         write(un,*) 'compute_surface_power               = ';write(un,*) this%compute_surface_power
         write(un,*) 'print_mesh_before_solve             = ';write(un,*) this%print_mesh_before_solve
         write(un,*) 'fresh_restart_file                  = ';write(un,*) this%fresh_restart_file
         write(un,*) 'matrix_visualization                = ';write(un,*) this%matrix_visualization
         write(un,*) 'restart_all                         = ';write(un,*) this%restart_all
       end subroutine

       subroutine import_primitives_flow_control_logicals(this,un)
         implicit none
         type(flow_control_logicals),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%simulate_crash
         read(un,*); read(un,*) this%restart_simulated_crash
         read(un,*); read(un,*) this%post_process
         read(un,*); read(un,*) this%skip_solver_loop
         read(un,*); read(un,*) this%stop_before_solve
         read(un,*); read(un,*) this%stop_after_mesh_export
         read(un,*); read(un,*) this%Poisson_test
         read(un,*); read(un,*) this%Taylor_Green_Vortex_test
         read(un,*); read(un,*) this%temporal_convergence_test
         read(un,*); read(un,*) this%export_numerical_flow_rate
         read(un,*); read(un,*) this%export_Shercliff_Hunt_analytic_sol
         read(un,*); read(un,*) this%export_vorticity_streamfunction
         read(un,*); read(un,*) this%compute_export_E_K_Budget
         read(un,*); read(un,*) this%compute_export_E_M_budget
         read(un,*); read(un,*) this%operator_commute_test
         read(un,*); read(un,*) this%export_final_tec
         read(un,*); read(un,*) this%export_final_restart
         read(un,*); read(un,*) this%restart_meshes
         read(un,*); read(un,*) this%export_heavy
         read(un,*); read(un,*) this%print_every_MHD_step
         read(un,*); read(un,*) this%compute_surface_power
         read(un,*); read(un,*) this%print_mesh_before_solve
         read(un,*); read(un,*) this%fresh_restart_file
         read(un,*); read(un,*) this%matrix_visualization
         read(un,*); read(un,*) this%restart_all
       end subroutine

       subroutine export_wrap_flow_control_logicals(this,dir,name)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_flow_control_logicals(this,dir,name)
         implicit none
         type(flow_control_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_flow_control_logicals(this,dir)
         implicit none
         type(flow_control_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_flow_control_logicals(this,dir)
         implicit none
         type(flow_control_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_flow_control_logicals(this,dir)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_flow_control_logicals(this,dir)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_flow_control_logicals(this,dir)
         implicit none
         type(flow_control_logicals),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_flow_control_logicals(this)
         implicit none
         type(flow_control_logicals),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module geometry_props_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: geometry_props
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_geometry_props;              end interface
       interface delete;                 module procedure delete_geometry_props;                 end interface
       interface display;                module procedure display_geometry_props;                end interface
       interface display_short;          module procedure display_short_geometry_props;          end interface
       interface display;                module procedure display_wrap_geometry_props;           end interface
       interface print;                  module procedure print_geometry_props;                  end interface
       interface print_short;            module procedure print_short_geometry_props;            end interface
       interface export;                 module procedure export_geometry_props;                 end interface
       interface export_primitives;      module procedure export_primitives_geometry_props;      end interface
       interface import;                 module procedure import_geometry_props;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_geometry_props;end interface
       interface export_structured;      module procedure export_structured_D_geometry_props;    end interface
       interface import_structured;      module procedure import_structured_D_geometry_props;    end interface
       interface import_primitives;      module procedure import_primitives_geometry_props;      end interface
       interface export;                 module procedure export_wrap_geometry_props;            end interface
       interface import;                 module procedure import_wrap_geometry_props;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_geometry_props;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_geometry_props;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_geometry_props;      end interface

       type geometry_props
         integer,dimension(3) :: periodic_dir = 0
         integer,dimension(6) :: apply_BC_order = 0
         integer :: FFT_dir = 0
       end type

       contains

       subroutine init_copy_geometry_props(this,that)
         implicit none
         type(geometry_props),intent(inout) :: this
         type(geometry_props),intent(in) :: that
         call delete(this)
         this%periodic_dir = that%periodic_dir
         this%apply_BC_order = that%apply_BC_order
         this%FFT_dir = that%FFT_dir
       end subroutine

       subroutine delete_geometry_props(this)
         implicit none
         type(geometry_props),intent(inout) :: this
         this%periodic_dir = 0
         this%apply_BC_order = 0
         this%FFT_dir = 0
       end subroutine

       subroutine display_geometry_props(this,un)
         implicit none
         type(geometry_props),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'periodic_dir   = ',this%periodic_dir
         write(un,*) 'apply_BC_order = ',this%apply_BC_order
         write(un,*) 'FFT_dir        = ',this%FFT_dir
       end subroutine

       subroutine display_short_geometry_props(this,un)
         implicit none
         type(geometry_props),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'periodic_dir   = ',this%periodic_dir
         write(un,*) 'apply_BC_order = ',this%apply_BC_order
         write(un,*) 'FFT_dir        = ',this%FFT_dir
       end subroutine

       subroutine display_wrap_geometry_props(this,dir,name)
         implicit none
         type(geometry_props),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_geometry_props(this)
         implicit none
         type(geometry_props),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_geometry_props(this)
         implicit none
         type(geometry_props),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_geometry_props(this,un)
         implicit none
         type(geometry_props),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_geometry_props(this,un)
         implicit none
         type(geometry_props),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_geometry_props(this,un)
         implicit none
         type(geometry_props),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'periodic_dir    = ';write(un,*) this%periodic_dir
         write(un,*) 'apply_BC_order  = ';write(un,*) this%apply_BC_order
         write(un,*) 'FFT_dir         = ';write(un,*) this%FFT_dir
       end subroutine

       subroutine import_primitives_geometry_props(this,un)
         implicit none
         type(geometry_props),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%periodic_dir
         read(un,*); read(un,*) this%apply_BC_order
         read(un,*); read(un,*) this%FFT_dir
       end subroutine

       subroutine export_wrap_geometry_props(this,dir,name)
         implicit none
         type(geometry_props),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_geometry_props(this,dir,name)
         implicit none
         type(geometry_props),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_geometry_props(this,dir)
         implicit none
         type(geometry_props),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_geometry_props(this,dir)
         implicit none
         type(geometry_props),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_geometry_props(this,dir)
         implicit none
         type(geometry_props),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_geometry_props(this,dir)
         implicit none
         type(geometry_props),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_geometry_props(this,dir)
         implicit none
         type(geometry_props),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_geometry_props(this)
         implicit none
         type(geometry_props),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module grid_field_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: grid_field
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_grid_field;              end interface
       interface delete;                 module procedure delete_grid_field;                 end interface
       interface display;                module procedure display_grid_field;                end interface
       interface display_short;          module procedure display_short_grid_field;          end interface
       interface display;                module procedure display_wrap_grid_field;           end interface
       interface print;                  module procedure print_grid_field;                  end interface
       interface print_short;            module procedure print_short_grid_field;            end interface
       interface export;                 module procedure export_grid_field;                 end interface
       interface export_primitives;      module procedure export_primitives_grid_field;      end interface
       interface import;                 module procedure import_grid_field;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_grid_field;end interface
       interface export_structured;      module procedure export_structured_D_grid_field;    end interface
       interface import_structured;      module procedure import_structured_D_grid_field;    end interface
       interface import_primitives;      module procedure import_primitives_grid_field;      end interface
       interface export;                 module procedure export_wrap_grid_field;            end interface
       interface import;                 module procedure import_wrap_grid_field;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_grid_field;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_grid_field;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_grid_field;      end interface

       type grid_field
         real(cp),dimension(:,:,:),allocatable :: f
         integer,dimension(3) :: s = 0
         integer :: s_1D = 0
       end type

       contains

       subroutine init_copy_grid_field(this,that)
         implicit none
         type(grid_field),intent(inout) :: this
         type(grid_field),intent(in) :: that
         call delete(this)
         if (allocated(that%f)) then
           this%f = that%f
         endif
         this%s = that%s
         this%s_1D = that%s_1D
       end subroutine

       subroutine delete_grid_field(this)
         implicit none
         type(grid_field),intent(inout) :: this
         if (allocated(this%f)) then
           deallocate(this%f)
         endif
         this%s = 0
         this%s_1D = 0
       end subroutine

       subroutine display_grid_field(this,un)
         implicit none
         type(grid_field),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'f    = ',this%f
         write(un,*) 's    = ',this%s
         write(un,*) 's_1D = ',this%s_1D
       end subroutine

       subroutine display_short_grid_field(this,un)
         implicit none
         type(grid_field),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 's    = ',this%s
         write(un,*) 's_1D = ',this%s_1D
       end subroutine

       subroutine display_wrap_grid_field(this,dir,name)
         implicit none
         type(grid_field),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_grid_field(this)
         implicit none
         type(grid_field),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_grid_field(this)
         implicit none
         type(grid_field),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_grid_field(this,un)
         implicit none
         type(grid_field),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_grid_field(this,un)
         implicit none
         type(grid_field),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_grid_field(this,un)
         implicit none
         type(grid_field),intent(in) :: this
         integer,intent(in) :: un
         integer,dimension(3) :: s_f
         if (allocated(this%f)) then
           s_f = shape(this%f)
           write(un,*) s_f
           if (all((/s_f(1).gt.0,s_f(2).gt.0,s_f(3).gt.0/))) then
             write(un,*) 'f     = ';write(un,*) this%f
           endif
         else
           write(un,*) 0
         endif
         write(un,*) 's     = ';write(un,*) this%s
         write(un,*) 's_1D  = ';write(un,*) this%s_1D
       end subroutine

       subroutine import_primitives_grid_field(this,un)
         implicit none
         type(grid_field),intent(inout) :: this
         integer,intent(in) :: un
         integer,dimension(3) :: s_f
         read(un,*) s_f
         if (all((/s_f(1).gt.0,s_f(2).gt.0,s_f(3).gt.0/))) then
           if (allocated(this%f)) then
             deallocate(this%f)
           endif
           allocate(this%f(s_f(1),s_f(2),s_f(3)))
           read(un,*); read(un,*) this%f
         endif
         read(un,*); read(un,*) this%s
         read(un,*); read(un,*) this%s_1D
       end subroutine

       subroutine export_wrap_grid_field(this,dir,name)
         implicit none
         type(grid_field),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_grid_field(this,dir,name)
         implicit none
         type(grid_field),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_grid_field(this,dir)
         implicit none
         type(grid_field),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_grid_field(this,dir)
         implicit none
         type(grid_field),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_grid_field(this,dir)
         implicit none
         type(grid_field),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_grid_field(this,dir)
         implicit none
         type(grid_field),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_grid_field(this,dir)
         implicit none
         type(grid_field),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_grid_field(this)
         implicit none
         type(grid_field),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module index_2D_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: index_2D
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_index_2D;              end interface
       interface delete;                 module procedure delete_index_2D;                 end interface
       interface display;                module procedure display_index_2D;                end interface
       interface display_short;          module procedure display_short_index_2D;          end interface
       interface display;                module procedure display_wrap_index_2D;           end interface
       interface print;                  module procedure print_index_2D;                  end interface
       interface print_short;            module procedure print_short_index_2D;            end interface
       interface export;                 module procedure export_index_2D;                 end interface
       interface export_primitives;      module procedure export_primitives_index_2D;      end interface
       interface import;                 module procedure import_index_2D;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_index_2D;end interface
       interface export_structured;      module procedure export_structured_D_index_2D;    end interface
       interface import_structured;      module procedure import_structured_D_index_2D;    end interface
       interface import_primitives;      module procedure import_primitives_index_2D;      end interface
       interface export;                 module procedure export_wrap_index_2D;            end interface
       interface import;                 module procedure import_wrap_index_2D;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_index_2D;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_index_2D;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_index_2D;      end interface

       type index_2D
         integer,dimension(2) :: i = 0
       end type

       contains

       subroutine init_copy_index_2D(this,that)
         implicit none
         type(index_2D),intent(inout) :: this
         type(index_2D),intent(in) :: that
         call delete(this)
         this%i = that%i
       end subroutine

       subroutine delete_index_2D(this)
         implicit none
         type(index_2D),intent(inout) :: this
         this%i = 0
       end subroutine

       subroutine display_index_2D(this,un)
         implicit none
         type(index_2D),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'i = ',this%i
       end subroutine

       subroutine display_short_index_2D(this,un)
         implicit none
         type(index_2D),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'i = ',this%i
       end subroutine

       subroutine display_wrap_index_2D(this,dir,name)
         implicit none
         type(index_2D),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_index_2D(this)
         implicit none
         type(index_2D),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_index_2D(this)
         implicit none
         type(index_2D),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_index_2D(this,un)
         implicit none
         type(index_2D),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_index_2D(this,un)
         implicit none
         type(index_2D),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_index_2D(this,un)
         implicit none
         type(index_2D),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'i  = ';write(un,*) this%i
       end subroutine

       subroutine import_primitives_index_2D(this,un)
         implicit none
         type(index_2D),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%i
       end subroutine

       subroutine export_wrap_index_2D(this,dir,name)
         implicit none
         type(index_2D),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_index_2D(this,dir,name)
         implicit none
         type(index_2D),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_index_2D(this,dir)
         implicit none
         type(index_2D),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_index_2D(this,dir)
         implicit none
         type(index_2D),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_index_2D(this,dir)
         implicit none
         type(index_2D),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_index_2D(this,dir)
         implicit none
         type(index_2D),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_index_2D(this,dir)
         implicit none
         type(index_2D),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_index_2D(this)
         implicit none
         type(index_2D),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module kill_switch_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: kill_switch
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_kill_switch;              end interface
       interface delete;                 module procedure delete_kill_switch;                 end interface
       interface display;                module procedure display_kill_switch;                end interface
       interface display_short;          module procedure display_short_kill_switch;          end interface
       interface display;                module procedure display_wrap_kill_switch;           end interface
       interface print;                  module procedure print_kill_switch;                  end interface
       interface print_short;            module procedure print_short_kill_switch;            end interface
       interface export;                 module procedure export_kill_switch;                 end interface
       interface export_primitives;      module procedure export_primitives_kill_switch;      end interface
       interface import;                 module procedure import_kill_switch;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_kill_switch;end interface
       interface export_structured;      module procedure export_structured_D_kill_switch;    end interface
       interface import_structured;      module procedure import_structured_D_kill_switch;    end interface
       interface import_primitives;      module procedure import_primitives_kill_switch;      end interface
       interface export;                 module procedure export_wrap_kill_switch;            end interface
       interface import;                 module procedure import_wrap_kill_switch;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_kill_switch;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_kill_switch;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_kill_switch;      end interface
       interface export;                 module procedure export_DN_kill_switch;              end interface
       interface import;                 module procedure import_DN_kill_switch;              end interface
       interface export_structured;      module procedure export_structured_DN_kill_switch;   end interface
       interface import_structured;      module procedure import_structured_DN_kill_switch;   end interface

       type kill_switch
         integer :: un = 0
         logical :: terminate_loop = .false.
         type(string) :: dir
         type(string) :: name
       end type

       contains

       subroutine init_copy_kill_switch(this,that)
         implicit none
         type(kill_switch),intent(inout) :: this
         type(kill_switch),intent(in) :: that
         call delete(this)
         this%un = that%un
         this%terminate_loop = that%terminate_loop
         call init(this%dir,that%dir)
         call init(this%name,that%name)
       end subroutine

       subroutine delete_kill_switch(this)
         implicit none
         type(kill_switch),intent(inout) :: this
         this%un = 0
         this%terminate_loop = .false.
         call delete(this%dir)
         call delete(this%name)
       end subroutine

       subroutine display_kill_switch(this,un)
         implicit none
         type(kill_switch),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'un             = ',this%un
         write(un,*) 'terminate_loop = ',this%terminate_loop
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_short_kill_switch(this,un)
         implicit none
         type(kill_switch),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'un             = ',this%un
         write(un,*) 'terminate_loop = ',this%terminate_loop
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_wrap_kill_switch(this,dir,name)
         implicit none
         type(kill_switch),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_kill_switch(this)
         implicit none
         type(kill_switch),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_kill_switch(this)
         implicit none
         type(kill_switch),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_kill_switch(this,un)
         implicit none
         type(kill_switch),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_kill_switch(this,un)
         implicit none
         type(kill_switch),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_kill_switch(this,un)
         implicit none
         type(kill_switch),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'un              = ';write(un,*) this%un
         write(un,*) 'terminate_loop  = ';write(un,*) this%terminate_loop
       end subroutine

       subroutine import_primitives_kill_switch(this,un)
         implicit none
         type(kill_switch),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%un
         read(un,*); read(un,*) this%terminate_loop
       end subroutine

       subroutine export_wrap_kill_switch(this,dir,name)
         implicit none
         type(kill_switch),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_kill_switch(this,dir,name)
         implicit none
         type(kill_switch),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_kill_switch(this)
         implicit none
         type(kill_switch),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_kill_switch(this)
         implicit none
         type(kill_switch),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_kill_switch(this)
         implicit none
         type(kill_switch),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_kill_switch(this)
         implicit none
         type(kill_switch),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_kill_switch(this,dir)
         implicit none
         type(kill_switch),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_kill_switch(this,dir)
         implicit none
         type(kill_switch),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_kill_switch(this,dir)
         implicit none
         type(kill_switch),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_kill_switch(this,dir)
         implicit none
         type(kill_switch),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_kill_switch(this,dir)
         implicit none
         type(kill_switch),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_kill_switch(this)
         implicit none
         type(kill_switch),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module matrix_free_params_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: matrix_free_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_matrix_free_params;              end interface
       interface delete;                 module procedure delete_matrix_free_params;                 end interface
       interface display;                module procedure display_matrix_free_params;                end interface
       interface display_short;          module procedure display_short_matrix_free_params;          end interface
       interface display;                module procedure display_wrap_matrix_free_params;           end interface
       interface print;                  module procedure print_matrix_free_params;                  end interface
       interface print_short;            module procedure print_short_matrix_free_params;            end interface
       interface export;                 module procedure export_matrix_free_params;                 end interface
       interface export_primitives;      module procedure export_primitives_matrix_free_params;      end interface
       interface import;                 module procedure import_matrix_free_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_matrix_free_params;end interface
       interface export_structured;      module procedure export_structured_D_matrix_free_params;    end interface
       interface import_structured;      module procedure import_structured_D_matrix_free_params;    end interface
       interface import_primitives;      module procedure import_primitives_matrix_free_params;      end interface
       interface export;                 module procedure export_wrap_matrix_free_params;            end interface
       interface import;                 module procedure import_wrap_matrix_free_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_matrix_free_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_matrix_free_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_matrix_free_params;      end interface

       type matrix_free_params
         logical :: suppress_warning = .false.
         real(cp) :: alpha = 0.0_cp
         real(cp) :: beta = 0.0_cp
         real(cp) :: coeff_natural = 0.0_cp
         real(cp) :: coeff_explicit = 0.0_cp
         real(cp) :: coeff_implicit = 0.0_cp
         real(cp) :: coeff_implicit_time_split = 0.0_cp
       end type

       contains

       subroutine init_copy_matrix_free_params(this,that)
         implicit none
         type(matrix_free_params),intent(inout) :: this
         type(matrix_free_params),intent(in) :: that
         call delete(this)
         this%suppress_warning = that%suppress_warning
         this%alpha = that%alpha
         this%beta = that%beta
         this%coeff_natural = that%coeff_natural
         this%coeff_explicit = that%coeff_explicit
         this%coeff_implicit = that%coeff_implicit
         this%coeff_implicit_time_split = that%coeff_implicit_time_split
       end subroutine

       subroutine delete_matrix_free_params(this)
         implicit none
         type(matrix_free_params),intent(inout) :: this
         this%suppress_warning = .false.
         this%alpha = 0.0_cp
         this%beta = 0.0_cp
         this%coeff_natural = 0.0_cp
         this%coeff_explicit = 0.0_cp
         this%coeff_implicit = 0.0_cp
         this%coeff_implicit_time_split = 0.0_cp
       end subroutine

       subroutine display_matrix_free_params(this,un)
         implicit none
         type(matrix_free_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning          = ',this%suppress_warning
         write(un,*) 'alpha                     = ',this%alpha
         write(un,*) 'beta                      = ',this%beta
         write(un,*) 'coeff_natural             = ',this%coeff_natural
         write(un,*) 'coeff_explicit            = ',this%coeff_explicit
         write(un,*) 'coeff_implicit            = ',this%coeff_implicit
         write(un,*) 'coeff_implicit_time_split = ',&
         this%coeff_implicit_time_split
       end subroutine

       subroutine display_short_matrix_free_params(this,un)
         implicit none
         type(matrix_free_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning          = ',this%suppress_warning
         write(un,*) 'alpha                     = ',this%alpha
         write(un,*) 'beta                      = ',this%beta
         write(un,*) 'coeff_natural             = ',this%coeff_natural
         write(un,*) 'coeff_explicit            = ',this%coeff_explicit
         write(un,*) 'coeff_implicit            = ',this%coeff_implicit
         write(un,*) 'coeff_implicit_time_split = ',&
         this%coeff_implicit_time_split
       end subroutine

       subroutine display_wrap_matrix_free_params(this,dir,name)
         implicit none
         type(matrix_free_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_matrix_free_params(this)
         implicit none
         type(matrix_free_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_matrix_free_params(this)
         implicit none
         type(matrix_free_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_matrix_free_params(this,un)
         implicit none
         type(matrix_free_params),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_matrix_free_params(this,un)
         implicit none
         type(matrix_free_params),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_matrix_free_params(this,un)
         implicit none
         type(matrix_free_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning           = ';write(un,*) this%suppress_warning
         write(un,*) 'alpha                      = ';write(un,*) this%alpha
         write(un,*) 'beta                       = ';write(un,*) this%beta
         write(un,*) 'coeff_natural              = ';write(un,*) this%coeff_natural
         write(un,*) 'coeff_explicit             = ';write(un,*) this%coeff_explicit
         write(un,*) 'coeff_implicit             = ';write(un,*) this%coeff_implicit
         write(un,*) 'coeff_implicit_time_split  = ';write(un,*) this%coeff_implicit_time_split
       end subroutine

       subroutine import_primitives_matrix_free_params(this,un)
         implicit none
         type(matrix_free_params),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%suppress_warning
         read(un,*); read(un,*) this%alpha
         read(un,*); read(un,*) this%beta
         read(un,*); read(un,*) this%coeff_natural
         read(un,*); read(un,*) this%coeff_explicit
         read(un,*); read(un,*) this%coeff_implicit
         read(un,*); read(un,*) this%coeff_implicit_time_split
       end subroutine

       subroutine export_wrap_matrix_free_params(this,dir,name)
         implicit none
         type(matrix_free_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_matrix_free_params(this,dir,name)
         implicit none
         type(matrix_free_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_matrix_free_params(this,dir)
         implicit none
         type(matrix_free_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_matrix_free_params(this,dir)
         implicit none
         type(matrix_free_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_matrix_free_params(this,dir)
         implicit none
         type(matrix_free_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_matrix_free_params(this,dir)
         implicit none
         type(matrix_free_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_matrix_free_params(this,dir)
         implicit none
         type(matrix_free_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_matrix_free_params(this)
         implicit none
         type(matrix_free_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module mesh_quality_params_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: mesh_quality_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_mesh_quality_params;              end interface
       interface delete;                 module procedure delete_mesh_quality_params;                 end interface
       interface display;                module procedure display_mesh_quality_params;                end interface
       interface display_short;          module procedure display_short_mesh_quality_params;          end interface
       interface display;                module procedure display_wrap_mesh_quality_params;           end interface
       interface print;                  module procedure print_mesh_quality_params;                  end interface
       interface print_short;            module procedure print_short_mesh_quality_params;            end interface
       interface export;                 module procedure export_mesh_quality_params;                 end interface
       interface export_primitives;      module procedure export_primitives_mesh_quality_params;      end interface
       interface import;                 module procedure import_mesh_quality_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_mesh_quality_params;end interface
       interface export_structured;      module procedure export_structured_D_mesh_quality_params;    end interface
       interface import_structured;      module procedure import_structured_D_mesh_quality_params;    end interface
       interface import_primitives;      module procedure import_primitives_mesh_quality_params;      end interface
       interface export;                 module procedure export_wrap_mesh_quality_params;            end interface
       interface import;                 module procedure import_wrap_mesh_quality_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_mesh_quality_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_mesh_quality_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_mesh_quality_params;      end interface

       type mesh_quality_params
         real(cp) :: max_mesh_stretch_ratio = 0.0_cp
         integer :: N_max_points_add = 0
         integer :: N_iter = 0
         logical :: auto_find_N = .false.
       end type

       contains

       subroutine init_copy_mesh_quality_params(this,that)
         implicit none
         type(mesh_quality_params),intent(inout) :: this
         type(mesh_quality_params),intent(in) :: that
         call delete(this)
         this%max_mesh_stretch_ratio = that%max_mesh_stretch_ratio
         this%N_max_points_add = that%N_max_points_add
         this%N_iter = that%N_iter
         this%auto_find_N = that%auto_find_N
       end subroutine

       subroutine delete_mesh_quality_params(this)
         implicit none
         type(mesh_quality_params),intent(inout) :: this
         this%max_mesh_stretch_ratio = 0.0_cp
         this%N_max_points_add = 0
         this%N_iter = 0
         this%auto_find_N = .false.
       end subroutine

       subroutine display_mesh_quality_params(this,un)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'max_mesh_stretch_ratio = ',this%max_mesh_stretch_ratio
         write(un,*) 'N_max_points_add       = ',this%N_max_points_add
         write(un,*) 'N_iter                 = ',this%N_iter
         write(un,*) 'auto_find_N            = ',this%auto_find_N
       end subroutine

       subroutine display_short_mesh_quality_params(this,un)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'max_mesh_stretch_ratio = ',this%max_mesh_stretch_ratio
         write(un,*) 'N_max_points_add       = ',this%N_max_points_add
         write(un,*) 'N_iter                 = ',this%N_iter
         write(un,*) 'auto_find_N            = ',this%auto_find_N
       end subroutine

       subroutine display_wrap_mesh_quality_params(this,dir,name)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_mesh_quality_params(this)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_mesh_quality_params(this)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_mesh_quality_params(this,un)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_mesh_quality_params(this,un)
         implicit none
         type(mesh_quality_params),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_mesh_quality_params(this,un)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'max_mesh_stretch_ratio  = ';write(un,*) this%max_mesh_stretch_ratio
         write(un,*) 'N_max_points_add        = ';write(un,*) this%N_max_points_add
         write(un,*) 'N_iter                  = ';write(un,*) this%N_iter
         write(un,*) 'auto_find_N             = ';write(un,*) this%auto_find_N
       end subroutine

       subroutine import_primitives_mesh_quality_params(this,un)
         implicit none
         type(mesh_quality_params),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%max_mesh_stretch_ratio
         read(un,*); read(un,*) this%N_max_points_add
         read(un,*); read(un,*) this%N_iter
         read(un,*); read(un,*) this%auto_find_N
       end subroutine

       subroutine export_wrap_mesh_quality_params(this,dir,name)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_mesh_quality_params(this,dir,name)
         implicit none
         type(mesh_quality_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_mesh_quality_params(this,dir)
         implicit none
         type(mesh_quality_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_mesh_quality_params(this,dir)
         implicit none
         type(mesh_quality_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_mesh_quality_params(this,dir)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_mesh_quality_params(this,dir)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_mesh_quality_params(this,dir)
         implicit none
         type(mesh_quality_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_mesh_quality_params(this)
         implicit none
         type(mesh_quality_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module mirror_props_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: mirror_props
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_mirror_props;              end interface
       interface delete;                 module procedure delete_mirror_props;                 end interface
       interface display;                module procedure display_mirror_props;                end interface
       interface display_short;          module procedure display_short_mirror_props;          end interface
       interface display;                module procedure display_wrap_mirror_props;           end interface
       interface print;                  module procedure print_mirror_props;                  end interface
       interface print_short;            module procedure print_short_mirror_props;            end interface
       interface export;                 module procedure export_mirror_props;                 end interface
       interface export_primitives;      module procedure export_primitives_mirror_props;      end interface
       interface import;                 module procedure import_mirror_props;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_mirror_props;end interface
       interface export_structured;      module procedure export_structured_D_mirror_props;    end interface
       interface import_structured;      module procedure import_structured_D_mirror_props;    end interface
       interface import_primitives;      module procedure import_primitives_mirror_props;      end interface
       interface export;                 module procedure export_wrap_mirror_props;            end interface
       interface import;                 module procedure import_wrap_mirror_props;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_mirror_props;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_mirror_props;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_mirror_props;      end interface

       type mirror_props
         logical :: mirror = .false.
         integer :: mirror_face = 0
         real(cp),dimension(3) :: mirror_sign = 0.0_cp
         real(cp),dimension(3) :: mirror_sign_a = 0.0_cp
       end type

       contains

       subroutine init_copy_mirror_props(this,that)
         implicit none
         type(mirror_props),intent(inout) :: this
         type(mirror_props),intent(in) :: that
         call delete(this)
         this%mirror = that%mirror
         this%mirror_face = that%mirror_face
         this%mirror_sign = that%mirror_sign
         this%mirror_sign_a = that%mirror_sign_a
       end subroutine

       subroutine delete_mirror_props(this)
         implicit none
         type(mirror_props),intent(inout) :: this
         this%mirror = .false.
         this%mirror_face = 0
         this%mirror_sign = 0.0_cp
         this%mirror_sign_a = 0.0_cp
       end subroutine

       subroutine display_mirror_props(this,un)
         implicit none
         type(mirror_props),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'mirror        = ',this%mirror
         write(un,*) 'mirror_face   = ',this%mirror_face
         write(un,*) 'mirror_sign   = ',this%mirror_sign
         write(un,*) 'mirror_sign_a = ',this%mirror_sign_a
       end subroutine

       subroutine display_short_mirror_props(this,un)
         implicit none
         type(mirror_props),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'mirror        = ',this%mirror
         write(un,*) 'mirror_face   = ',this%mirror_face
         write(un,*) 'mirror_sign   = ',this%mirror_sign
         write(un,*) 'mirror_sign_a = ',this%mirror_sign_a
       end subroutine

       subroutine display_wrap_mirror_props(this,dir,name)
         implicit none
         type(mirror_props),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_mirror_props(this)
         implicit none
         type(mirror_props),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_mirror_props(this)
         implicit none
         type(mirror_props),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_mirror_props(this,un)
         implicit none
         type(mirror_props),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_mirror_props(this,un)
         implicit none
         type(mirror_props),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_mirror_props(this,un)
         implicit none
         type(mirror_props),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'mirror         = ';write(un,*) this%mirror
         write(un,*) 'mirror_face    = ';write(un,*) this%mirror_face
         write(un,*) 'mirror_sign    = ';write(un,*) this%mirror_sign
         write(un,*) 'mirror_sign_a  = ';write(un,*) this%mirror_sign_a
       end subroutine

       subroutine import_primitives_mirror_props(this,un)
         implicit none
         type(mirror_props),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%mirror
         read(un,*); read(un,*) this%mirror_face
         read(un,*); read(un,*) this%mirror_sign
         read(un,*); read(un,*) this%mirror_sign_a
       end subroutine

       subroutine export_wrap_mirror_props(this,dir,name)
         implicit none
         type(mirror_props),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_mirror_props(this,dir,name)
         implicit none
         type(mirror_props),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_mirror_props(this,dir)
         implicit none
         type(mirror_props),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_mirror_props(this,dir)
         implicit none
         type(mirror_props),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_mirror_props(this,dir)
         implicit none
         type(mirror_props),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_mirror_props(this,dir)
         implicit none
         type(mirror_props),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_mirror_props(this,dir)
         implicit none
         type(mirror_props),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_mirror_props(this)
         implicit none
         type(mirror_props),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module norms_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: norms
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_norms;              end interface
       interface delete;                 module procedure delete_norms;                 end interface
       interface display;                module procedure display_norms;                end interface
       interface display_short;          module procedure display_short_norms;          end interface
       interface display;                module procedure display_wrap_norms;           end interface
       interface print;                  module procedure print_norms;                  end interface
       interface print_short;            module procedure print_short_norms;            end interface
       interface export;                 module procedure export_norms;                 end interface
       interface export_primitives;      module procedure export_primitives_norms;      end interface
       interface import;                 module procedure import_norms;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_norms;end interface
       interface export_structured;      module procedure export_structured_D_norms;    end interface
       interface import_structured;      module procedure import_structured_D_norms;    end interface
       interface import_primitives;      module procedure import_primitives_norms;      end interface
       interface export;                 module procedure export_wrap_norms;            end interface
       interface import;                 module procedure import_wrap_norms;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_norms;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_norms;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_norms;      end interface

       type norms
         real(cp) :: L1 = 0.0_cp
         real(cp) :: L2 = 0.0_cp
         real(cp) :: Linf = 0.0_cp
       end type

       contains

       subroutine init_copy_norms(this,that)
         implicit none
         type(norms),intent(inout) :: this
         type(norms),intent(in) :: that
         call delete(this)
         this%L1 = that%L1
         this%L2 = that%L2
         this%Linf = that%Linf
       end subroutine

       subroutine delete_norms(this)
         implicit none
         type(norms),intent(inout) :: this
         this%L1 = 0.0_cp
         this%L2 = 0.0_cp
         this%Linf = 0.0_cp
       end subroutine

       subroutine display_norms(this,un)
         implicit none
         type(norms),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'L1   = ',this%L1
         write(un,*) 'L2   = ',this%L2
         write(un,*) 'Linf = ',this%Linf
       end subroutine

       subroutine display_short_norms(this,un)
         implicit none
         type(norms),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'L1   = ',this%L1
         write(un,*) 'L2   = ',this%L2
         write(un,*) 'Linf = ',this%Linf
       end subroutine

       subroutine display_wrap_norms(this,dir,name)
         implicit none
         type(norms),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_norms(this)
         implicit none
         type(norms),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_norms(this)
         implicit none
         type(norms),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_norms(this,un)
         implicit none
         type(norms),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_norms(this,un)
         implicit none
         type(norms),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_norms(this,un)
         implicit none
         type(norms),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'L1    = ';write(un,*) this%L1
         write(un,*) 'L2    = ';write(un,*) this%L2
         write(un,*) 'Linf  = ';write(un,*) this%Linf
       end subroutine

       subroutine import_primitives_norms(this,un)
         implicit none
         type(norms),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%L1
         read(un,*); read(un,*) this%L2
         read(un,*); read(un,*) this%Linf
       end subroutine

       subroutine export_wrap_norms(this,dir,name)
         implicit none
         type(norms),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_norms(this,dir,name)
         implicit none
         type(norms),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_norms(this,dir)
         implicit none
         type(norms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_norms(this,dir)
         implicit none
         type(norms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_norms(this,dir)
         implicit none
         type(norms),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_norms(this,dir)
         implicit none
         type(norms),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_norms(this,dir)
         implicit none
         type(norms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_norms(this)
         implicit none
         type(norms),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module overlap_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: overlap
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_overlap;              end interface
       interface delete;                 module procedure delete_overlap;                 end interface
       interface display;                module procedure display_overlap;                end interface
       interface display_short;          module procedure display_short_overlap;          end interface
       interface display;                module procedure display_wrap_overlap;           end interface
       interface print;                  module procedure print_overlap;                  end interface
       interface print_short;            module procedure print_short_overlap;            end interface
       interface export;                 module procedure export_overlap;                 end interface
       interface export_primitives;      module procedure export_primitives_overlap;      end interface
       interface import;                 module procedure import_overlap;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_overlap;end interface
       interface export_structured;      module procedure export_structured_D_overlap;    end interface
       interface import_structured;      module procedure import_structured_D_overlap;    end interface
       interface import_primitives;      module procedure import_primitives_overlap;      end interface
       interface export;                 module procedure export_wrap_overlap;            end interface
       interface import;                 module procedure import_wrap_overlap;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_overlap;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_overlap;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_overlap;      end interface

       type overlap
         integer,dimension(2) :: i1 = 0
         integer,dimension(2) :: i2 = 0
         integer :: iR = 0
         logical :: success = .false.
       end type

       contains

       subroutine init_copy_overlap(this,that)
         implicit none
         type(overlap),intent(inout) :: this
         type(overlap),intent(in) :: that
         call delete(this)
         this%i1 = that%i1
         this%i2 = that%i2
         this%iR = that%iR
         this%success = that%success
       end subroutine

       subroutine delete_overlap(this)
         implicit none
         type(overlap),intent(inout) :: this
         this%i1 = 0
         this%i2 = 0
         this%iR = 0
         this%success = .false.
       end subroutine

       subroutine display_overlap(this,un)
         implicit none
         type(overlap),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'i1      = ',this%i1
         write(un,*) 'i2      = ',this%i2
         write(un,*) 'iR      = ',this%iR
         write(un,*) 'success = ',this%success
       end subroutine

       subroutine display_short_overlap(this,un)
         implicit none
         type(overlap),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'i1      = ',this%i1
         write(un,*) 'i2      = ',this%i2
         write(un,*) 'iR      = ',this%iR
         write(un,*) 'success = ',this%success
       end subroutine

       subroutine display_wrap_overlap(this,dir,name)
         implicit none
         type(overlap),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_overlap(this)
         implicit none
         type(overlap),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_overlap(this)
         implicit none
         type(overlap),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_overlap(this,un)
         implicit none
         type(overlap),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_overlap(this,un)
         implicit none
         type(overlap),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_overlap(this,un)
         implicit none
         type(overlap),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'i1       = ';write(un,*) this%i1
         write(un,*) 'i2       = ';write(un,*) this%i2
         write(un,*) 'iR       = ';write(un,*) this%iR
         write(un,*) 'success  = ';write(un,*) this%success
       end subroutine

       subroutine import_primitives_overlap(this,un)
         implicit none
         type(overlap),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%i1
         read(un,*); read(un,*) this%i2
         read(un,*); read(un,*) this%iR
         read(un,*); read(un,*) this%success
       end subroutine

       subroutine export_wrap_overlap(this,dir,name)
         implicit none
         type(overlap),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_overlap(this,dir,name)
         implicit none
         type(overlap),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_overlap(this,dir)
         implicit none
         type(overlap),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_overlap(this,dir)
         implicit none
         type(overlap),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_overlap(this,dir)
         implicit none
         type(overlap),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_overlap(this,dir)
         implicit none
         type(overlap),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_overlap(this,dir)
         implicit none
         type(overlap),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_overlap(this)
         implicit none
         type(overlap),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module path_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: path
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_path;              end interface
       interface delete;                 module procedure delete_path;                 end interface
       interface display;                module procedure display_path;                end interface
       interface display_short;          module procedure display_short_path;          end interface
       interface display;                module procedure display_wrap_path;           end interface
       interface print;                  module procedure print_path;                  end interface
       interface print_short;            module procedure print_short_path;            end interface
       interface export;                 module procedure export_path;                 end interface
       interface export_primitives;      module procedure export_primitives_path;      end interface
       interface import;                 module procedure import_path;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_path;end interface
       interface export_structured;      module procedure export_structured_D_path;    end interface
       interface import_structured;      module procedure import_structured_D_path;    end interface
       interface import_primitives;      module procedure import_primitives_path;      end interface
       interface export;                 module procedure export_wrap_path;            end interface
       interface import;                 module procedure import_wrap_path;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_path;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_path;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_path;      end interface

       type path
         type(string) :: absolute
         type(string) :: relative
       end type

       contains

       subroutine init_copy_path(this,that)
         implicit none
         type(path),intent(inout) :: this
         type(path),intent(in) :: that
         call delete(this)
         call init(this%absolute,that%absolute)
         call init(this%relative,that%relative)
       end subroutine

       subroutine delete_path(this)
         implicit none
         type(path),intent(inout) :: this
         call delete(this%absolute)
         call delete(this%relative)
       end subroutine

       subroutine display_path(this,un)
         implicit none
         type(path),intent(in) :: this
         integer,intent(in) :: un
         call display(this%absolute,un)
         call display(this%relative,un)
       end subroutine

       subroutine display_short_path(this,un)
         implicit none
         type(path),intent(in) :: this
         integer,intent(in) :: un
         call display(this%absolute,un)
         call display(this%relative,un)
       end subroutine

       subroutine display_wrap_path(this,dir,name)
         implicit none
         type(path),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_path(this)
         implicit none
         type(path),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_path(this)
         implicit none
         type(path),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_path(this,un)
         implicit none
         type(path),intent(in) :: this
         integer,intent(in) :: un
         call export(this%absolute,un)
         call export(this%relative,un)
       end subroutine

       subroutine import_path(this,un)
         implicit none
         type(path),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%absolute,un)
         call import(this%relative,un)
       end subroutine

       subroutine export_primitives_path(this,un)
         implicit none
         type(path),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_path(this,un)
         implicit none
         type(path),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_path(this,dir,name)
         implicit none
         type(path),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_path(this,dir,name)
         implicit none
         type(path),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_path(this,dir)
         implicit none
         type(path),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
         call set_IO_dir(this%relative,dir//'relative'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_path(this,dir)
         implicit none
         type(path),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%relative,dir//'relative'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_path(this,dir)
         implicit none
         type(path),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%relative,dir//'relative'//fortran_PS)
       end subroutine

       subroutine export_structured_D_path(this,dir)
         implicit none
         type(path),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%relative,dir//'relative'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_path(this,dir)
         implicit none
         type(path),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%relative,dir//'relative'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_path(this)
         implicit none
         type(path),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module probe_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: probe
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_probe;              end interface
       interface delete;                 module procedure delete_probe;                 end interface
       interface display;                module procedure display_probe;                end interface
       interface display_short;          module procedure display_short_probe;          end interface
       interface display;                module procedure display_wrap_probe;           end interface
       interface print;                  module procedure print_probe;                  end interface
       interface print_short;            module procedure print_short_probe;            end interface
       interface export;                 module procedure export_probe;                 end interface
       interface export_primitives;      module procedure export_primitives_probe;      end interface
       interface import;                 module procedure import_probe;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_probe;end interface
       interface export_structured;      module procedure export_structured_D_probe;    end interface
       interface import_structured;      module procedure import_structured_D_probe;    end interface
       interface import_primitives;      module procedure import_primitives_probe;      end interface
       interface export;                 module procedure export_wrap_probe;            end interface
       interface import;                 module procedure import_wrap_probe;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_probe;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_probe;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_probe;      end interface
       interface export;                 module procedure export_DN_probe;              end interface
       interface import;                 module procedure import_DN_probe;              end interface
       interface export_structured;      module procedure export_structured_DN_probe;   end interface
       interface import_structured;      module procedure import_structured_DN_probe;   end interface

       type probe
         type(string) :: tec_dir
         type(string) :: tec_name
         real(cp) :: d = 0.0_cp
         real(cp) :: d_data_dt = 0.0_cp
         real(cp) :: d_amax = 0.0_cp
         real(cp) :: t = 0.0_cp
         real(cp) :: abs_d_data_dt = 0.0_cp
         real(cp) :: abs_d_data_dt_by_dmax = 0.0_cp
         integer :: un = 0
         integer :: cols = 0
         integer(li) :: n_step = 0
         logical :: restart = .false.
         logical :: simple = .false.
         type(string) :: dir
         type(string) :: name
       end type

       contains

       subroutine init_copy_probe(this,that)
         implicit none
         type(probe),intent(inout) :: this
         type(probe),intent(in) :: that
         call delete(this)
         call init(this%tec_dir,that%tec_dir)
         call init(this%tec_name,that%tec_name)
         this%d = that%d
         this%d_data_dt = that%d_data_dt
         this%d_amax = that%d_amax
         this%t = that%t
         this%abs_d_data_dt = that%abs_d_data_dt
         this%abs_d_data_dt_by_dmax = that%abs_d_data_dt_by_dmax
         this%un = that%un
         this%cols = that%cols
         this%n_step = that%n_step
         this%restart = that%restart
         this%simple = that%simple
         call init(this%dir,that%dir)
         call init(this%name,that%name)
       end subroutine

       subroutine delete_probe(this)
         implicit none
         type(probe),intent(inout) :: this
         call delete(this%tec_dir)
         call delete(this%tec_name)
         this%d = 0.0_cp
         this%d_data_dt = 0.0_cp
         this%d_amax = 0.0_cp
         this%t = 0.0_cp
         this%abs_d_data_dt = 0.0_cp
         this%abs_d_data_dt_by_dmax = 0.0_cp
         this%un = 0
         this%cols = 0
         this%n_step = 0
         this%restart = .false.
         this%simple = .false.
         call delete(this%dir)
         call delete(this%name)
       end subroutine

       subroutine display_probe(this,un)
         implicit none
         type(probe),intent(in) :: this
         integer,intent(in) :: un
         call display(this%tec_dir,un)
         call display(this%tec_name,un)
         write(un,*) 'd                     = ',this%d
         write(un,*) 'd_data_dt             = ',this%d_data_dt
         write(un,*) 'd_amax                = ',this%d_amax
         write(un,*) 't                     = ',this%t
         write(un,*) 'abs_d_data_dt         = ',this%abs_d_data_dt
         write(un,*) 'abs_d_data_dt_by_dmax = ',this%abs_d_data_dt_by_dmax
         write(un,*) 'un                    = ',this%un
         write(un,*) 'cols                  = ',this%cols
         write(un,*) 'n_step                = ',this%n_step
         write(un,*) 'restart               = ',this%restart
         write(un,*) 'simple                = ',this%simple
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_short_probe(this,un)
         implicit none
         type(probe),intent(in) :: this
         integer,intent(in) :: un
         call display(this%tec_dir,un)
         call display(this%tec_name,un)
         write(un,*) 'd                     = ',this%d
         write(un,*) 'd_data_dt             = ',this%d_data_dt
         write(un,*) 'd_amax                = ',this%d_amax
         write(un,*) 't                     = ',this%t
         write(un,*) 'abs_d_data_dt         = ',this%abs_d_data_dt
         write(un,*) 'abs_d_data_dt_by_dmax = ',this%abs_d_data_dt_by_dmax
         write(un,*) 'un                    = ',this%un
         write(un,*) 'cols                  = ',this%cols
         write(un,*) 'n_step                = ',this%n_step
         write(un,*) 'restart               = ',this%restart
         write(un,*) 'simple                = ',this%simple
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_wrap_probe(this,dir,name)
         implicit none
         type(probe),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_probe(this)
         implicit none
         type(probe),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_probe(this)
         implicit none
         type(probe),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_probe(this,un)
         implicit none
         type(probe),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%tec_dir,un)
         call export(this%tec_name,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_probe(this,un)
         implicit none
         type(probe),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%tec_dir,un)
         call import(this%tec_name,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_probe(this,un)
         implicit none
         type(probe),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'd                      = ';write(un,*) this%d
         write(un,*) 'd_data_dt              = ';write(un,*) this%d_data_dt
         write(un,*) 'd_amax                 = ';write(un,*) this%d_amax
         write(un,*) 't                      = ';write(un,*) this%t
         write(un,*) 'abs_d_data_dt          = ';write(un,*) this%abs_d_data_dt
         write(un,*) 'abs_d_data_dt_by_dmax  = ';write(un,*) this%abs_d_data_dt_by_dmax
         write(un,*) 'un                     = ';write(un,*) this%un
         write(un,*) 'cols                   = ';write(un,*) this%cols
         write(un,*) 'n_step                 = ';write(un,*) this%n_step
         write(un,*) 'restart                = ';write(un,*) this%restart
         write(un,*) 'simple                 = ';write(un,*) this%simple
       end subroutine

       subroutine import_primitives_probe(this,un)
         implicit none
         type(probe),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%d
         read(un,*); read(un,*) this%d_data_dt
         read(un,*); read(un,*) this%d_amax
         read(un,*); read(un,*) this%t
         read(un,*); read(un,*) this%abs_d_data_dt
         read(un,*); read(un,*) this%abs_d_data_dt_by_dmax
         read(un,*); read(un,*) this%un
         read(un,*); read(un,*) this%cols
         read(un,*); read(un,*) this%n_step
         read(un,*); read(un,*) this%restart
         read(un,*); read(un,*) this%simple
       end subroutine

       subroutine export_wrap_probe(this,dir,name)
         implicit none
         type(probe),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_probe(this,dir,name)
         implicit none
         type(probe),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_probe(this)
         implicit none
         type(probe),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_probe(this)
         implicit none
         type(probe),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_probe(this)
         implicit none
         type(probe),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%tec_dir,&
         str(this%dir)//'tec_dir'//fortran_PS)
         call export_structured(this%tec_name,&
         str(this%dir)//'tec_name'//fortran_PS)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_probe(this)
         implicit none
         type(probe),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%tec_dir,&
         str(this%dir)//'tec_dir'//fortran_PS)
         call import_structured(this%tec_name,&
         str(this%dir)//'tec_name'//fortran_PS)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_probe(this,dir)
         implicit none
         type(probe),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%tec_dir,dir//'tec_dir'//fortran_PS)
         call set_IO_dir(this%tec_name,dir//'tec_name'//fortran_PS)
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_probe(this,dir)
         implicit none
         type(probe),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%tec_dir,dir//'tec_dir'//fortran_PS)
         call make_IO_dir(this%tec_name,dir//'tec_name'//fortran_PS)
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_probe(this,dir)
         implicit none
         type(probe),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%tec_dir,dir//'tec_dir'//fortran_PS)
         call export_structured(this%tec_name,dir//'tec_name'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_probe(this,dir)
         implicit none
         type(probe),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%tec_dir,dir//'tec_dir'//fortran_PS)
         call export_structured(this%tec_name,dir//'tec_name'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_probe(this,dir)
         implicit none
         type(probe),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%tec_dir,dir//'tec_dir'//fortran_PS)
         call import_structured(this%tec_name,dir//'tec_name'//fortran_PS)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_probe(this)
         implicit none
         type(probe),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module segment_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: segment
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_segment;              end interface
       interface delete;                 module procedure delete_segment;                 end interface
       interface display;                module procedure display_segment;                end interface
       interface display_short;          module procedure display_short_segment;          end interface
       interface display;                module procedure display_wrap_segment;           end interface
       interface print;                  module procedure print_segment;                  end interface
       interface print_short;            module procedure print_short_segment;            end interface
       interface export;                 module procedure export_segment;                 end interface
       interface export_primitives;      module procedure export_primitives_segment;      end interface
       interface import;                 module procedure import_segment;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_segment;end interface
       interface export_structured;      module procedure export_structured_D_segment;    end interface
       interface import_structured;      module procedure import_structured_D_segment;    end interface
       interface import_primitives;      module procedure import_primitives_segment;      end interface
       interface export;                 module procedure export_wrap_segment;            end interface
       interface import;                 module procedure import_wrap_segment;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_segment;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_segment;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_segment;      end interface

       type segment
         integer :: N_cells = 0
         type(string) :: distribution
         real(cp) :: hmax = 0.0_cp
         real(cp) :: hmin = 0.0_cp
         real(cp) :: buffer = 0.0_cp
         real(cp) :: L = 0.0_cp
         real(cp) :: tau = 0.0_cp
         real(cp) :: yc = 0.0_cp
         integer :: dir = 0
       end type

       contains

       subroutine init_copy_segment(this,that)
         implicit none
         type(segment),intent(inout) :: this
         type(segment),intent(in) :: that
         call delete(this)
         this%N_cells = that%N_cells
         call init(this%distribution,that%distribution)
         this%hmax = that%hmax
         this%hmin = that%hmin
         this%buffer = that%buffer
         this%L = that%L
         this%tau = that%tau
         this%yc = that%yc
         this%dir = that%dir
       end subroutine

       subroutine delete_segment(this)
         implicit none
         type(segment),intent(inout) :: this
         this%N_cells = 0
         call delete(this%distribution)
         this%hmax = 0.0_cp
         this%hmin = 0.0_cp
         this%buffer = 0.0_cp
         this%L = 0.0_cp
         this%tau = 0.0_cp
         this%yc = 0.0_cp
         this%dir = 0
       end subroutine

       subroutine display_segment(this,un)
         implicit none
         type(segment),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'N_cells      = ',this%N_cells
         call display(this%distribution,un)
         write(un,*) 'hmax         = ',this%hmax
         write(un,*) 'hmin         = ',this%hmin
         write(un,*) 'buffer       = ',this%buffer
         write(un,*) 'L            = ',this%L
         write(un,*) 'tau          = ',this%tau
         write(un,*) 'yc           = ',this%yc
         write(un,*) 'dir          = ',this%dir
       end subroutine

       subroutine display_short_segment(this,un)
         implicit none
         type(segment),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'N_cells      = ',this%N_cells
         call display(this%distribution,un)
         write(un,*) 'hmax         = ',this%hmax
         write(un,*) 'hmin         = ',this%hmin
         write(un,*) 'buffer       = ',this%buffer
         write(un,*) 'L            = ',this%L
         write(un,*) 'tau          = ',this%tau
         write(un,*) 'yc           = ',this%yc
         write(un,*) 'dir          = ',this%dir
       end subroutine

       subroutine display_wrap_segment(this,dir,name)
         implicit none
         type(segment),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_segment(this)
         implicit none
         type(segment),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_segment(this)
         implicit none
         type(segment),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_segment(this,un)
         implicit none
         type(segment),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%distribution,un)
       end subroutine

       subroutine import_segment(this,un)
         implicit none
         type(segment),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%distribution,un)
       end subroutine

       subroutine export_primitives_segment(this,un)
         implicit none
         type(segment),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'N_cells       = ';write(un,*) this%N_cells
         write(un,*) 'hmax          = ';write(un,*) this%hmax
         write(un,*) 'hmin          = ';write(un,*) this%hmin
         write(un,*) 'buffer        = ';write(un,*) this%buffer
         write(un,*) 'L             = ';write(un,*) this%L
         write(un,*) 'tau           = ';write(un,*) this%tau
         write(un,*) 'yc            = ';write(un,*) this%yc
         write(un,*) 'dir           = ';write(un,*) this%dir
       end subroutine

       subroutine import_primitives_segment(this,un)
         implicit none
         type(segment),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%N_cells
         read(un,*); read(un,*) this%hmax
         read(un,*); read(un,*) this%hmin
         read(un,*); read(un,*) this%buffer
         read(un,*); read(un,*) this%L
         read(un,*); read(un,*) this%tau
         read(un,*); read(un,*) this%yc
         read(un,*); read(un,*) this%dir
       end subroutine

       subroutine export_wrap_segment(this,dir,name)
         implicit none
         type(segment),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_segment(this,dir,name)
         implicit none
         type(segment),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_segment(this,dir)
         implicit none
         type(segment),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
         call set_IO_dir(this%distribution,dir//'distribution'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_segment(this,dir)
         implicit none
         type(segment),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%distribution,dir//'distribution'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_segment(this,dir)
         implicit none
         type(segment),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%distribution,&
         dir//'distribution'//fortran_PS)
       end subroutine

       subroutine export_structured_D_segment(this,dir)
         implicit none
         type(segment),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%distribution,&
         dir//'distribution'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_segment(this,dir)
         implicit none
         type(segment),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%distribution,&
         dir//'distribution'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_segment(this)
         implicit none
         type(segment),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module sim_config_params_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: sim_config_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_sim_config_params;              end interface
       interface delete;                 module procedure delete_sim_config_params;                 end interface
       interface display;                module procedure display_sim_config_params;                end interface
       interface display_short;          module procedure display_short_sim_config_params;          end interface
       interface display;                module procedure display_wrap_sim_config_params;           end interface
       interface print;                  module procedure print_sim_config_params;                  end interface
       interface print_short;            module procedure print_short_sim_config_params;            end interface
       interface export;                 module procedure export_sim_config_params;                 end interface
       interface export_primitives;      module procedure export_primitives_sim_config_params;      end interface
       interface import;                 module procedure import_sim_config_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_sim_config_params;end interface
       interface export_structured;      module procedure export_structured_D_sim_config_params;    end interface
       interface import_structured;      module procedure import_structured_D_sim_config_params;    end interface
       interface import_primitives;      module procedure import_primitives_sim_config_params;      end interface
       interface export;                 module procedure export_wrap_sim_config_params;            end interface
       interface import;                 module procedure import_wrap_sim_config_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_sim_config_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_sim_config_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_sim_config_params;      end interface

       type sim_config_params
         real(cp) :: export_safe_period = 0.0_cp
         logical :: embed_b_interior = .false.
         logical :: couple_time_steps = .false.
         logical :: finite_rem = .false.
         logical :: include_vacuum = .false.
         integer :: mpg_dir = 0
         integer :: uniform_b0_dir = 0
         integer :: uniform_gravity_dir = 0
       end type

       contains

       subroutine init_copy_sim_config_params(this,that)
         implicit none
         type(sim_config_params),intent(inout) :: this
         type(sim_config_params),intent(in) :: that
         call delete(this)
         this%export_safe_period = that%export_safe_period
         this%embed_b_interior = that%embed_b_interior
         this%couple_time_steps = that%couple_time_steps
         this%finite_rem = that%finite_rem
         this%include_vacuum = that%include_vacuum
         this%mpg_dir = that%mpg_dir
         this%uniform_b0_dir = that%uniform_b0_dir
         this%uniform_gravity_dir = that%uniform_gravity_dir
       end subroutine

       subroutine delete_sim_config_params(this)
         implicit none
         type(sim_config_params),intent(inout) :: this
         this%export_safe_period = 0.0_cp
         this%embed_b_interior = .false.
         this%couple_time_steps = .false.
         this%finite_rem = .false.
         this%include_vacuum = .false.
         this%mpg_dir = 0
         this%uniform_b0_dir = 0
         this%uniform_gravity_dir = 0
       end subroutine

       subroutine display_sim_config_params(this,un)
         implicit none
         type(sim_config_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_safe_period  = ',this%export_safe_period
         write(un,*) 'embed_b_interior    = ',this%embed_b_interior
         write(un,*) 'couple_time_steps   = ',this%couple_time_steps
         write(un,*) 'finite_rem          = ',this%finite_rem
         write(un,*) 'include_vacuum      = ',this%include_vacuum
         write(un,*) 'mpg_dir             = ',this%mpg_dir
         write(un,*) 'uniform_b0_dir      = ',this%uniform_b0_dir
         write(un,*) 'uniform_gravity_dir = ',this%uniform_gravity_dir
       end subroutine

       subroutine display_short_sim_config_params(this,un)
         implicit none
         type(sim_config_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_safe_period  = ',this%export_safe_period
         write(un,*) 'embed_b_interior    = ',this%embed_b_interior
         write(un,*) 'couple_time_steps   = ',this%couple_time_steps
         write(un,*) 'finite_rem          = ',this%finite_rem
         write(un,*) 'include_vacuum      = ',this%include_vacuum
         write(un,*) 'mpg_dir             = ',this%mpg_dir
         write(un,*) 'uniform_b0_dir      = ',this%uniform_b0_dir
         write(un,*) 'uniform_gravity_dir = ',this%uniform_gravity_dir
       end subroutine

       subroutine display_wrap_sim_config_params(this,dir,name)
         implicit none
         type(sim_config_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_sim_config_params(this)
         implicit none
         type(sim_config_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_sim_config_params(this)
         implicit none
         type(sim_config_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_sim_config_params(this,un)
         implicit none
         type(sim_config_params),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_sim_config_params(this,un)
         implicit none
         type(sim_config_params),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_sim_config_params(this,un)
         implicit none
         type(sim_config_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'export_safe_period   = ';write(un,*) this%export_safe_period
         write(un,*) 'embed_b_interior     = ';write(un,*) this%embed_b_interior
         write(un,*) 'couple_time_steps    = ';write(un,*) this%couple_time_steps
         write(un,*) 'finite_rem           = ';write(un,*) this%finite_rem
         write(un,*) 'include_vacuum       = ';write(un,*) this%include_vacuum
         write(un,*) 'mpg_dir              = ';write(un,*) this%mpg_dir
         write(un,*) 'uniform_b0_dir       = ';write(un,*) this%uniform_b0_dir
         write(un,*) 'uniform_gravity_dir  = ';write(un,*) this%uniform_gravity_dir
       end subroutine

       subroutine import_primitives_sim_config_params(this,un)
         implicit none
         type(sim_config_params),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%export_safe_period
         read(un,*); read(un,*) this%embed_b_interior
         read(un,*); read(un,*) this%couple_time_steps
         read(un,*); read(un,*) this%finite_rem
         read(un,*); read(un,*) this%include_vacuum
         read(un,*); read(un,*) this%mpg_dir
         read(un,*); read(un,*) this%uniform_b0_dir
         read(un,*); read(un,*) this%uniform_gravity_dir
       end subroutine

       subroutine export_wrap_sim_config_params(this,dir,name)
         implicit none
         type(sim_config_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_sim_config_params(this,dir,name)
         implicit none
         type(sim_config_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_sim_config_params(this,dir)
         implicit none
         type(sim_config_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_sim_config_params(this,dir)
         implicit none
         type(sim_config_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_sim_config_params(this,dir)
         implicit none
         type(sim_config_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_sim_config_params(this,dir)
         implicit none
         type(sim_config_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_sim_config_params(this,dir)
         implicit none
         type(sim_config_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_sim_config_params(this)
         implicit none
         type(sim_config_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module simple_int_tensor_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: simple_int_tensor
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_simple_int_tensor;              end interface
       interface delete;                 module procedure delete_simple_int_tensor;                 end interface
       interface display;                module procedure display_simple_int_tensor;                end interface
       interface display_short;          module procedure display_short_simple_int_tensor;          end interface
       interface display;                module procedure display_wrap_simple_int_tensor;           end interface
       interface print;                  module procedure print_simple_int_tensor;                  end interface
       interface print_short;            module procedure print_short_simple_int_tensor;            end interface
       interface export;                 module procedure export_simple_int_tensor;                 end interface
       interface export_primitives;      module procedure export_primitives_simple_int_tensor;      end interface
       interface import;                 module procedure import_simple_int_tensor;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_simple_int_tensor;end interface
       interface export_structured;      module procedure export_structured_D_simple_int_tensor;    end interface
       interface import_structured;      module procedure import_structured_D_simple_int_tensor;    end interface
       interface import_primitives;      module procedure import_primitives_simple_int_tensor;      end interface
       interface export;                 module procedure export_wrap_simple_int_tensor;            end interface
       interface import;                 module procedure import_wrap_simple_int_tensor;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_simple_int_tensor;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_simple_int_tensor;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_simple_int_tensor;      end interface

       type simple_int_tensor
         integer,dimension(3) :: eye = 0
       end type

       contains

       subroutine init_copy_simple_int_tensor(this,that)
         implicit none
         type(simple_int_tensor),intent(inout) :: this
         type(simple_int_tensor),intent(in) :: that
         call delete(this)
         this%eye = that%eye
       end subroutine

       subroutine delete_simple_int_tensor(this)
         implicit none
         type(simple_int_tensor),intent(inout) :: this
         this%eye = 0
       end subroutine

       subroutine display_simple_int_tensor(this,un)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'eye = ',this%eye
       end subroutine

       subroutine display_short_simple_int_tensor(this,un)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'eye = ',this%eye
       end subroutine

       subroutine display_wrap_simple_int_tensor(this,dir,name)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_simple_int_tensor(this)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_simple_int_tensor(this)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_simple_int_tensor(this,un)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_simple_int_tensor(this,un)
         implicit none
         type(simple_int_tensor),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_simple_int_tensor(this,un)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'eye  = ';write(un,*) this%eye
       end subroutine

       subroutine import_primitives_simple_int_tensor(this,un)
         implicit none
         type(simple_int_tensor),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%eye
       end subroutine

       subroutine export_wrap_simple_int_tensor(this,dir,name)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_simple_int_tensor(this,dir,name)
         implicit none
         type(simple_int_tensor),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_simple_int_tensor(this,dir)
         implicit none
         type(simple_int_tensor),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_simple_int_tensor(this,dir)
         implicit none
         type(simple_int_tensor),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_simple_int_tensor(this,dir)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_simple_int_tensor(this,dir)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_simple_int_tensor(this,dir)
         implicit none
         type(simple_int_tensor),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_simple_int_tensor(this)
         implicit none
         type(simple_int_tensor),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module solver_settings_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: solver_settings
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_solver_settings;              end interface
       interface delete;                 module procedure delete_solver_settings;                 end interface
       interface display;                module procedure display_solver_settings;                end interface
       interface display_short;          module procedure display_short_solver_settings;          end interface
       interface display;                module procedure display_wrap_solver_settings;           end interface
       interface print;                  module procedure print_solver_settings;                  end interface
       interface print_short;            module procedure print_short_solver_settings;            end interface
       interface export;                 module procedure export_solver_settings;                 end interface
       interface export_primitives;      module procedure export_primitives_solver_settings;      end interface
       interface import;                 module procedure import_solver_settings;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_solver_settings;end interface
       interface export_structured;      module procedure export_structured_D_solver_settings;    end interface
       interface import_structured;      module procedure import_structured_D_solver_settings;    end interface
       interface import_primitives;      module procedure import_primitives_solver_settings;      end interface
       interface export;                 module procedure export_wrap_solver_settings;            end interface
       interface import;                 module procedure import_wrap_solver_settings;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_solver_settings;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_solver_settings;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_solver_settings;      end interface

       type solver_settings
         integer :: solve_method = 0
         logical :: initialize = .false.
         logical :: solve = .false.
         logical :: restart = .false.
         logical :: prescribed_BCs = .false.
       end type

       contains

       subroutine init_copy_solver_settings(this,that)
         implicit none
         type(solver_settings),intent(inout) :: this
         type(solver_settings),intent(in) :: that
         call delete(this)
         this%solve_method = that%solve_method
         this%initialize = that%initialize
         this%solve = that%solve
         this%restart = that%restart
         this%prescribed_BCs = that%prescribed_BCs
       end subroutine

       subroutine delete_solver_settings(this)
         implicit none
         type(solver_settings),intent(inout) :: this
         this%solve_method = 0
         this%initialize = .false.
         this%solve = .false.
         this%restart = .false.
         this%prescribed_BCs = .false.
       end subroutine

       subroutine display_solver_settings(this,un)
         implicit none
         type(solver_settings),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'solve_method   = ',this%solve_method
         write(un,*) 'initialize     = ',this%initialize
         write(un,*) 'solve          = ',this%solve
         write(un,*) 'restart        = ',this%restart
         write(un,*) 'prescribed_BCs = ',this%prescribed_BCs
       end subroutine

       subroutine display_short_solver_settings(this,un)
         implicit none
         type(solver_settings),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'solve_method   = ',this%solve_method
         write(un,*) 'initialize     = ',this%initialize
         write(un,*) 'solve          = ',this%solve
         write(un,*) 'restart        = ',this%restart
         write(un,*) 'prescribed_BCs = ',this%prescribed_BCs
       end subroutine

       subroutine display_wrap_solver_settings(this,dir,name)
         implicit none
         type(solver_settings),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_solver_settings(this)
         implicit none
         type(solver_settings),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_solver_settings(this)
         implicit none
         type(solver_settings),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_solver_settings(this,un)
         implicit none
         type(solver_settings),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_solver_settings(this,un)
         implicit none
         type(solver_settings),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_solver_settings(this,un)
         implicit none
         type(solver_settings),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'solve_method    = ';write(un,*) this%solve_method
         write(un,*) 'initialize      = ';write(un,*) this%initialize
         write(un,*) 'solve           = ';write(un,*) this%solve
         write(un,*) 'restart         = ';write(un,*) this%restart
         write(un,*) 'prescribed_BCs  = ';write(un,*) this%prescribed_BCs
       end subroutine

       subroutine import_primitives_solver_settings(this,un)
         implicit none
         type(solver_settings),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%solve_method
         read(un,*); read(un,*) this%initialize
         read(un,*); read(un,*) this%solve
         read(un,*); read(un,*) this%restart
         read(un,*); read(un,*) this%prescribed_BCs
       end subroutine

       subroutine export_wrap_solver_settings(this,dir,name)
         implicit none
         type(solver_settings),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_solver_settings(this,dir,name)
         implicit none
         type(solver_settings),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_solver_settings(this,dir)
         implicit none
         type(solver_settings),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_solver_settings(this,dir)
         implicit none
         type(solver_settings),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_solver_settings(this,dir)
         implicit none
         type(solver_settings),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_solver_settings(this,dir)
         implicit none
         type(solver_settings),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_solver_settings(this,dir)
         implicit none
         type(solver_settings),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_solver_settings(this)
         implicit none
         type(solver_settings),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module stats_period_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: stats_period
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_stats_period;              end interface
       interface delete;                 module procedure delete_stats_period;                 end interface
       interface display;                module procedure display_stats_period;                end interface
       interface display_short;          module procedure display_short_stats_period;          end interface
       interface display;                module procedure display_wrap_stats_period;           end interface
       interface print;                  module procedure print_stats_period;                  end interface
       interface print_short;            module procedure print_short_stats_period;            end interface
       interface export;                 module procedure export_stats_period;                 end interface
       interface export_primitives;      module procedure export_primitives_stats_period;      end interface
       interface import;                 module procedure import_stats_period;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_stats_period;end interface
       interface export_structured;      module procedure export_structured_D_stats_period;    end interface
       interface import_structured;      module procedure import_structured_D_stats_period;    end interface
       interface import_primitives;      module procedure import_primitives_stats_period;      end interface
       interface export;                 module procedure export_wrap_stats_period;            end interface
       interface import;                 module procedure import_wrap_stats_period;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_stats_period;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_stats_period;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_stats_period;      end interface

       type stats_period
         real(cp) :: t_start = 0.0_cp
         real(cp) :: t_start_actual = 0.0_cp
         real(cp) :: t_stop = 0.0_cp
         real(cp) :: period = 0.0_cp
         integer :: N_stats_collected = 0
         logical :: compute_stats = .false.
         logical :: define_t_start_actual = .false.
         logical :: t_start_actual_defined = .false.
         logical :: export_stats = .false.
         logical :: exported_stats = .false.
       end type

       contains

       subroutine init_copy_stats_period(this,that)
         implicit none
         type(stats_period),intent(inout) :: this
         type(stats_period),intent(in) :: that
         call delete(this)
         this%t_start = that%t_start
         this%t_start_actual = that%t_start_actual
         this%t_stop = that%t_stop
         this%period = that%period
         this%N_stats_collected = that%N_stats_collected
         this%compute_stats = that%compute_stats
         this%define_t_start_actual = that%define_t_start_actual
         this%t_start_actual_defined = that%t_start_actual_defined
         this%export_stats = that%export_stats
         this%exported_stats = that%exported_stats
       end subroutine

       subroutine delete_stats_period(this)
         implicit none
         type(stats_period),intent(inout) :: this
         this%t_start = 0.0_cp
         this%t_start_actual = 0.0_cp
         this%t_stop = 0.0_cp
         this%period = 0.0_cp
         this%N_stats_collected = 0
         this%compute_stats = .false.
         this%define_t_start_actual = .false.
         this%t_start_actual_defined = .false.
         this%export_stats = .false.
         this%exported_stats = .false.
       end subroutine

       subroutine display_stats_period(this,un)
         implicit none
         type(stats_period),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 't_start                = ',this%t_start
         write(un,*) 't_start_actual         = ',this%t_start_actual
         write(un,*) 't_stop                 = ',this%t_stop
         write(un,*) 'period                 = ',this%period
         write(un,*) 'N_stats_collected      = ',this%N_stats_collected
         write(un,*) 'compute_stats          = ',this%compute_stats
         write(un,*) 'define_t_start_actual  = ',this%define_t_start_actual
         write(un,*) 't_start_actual_defined = ',this%t_start_actual_defined
         write(un,*) 'export_stats           = ',this%export_stats
         write(un,*) 'exported_stats         = ',this%exported_stats
       end subroutine

       subroutine display_short_stats_period(this,un)
         implicit none
         type(stats_period),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 't_start                = ',this%t_start
         write(un,*) 't_start_actual         = ',this%t_start_actual
         write(un,*) 't_stop                 = ',this%t_stop
         write(un,*) 'period                 = ',this%period
         write(un,*) 'N_stats_collected      = ',this%N_stats_collected
         write(un,*) 'compute_stats          = ',this%compute_stats
         write(un,*) 'define_t_start_actual  = ',this%define_t_start_actual
         write(un,*) 't_start_actual_defined = ',this%t_start_actual_defined
         write(un,*) 'export_stats           = ',this%export_stats
         write(un,*) 'exported_stats         = ',this%exported_stats
       end subroutine

       subroutine display_wrap_stats_period(this,dir,name)
         implicit none
         type(stats_period),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_stats_period(this)
         implicit none
         type(stats_period),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_stats_period(this)
         implicit none
         type(stats_period),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_stats_period(this,un)
         implicit none
         type(stats_period),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_stats_period(this,un)
         implicit none
         type(stats_period),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_stats_period(this,un)
         implicit none
         type(stats_period),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 't_start                 = ';write(un,*) this%t_start
         write(un,*) 't_start_actual          = ';write(un,*) this%t_start_actual
         write(un,*) 't_stop                  = ';write(un,*) this%t_stop
         write(un,*) 'period                  = ';write(un,*) this%period
         write(un,*) 'N_stats_collected       = ';write(un,*) this%N_stats_collected
         write(un,*) 'compute_stats           = ';write(un,*) this%compute_stats
         write(un,*) 'define_t_start_actual   = ';write(un,*) this%define_t_start_actual
         write(un,*) 't_start_actual_defined  = ';write(un,*) this%t_start_actual_defined
         write(un,*) 'export_stats            = ';write(un,*) this%export_stats
         write(un,*) 'exported_stats          = ';write(un,*) this%exported_stats
       end subroutine

       subroutine import_primitives_stats_period(this,un)
         implicit none
         type(stats_period),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%t_start
         read(un,*); read(un,*) this%t_start_actual
         read(un,*); read(un,*) this%t_stop
         read(un,*); read(un,*) this%period
         read(un,*); read(un,*) this%N_stats_collected
         read(un,*); read(un,*) this%compute_stats
         read(un,*); read(un,*) this%define_t_start_actual
         read(un,*); read(un,*) this%t_start_actual_defined
         read(un,*); read(un,*) this%export_stats
         read(un,*); read(un,*) this%exported_stats
       end subroutine

       subroutine export_wrap_stats_period(this,dir,name)
         implicit none
         type(stats_period),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_stats_period(this,dir,name)
         implicit none
         type(stats_period),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_stats_period(this,dir)
         implicit none
         type(stats_period),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_stats_period(this,dir)
         implicit none
         type(stats_period),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_stats_period(this,dir)
         implicit none
         type(stats_period),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_stats_period(this,dir)
         implicit none
         type(stats_period),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_stats_period(this,dir)
         implicit none
         type(stats_period),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_stats_period(this)
         implicit none
         type(stats_period),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module step_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: step
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_step;              end interface
       interface delete;                 module procedure delete_step;                 end interface
       interface display;                module procedure display_step;                end interface
       interface display_short;          module procedure display_short_step;          end interface
       interface display;                module procedure display_wrap_step;           end interface
       interface print;                  module procedure print_step;                  end interface
       interface print_short;            module procedure print_short_step;            end interface
       interface export;                 module procedure export_step;                 end interface
       interface export_primitives;      module procedure export_primitives_step;      end interface
       interface import;                 module procedure import_step;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_step;end interface
       interface export_structured;      module procedure export_structured_D_step;    end interface
       interface import_structured;      module procedure import_structured_D_step;    end interface
       interface import_primitives;      module procedure import_primitives_step;      end interface
       interface export;                 module procedure export_wrap_step;            end interface
       interface import;                 module procedure import_wrap_step;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_step;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_step;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_step;      end interface

       type step
         logical :: this = .false.
         logical :: next = .false.
       end type

       contains

       subroutine init_copy_step(this,that)
         implicit none
         type(step),intent(inout) :: this
         type(step),intent(in) :: that
         call delete(this)
         this%this = that%this
         this%next = that%next
       end subroutine

       subroutine delete_step(this)
         implicit none
         type(step),intent(inout) :: this
         this%this = .false.
         this%next = .false.
       end subroutine

       subroutine display_step(this,un)
         implicit none
         type(step),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'this = ',this%this
         write(un,*) 'next = ',this%next
       end subroutine

       subroutine display_short_step(this,un)
         implicit none
         type(step),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'this = ',this%this
         write(un,*) 'next = ',this%next
       end subroutine

       subroutine display_wrap_step(this,dir,name)
         implicit none
         type(step),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_step(this)
         implicit none
         type(step),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_step(this)
         implicit none
         type(step),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_step(this,un)
         implicit none
         type(step),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_step(this,un)
         implicit none
         type(step),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_step(this,un)
         implicit none
         type(step),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'this  = ';write(un,*) this%this
         write(un,*) 'next  = ';write(un,*) this%next
       end subroutine

       subroutine import_primitives_step(this,un)
         implicit none
         type(step),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%this
         read(un,*); read(un,*) this%next
       end subroutine

       subroutine export_wrap_step(this,dir,name)
         implicit none
         type(step),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_step(this,dir,name)
         implicit none
         type(step),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_step(this,dir)
         implicit none
         type(step),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_step(this,dir)
         implicit none
         type(step),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_step(this,dir)
         implicit none
         type(step),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_step(this,dir)
         implicit none
         type(step),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_step(this,dir)
         implicit none
         type(step),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_step(this)
         implicit none
         type(step),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module stitch_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: stitch
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_stitch;              end interface
       interface delete;                 module procedure delete_stitch;                 end interface
       interface display;                module procedure display_stitch;                end interface
       interface display_short;          module procedure display_short_stitch;          end interface
       interface display;                module procedure display_wrap_stitch;           end interface
       interface print;                  module procedure print_stitch;                  end interface
       interface print_short;            module procedure print_short_stitch;            end interface
       interface export;                 module procedure export_stitch;                 end interface
       interface export_primitives;      module procedure export_primitives_stitch;      end interface
       interface import;                 module procedure import_stitch;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_stitch;end interface
       interface export_structured;      module procedure export_structured_D_stitch;    end interface
       interface import_structured;      module procedure import_structured_D_stitch;    end interface
       interface import_primitives;      module procedure import_primitives_stitch;      end interface
       interface export;                 module procedure export_wrap_stitch;            end interface
       interface import;                 module procedure import_wrap_stitch;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_stitch;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_stitch;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_stitch;      end interface

       type stitch
         logical :: L = .false.
         integer :: ID = 0
       end type

       contains

       subroutine init_copy_stitch(this,that)
         implicit none
         type(stitch),intent(inout) :: this
         type(stitch),intent(in) :: that
         call delete(this)
         this%L = that%L
         this%ID = that%ID
       end subroutine

       subroutine delete_stitch(this)
         implicit none
         type(stitch),intent(inout) :: this
         this%L = .false.
         this%ID = 0
       end subroutine

       subroutine display_stitch(this,un)
         implicit none
         type(stitch),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'L  = ',this%L
         write(un,*) 'ID = ',this%ID
       end subroutine

       subroutine display_short_stitch(this,un)
         implicit none
         type(stitch),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'L  = ',this%L
         write(un,*) 'ID = ',this%ID
       end subroutine

       subroutine display_wrap_stitch(this,dir,name)
         implicit none
         type(stitch),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_stitch(this)
         implicit none
         type(stitch),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_stitch(this)
         implicit none
         type(stitch),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_stitch(this,un)
         implicit none
         type(stitch),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_stitch(this,un)
         implicit none
         type(stitch),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_stitch(this,un)
         implicit none
         type(stitch),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'L   = ';write(un,*) this%L
         write(un,*) 'ID  = ';write(un,*) this%ID
       end subroutine

       subroutine import_primitives_stitch(this,un)
         implicit none
         type(stitch),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%L
         read(un,*); read(un,*) this%ID
       end subroutine

       subroutine export_wrap_stitch(this,dir,name)
         implicit none
         type(stitch),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_stitch(this,dir,name)
         implicit none
         type(stitch),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_stitch(this,dir)
         implicit none
         type(stitch),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_stitch(this,dir)
         implicit none
         type(stitch),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_stitch(this,dir)
         implicit none
         type(stitch),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_stitch(this,dir)
         implicit none
         type(stitch),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_stitch(this,dir)
         implicit none
         type(stitch),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_stitch(this)
         implicit none
         type(stitch),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module stitch_face_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use dir_manip_mod
       implicit none

       private
       public :: stitch_face
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_stitch_face;              end interface
       interface delete;                 module procedure delete_stitch_face;                 end interface
       interface display;                module procedure display_stitch_face;                end interface
       interface display_short;          module procedure display_short_stitch_face;          end interface
       interface display;                module procedure display_wrap_stitch_face;           end interface
       interface print;                  module procedure print_stitch_face;                  end interface
       interface print_short;            module procedure print_short_stitch_face;            end interface
       interface export;                 module procedure export_stitch_face;                 end interface
       interface export_primitives;      module procedure export_primitives_stitch_face;      end interface
       interface import;                 module procedure import_stitch_face;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_stitch_face;end interface
       interface export_structured;      module procedure export_structured_D_stitch_face;    end interface
       interface import_structured;      module procedure import_structured_D_stitch_face;    end interface
       interface import_primitives;      module procedure import_primitives_stitch_face;      end interface
       interface export;                 module procedure export_wrap_stitch_face;            end interface
       interface import;                 module procedure import_wrap_stitch_face;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_stitch_face;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_stitch_face;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_stitch_face;      end interface

       type stitch_face
         logical,dimension(3) :: hmin = .false.
         logical,dimension(3) :: hmax = .false.
         integer,dimension(3) :: hmin_id = 0
         integer,dimension(3) :: hmax_id = 0
       end type

       contains

       subroutine init_copy_stitch_face(this,that)
         implicit none
         type(stitch_face),intent(inout) :: this
         type(stitch_face),intent(in) :: that
         call delete(this)
         this%hmin = that%hmin
         this%hmax = that%hmax
         this%hmin_id = that%hmin_id
         this%hmax_id = that%hmax_id
       end subroutine

       subroutine delete_stitch_face(this)
         implicit none
         type(stitch_face),intent(inout) :: this
         this%hmin = .false.
         this%hmax = .false.
         this%hmin_id = 0
         this%hmax_id = 0
       end subroutine

       subroutine display_stitch_face(this,un)
         implicit none
         type(stitch_face),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'hmin    = ',this%hmin
         write(un,*) 'hmax    = ',this%hmax
         write(un,*) 'hmin_id = ',this%hmin_id
         write(un,*) 'hmax_id = ',this%hmax_id
       end subroutine

       subroutine display_short_stitch_face(this,un)
         implicit none
         type(stitch_face),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'hmin    = ',this%hmin
         write(un,*) 'hmax    = ',this%hmax
         write(un,*) 'hmin_id = ',this%hmin_id
         write(un,*) 'hmax_id = ',this%hmax_id
       end subroutine

       subroutine display_wrap_stitch_face(this,dir,name)
         implicit none
         type(stitch_face),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_stitch_face(this)
         implicit none
         type(stitch_face),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_stitch_face(this)
         implicit none
         type(stitch_face),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_stitch_face(this,un)
         implicit none
         type(stitch_face),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_stitch_face(this,un)
         implicit none
         type(stitch_face),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_stitch_face(this,un)
         implicit none
         type(stitch_face),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'hmin     = ';write(un,*) this%hmin
         write(un,*) 'hmax     = ';write(un,*) this%hmax
         write(un,*) 'hmin_id  = ';write(un,*) this%hmin_id
         write(un,*) 'hmax_id  = ';write(un,*) this%hmax_id
       end subroutine

       subroutine import_primitives_stitch_face(this,un)
         implicit none
         type(stitch_face),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%hmin
         read(un,*); read(un,*) this%hmax
         read(un,*); read(un,*) this%hmin_id
         read(un,*); read(un,*) this%hmax_id
       end subroutine

       subroutine export_wrap_stitch_face(this,dir,name)
         implicit none
         type(stitch_face),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_stitch_face(this,dir,name)
         implicit none
         type(stitch_face),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_stitch_face(this,dir)
         implicit none
         type(stitch_face),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_stitch_face(this,dir)
         implicit none
         type(stitch_face),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_stitch_face(this,dir)
         implicit none
         type(stitch_face),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_stitch_face(this,dir)
         implicit none
         type(stitch_face),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_stitch_face(this,dir)
         implicit none
         type(stitch_face),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_stitch_face(this)
         implicit none
         type(stitch_face),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module time_step_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: time_step
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_time_step;              end interface
       interface delete;                 module procedure delete_time_step;                 end interface
       interface display;                module procedure display_time_step;                end interface
       interface display_short;          module procedure display_short_time_step;          end interface
       interface display;                module procedure display_wrap_time_step;           end interface
       interface print;                  module procedure print_time_step;                  end interface
       interface print_short;            module procedure print_short_time_step;            end interface
       interface export;                 module procedure export_time_step;                 end interface
       interface export_primitives;      module procedure export_primitives_time_step;      end interface
       interface import;                 module procedure import_time_step;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_time_step;end interface
       interface export_structured;      module procedure export_structured_D_time_step;    end interface
       interface import_structured;      module procedure import_structured_D_time_step;    end interface
       interface import_primitives;      module procedure import_primitives_time_step;      end interface
       interface export;                 module procedure export_wrap_time_step;            end interface
       interface import;                 module procedure import_wrap_time_step;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_time_step;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_time_step;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_time_step;      end interface
       interface export;                 module procedure export_DN_time_step;              end interface
       interface import;                 module procedure import_DN_time_step;              end interface
       interface export_structured;      module procedure export_structured_DN_time_step;   end interface
       interface import_structured;      module procedure import_structured_DN_time_step;   end interface

       type time_step
         real(cp) :: dt = 0.0_cp
         real(cp) :: t_final = 0.0_cp
         real(cp) :: t_start = 0.0_cp
         type(string) :: dir
         type(string) :: name
       end type

       contains

       subroutine init_copy_time_step(this,that)
         implicit none
         type(time_step),intent(inout) :: this
         type(time_step),intent(in) :: that
         call delete(this)
         this%dt = that%dt
         this%t_final = that%t_final
         this%t_start = that%t_start
         call init(this%dir,that%dir)
         call init(this%name,that%name)
       end subroutine

       subroutine delete_time_step(this)
         implicit none
         type(time_step),intent(inout) :: this
         this%dt = 0.0_cp
         this%t_final = 0.0_cp
         this%t_start = 0.0_cp
         call delete(this%dir)
         call delete(this%name)
       end subroutine

       subroutine display_time_step(this,un)
         implicit none
         type(time_step),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'dt      = ',this%dt
         write(un,*) 't_final = ',this%t_final
         write(un,*) 't_start = ',this%t_start
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_short_time_step(this,un)
         implicit none
         type(time_step),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'dt      = ',this%dt
         write(un,*) 't_final = ',this%t_final
         write(un,*) 't_start = ',this%t_start
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_wrap_time_step(this,dir,name)
         implicit none
         type(time_step),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_time_step(this)
         implicit none
         type(time_step),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_time_step(this)
         implicit none
         type(time_step),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_time_step(this,un)
         implicit none
         type(time_step),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_time_step(this,un)
         implicit none
         type(time_step),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_time_step(this,un)
         implicit none
         type(time_step),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'dt       = ';write(un,*) this%dt
         write(un,*) 't_final  = ';write(un,*) this%t_final
         write(un,*) 't_start  = ';write(un,*) this%t_start
       end subroutine

       subroutine import_primitives_time_step(this,un)
         implicit none
         type(time_step),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%dt
         read(un,*); read(un,*) this%t_final
         read(un,*); read(un,*) this%t_start
       end subroutine

       subroutine export_wrap_time_step(this,dir,name)
         implicit none
         type(time_step),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_time_step(this,dir,name)
         implicit none
         type(time_step),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_time_step(this)
         implicit none
         type(time_step),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_time_step(this)
         implicit none
         type(time_step),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_time_step(this)
         implicit none
         type(time_step),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_time_step(this)
         implicit none
         type(time_step),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_time_step(this,dir)
         implicit none
         type(time_step),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_time_step(this,dir)
         implicit none
         type(time_step),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_time_step(this,dir)
         implicit none
         type(time_step),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_time_step(this,dir)
         implicit none
         type(time_step),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_time_step(this,dir)
         implicit none
         type(time_step),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_time_step(this)
         implicit none
         type(time_step),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module unit_conversion_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: unit_conversion
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_unit_conversion;              end interface
       interface delete;                 module procedure delete_unit_conversion;                 end interface
       interface display;                module procedure display_unit_conversion;                end interface
       interface display_short;          module procedure display_short_unit_conversion;          end interface
       interface display;                module procedure display_wrap_unit_conversion;           end interface
       interface print;                  module procedure print_unit_conversion;                  end interface
       interface print_short;            module procedure print_short_unit_conversion;            end interface
       interface export;                 module procedure export_unit_conversion;                 end interface
       interface export_primitives;      module procedure export_primitives_unit_conversion;      end interface
       interface import;                 module procedure import_unit_conversion;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_unit_conversion;end interface
       interface export_structured;      module procedure export_structured_D_unit_conversion;    end interface
       interface import_structured;      module procedure import_structured_D_unit_conversion;    end interface
       interface import_primitives;      module procedure import_primitives_unit_conversion;      end interface
       interface export;                 module procedure export_wrap_unit_conversion;            end interface
       interface import;                 module procedure import_wrap_unit_conversion;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_unit_conversion;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_unit_conversion;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_unit_conversion;      end interface

       type unit_conversion
         real(cp) :: days_per_year = 0.0_cp
         real(cp) :: seconds_per_second = 0.0_cp
         real(cp) :: seconds_per_minute = 0.0_cp
         real(cp) :: seconds_per_hour = 0.0_cp
         real(cp) :: seconds_per_day = 0.0_cp
         real(cp) :: seconds_per_year = 0.0_cp
         real(cp) :: minute_per_seconds = 0.0_cp
         real(cp) :: hour_per_seconds = 0.0_cp
         real(cp) :: day_per_seconds = 0.0_cp
         real(cp) :: year_per_seconds = 0.0_cp
       end type

       contains

       subroutine init_copy_unit_conversion(this,that)
         implicit none
         type(unit_conversion),intent(inout) :: this
         type(unit_conversion),intent(in) :: that
         call delete(this)
         this%days_per_year = that%days_per_year
         this%seconds_per_second = that%seconds_per_second
         this%seconds_per_minute = that%seconds_per_minute
         this%seconds_per_hour = that%seconds_per_hour
         this%seconds_per_day = that%seconds_per_day
         this%seconds_per_year = that%seconds_per_year
         this%minute_per_seconds = that%minute_per_seconds
         this%hour_per_seconds = that%hour_per_seconds
         this%day_per_seconds = that%day_per_seconds
         this%year_per_seconds = that%year_per_seconds
       end subroutine

       subroutine delete_unit_conversion(this)
         implicit none
         type(unit_conversion),intent(inout) :: this
         this%days_per_year = 0.0_cp
         this%seconds_per_second = 0.0_cp
         this%seconds_per_minute = 0.0_cp
         this%seconds_per_hour = 0.0_cp
         this%seconds_per_day = 0.0_cp
         this%seconds_per_year = 0.0_cp
         this%minute_per_seconds = 0.0_cp
         this%hour_per_seconds = 0.0_cp
         this%day_per_seconds = 0.0_cp
         this%year_per_seconds = 0.0_cp
       end subroutine

       subroutine display_unit_conversion(this,un)
         implicit none
         type(unit_conversion),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'days_per_year      = ',this%days_per_year
         write(un,*) 'seconds_per_second = ',this%seconds_per_second
         write(un,*) 'seconds_per_minute = ',this%seconds_per_minute
         write(un,*) 'seconds_per_hour   = ',this%seconds_per_hour
         write(un,*) 'seconds_per_day    = ',this%seconds_per_day
         write(un,*) 'seconds_per_year   = ',this%seconds_per_year
         write(un,*) 'minute_per_seconds = ',this%minute_per_seconds
         write(un,*) 'hour_per_seconds   = ',this%hour_per_seconds
         write(un,*) 'day_per_seconds    = ',this%day_per_seconds
         write(un,*) 'year_per_seconds   = ',this%year_per_seconds
       end subroutine

       subroutine display_short_unit_conversion(this,un)
         implicit none
         type(unit_conversion),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'days_per_year      = ',this%days_per_year
         write(un,*) 'seconds_per_second = ',this%seconds_per_second
         write(un,*) 'seconds_per_minute = ',this%seconds_per_minute
         write(un,*) 'seconds_per_hour   = ',this%seconds_per_hour
         write(un,*) 'seconds_per_day    = ',this%seconds_per_day
         write(un,*) 'seconds_per_year   = ',this%seconds_per_year
         write(un,*) 'minute_per_seconds = ',this%minute_per_seconds
         write(un,*) 'hour_per_seconds   = ',this%hour_per_seconds
         write(un,*) 'day_per_seconds    = ',this%day_per_seconds
         write(un,*) 'year_per_seconds   = ',this%year_per_seconds
       end subroutine

       subroutine display_wrap_unit_conversion(this,dir,name)
         implicit none
         type(unit_conversion),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_unit_conversion(this)
         implicit none
         type(unit_conversion),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_unit_conversion(this)
         implicit none
         type(unit_conversion),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_unit_conversion(this,un)
         implicit none
         type(unit_conversion),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_unit_conversion(this,un)
         implicit none
         type(unit_conversion),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_unit_conversion(this,un)
         implicit none
         type(unit_conversion),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'days_per_year       = ';write(un,*) this%days_per_year
         write(un,*) 'seconds_per_second  = ';write(un,*) this%seconds_per_second
         write(un,*) 'seconds_per_minute  = ';write(un,*) this%seconds_per_minute
         write(un,*) 'seconds_per_hour    = ';write(un,*) this%seconds_per_hour
         write(un,*) 'seconds_per_day     = ';write(un,*) this%seconds_per_day
         write(un,*) 'seconds_per_year    = ';write(un,*) this%seconds_per_year
         write(un,*) 'minute_per_seconds  = ';write(un,*) this%minute_per_seconds
         write(un,*) 'hour_per_seconds    = ';write(un,*) this%hour_per_seconds
         write(un,*) 'day_per_seconds     = ';write(un,*) this%day_per_seconds
         write(un,*) 'year_per_seconds    = ';write(un,*) this%year_per_seconds
       end subroutine

       subroutine import_primitives_unit_conversion(this,un)
         implicit none
         type(unit_conversion),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%days_per_year
         read(un,*); read(un,*) this%seconds_per_second
         read(un,*); read(un,*) this%seconds_per_minute
         read(un,*); read(un,*) this%seconds_per_hour
         read(un,*); read(un,*) this%seconds_per_day
         read(un,*); read(un,*) this%seconds_per_year
         read(un,*); read(un,*) this%minute_per_seconds
         read(un,*); read(un,*) this%hour_per_seconds
         read(un,*); read(un,*) this%day_per_seconds
         read(un,*); read(un,*) this%year_per_seconds
       end subroutine

       subroutine export_wrap_unit_conversion(this,dir,name)
         implicit none
         type(unit_conversion),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_unit_conversion(this,dir,name)
         implicit none
         type(unit_conversion),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_unit_conversion(this,dir)
         implicit none
         type(unit_conversion),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_unit_conversion(this,dir)
         implicit none
         type(unit_conversion),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_unit_conversion(this,dir)
         implicit none
         type(unit_conversion),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_unit_conversion(this,dir)
         implicit none
         type(unit_conversion),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_unit_conversion(this,dir)
         implicit none
         type(unit_conversion),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_unit_conversion(this)
         implicit none
         type(unit_conversion),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module GF_embed_extract_mod
       ! Pre-processor directives: (_PARALLELIZE_EMBED_EXTRACT_)
       use overlap_mod
       use grid_field_mod
       implicit none
       private
       public :: EM
       public :: EX
       interface EM;  module procedure embed_GF;    end interface
       interface EX;  module procedure extract_GF;  end interface

       contains

       subroutine embed_extract_GF(A,B,A1,A2,B1,B2)
         implicit none
         type(grid_field),intent(inout) :: A
         type(grid_field),intent(in) :: B
         integer,dimension(3),intent(in) :: A1,A2,B1,B2
#ifdef _PARALLELIZE_EMBED_EXTRACT_
         integer :: i,j,k
         integer :: suppress_warning
         suppress_warning = B2(1) ! B2 is not needed for parallel computations
         !$OMP PARALLEL DO
         do k=A1(3),A2(3);do j=A1(2),A2(2);do i=A1(1),A2(1)
         A%f(i,j,k) = B%f(B1(1)+(i-A1(1)),B1(2)+(j-A1(2)),B1(3)+(k-A1(3)))
         enddo; enddo; enddo
         !$OMP END PARALLEL DO
#else
         A%f(A1(1):A2(1),A1(2):A2(2),A1(3):A2(3)) = &
         B%f(B1(1):B2(1),B1(2):B2(2),B1(3):B2(3))
#endif
       end subroutine

       subroutine embed_GF(A,B,AB)
         implicit none
         type(grid_field),intent(inout) :: A
         type(grid_field),intent(in) :: B
         type(overlap),dimension(3),intent(in) :: AB
         call embed_extract_GF(A,B,AB(1:3)%i2(1),&
                                   AB(1:3)%i2(2),&
                                   AB(1:3)%i1(1),&
                                   AB(1:3)%i1(2))
       end subroutine

       subroutine extract_GF(A,B,AB)
         implicit none
         type(grid_field),intent(inout) :: A
         type(grid_field),intent(in) :: B
         type(overlap),dimension(3),intent(in) :: AB
         call embed_extract_GF(A,B,AB(1:3)%i1(1),&
                                   AB(1:3)%i1(2),&
                                   AB(1:3)%i2(1),&
                                   AB(1:3)%i2(2))
       end subroutine

       end module
      module GF_square_mod
        use grid_field_mod
        use current_precision_mod
        implicit none
        private

        public :: square
        interface square;  module procedure square_GF;  end interface

        contains

        subroutine square_GF(a)
          implicit none
          type(grid_field),intent(inout) :: a
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = a%f(i,j,k) * a%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          a%f = a%f*a%f
#endif
        end subroutine

      end module
      module GF_square_root_mod
        use grid_field_mod
        use current_precision_mod
        implicit none
        private

        public :: square_root
        interface square_root;   module procedure square_root_GF;  end interface

        contains

        subroutine square_root_GF(a)
          implicit none
          type(grid_field),intent(inout) :: a
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = sqrt(a%f(i,j,k))
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          a%f = sqrt(a%f)
#endif
        end subroutine

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module RK_params_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use array_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: RK_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_RK_params;              end interface
       interface delete;                 module procedure delete_RK_params;                 end interface
       interface display;                module procedure display_RK_params;                end interface
       interface display_short;          module procedure display_short_RK_params;          end interface
       interface display;                module procedure display_wrap_RK_params;           end interface
       interface print;                  module procedure print_RK_params;                  end interface
       interface print_short;            module procedure print_short_RK_params;            end interface
       interface export;                 module procedure export_RK_params;                 end interface
       interface export_primitives;      module procedure export_primitives_RK_params;      end interface
       interface import;                 module procedure import_RK_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_RK_params;end interface
       interface export_structured;      module procedure export_structured_D_RK_params;    end interface
       interface import_structured;      module procedure import_structured_D_RK_params;    end interface
       interface import_primitives;      module procedure import_primitives_RK_params;      end interface
       interface export;                 module procedure export_wrap_RK_params;            end interface
       interface import;                 module procedure import_wrap_RK_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_RK_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_RK_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_RK_params;      end interface

       type RK_params
         integer :: n_stages = 0
         integer :: n = 0
         logical :: RK_active = .false.
         type(array) :: gamma
         type(array) :: zeta
         type(array) :: alpha
         type(array) :: beta
       end type

       contains

       subroutine init_copy_RK_params(this,that)
         implicit none
         type(RK_params),intent(inout) :: this
         type(RK_params),intent(in) :: that
         call delete(this)
         this%n_stages = that%n_stages
         this%n = that%n
         this%RK_active = that%RK_active
         call init(this%gamma,that%gamma)
         call init(this%zeta,that%zeta)
         call init(this%alpha,that%alpha)
         call init(this%beta,that%beta)
       end subroutine

       subroutine delete_RK_params(this)
         implicit none
         type(RK_params),intent(inout) :: this
         this%n_stages = 0
         this%n = 0
         this%RK_active = .false.
         call delete(this%gamma)
         call delete(this%zeta)
         call delete(this%alpha)
         call delete(this%beta)
       end subroutine

       subroutine display_RK_params(this,un)
         implicit none
         type(RK_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'n_stages  = ',this%n_stages
         write(un,*) 'n         = ',this%n
         write(un,*) 'RK_active = ',this%RK_active
         call display(this%gamma,un)
         call display(this%zeta,un)
         call display(this%alpha,un)
         call display(this%beta,un)
       end subroutine

       subroutine display_short_RK_params(this,un)
         implicit none
         type(RK_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'n_stages  = ',this%n_stages
         write(un,*) 'n         = ',this%n
         write(un,*) 'RK_active = ',this%RK_active
         call display(this%gamma,un)
         call display(this%zeta,un)
         call display(this%alpha,un)
         call display(this%beta,un)
       end subroutine

       subroutine display_wrap_RK_params(this,dir,name)
         implicit none
         type(RK_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_RK_params(this)
         implicit none
         type(RK_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_RK_params(this)
         implicit none
         type(RK_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_RK_params(this,un)
         implicit none
         type(RK_params),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%gamma,un)
         call export(this%zeta,un)
         call export(this%alpha,un)
         call export(this%beta,un)
       end subroutine

       subroutine import_RK_params(this,un)
         implicit none
         type(RK_params),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%gamma,un)
         call import(this%zeta,un)
         call import(this%alpha,un)
         call import(this%beta,un)
       end subroutine

       subroutine export_primitives_RK_params(this,un)
         implicit none
         type(RK_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'n_stages   = ';write(un,*) this%n_stages
         write(un,*) 'n          = ';write(un,*) this%n
         write(un,*) 'RK_active  = ';write(un,*) this%RK_active
       end subroutine

       subroutine import_primitives_RK_params(this,un)
         implicit none
         type(RK_params),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%n_stages
         read(un,*); read(un,*) this%n
         read(un,*); read(un,*) this%RK_active
       end subroutine

       subroutine export_wrap_RK_params(this,dir,name)
         implicit none
         type(RK_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_RK_params(this,dir,name)
         implicit none
         type(RK_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_RK_params(this,dir)
         implicit none
         type(RK_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%gamma,dir//'gamma'//fortran_PS)
         call set_IO_dir(this%zeta,dir//'zeta'//fortran_PS)
         call set_IO_dir(this%alpha,dir//'alpha'//fortran_PS)
         call set_IO_dir(this%beta,dir//'beta'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_RK_params(this,dir)
         implicit none
         type(RK_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%gamma,dir//'gamma'//fortran_PS)
         call make_IO_dir(this%zeta,dir//'zeta'//fortran_PS)
         call make_IO_dir(this%alpha,dir//'alpha'//fortran_PS)
         call make_IO_dir(this%beta,dir//'beta'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_RK_params(this,dir)
         implicit none
         type(RK_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%gamma,dir//'gamma'//fortran_PS)
         call export_structured(this%zeta,dir//'zeta'//fortran_PS)
         call export_structured(this%alpha,dir//'alpha'//fortran_PS)
         call export_structured(this%beta,dir//'beta'//fortran_PS)
       end subroutine

       subroutine export_structured_D_RK_params(this,dir)
         implicit none
         type(RK_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%gamma,dir//'gamma'//fortran_PS)
         call export_structured(this%zeta,dir//'zeta'//fortran_PS)
         call export_structured(this%alpha,dir//'alpha'//fortran_PS)
         call export_structured(this%beta,dir//'beta'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_RK_params(this,dir)
         implicit none
         type(RK_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%gamma,dir//'gamma'//fortran_PS)
         call import_structured(this%zeta,dir//'zeta'//fortran_PS)
         call import_structured(this%alpha,dir//'alpha'//fortran_PS)
         call import_structured(this%beta,dir//'beta'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_RK_params(this)
         implicit none
         type(RK_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module array_extend_mod
      use array_mod
      use current_precision_mod
      implicit none
      private
      public :: array
      public :: init

      public :: assign,add,multiply
      public :: insert
      public :: append,prepend
      public :: pop,snip

      public :: reverse

      public :: insist_allocated

      interface init;               module procedure init_array_size;            end interface
      interface init;               module procedure init_array_value;           end interface
      interface init;               module procedure init_array;                 end interface
      interface init;               module procedure init_array_defferred;       end interface

      interface assign;             module procedure assign_array;               end interface
      interface assign;             module procedure assign_array_cp;            end interface
      interface assign;             module procedure assign_array_element;       end interface
      interface add;                module procedure add_array_cp;               end interface
      interface add;                module procedure add_array;                  end interface
      interface add;                module procedure add_array_2;                end interface
      interface multiply;           module procedure multiply_array_cp;          end interface
      interface multiply;           module procedure multiply_array;             end interface
      interface multiply;           module procedure multiply_array_2;           end interface

      interface insert;             module procedure insert_element_array;       end interface
      interface append;             module procedure append_element_array;       end interface
      interface append;             module procedure append_A_A;                 end interface
      interface append;             module procedure append_A_cp;                end interface
      interface prepend;            module procedure prepend_A_A;                end interface
      interface prepend;            module procedure prepend_A_cp;               end interface
      interface pop;                module procedure pop_element_array;          end interface
      interface snip;               module procedure snip_element_array;         end interface

      interface reverse;            module procedure reverse_array;              end interface

      interface insist_allocated;   module procedure insist_allocated_array;     end interface
#ifdef _DEBUG_ARRAY_
      interface check_bounds;       module procedure check_bounds_array;         end interface
      interface insist_equal_sizes; module procedure insist_equal_sizes_array;   end interface
#endif

      contains

      ! ***************************************************************

      subroutine init_array_size(A,N)
        implicit none
        type(array),intent(inout) :: A
        integer,intent(in) :: N
#ifdef _DEBUG_ARRAY_
        if (N.lt.1) stop 'Error: array size must be > 0 in init_array in array.f90'
#endif
        call delete(A)
        A%N = N
        allocate(A%f(N))
      end subroutine

      subroutine init_array_value(A,v,i)
        implicit none
        type(array),intent(inout) :: A
        real(cp),intent(in) :: v
        integer,intent(in) :: i
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'init_array_value')
        call check_bounds(A,i,'init_array_value')
#endif
        A%f(i) = v
      end subroutine

      subroutine init_array(A,f,N)
        implicit none
        type(array),intent(inout) :: A
        integer,intent(in) :: N
        real(cp),dimension(N),intent(in) :: f
        call delete(A)
#ifdef _DEBUG_ARRAY_
        if (N.ne.size(f)) then
          write(*,*) 'Error: bad size input to init_array in array.f90'
          write(*,*) 'N = ',N
          write(*,*) 'size(f) = ',size(f)
          write(*,*) 'f = ',f
          stop 'Done'
        endif
#endif
        call init(A,N)
        A%f = f
      end subroutine

      subroutine init_array_defferred(A,f)
        implicit none
        type(array),intent(inout) :: A
        real(cp),dimension(:),intent(in) :: f
        call init(A,f,size(f))
      end subroutine

      ! ***************************************************************

      subroutine assign_array(A,B)
        implicit none
        type(array),intent(inout) :: A
        type(array),intent(in) :: B
#ifdef _DEBUG_ARRAY_
        call insist_allocated(B,'assign_array')
#endif
        if (.not.allocated(A%f)) call init(A,B%N)
        A%f = B%f
      end subroutine

      subroutine assign_array_cp(A,B)
        implicit none
        type(array),intent(inout) :: A
        real(cp),intent(in) :: B
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'assign_array_cp')
#endif
        A%f = B
      end subroutine
      subroutine assign_array_element(A,B,i)
        implicit none
        type(array),intent(inout) :: A
        real(cp),intent(in) :: B
        integer,intent(in) :: i
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'assign_array_element')
        call check_bounds_array(A,i,'assign_array_element')
#endif
        A%f(i) = B
      end subroutine

      subroutine add_array_cp(A,B)
        implicit none
        type(array),intent(inout) :: A
        real(cp),intent(in) :: B
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'add_array_cp (A)')
#endif
        A%f = A%f + B
      end subroutine
      subroutine add_array(A,B)
        implicit none
        type(array),intent(inout) :: A
        type(array),intent(in) :: B
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'add_array (A)')
        call insist_allocated(B,'add_array (B)')
        call insist_equal_sizes(A,B,'add_array')
#endif
        A%f = A%f + B%f
      end subroutine
      subroutine add_array_2(A,B,C)
        implicit none
        type(array),intent(inout) :: A
        type(array),intent(in) :: B,C
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'add_array_2 (A)')
        call insist_allocated(B,'add_array_2 (B)')
        call insist_allocated(C,'add_array_2 (C)')
        call insist_equal_sizes(A,B,'add_array_2 (A,B)')
        call insist_equal_sizes(A,C,'add_array_2 (A,C)')
#endif
        A%f = B%f + C%f
      end subroutine

      subroutine multiply_array_cp(A,B)
        implicit none
        type(array),intent(inout) :: A
        real(cp),intent(in) :: B
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'multiply_array_cp (A)')
#endif
        A%f = A%f*B
      end subroutine
      subroutine multiply_array(A,B)
        implicit none
        type(array),intent(inout) :: A
        type(array),intent(in) :: B
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'multiply_array (A)')
        call insist_allocated(B,'multiply_array (B)')
        call insist_equal_sizes(A,B,'multiply_array')
#endif
        A%f = A%f*B%f
      end subroutine
      subroutine multiply_array_2(A,B,C)
        implicit none
        type(array),intent(inout) :: A
        type(array),intent(in) :: B,C
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'multiply_array (A)')
        call insist_allocated(B,'multiply_array (B)')
        call insist_allocated(C,'multiply_array (C)')
        call insist_equal_sizes(A,B,'multiply_array (A,B)')
        call insist_equal_sizes(A,C,'multiply_array (A,C)')
#endif
        A%f = B%f*C%f
      end subroutine

      subroutine append_element_array(A,value)
        implicit none
        type(array),intent(inout) :: A
        real(cp),intent(in) :: value
        type(array) :: temp
        call init(temp,A)
        call init(A,(/temp%f,value/),temp%N+1)
        call delete(temp)
      end subroutine

      subroutine append_A_A(A,B)
        implicit none
        type(array),intent(inout) :: A
        type(array),intent(in) :: B
        type(array) :: temp
        call init(temp,A)
        call init(A,(/temp%f,B%f/),temp%N+B%N)
        call delete(temp)
      end subroutine

      subroutine prepend_A_A(A,B)
        implicit none
        type(array),intent(inout) :: A
        type(array),intent(in) :: B
        type(array) :: temp
        call init(temp,A)
        call init(A,(/B%f,temp%f/),temp%N+B%N)
        call delete(temp)
      end subroutine

      subroutine append_A_cp(A,B)
        implicit none
        type(array),intent(inout) :: A
        real(cp),dimension(:),intent(in) :: B
        type(array) :: temp
        call init(temp,A)
        call init(A,(/temp%f,B/),temp%N+size(B))
        call delete(temp)
      end subroutine

      subroutine prepend_A_cp(A,B)
        implicit none
        type(array),intent(inout) :: A
        real(cp),dimension(:),intent(in) :: B
        type(array) :: temp
        call init(temp,A)
        call init(A,(/B,temp%f/),temp%N+size(B))
        call delete(temp)
      end subroutine

      subroutine insert_element_array(A,value)
        implicit none
        type(array),intent(inout) :: A
        real(cp),intent(in) :: value
        type(array) :: temp
        call init(temp,A)
        call init(A,(/value,temp%f/),temp%N+1)
        call delete(temp)
      end subroutine

      subroutine pop_element_array(A)
        implicit none
        type(array),intent(inout) :: A
        type(array) :: temp
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'pop_element_array')
#endif
        if (A%N.eq.1) then
          call delete(A)
        else
          call init(temp,A)
          call init(A,(/temp%f(1:temp%N-1)/),temp%N-1)
          call delete(temp)
        endif
      end subroutine

      subroutine snip_element_array(A)
        implicit none
        type(array),intent(inout) :: A
        type(array) :: temp
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'snip_element_array')
#endif
        if (A%N.eq.1) then
          call delete(A)
        else
          call init(temp,A)
          call init(A,(/temp%f(2:temp%N)/),temp%N-1)
          call delete(temp)
        endif
      end subroutine

      subroutine reverse_array(A)
        implicit none
        type(array),intent(inout) :: A
#ifdef _DEBUG_ARRAY_
        call insist_allocated(A,'snip_element_array')
#endif
        A%f(1:A%N) = A%f(A%N:1:-1)
      end subroutine

      ! ***************************************************************
      ! *********************** DEBUG *********************************
      ! ***************************************************************

      subroutine insist_allocated_array(A,caller)
        implicit none
        type(array),intent(in) :: A
        character(len=*),intent(in) :: caller
        if (.not.allocated(A%f)) then
         write(*,*) 'Error: input array is not allocated in ',caller,' in array.f90'
         write(*,*) 'A%N = ',A%N
         stop 'Done'
        endif
      end subroutine

#ifdef _DEBUG_ARRAY_
      subroutine check_bounds_array(A,i,caller)
        implicit none
        type(array),intent(in) :: A
        integer,intent(in) :: i
        character(len=*),intent(in) :: caller
        logical,dimension(2) :: L
        L(1) = i.ge.1
        L(2) = i.le.A%N
        if (.not.all(L)) then
         write(*,*) 'Error: bounds error in ',caller,' in array.f90'
         stop 'Done'
        endif
      end subroutine

      subroutine insist_equal_sizes_array(A,B,caller)
        implicit none
        type(array),intent(in) :: A,B
        character(len=*),intent(in) :: caller
        call insist_allocated(A,'insist_equal_sizes_array in '//caller//' (A)')
        call insist_allocated(B,'insist_equal_sizes_array in '//caller//' (B)')
        if (A%N.ne.B%N) then
          write(*,*) 'Error: N mismatch in ',caller,' in array.f90'
          write(*,*) 'A%N = ',A%N
          write(*,*) 'B%N = ',B%N
          stop 'Done'
        endif
        if (size(A%f).ne.size(B%f)) then
          write(*,*) 'Error: size mismatch in ',caller,' in array.f90'
          write(*,*) 'A%N = ',size(A%f)
          write(*,*) 'B%N = ',size(B%f)
          stop 'Done'
        endif
      end subroutine
#endif

      end module
       module bctype_extend_mod
       use bctype_mod
       use current_precision_mod
       implicit none

       private
       public :: bctype
       public :: init,delete,display,print,export,import ! Essentials
       public :: display_info

       public :: init_Dirichlet,     is_Dirichlet
       public :: init_Neumann,       is_Neumann
       public :: init_Robin,         is_Robin
       public :: init_Periodic,      is_Periodic
       public :: init_symmetric,     is_symmetric
       public :: init_antisymmetric, is_antisymmetric
       public :: is_defined
       public :: is_prescribed
       public :: set_prescribed

       public :: get_mean_value
       public :: display_type,display_meanVal,get_bctype

       interface init;                module procedure init_val0;              end interface
       interface init;                module procedure init_val1;              end interface
       interface init;                module procedure init_val2;              end interface
       interface display_info;        module procedure display_info_bctype;    end interface

       interface init_Dirichlet;      module procedure init_Dirichlet_b;       end interface
       interface init_Neumann;        module procedure init_Neumann_b;         end interface
       interface init_Robin;          module procedure init_Robin_b;           end interface
       interface init_Periodic;       module procedure init_Periodic_b;        end interface
       interface init_symmetric;      module procedure init_symmetric_b;       end interface
       interface init_antisymmetric;  module procedure init_antisymmetric_b;   end interface

       interface is_Dirichlet;        module procedure get_Dirichlet_b;        end interface
       interface is_Neumann;          module procedure get_Neumann_b;          end interface
       interface is_Robin;            module procedure get_Robin_b;            end interface
       interface is_Periodic;         module procedure get_Periodic_b;         end interface
       interface is_symmetric;        module procedure get_symmetric_b;        end interface
       interface is_antisymmetric;    module procedure get_antisymmetric_b;    end interface

       interface display_type;        module procedure display_bctype_T_only;  end interface
       interface display_meanVal;     module procedure display_bctype_MV_only; end interface

       interface is_defined;          module procedure is_defined_BCT;         end interface
       interface is_prescribed;       module procedure is_prescribed_BCT;      end interface
       interface set_prescribed;      module procedure set_prescribed_BCT;     end interface
       interface get_mean_value;      module procedure get_mean_value_BCT;     end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_val0(b,val)
         implicit none
         type(bctype),intent(inout) :: b
         real(cp),intent(in) :: val
         b%meanVal = val
       end subroutine

       subroutine init_val1(b,val)
         implicit none
         type(bctype),intent(inout) :: b
         real(cp),dimension(:),intent(in) :: val
         b%meanVal = sum(val)/real(size(val),cp)
       end subroutine

       subroutine init_val2(b,val)
         implicit none
         type(bctype),intent(inout) :: b
         real(cp),dimension(:,:),intent(in) :: val
         b%meanVal = sum(val)/real(size(val),cp)
       end subroutine

       subroutine display_info_bctype(b,un)
         implicit none
         type(bctype),intent(in) :: b
         integer,intent(in) :: un
         logical :: L
         L = .false. ! show all regardless

         if (.not.b%defined) then
           write(un,*) 'defined = ',b%defined
           stop 'Error: trying to export bctype before defined in bctype.f90'
         endif
         if (L) then
           write(un,*) 'Dirichlet     = ',b%Dirichlet
           write(un,*) 'Neumann       = ',b%Neumann
           write(un,*) 'Robin         = ',b%Robin
           write(un,*) 'Periodic      = ',b%Periodic
           write(un,*) 'Symmetric     = ',b%symmetric
           write(un,*) 'Antisymmetric = ',b%antisymmetric
           write(un,*) 'prescribed    = ',b%prescribed
         else
           ! if (b%Dirichlet)     write(un,*) 'Dirichlet'
           ! if (b%Neumann)       write(un,*) 'Neumann'
           ! if (b%Periodic)      write(un,*) 'Periodic'
           ! if (b%symmetric)     write(un,*) 'Symmetric'
           ! if (b%antisymmetric) write(un,*) 'Antisymmetric'
           write(un,'(A,T1)',advance='no') get_bctype(b)
         endif

         write(un,'(F5.2)',advance='no') b%meanVal
         ! write(un,*) 'meanVal = ',b%meanVal
         ! write(un,*) 'defined = ',b%defined
       end subroutine

       subroutine init_Dirichlet_b(b)
         implicit none
         type(bctype),intent(inout) :: b
         call delete(b); b%defined = .true.; b%BCT = 'D'; b%Dirichlet = .true.
       end subroutine
       subroutine init_Neumann_b(b)
         implicit none
         type(bctype),intent(inout) :: b
         call delete(b); b%defined = .true.; b%BCT = 'N'; b%Neumann = .true.
       end subroutine
       subroutine init_Robin_b(b)
         implicit none
         type(bctype),intent(inout) :: b
         call delete(b); b%defined = .true.; b%BCT = 'R'; b%Robin = .true.
       end subroutine
       subroutine init_Periodic_b(b)
         implicit none
         type(bctype),intent(inout) :: b
         call delete(b); b%defined = .true.; b%BCT = 'P'; b%Periodic = .true.
       end subroutine
       subroutine init_symmetric_b(b)
         implicit none
         type(bctype),intent(inout) :: b
         call delete(b); b%defined = .true.; b%BCT = 'S'; b%symmetric = .true.
       end subroutine
       subroutine init_antisymmetric_b(b)
         implicit none
         type(bctype),intent(inout) :: b
         call delete(b); b%defined = .true.; b%BCT = 'A'; b%antisymmetric = .true.
       end subroutine

       function get_Dirichlet_b(b) result(L)
         implicit none
         type(bctype),intent(in) :: b
         logical :: L
         L = b%Dirichlet
       end function
       function get_Neumann_b(b) result(L)
         implicit none
         type(bctype),intent(in) :: b
         logical :: L
         L = b%Neumann
       end function
       function get_Robin_b(b) result(L)
         implicit none
         type(bctype),intent(in) :: b
         logical :: L
         L = b%Robin
       end function
       function get_Periodic_b(b) result(L)
         implicit none
         type(bctype),intent(in) :: b
         logical :: L
         L = b%Periodic
       end function
       function get_symmetric_b(b) result(L)
         implicit none
         type(bctype),intent(in) :: b
         logical :: L
         L = b%symmetric
       end function
       function get_antisymmetric_b(b) result(L)
         implicit none
         type(bctype),intent(in) :: b
         logical :: L
         L = b%antisymmetric
       end function

       function get_bctype(b) result(BCT)
         implicit none
         type(bctype),intent(in) :: b
         character(len=1) :: BCT
         BCT = 'X'
         ! BCT = b%BCT
         if (b%Dirichlet)     BCT = 'D'
         if (b%Neumann)       BCT = 'N'
         if (b%Robin)         BCT = 'R'
         if (b%Periodic)      BCT = 'P'
         if (b%symmetric)     BCT = 'S'
         if (b%antisymmetric) BCT = 'A'
       end function

       subroutine display_bctype_T_only(b,un)
         implicit none
         type(bctype),intent(in) :: b
         integer,intent(in) :: un
         if (.not.b%defined) stop 'Error: trying to export bctype (T only) before fully defined in bctype.f90'
         write(un,'(A,T1)',advance='no') get_bctype(b)
       end subroutine

       subroutine display_bctype_MV_only(b,un)
         implicit none
         type(bctype),intent(in) :: b
         integer,intent(in) :: un
         if (.not.b%defined) stop 'Error: trying to export bctype (MV only) before fully defined in bctype.f90'
         write(un,'(F19.10)',advance='no') b%meanVal
       end subroutine

       function get_mean_value_BCT(BCT) result(MV)
        implicit none
        type(bctype),intent(in) :: BCT
        real(cp) :: MV
        MV = BCT%meanVal
       end function

       function is_defined_BCT(BCT) result(L)
        implicit none
        type(bctype),intent(in) :: BCT
        logical :: L
        L = BCT%defined
       end function

       subroutine set_prescribed_BCT(BCT)
         implicit none
         type(bctype),intent(inout) :: BCT
         BCT%prescribed = .true.
       end subroutine

       function is_prescribed_BCT(BCT) result(L)
        implicit none
        type(bctype),intent(in) :: BCT
        logical :: L
        L = BCT%prescribed
       end function

       end module
       module clock_extend_mod
       use clock_mod
       use current_precision_mod
       implicit none

       private
       public :: init
       public :: tic,toc

       interface init;         module procedure init_clock;          end interface
       interface tic;          module procedure tic_clock;           end interface
       interface toc;          module procedure toc_clock;           end interface

       contains

       subroutine init_clock(c)
         implicit none
         type(clock),intent(inout) :: c
         call delete(c)
       end subroutine

       subroutine tic_clock(c)
         implicit none
         type(clock),intent(inout) :: c
         call system_clock(c%i_start,c%count_rate)
         c%t_start = real(c%i_start,cp)

         call cpu_time(c%t_start_computational)
       end subroutine

       subroutine toc_clock(c)
         implicit none
         type(clock),intent(inout) :: c
         call system_clock(c%i_stop,c%count_rate)
         c%t_stop = real(c%i_stop,cp)
         c%t_elapsed = (c%t_stop - c%t_start)/real(c%count_rate,cp)

         call cpu_time(c%t_stop_computational)
         c%t_elapsed_computational = (c%t_stop_computational - c%t_start_computational)
       end subroutine

       end module
       module data_location_extend_mod
       use data_location_mod
       ! Compiler flags: (_DEBUG_DATA_LOCATION_)
       use dir_manip_mod
       implicit none

       private
       public :: data_location
       public :: init,delete,display,print,export,import ! Essentials

       public :: init_CC,   is_CC,   is_CC_VF,   is_CC_TF
       public :: init_Node, is_Node, is_Node_VF, is_Node_TF
       public :: init_Face, is_Face, is_Face_VF, is_Face_TF
       public :: init_Edge, is_Edge, is_Edge_VF, is_Edge_TF
       public :: is_CC_Edge_TF

       public :: DL_CC
       public :: DL_Node
       public :: DL_Face
       public :: DL_Edge

       public :: get_Face
       public :: get_Edge

       public :: CC_along,N_along

       public :: insist_collocated
       public :: is_collocated_VF
       public :: is_collocated_TF

       public :: CC_eye
       public :: N_eye

       public :: vol_ID

       public :: get_char
       public :: defined
       public :: indentical

       interface init_CC;             module procedure init_CC_DL;              end interface
       interface init_Node;           module procedure init_Node_DL;            end interface
       interface init_Face;           module procedure init_Face_DL;            end interface
       interface init_Edge;           module procedure init_Edge_DL;            end interface

       interface indentical;          module procedure indentical_DL;           end interface

       interface DL_CC;               module procedure DL_CC_DL;                end interface
       interface DL_Node;             module procedure DL_Node_DL;              end interface
       interface DL_Face;             module procedure DL_Face_DL;              end interface
       interface DL_Edge;             module procedure DL_Edge_DL;              end interface

       interface is_CC;               module procedure is_CC_DL;                end interface
       interface is_Node;             module procedure is_Node_DL;              end interface
       interface is_Face;             module procedure is_Face_DL;              end interface
       interface is_Edge;             module procedure is_Edge_DL;              end interface

       interface is_CC_VF;            module procedure is_CC_VF_DL;             end interface
       interface is_Node_VF;          module procedure is_Node_VF_DL;           end interface
       interface is_Face_VF;          module procedure is_Face_VF_DL;           end interface
       interface is_Edge_VF;          module procedure is_Edge_VF_DL;           end interface

       interface is_CC_TF;            module procedure is_CC_TF_DL;             end interface
       interface is_Node_TF;          module procedure is_Node_TF_DL;           end interface
       interface is_Face_TF;          module procedure is_Face_TF_DL;           end interface
       interface is_Edge_TF;          module procedure is_Edge_TF_DL;           end interface
       interface is_CC_Edge_TF;       module procedure is_CC_Edge_TF_DL;        end interface

       interface get_Face;            module procedure get_Face_DL;             end interface
       interface get_Edge;            module procedure get_Edge_DL;             end interface

       interface CC_along;            module procedure CC_along_DL;             end interface
       interface N_along;             module procedure N_along_DL;              end interface

       interface vol_ID;              module procedure volume_ID_DL;            end interface

       interface CC_eye;              module procedure CC_eye_DL;               end interface
       interface N_eye;               module procedure N_eye_DL;                end interface

       interface get_char;            module procedure get_char_DL;             end interface
       interface defined;             module procedure defined_DL;              end interface
       interface insist_collocated;   module procedure insist_collocated_DL;    end interface
       interface is_collocated_VF;    module procedure is_collocated_VF_DL;     end interface
       interface is_collocated_TF;    module procedure is_collocated_TF_DL;     end interface

       interface print;               module procedure print_DL3;               end interface

       contains

       function indentical_DL(A,B) result(L_all)
         implicit none
         type(data_location),intent(in) :: A,B
         logical,dimension(12) :: L
         logical :: L_all
         L(1)  = A%C         .eqv. B%C
         L(2)  = A%N         .eqv. B%N
         L(3)  = A%E         .eqv. B%E
         L(4)  = A%F         .eqv. B%F
         L(5)  = A%face      .eq. B%face
         L(6)  = A%edge      .eq. B%edge
         L(7)  = A%defined   .eqv. B%defined
         L(8)  = all(A%CC_along  .eqv. B%CC_along)
         L(9)  = all(A%N_along   .eqv. B%N_along)
         L(10) = A%volume_ID .eq. B%volume_ID
         L(11) = all(A%CC_eye    .eq. B%CC_eye)
         L(12) = all(A%N_eye     .eq. B%N_eye)
         L_all = all(L)
       end function

       subroutine init_CC_DL(DL)
         implicit none
         type(data_location),intent(inout) :: DL
         call delete(DL)
         DL%C = .true.
         DL%defined = .true.
         DL%volume_ID = 1
         call init_CC_N_along(DL,'init_CC_DL')
         DL%N_eye = (/0,0,0/)
         DL%CC_eye = (/1,1,1/)
       end subroutine

       subroutine init_Node_DL(DL)
         implicit none
         type(data_location),intent(inout) :: DL
         call delete(DL)
         DL%N = .true.
         DL%defined = .true.
         DL%volume_ID = 2
         call init_CC_N_along(DL,'init_Node_DL')
         DL%N_eye = (/1,1,1/)
         DL%CC_eye = (/0,0,0/)
       end subroutine

       subroutine init_Face_DL(DL,dir)
         implicit none
         type(data_location),intent(inout) :: DL
         integer,intent(in) :: dir
         call delete(DL)
         DL%F = .true.
         call insist_valid_dir(DL,dir,'init_Face_DL')
         DL%face = dir
         DL%defined = .true.
         DL%volume_ID = 2+dir
         call init_CC_N_along(DL,'init_Face_DL')
         select case (dir)
         case (1); DL%N_eye = (/1,0,0/); DL%CC_eye = (/0,1,1/)
         case (2); DL%N_eye = (/0,1,0/); DL%CC_eye = (/1,0,1/)
         case (3); DL%N_eye = (/0,0,1/); DL%CC_eye = (/1,1,0/)
         end select
       end subroutine

       subroutine init_Edge_DL(DL,dir)
         implicit none
         type(data_location),intent(inout) :: DL
         integer,intent(in) :: dir
         call delete(DL)
         DL%E = .true.
         call insist_valid_dir(DL,dir,'init_Edge_DL')
         DL%edge = dir
         DL%defined = .true.
         DL%volume_ID = 5+dir
         call init_CC_N_along(DL,'init_Edge_DL')
         select case (dir)
         case (1); DL%N_eye = (/0,1,1/); DL%CC_eye = (/1,0,0/)
         case (2); DL%N_eye = (/1,0,1/); DL%CC_eye = (/0,1,0/)
         case (3); DL%N_eye = (/1,1,0/); DL%CC_eye = (/0,0,1/)
         end select
       end subroutine

       subroutine print_DL3(DL)
         implicit none
         type(data_location),dimension(3),intent(in) :: DL
         call display(DL(1),6)
         call display(DL(2),6)
         call display(DL(3),6)
       end subroutine

       function CC_eye_DL(DL) result(I)
         implicit none
         type(data_location),intent(in) :: DL
         integer,dimension(3) :: I
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'CC_eye_DL')
#endif
         I = DL%CC_eye
       end function

       function N_eye_DL(DL) result(I)
         implicit none
         type(data_location),intent(in) :: DL
         integer,dimension(3) :: I
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'N_eye_DL')
#endif
         I = DL%N_eye
       end function

       function volume_ID_DL(DL) result(volume_ID)
         implicit none
         type(data_location),intent(in) :: DL
         integer :: volume_ID
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'volume_ID_DL')
#endif
         volume_ID = DL%volume_ID
       end function

       function is_CC_DL(DL) result(L)
         implicit none
         type(data_location),intent(in) :: DL
         logical :: L
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'is_CC_DL')
#endif
         L = DL%C
       end function

       function is_Node_DL(DL) result(L)
         implicit none
         type(data_location),intent(in) :: DL
         logical :: L
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'is_Node_DL')
#endif
         L = DL%N
       end function

       function is_Edge_DL(DL) result(L)
         implicit none
         type(data_location),intent(in) :: DL
         logical :: L
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'is_Edge_DL')
#endif
         L = DL%E
       end function

       function is_Face_DL(DL) result(L)
         implicit none
         type(data_location),intent(in) :: DL
         logical :: L
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'is_Face_DL')
#endif
         L = DL%F
       end function

       function is_CC_VF_DL(DL) result(L_final)
         implicit none
         type(data_location),dimension(3),intent(in) :: DL
         logical,dimension(3) :: L
         logical :: L_final
         integer :: i
         do i=1,3; L(i) = is_CC(DL(i)); enddo
         L_final = all(L)
       end function

       function is_Node_VF_DL(DL) result(L_final)
         implicit none
         type(data_location),dimension(3),intent(in) :: DL
         logical,dimension(3) :: L
         logical :: L_final
         integer :: i
         do i=1,3; L(i) = is_Node(DL(i)); enddo
         L_final = all(L)
       end function

       function is_Edge_VF_DL(DL) result(L_final)
         implicit none
         type(data_location),dimension(3),intent(in) :: DL
         logical,dimension(3) :: L
         logical :: L_final
         integer :: i
         do i=1,3; L(i) = is_Edge(DL(i)).and.(get_Edge(DL(i)).eq.i); enddo
         L_final = all(L)
       end function

       function is_Face_VF_DL(DL) result(L_final)
         implicit none
         type(data_location),dimension(3),intent(in) :: DL
         logical,dimension(3) :: L
         logical :: L_final
         integer :: i
         do i=1,3; L(i) = is_Face(DL(i)).and.(get_Face(DL(i)).eq.i); enddo
         L_final = all(L)
       end function

       function is_CC_TF_DL(DL) result(L_final)
         implicit none
         type(data_location),dimension(9),intent(in) :: DL
         logical,dimension(9) :: L
         logical :: L_final
         integer :: i
         do i=1,9; L(i) = is_CC(DL(i)); enddo
         L_final = all(L)
       end function

       function is_Node_TF_DL(DL) result(L_final)
         implicit none
         type(data_location),dimension(9),intent(in) :: DL
         logical,dimension(9) :: L
         logical :: L_final
         integer :: i
         do i=1,9; L(i) = is_Node(DL(i)); enddo
         L_final = all(L)
       end function

       function is_Edge_TF_DL(DL) result(L_final)
         implicit none
         type(data_location),dimension(9),intent(in) :: DL
         logical,dimension(9) :: L
         logical :: L_final
         integer :: i
         do i=1,9; L(i) = is_Edge(DL(i)).and.(get_Edge(DL(i)).eq.i); enddo
         L_final = all(L)
       end function

       function is_Face_TF_DL(DL) result(L_final)
         implicit none
         type(data_location),dimension(9),intent(in) :: DL
         logical,dimension(9) :: L
         logical :: L_final
         integer :: i
         do i=1,9; L(i) = is_Face(DL(i)).and.(get_Face(DL(i)).eq.i); enddo
         L_final = all(L)
       end function

       function is_CC_Edge_TF_DL(DL) result(L_final)
         implicit none
         type(data_location),dimension(9),intent(in) :: DL
         logical,dimension(9) :: L
         logical :: L_final
         L(1) = is_CC(DL(1))
         L(2) = is_Face(DL(2)).and.(get_Face(DL(2)).eq.2)
         L(3) = is_Face(DL(3)).and.(get_Face(DL(3)).eq.3)

         L(4) = is_Face(DL(4)).and.(get_Face(DL(4)).eq.4)
         L(5) = is_CC(DL(5))
         L(6) = is_Face(DL(6)).and.(get_Face(DL(6)).eq.6)

         L(7) = is_Face(DL(7)).and.(get_Face(DL(7)).eq.7)
         L(8) = is_Face(DL(8)).and.(get_Face(DL(8)).eq.8)
         L(9) = is_CC(DL(9))
         L_final = all(L)
       end function

       function DL_CC_DL() result(DL)
         implicit none
         type(data_location) :: DL
         call init_CC(DL)
       end function

       function DL_Node_DL() result(DL)
         implicit none
         type(data_location) :: DL
         call init_Node(DL)
       end function

       function DL_Edge_DL(dir) result(DL)
         implicit none
         integer,intent(in) :: dir
         type(data_location) :: DL
         call init_Edge(DL,dir)
       end function

       function DL_Face_DL(dir) result(DL)
         implicit none
         integer,intent(in) :: dir
         type(data_location) :: DL
         call init_Face(DL,dir)
       end function

       function get_Face_DL(DL) result(dir)
         implicit none
         type(data_location),intent(in) :: DL
         integer :: dir
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'get_Face_DL')
#endif
         dir = DL%face
       end function

       function get_Edge_DL(DL) result(dir)
         implicit none
         type(data_location),intent(in) :: DL
         integer :: dir
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'get_Edge_DL')
#endif
         dir = DL%edge
       end function

       function CC_along_DL(DL,dir) result(L)
         implicit none
         type(data_location),intent(in) :: DL
         integer,intent(in) :: dir
         logical :: L
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'CC_along_DL')
         call insist_valid_dir(DL,dir,'CC_along_DL')
#endif
         L = DL%CC_along(dir)
       end function

       function N_along_DL(DL,dir) result(L)
         implicit none
         type(data_location),intent(in) :: DL
         integer,intent(in) :: dir
         logical :: L
#ifdef _DEBUG_DATA_LOCATION_
         call insist_defined(DL,'N_along_DL')
         call insist_valid_dir(DL,dir,'N_along_DL')
#endif
         L = DL%N_along(dir)
       end function

        subroutine init_CC_N_along(DL,caller)
          implicit none
          type(data_location),intent(inout) :: DL
          character(len=*),intent(in) :: caller
              if (DL%C) then; DL%CC_along = .true.
          elseif (DL%N) then; DL%CC_along = .false.
          elseif (DL%F) then; DL%CC_along = .not.diag_true(DL%face,caller)
          elseif (DL%E) then; DL%CC_along =      diag_true(DL%edge,caller)
          else
            write(*,*) 'Error: bad data type in '//caller//' in data_location.f90'
            stop 'Done'
          endif
          DL%N_along = .not.DL%CC_along
        end subroutine

        function diag_true(dir,caller) result(L)
          implicit none
          character(len=*),intent(in) :: caller
          integer,intent(in) :: dir
          logical,dimension(3) :: L
          select case(dir)
          case (1);L=(/.true.,.false.,.false./)
          case (2);L=(/.false.,.true.,.false./)
          case (3);L=(/.false.,.false.,.true./)
          case default
          write(*,*) 'Error: dir must = 1,2,3 in ',caller,' in data_location.f90'
          stop 'Done'
          end select
        end function

        function defined_DL(DL) result(defined)
          implicit none
          type(data_location),intent(in) :: DL
          logical :: defined
          defined = DL%defined
        end function

        subroutine insist_collocated_DL(DL,caller)
          implicit none
          type(data_location),dimension(3),intent(in) :: DL
          character(len=*),intent(in) :: caller
          if (.not.is_collocated_VF(DL)) then
            call print(DL(1))
            call print(DL(2))
            call print(DL(3))
            write(*,*) 'Error: DLs are not collocated in '//caller//' in data_location.f90'
            stop 'Done'
          endif
        end subroutine

        function is_collocated_VF_DL(DL) result(L_final)
          implicit none
          type(data_location),dimension(3),intent(in) :: DL
          integer :: i
          logical :: L_final
          logical,dimension(4) :: L
          L(1) = all((/(DL(i)%C,i=1,3)/))
          L(2) = all((/(DL(i)%N,i=1,3)/))
          L(3) = all((/(DL(i)%F.and.(DL(i)%face.eq.DL(1)%face),i=1,3)/))
          L(4) = all((/(DL(i)%E.and.(DL(i)%edge.eq.DL(1)%edge),i=1,3)/))
          L_final = any(L)
        end function

        function is_collocated_TF_DL(DL) result(L_final)
          implicit none
          type(data_location),dimension(9),intent(in) :: DL
          integer :: i
          logical :: L_final
          logical,dimension(4) :: L
          L(1) = all((/(DL(i)%C,i=1,9)/))
          L(2) = all((/(DL(i)%N,i=1,9)/))
          L(3) = all((/(DL(i)%F.and.(DL(i)%face.eq.DL(1)%face),i=1,9)/))
          L(4) = all((/(DL(i)%E.and.(DL(i)%edge.eq.DL(1)%edge),i=1,9)/))
          L_final = any(L)
        end function

        function get_char_DL(DL) result(c)
          implicit none
          type(data_location),intent(in) :: DL
          character(len=1) :: c
              if (DL%C) then; c = 'c'
          elseif (DL%N) then; c = 'n'
          elseif (DL%F) then; c = 'f'
          elseif (DL%E) then; c = 'e'
          else; stop 'Error: bad input type in get_char_DL in data_location.f90'
          endif
        end function

        subroutine insist_valid_dir(DL,dir,caller)
          implicit none
          type(data_location),intent(in) :: DL
          integer,intent(in) :: dir
          character(len=*),intent(in) :: caller
          if ((dir.ne.1).and.(dir.ne.2).and.(dir.ne.3)) then
            write(*,*) '-------------------------------------------------------------'
            call print(DL)
            write(*,*) 'Error: dir must = 1,2,3 in ',caller,' in data_location.f90'
            write(*,*) 'dir = ',dir
            write(*,*) '-------------------------------------------------------------'
            stop 'Done'
          endif
        end subroutine

#ifdef _DEBUG_DATA_LOCATION_
       subroutine insist_defined(DL,caller)
         implicit none
         type(data_location),intent(in) :: DL
         character(len=*),intent(in) :: caller
         if (.not.DL%defined) then
           call print(DL)
           write(*,*) 'Error: undefined DL in ',caller,' in data_location.f90'
           stop 'Done'
         endif
       end subroutine
#endif

       end module
       module dimensionless_params_extend_mod
       use current_precision_mod
       use dimensionless_params_mod
       implicit none
       private
       public :: init

       interface init;    module procedure init_dir_name;    end interface

       contains

       subroutine init_dir_name(DP,dir,name)
         implicit none
         type(dimensionless_params),intent(inout) :: DP
         character(len=*),intent(in) :: dir,name
         call init(DP%dir,dir)
         call init(DP%name,name)
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module dir_group_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use path_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: dir_group
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_dir_group;              end interface
       interface delete;                 module procedure delete_dir_group;                 end interface
       interface display;                module procedure display_dir_group;                end interface
       interface display_short;          module procedure display_short_dir_group;          end interface
       interface display;                module procedure display_wrap_dir_group;           end interface
       interface print;                  module procedure print_dir_group;                  end interface
       interface print_short;            module procedure print_short_dir_group;            end interface
       interface export;                 module procedure export_dir_group;                 end interface
       interface export_primitives;      module procedure export_primitives_dir_group;      end interface
       interface import;                 module procedure import_dir_group;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_dir_group;end interface
       interface export_structured;      module procedure export_structured_D_dir_group;    end interface
       interface import_structured;      module procedure import_structured_D_dir_group;    end interface
       interface import_primitives;      module procedure import_primitives_dir_group;      end interface
       interface export;                 module procedure export_wrap_dir_group;            end interface
       interface import;                 module procedure import_wrap_dir_group;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_dir_group;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_dir_group;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_dir_group;      end interface

       type dir_group
         type(path) :: base
         type(path) :: field
         type(path) :: debug
         type(path) :: energy
         type(path) :: local
         type(path) :: residual
         type(path) :: unsteady
         type(path) :: stats
         type(path) :: BCs
       end type

       contains

       subroutine init_copy_dir_group(this,that)
         implicit none
         type(dir_group),intent(inout) :: this
         type(dir_group),intent(in) :: that
         call delete(this)
         call init(this%base,that%base)
         call init(this%field,that%field)
         call init(this%debug,that%debug)
         call init(this%energy,that%energy)
         call init(this%local,that%local)
         call init(this%residual,that%residual)
         call init(this%unsteady,that%unsteady)
         call init(this%stats,that%stats)
         call init(this%BCs,that%BCs)
       end subroutine

       subroutine delete_dir_group(this)
         implicit none
         type(dir_group),intent(inout) :: this
         call delete(this%base)
         call delete(this%field)
         call delete(this%debug)
         call delete(this%energy)
         call delete(this%local)
         call delete(this%residual)
         call delete(this%unsteady)
         call delete(this%stats)
         call delete(this%BCs)
       end subroutine

       subroutine display_dir_group(this,un)
         implicit none
         type(dir_group),intent(in) :: this
         integer,intent(in) :: un
         call display(this%base,un)
         call display(this%field,un)
         call display(this%debug,un)
         call display(this%energy,un)
         call display(this%local,un)
         call display(this%residual,un)
         call display(this%unsteady,un)
         call display(this%stats,un)
         call display(this%BCs,un)
       end subroutine

       subroutine display_short_dir_group(this,un)
         implicit none
         type(dir_group),intent(in) :: this
         integer,intent(in) :: un
         call display(this%base,un)
         call display(this%field,un)
         call display(this%debug,un)
         call display(this%energy,un)
         call display(this%local,un)
         call display(this%residual,un)
         call display(this%unsteady,un)
         call display(this%stats,un)
         call display(this%BCs,un)
       end subroutine

       subroutine display_wrap_dir_group(this,dir,name)
         implicit none
         type(dir_group),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_dir_group(this)
         implicit none
         type(dir_group),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_dir_group(this)
         implicit none
         type(dir_group),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_dir_group(this,un)
         implicit none
         type(dir_group),intent(in) :: this
         integer,intent(in) :: un
         call export(this%base,un)
         call export(this%field,un)
         call export(this%debug,un)
         call export(this%energy,un)
         call export(this%local,un)
         call export(this%residual,un)
         call export(this%unsteady,un)
         call export(this%stats,un)
         call export(this%BCs,un)
       end subroutine

       subroutine import_dir_group(this,un)
         implicit none
         type(dir_group),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%base,un)
         call import(this%field,un)
         call import(this%debug,un)
         call import(this%energy,un)
         call import(this%local,un)
         call import(this%residual,un)
         call import(this%unsteady,un)
         call import(this%stats,un)
         call import(this%BCs,un)
       end subroutine

       subroutine export_primitives_dir_group(this,un)
         implicit none
         type(dir_group),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_dir_group(this,un)
         implicit none
         type(dir_group),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_dir_group(this,dir,name)
         implicit none
         type(dir_group),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_dir_group(this,dir,name)
         implicit none
         type(dir_group),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_dir_group(this,dir)
         implicit none
         type(dir_group),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%base,dir//'base'//fortran_PS)
         call set_IO_dir(this%field,dir//'field'//fortran_PS)
         call set_IO_dir(this%debug,dir//'debug'//fortran_PS)
         call set_IO_dir(this%energy,dir//'energy'//fortran_PS)
         call set_IO_dir(this%local,dir//'local'//fortran_PS)
         call set_IO_dir(this%residual,dir//'residual'//fortran_PS)
         call set_IO_dir(this%unsteady,dir//'unsteady'//fortran_PS)
         call set_IO_dir(this%stats,dir//'stats'//fortran_PS)
         call set_IO_dir(this%BCs,dir//'BCs'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_dir_group(this,dir)
         implicit none
         type(dir_group),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%base,dir//'base'//fortran_PS)
         call make_IO_dir(this%field,dir//'field'//fortran_PS)
         call make_IO_dir(this%debug,dir//'debug'//fortran_PS)
         call make_IO_dir(this%energy,dir//'energy'//fortran_PS)
         call make_IO_dir(this%local,dir//'local'//fortran_PS)
         call make_IO_dir(this%residual,dir//'residual'//fortran_PS)
         call make_IO_dir(this%unsteady,dir//'unsteady'//fortran_PS)
         call make_IO_dir(this%stats,dir//'stats'//fortran_PS)
         call make_IO_dir(this%BCs,dir//'BCs'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_dir_group(this,dir)
         implicit none
         type(dir_group),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%base,dir//'base'//fortran_PS)
         call export_structured(this%field,dir//'field'//fortran_PS)
         call export_structured(this%debug,dir//'debug'//fortran_PS)
         call export_structured(this%energy,dir//'energy'//fortran_PS)
         call export_structured(this%local,dir//'local'//fortran_PS)
         call export_structured(this%residual,dir//'residual'//fortran_PS)
         call export_structured(this%unsteady,dir//'unsteady'//fortran_PS)
         call export_structured(this%stats,dir//'stats'//fortran_PS)
         call export_structured(this%BCs,dir//'BCs'//fortran_PS)
       end subroutine

       subroutine export_structured_D_dir_group(this,dir)
         implicit none
         type(dir_group),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%base,dir//'base'//fortran_PS)
         call export_structured(this%field,dir//'field'//fortran_PS)
         call export_structured(this%debug,dir//'debug'//fortran_PS)
         call export_structured(this%energy,dir//'energy'//fortran_PS)
         call export_structured(this%local,dir//'local'//fortran_PS)
         call export_structured(this%residual,dir//'residual'//fortran_PS)
         call export_structured(this%unsteady,dir//'unsteady'//fortran_PS)
         call export_structured(this%stats,dir//'stats'//fortran_PS)
         call export_structured(this%BCs,dir//'BCs'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_dir_group(this,dir)
         implicit none
         type(dir_group),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%base,dir//'base'//fortran_PS)
         call import_structured(this%field,dir//'field'//fortran_PS)
         call import_structured(this%debug,dir//'debug'//fortran_PS)
         call import_structured(this%energy,dir//'energy'//fortran_PS)
         call import_structured(this%local,dir//'local'//fortran_PS)
         call import_structured(this%residual,dir//'residual'//fortran_PS)
         call import_structured(this%unsteady,dir//'unsteady'//fortran_PS)
         call import_structured(this%stats,dir//'stats'//fortran_PS)
         call import_structured(this%BCs,dir//'BCs'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_dir_group(this)
         implicit none
         type(dir_group),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module energy_terms_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use equation_term_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: energy_terms
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_energy_terms;              end interface
       interface delete;                 module procedure delete_energy_terms;                 end interface
       interface display;                module procedure display_energy_terms;                end interface
       interface display_short;          module procedure display_short_energy_terms;          end interface
       interface display;                module procedure display_wrap_energy_terms;           end interface
       interface print;                  module procedure print_energy_terms;                  end interface
       interface print_short;            module procedure print_short_energy_terms;            end interface
       interface export;                 module procedure export_energy_terms;                 end interface
       interface export_primitives;      module procedure export_primitives_energy_terms;      end interface
       interface import;                 module procedure import_energy_terms;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_energy_terms;end interface
       interface export_structured;      module procedure export_structured_D_energy_terms;    end interface
       interface import_structured;      module procedure import_structured_D_energy_terms;    end interface
       interface import_primitives;      module procedure import_primitives_energy_terms;      end interface
       interface export;                 module procedure export_wrap_energy_terms;            end interface
       interface import;                 module procedure import_wrap_energy_terms;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_energy_terms;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_energy_terms;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_energy_terms;      end interface

       type energy_terms
         type(equation_term) :: advection
         type(equation_term) :: diffusion
         type(equation_term) :: diffusion_linear
         type(equation_term) :: KE_diffusion
         type(equation_term) :: viscous_dissipation
         type(equation_term) :: joule_heating
         type(equation_term) :: volumetric_heating
       end type

       contains

       subroutine init_copy_energy_terms(this,that)
         implicit none
         type(energy_terms),intent(inout) :: this
         type(energy_terms),intent(in) :: that
         call delete(this)
         call init(this%advection,that%advection)
         call init(this%diffusion,that%diffusion)
         call init(this%diffusion_linear,that%diffusion_linear)
         call init(this%KE_diffusion,that%KE_diffusion)
         call init(this%viscous_dissipation,that%viscous_dissipation)
         call init(this%joule_heating,that%joule_heating)
         call init(this%volumetric_heating,that%volumetric_heating)
       end subroutine

       subroutine delete_energy_terms(this)
         implicit none
         type(energy_terms),intent(inout) :: this
         call delete(this%advection)
         call delete(this%diffusion)
         call delete(this%diffusion_linear)
         call delete(this%KE_diffusion)
         call delete(this%viscous_dissipation)
         call delete(this%joule_heating)
         call delete(this%volumetric_heating)
       end subroutine

       subroutine display_energy_terms(this,un)
         implicit none
         type(energy_terms),intent(in) :: this
         integer,intent(in) :: un
         call display(this%advection,un)
         call display(this%diffusion,un)
         call display(this%diffusion_linear,un)
         call display(this%KE_diffusion,un)
         call display(this%viscous_dissipation,un)
         call display(this%joule_heating,un)
         call display(this%volumetric_heating,un)
       end subroutine

       subroutine display_short_energy_terms(this,un)
         implicit none
         type(energy_terms),intent(in) :: this
         integer,intent(in) :: un
         call display(this%advection,un)
         call display(this%diffusion,un)
         call display(this%diffusion_linear,un)
         call display(this%KE_diffusion,un)
         call display(this%viscous_dissipation,un)
         call display(this%joule_heating,un)
         call display(this%volumetric_heating,un)
       end subroutine

       subroutine display_wrap_energy_terms(this,dir,name)
         implicit none
         type(energy_terms),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_energy_terms(this)
         implicit none
         type(energy_terms),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_energy_terms(this)
         implicit none
         type(energy_terms),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_energy_terms(this,un)
         implicit none
         type(energy_terms),intent(in) :: this
         integer,intent(in) :: un
         call export(this%advection,un)
         call export(this%diffusion,un)
         call export(this%diffusion_linear,un)
         call export(this%KE_diffusion,un)
         call export(this%viscous_dissipation,un)
         call export(this%joule_heating,un)
         call export(this%volumetric_heating,un)
       end subroutine

       subroutine import_energy_terms(this,un)
         implicit none
         type(energy_terms),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%advection,un)
         call import(this%diffusion,un)
         call import(this%diffusion_linear,un)
         call import(this%KE_diffusion,un)
         call import(this%viscous_dissipation,un)
         call import(this%joule_heating,un)
         call import(this%volumetric_heating,un)
       end subroutine

       subroutine export_primitives_energy_terms(this,un)
         implicit none
         type(energy_terms),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_energy_terms(this,un)
         implicit none
         type(energy_terms),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_energy_terms(this,dir,name)
         implicit none
         type(energy_terms),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_energy_terms(this,dir,name)
         implicit none
         type(energy_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_energy_terms(this,dir)
         implicit none
         type(energy_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%advection,dir//'advection'//fortran_PS)
         call set_IO_dir(this%diffusion,dir//'diffusion'//fortran_PS)
         call set_IO_dir(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call set_IO_dir(this%KE_diffusion,dir//'KE_diffusion'//fortran_PS)
         call set_IO_dir(this%viscous_dissipation,&
         dir//'viscous_dissipation'//fortran_PS)
         call set_IO_dir(this%joule_heating,&
         dir//'joule_heating'//fortran_PS)
         call set_IO_dir(this%volumetric_heating,&
         dir//'volumetric_heating'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_energy_terms(this,dir)
         implicit none
         type(energy_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%advection,dir//'advection'//fortran_PS)
         call make_IO_dir(this%diffusion,dir//'diffusion'//fortran_PS)
         call make_IO_dir(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call make_IO_dir(this%KE_diffusion,dir//'KE_diffusion'//fortran_PS)
         call make_IO_dir(this%viscous_dissipation,&
         dir//'viscous_dissipation'//fortran_PS)
         call make_IO_dir(this%joule_heating,&
         dir//'joule_heating'//fortran_PS)
         call make_IO_dir(this%volumetric_heating,&
         dir//'volumetric_heating'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_energy_terms(this,dir)
         implicit none
         type(energy_terms),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%advection,dir//'advection'//fortran_PS)
         call export_structured(this%diffusion,dir//'diffusion'//fortran_PS)
         call export_structured(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call export_structured(this%KE_diffusion,&
         dir//'KE_diffusion'//fortran_PS)
         call export_structured(this%viscous_dissipation,&
         dir//'viscous_dissipation'//fortran_PS)
         call export_structured(this%joule_heating,&
         dir//'joule_heating'//fortran_PS)
         call export_structured(this%volumetric_heating,&
         dir//'volumetric_heating'//fortran_PS)
       end subroutine

       subroutine export_structured_D_energy_terms(this,dir)
         implicit none
         type(energy_terms),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%advection,dir//'advection'//fortran_PS)
         call export_structured(this%diffusion,dir//'diffusion'//fortran_PS)
         call export_structured(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call export_structured(this%KE_diffusion,&
         dir//'KE_diffusion'//fortran_PS)
         call export_structured(this%viscous_dissipation,&
         dir//'viscous_dissipation'//fortran_PS)
         call export_structured(this%joule_heating,&
         dir//'joule_heating'//fortran_PS)
         call export_structured(this%volumetric_heating,&
         dir//'volumetric_heating'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_energy_terms(this,dir)
         implicit none
         type(energy_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%advection,dir//'advection'//fortran_PS)
         call import_structured(this%diffusion,dir//'diffusion'//fortran_PS)
         call import_structured(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call import_structured(this%KE_diffusion,&
         dir//'KE_diffusion'//fortran_PS)
         call import_structured(this%viscous_dissipation,&
         dir//'viscous_dissipation'//fortran_PS)
         call import_structured(this%joule_heating,&
         dir//'joule_heating'//fortran_PS)
         call import_structured(this%volumetric_heating,&
         dir//'volumetric_heating'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_energy_terms(this)
         implicit none
         type(energy_terms),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
     module equation_term_extend_mod
     use equation_term_mod
     use current_precision_mod
     use IO_tools_mod
     implicit none

     private
     public :: init

     interface init;    module procedure init_ET;           end interface

     contains

     subroutine init_ET(ET,add,scale)
       implicit none
       type(equation_term),intent(inout) :: ET
       logical,intent(in) :: add
       real(cp),intent(in) :: scale
       ET%add   = add
       if (add) ET%scale = scale
      end subroutine

     end module
       module export_field_extend_mod
       use export_field_mod
       implicit none

       private
       public :: init
       interface init;      module procedure init_EP;      end interface

       contains

       subroutine init_EP(EP,export_ever)
         implicit none
         type(export_field),intent(inout) :: EP
         logical,intent(in) :: export_ever
         EP%export_ever = export_ever
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module export_frequency_mod
       use datatype_conversion_mod
       use export_frequency_params_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: export_frequency
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_export_frequency;              end interface
       interface delete;                 module procedure delete_export_frequency;                 end interface
       interface display;                module procedure display_export_frequency;                end interface
       interface display_short;          module procedure display_short_export_frequency;          end interface
       interface display;                module procedure display_wrap_export_frequency;           end interface
       interface print;                  module procedure print_export_frequency;                  end interface
       interface print_short;            module procedure print_short_export_frequency;            end interface
       interface export;                 module procedure export_export_frequency;                 end interface
       interface export_primitives;      module procedure export_primitives_export_frequency;      end interface
       interface import;                 module procedure import_export_frequency;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_export_frequency;end interface
       interface export_structured;      module procedure export_structured_D_export_frequency;    end interface
       interface import_structured;      module procedure import_structured_D_export_frequency;    end interface
       interface import_primitives;      module procedure import_primitives_export_frequency;      end interface
       interface export;                 module procedure export_wrap_export_frequency;            end interface
       interface import;                 module procedure import_wrap_export_frequency;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_export_frequency;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_export_frequency;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_export_frequency;      end interface
       interface export;                 module procedure export_DN_export_frequency;              end interface
       interface import;                 module procedure import_DN_export_frequency;              end interface
       interface export_structured;      module procedure export_structured_DN_export_frequency;   end interface
       interface import_structured;      module procedure import_structured_DN_export_frequency;   end interface

       type export_frequency
         type(export_frequency_params) :: info
         type(export_frequency_params) :: unsteady_0D
         type(export_frequency_params) :: unsteady_1D
         type(export_frequency_params) :: unsteady_2D
         type(export_frequency_params) :: unsteady_3D
         type(export_frequency_params) :: final_solution
         type(export_frequency_params) :: restart_files
         type(string) :: dir
         type(string) :: name
       end type

       contains

       subroutine init_copy_export_frequency(this,that)
         implicit none
         type(export_frequency),intent(inout) :: this
         type(export_frequency),intent(in) :: that
         call delete(this)
         call init(this%info,that%info)
         call init(this%unsteady_0D,that%unsteady_0D)
         call init(this%unsteady_1D,that%unsteady_1D)
         call init(this%unsteady_2D,that%unsteady_2D)
         call init(this%unsteady_3D,that%unsteady_3D)
         call init(this%final_solution,that%final_solution)
         call init(this%restart_files,that%restart_files)
         call init(this%dir,that%dir)
         call init(this%name,that%name)
       end subroutine

       subroutine delete_export_frequency(this)
         implicit none
         type(export_frequency),intent(inout) :: this
         call delete(this%info)
         call delete(this%unsteady_0D)
         call delete(this%unsteady_1D)
         call delete(this%unsteady_2D)
         call delete(this%unsteady_3D)
         call delete(this%final_solution)
         call delete(this%restart_files)
         call delete(this%dir)
         call delete(this%name)
       end subroutine

       subroutine display_export_frequency(this,un)
         implicit none
         type(export_frequency),intent(in) :: this
         integer,intent(in) :: un
         call display(this%info,un)
         call display(this%unsteady_0D,un)
         call display(this%unsteady_1D,un)
         call display(this%unsteady_2D,un)
         call display(this%unsteady_3D,un)
         call display(this%final_solution,un)
         call display(this%restart_files,un)
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_short_export_frequency(this,un)
         implicit none
         type(export_frequency),intent(in) :: this
         integer,intent(in) :: un
         call display(this%info,un)
         call display(this%unsteady_0D,un)
         call display(this%unsteady_1D,un)
         call display(this%unsteady_2D,un)
         call display(this%unsteady_3D,un)
         call display(this%final_solution,un)
         call display(this%restart_files,un)
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_wrap_export_frequency(this,dir,name)
         implicit none
         type(export_frequency),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_export_frequency(this)
         implicit none
         type(export_frequency),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_export_frequency(this)
         implicit none
         type(export_frequency),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_export_frequency(this,un)
         implicit none
         type(export_frequency),intent(in) :: this
         integer,intent(in) :: un
         call export(this%info,un)
         call export(this%unsteady_0D,un)
         call export(this%unsteady_1D,un)
         call export(this%unsteady_2D,un)
         call export(this%unsteady_3D,un)
         call export(this%final_solution,un)
         call export(this%restart_files,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_export_frequency(this,un)
         implicit none
         type(export_frequency),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%info,un)
         call import(this%unsteady_0D,un)
         call import(this%unsteady_1D,un)
         call import(this%unsteady_2D,un)
         call import(this%unsteady_3D,un)
         call import(this%final_solution,un)
         call import(this%restart_files,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_export_frequency(this,un)
         implicit none
         type(export_frequency),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_export_frequency(this,un)
         implicit none
         type(export_frequency),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_export_frequency(this,dir,name)
         implicit none
         type(export_frequency),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_export_frequency(this,dir,name)
         implicit none
         type(export_frequency),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_export_frequency(this)
         implicit none
         type(export_frequency),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_export_frequency(this)
         implicit none
         type(export_frequency),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_export_frequency(this)
         implicit none
         type(export_frequency),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%info,str(this%dir)//'info'//fortran_PS)
         call export_structured(this%unsteady_0D,&
         str(this%dir)//'unsteady_0D'//fortran_PS)
         call export_structured(this%unsteady_1D,&
         str(this%dir)//'unsteady_1D'//fortran_PS)
         call export_structured(this%unsteady_2D,&
         str(this%dir)//'unsteady_2D'//fortran_PS)
         call export_structured(this%unsteady_3D,&
         str(this%dir)//'unsteady_3D'//fortran_PS)
         call export_structured(this%final_solution,&
         str(this%dir)//'final_solution'//fortran_PS)
         call export_structured(this%restart_files,&
         str(this%dir)//'restart_files'//fortran_PS)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_export_frequency(this)
         implicit none
         type(export_frequency),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%info,str(this%dir)//'info'//fortran_PS)
         call import_structured(this%unsteady_0D,&
         str(this%dir)//'unsteady_0D'//fortran_PS)
         call import_structured(this%unsteady_1D,&
         str(this%dir)//'unsteady_1D'//fortran_PS)
         call import_structured(this%unsteady_2D,&
         str(this%dir)//'unsteady_2D'//fortran_PS)
         call import_structured(this%unsteady_3D,&
         str(this%dir)//'unsteady_3D'//fortran_PS)
         call import_structured(this%final_solution,&
         str(this%dir)//'final_solution'//fortran_PS)
         call import_structured(this%restart_files,&
         str(this%dir)//'restart_files'//fortran_PS)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_export_frequency(this,dir)
         implicit none
         type(export_frequency),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%info,dir//'info'//fortran_PS)
         call set_IO_dir(this%unsteady_0D,dir//'unsteady_0D'//fortran_PS)
         call set_IO_dir(this%unsteady_1D,dir//'unsteady_1D'//fortran_PS)
         call set_IO_dir(this%unsteady_2D,dir//'unsteady_2D'//fortran_PS)
         call set_IO_dir(this%unsteady_3D,dir//'unsteady_3D'//fortran_PS)
         call set_IO_dir(this%final_solution,&
         dir//'final_solution'//fortran_PS)
         call set_IO_dir(this%restart_files,&
         dir//'restart_files'//fortran_PS)
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_export_frequency(this,dir)
         implicit none
         type(export_frequency),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%info,dir//'info'//fortran_PS)
         call make_IO_dir(this%unsteady_0D,dir//'unsteady_0D'//fortran_PS)
         call make_IO_dir(this%unsteady_1D,dir//'unsteady_1D'//fortran_PS)
         call make_IO_dir(this%unsteady_2D,dir//'unsteady_2D'//fortran_PS)
         call make_IO_dir(this%unsteady_3D,dir//'unsteady_3D'//fortran_PS)
         call make_IO_dir(this%final_solution,&
         dir//'final_solution'//fortran_PS)
         call make_IO_dir(this%restart_files,&
         dir//'restart_files'//fortran_PS)
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_export_frequency(this,dir)
         implicit none
         type(export_frequency),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%info,dir//'info'//fortran_PS)
         call export_structured(this%unsteady_0D,&
         dir//'unsteady_0D'//fortran_PS)
         call export_structured(this%unsteady_1D,&
         dir//'unsteady_1D'//fortran_PS)
         call export_structured(this%unsteady_2D,&
         dir//'unsteady_2D'//fortran_PS)
         call export_structured(this%unsteady_3D,&
         dir//'unsteady_3D'//fortran_PS)
         call export_structured(this%final_solution,&
         dir//'final_solution'//fortran_PS)
         call export_structured(this%restart_files,&
         dir//'restart_files'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_export_frequency(this,dir)
         implicit none
         type(export_frequency),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%info,dir//'info'//fortran_PS)
         call export_structured(this%unsteady_0D,&
         dir//'unsteady_0D'//fortran_PS)
         call export_structured(this%unsteady_1D,&
         dir//'unsteady_1D'//fortran_PS)
         call export_structured(this%unsteady_2D,&
         dir//'unsteady_2D'//fortran_PS)
         call export_structured(this%unsteady_3D,&
         dir//'unsteady_3D'//fortran_PS)
         call export_structured(this%final_solution,&
         dir//'final_solution'//fortran_PS)
         call export_structured(this%restart_files,&
         dir//'restart_files'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_export_frequency(this,dir)
         implicit none
         type(export_frequency),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%info,dir//'info'//fortran_PS)
         call import_structured(this%unsteady_0D,&
         dir//'unsteady_0D'//fortran_PS)
         call import_structured(this%unsteady_1D,&
         dir//'unsteady_1D'//fortran_PS)
         call import_structured(this%unsteady_2D,&
         dir//'unsteady_2D'//fortran_PS)
         call import_structured(this%unsteady_3D,&
         dir//'unsteady_3D'//fortran_PS)
         call import_structured(this%final_solution,&
         dir//'final_solution'//fortran_PS)
         call import_structured(this%restart_files,&
         dir//'restart_files'//fortran_PS)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_export_frequency(this)
         implicit none
         type(export_frequency),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module export_line_extend_mod
       use export_line_mod
       implicit none

       private
       public :: init

       interface init;      module procedure init_EL;      end interface

       contains

       subroutine init_EL(EL,export_ever,dir,line,suffix)
         implicit none
         type(export_line),intent(inout) :: EL
         logical,intent(in) :: export_ever
         integer,intent(in) :: dir
         integer,dimension(2),intent(in) :: line
         character(len=1),intent(in) :: suffix
         EL%export_ever = export_ever
         EL%dir         = dir
         EL%line        = line
         EL%suffix      = suffix
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module export_lines_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use export_line_mod
       use dir_manip_mod
       implicit none

       private
       public :: export_lines
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_export_lines;              end interface
       interface delete;                 module procedure delete_export_lines;                 end interface
       interface display;                module procedure display_export_lines;                end interface
       interface display_short;          module procedure display_short_export_lines;          end interface
       interface display;                module procedure display_wrap_export_lines;           end interface
       interface print;                  module procedure print_export_lines;                  end interface
       interface print_short;            module procedure print_short_export_lines;            end interface
       interface export;                 module procedure export_export_lines;                 end interface
       interface export_primitives;      module procedure export_primitives_export_lines;      end interface
       interface import;                 module procedure import_export_lines;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_export_lines;end interface
       interface export_structured;      module procedure export_structured_D_export_lines;    end interface
       interface import_structured;      module procedure import_structured_D_export_lines;    end interface
       interface import_primitives;      module procedure import_primitives_export_lines;      end interface
       interface export;                 module procedure export_wrap_export_lines;            end interface
       interface import;                 module procedure import_wrap_export_lines;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_export_lines;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_export_lines;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_export_lines;      end interface

       type export_lines
         type(export_line),dimension(:),allocatable :: EL
         integer :: N = 0
       end type

       contains

       subroutine init_copy_export_lines(this,that)
         implicit none
         type(export_lines),intent(inout) :: this
         type(export_lines),intent(in) :: that
         integer :: i_EL
         integer :: s_EL
         call delete(this)
         if (allocated(that%EL)) then
           s_EL = size(that%EL)
           if (s_EL.gt.0) then
             allocate(this%EL(s_EL))
             do i_EL=1,s_EL
               call init(this%EL(i_EL),that%EL(i_EL))
             enddo
           endif
         endif
         this%N = that%N
       end subroutine

       subroutine delete_export_lines(this)
         implicit none
         type(export_lines),intent(inout) :: this
         integer :: i_EL
         integer :: s_EL
         if (allocated(this%EL)) then
           s_EL = size(this%EL)
           do i_EL=1,s_EL
             call delete(this%EL(i_EL))
           enddo
           deallocate(this%EL)
         endif
         this%N = 0
       end subroutine

       subroutine display_export_lines(this,un)
         implicit none
         type(export_lines),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_EL
         integer :: s_EL
         if (allocated(this%EL)) then
           s_EL = size(this%EL)
           do i_EL=1,s_EL
             call display(this%EL(i_EL),un)
           enddo
         endif
         write(un,*) 'N  = ',this%N
       end subroutine

       subroutine display_short_export_lines(this,un)
         implicit none
         type(export_lines),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_EL
         integer :: s_EL
         if (allocated(this%EL)) then
           s_EL = size(this%EL)
           do i_EL=1,s_EL
             call display(this%EL(i_EL),un)
           enddo
         endif
         write(un,*) 'N  = ',this%N
       end subroutine

       subroutine display_wrap_export_lines(this,dir,name)
         implicit none
         type(export_lines),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_export_lines(this)
         implicit none
         type(export_lines),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_export_lines(this)
         implicit none
         type(export_lines),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_export_lines(this,un)
         implicit none
         type(export_lines),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_EL
         integer :: s_EL
         call export_primitives(this,un)
         if (allocated(this%EL)) then
           s_EL = size(this%EL)
           write(un,*) s_EL
           if (s_EL.gt.0) then
             do i_EL=1,s_EL
               call export(this%EL(i_EL),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
       end subroutine

       subroutine import_export_lines(this,un)
         implicit none
         type(export_lines),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_EL
         integer :: s_EL
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_EL
         if (s_EL.gt.0) then
           allocate(this%EL(s_EL))
           do i_EL=1,s_EL
             call import(this%EL(i_EL),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_export_lines(this,un)
         implicit none
         type(export_lines),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'N   = ';write(un,*) this%N
       end subroutine

       subroutine import_primitives_export_lines(this,un)
         implicit none
         type(export_lines),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%N
       end subroutine

       subroutine export_wrap_export_lines(this,dir,name)
         implicit none
         type(export_lines),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_export_lines(this,dir,name)
         implicit none
         type(export_lines),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_export_lines(this,dir)
         implicit none
         type(export_lines),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_EL
         integer :: s_EL
         call suppress_warnings(this)
         if (allocated(this%EL)) then
           s_EL = size(this%EL)
           do i_EL=1,s_EL
             call set_IO_dir(this%EL(i_EL),&
             dir//'EL_'//int2str(i_EL)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine make_IO_dir_export_lines(this,dir)
         implicit none
         type(export_lines),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_EL
         integer :: s_EL
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         if (allocated(this%EL)) then
           s_EL = size(this%EL)
           do i_EL=1,s_EL
             call make_IO_dir(this%EL(i_EL),&
             dir//'EL_'//int2str(i_EL)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine export_folder_structure_export_lines(this,dir)
         implicit none
         type(export_lines),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_EL
         integer :: s_EL
         integer :: un
         if (allocated(this%EL)) then
           s_EL = size(this%EL)
           write(un,*) s_EL
           do i_EL=1,s_EL
             call export_structured(this%EL(i_EL),&
             dir//'EL_'//int2str(i_EL)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
       end subroutine

       subroutine export_structured_D_export_lines(this,dir)
         implicit none
         type(export_lines),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_EL
         integer :: s_EL
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         if (allocated(this%EL)) then
           s_EL = size(this%EL)
           write(un,*) s_EL
           do i_EL=1,s_EL
             call export_structured(this%EL(i_EL),&
             dir//'EL_'//int2str(i_EL)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_export_lines(this,dir)
         implicit none
         type(export_lines),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_EL
         integer :: s_EL
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         read(un,*) s_EL
         if (s_EL.gt.0) then
           if (.not.allocated(this%EL)) then
             allocate(this%EL(s_EL))
           endif
           do i_EL=1,s_EL
             call import_structured(this%EL(i_EL),&
             dir//'EL_'//int2str(i_EL)//fortran_PS)
           enddo
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_export_lines(this)
         implicit none
         type(export_lines),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module export_now_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use step_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: export_now
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_export_now;              end interface
       interface delete;                 module procedure delete_export_now;                 end interface
       interface display;                module procedure display_export_now;                end interface
       interface display_short;          module procedure display_short_export_now;          end interface
       interface display;                module procedure display_wrap_export_now;           end interface
       interface print;                  module procedure print_export_now;                  end interface
       interface print_short;            module procedure print_short_export_now;            end interface
       interface export;                 module procedure export_export_now;                 end interface
       interface export_primitives;      module procedure export_primitives_export_now;      end interface
       interface import;                 module procedure import_export_now;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_export_now;end interface
       interface export_structured;      module procedure export_structured_D_export_now;    end interface
       interface import_structured;      module procedure import_structured_D_export_now;    end interface
       interface import_primitives;      module procedure import_primitives_export_now;      end interface
       interface export;                 module procedure export_wrap_export_now;            end interface
       interface import;                 module procedure import_wrap_export_now;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_export_now;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_export_now;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_export_now;      end interface
       interface export;                 module procedure export_DN_export_now;              end interface
       interface import;                 module procedure import_DN_export_now;              end interface
       interface export_structured;      module procedure export_structured_DN_export_now;   end interface
       interface import_structured;      module procedure import_structured_DN_export_now;   end interface

       type export_now
         type(step) :: U
         type(step) :: B
         type(step) :: T
         type(step) :: rho
         type(step) :: all
         logical :: any_next = .false.
         logical :: any_now = .false.
         integer :: un = 0
         type(string) :: dir
         type(string) :: name
       end type

       contains

       subroutine init_copy_export_now(this,that)
         implicit none
         type(export_now),intent(inout) :: this
         type(export_now),intent(in) :: that
         call delete(this)
         call init(this%U,that%U)
         call init(this%B,that%B)
         call init(this%T,that%T)
         call init(this%rho,that%rho)
         call init(this%all,that%all)
         this%any_next = that%any_next
         this%any_now = that%any_now
         this%un = that%un
         call init(this%dir,that%dir)
         call init(this%name,that%name)
       end subroutine

       subroutine delete_export_now(this)
         implicit none
         type(export_now),intent(inout) :: this
         call delete(this%U)
         call delete(this%B)
         call delete(this%T)
         call delete(this%rho)
         call delete(this%all)
         this%any_next = .false.
         this%any_now = .false.
         this%un = 0
         call delete(this%dir)
         call delete(this%name)
       end subroutine

       subroutine display_export_now(this,un)
         implicit none
         type(export_now),intent(in) :: this
         integer,intent(in) :: un
         call display(this%U,un)
         call display(this%B,un)
         call display(this%T,un)
         call display(this%rho,un)
         call display(this%all,un)
         write(un,*) 'any_next = ',this%any_next
         write(un,*) 'any_now  = ',this%any_now
         write(un,*) 'un       = ',this%un
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_short_export_now(this,un)
         implicit none
         type(export_now),intent(in) :: this
         integer,intent(in) :: un
         call display(this%U,un)
         call display(this%B,un)
         call display(this%T,un)
         call display(this%rho,un)
         call display(this%all,un)
         write(un,*) 'any_next = ',this%any_next
         write(un,*) 'any_now  = ',this%any_now
         write(un,*) 'un       = ',this%un
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_wrap_export_now(this,dir,name)
         implicit none
         type(export_now),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_export_now(this)
         implicit none
         type(export_now),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_export_now(this)
         implicit none
         type(export_now),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_export_now(this,un)
         implicit none
         type(export_now),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%U,un)
         call export(this%B,un)
         call export(this%T,un)
         call export(this%rho,un)
         call export(this%all,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_export_now(this,un)
         implicit none
         type(export_now),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%U,un)
         call import(this%B,un)
         call import(this%T,un)
         call import(this%rho,un)
         call import(this%all,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_export_now(this,un)
         implicit none
         type(export_now),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'any_next  = ';write(un,*) this%any_next
         write(un,*) 'any_now   = ';write(un,*) this%any_now
         write(un,*) 'un        = ';write(un,*) this%un
       end subroutine

       subroutine import_primitives_export_now(this,un)
         implicit none
         type(export_now),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%any_next
         read(un,*); read(un,*) this%any_now
         read(un,*); read(un,*) this%un
       end subroutine

       subroutine export_wrap_export_now(this,dir,name)
         implicit none
         type(export_now),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_export_now(this,dir,name)
         implicit none
         type(export_now),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_export_now(this)
         implicit none
         type(export_now),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_export_now(this)
         implicit none
         type(export_now),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_export_now(this)
         implicit none
         type(export_now),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%U,str(this%dir)//'U'//fortran_PS)
         call export_structured(this%B,str(this%dir)//'B'//fortran_PS)
         call export_structured(this%T,str(this%dir)//'T'//fortran_PS)
         call export_structured(this%rho,str(this%dir)//'rho'//fortran_PS)
         call export_structured(this%all,str(this%dir)//'all'//fortran_PS)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_export_now(this)
         implicit none
         type(export_now),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%U,str(this%dir)//'U'//fortran_PS)
         call import_structured(this%B,str(this%dir)//'B'//fortran_PS)
         call import_structured(this%T,str(this%dir)//'T'//fortran_PS)
         call import_structured(this%rho,str(this%dir)//'rho'//fortran_PS)
         call import_structured(this%all,str(this%dir)//'all'//fortran_PS)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_export_now(this,dir)
         implicit none
         type(export_now),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%U,dir//'U'//fortran_PS)
         call set_IO_dir(this%B,dir//'B'//fortran_PS)
         call set_IO_dir(this%T,dir//'T'//fortran_PS)
         call set_IO_dir(this%rho,dir//'rho'//fortran_PS)
         call set_IO_dir(this%all,dir//'all'//fortran_PS)
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_export_now(this,dir)
         implicit none
         type(export_now),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%U,dir//'U'//fortran_PS)
         call make_IO_dir(this%B,dir//'B'//fortran_PS)
         call make_IO_dir(this%T,dir//'T'//fortran_PS)
         call make_IO_dir(this%rho,dir//'rho'//fortran_PS)
         call make_IO_dir(this%all,dir//'all'//fortran_PS)
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_export_now(this,dir)
         implicit none
         type(export_now),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%U,dir//'U'//fortran_PS)
         call export_structured(this%B,dir//'B'//fortran_PS)
         call export_structured(this%T,dir//'T'//fortran_PS)
         call export_structured(this%rho,dir//'rho'//fortran_PS)
         call export_structured(this%all,dir//'all'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_export_now(this,dir)
         implicit none
         type(export_now),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%U,dir//'U'//fortran_PS)
         call export_structured(this%B,dir//'B'//fortran_PS)
         call export_structured(this%T,dir//'T'//fortran_PS)
         call export_structured(this%rho,dir//'rho'//fortran_PS)
         call export_structured(this%all,dir//'all'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_export_now(this,dir)
         implicit none
         type(export_now),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%U,dir//'U'//fortran_PS)
         call import_structured(this%B,dir//'B'//fortran_PS)
         call import_structured(this%T,dir//'T'//fortran_PS)
         call import_structured(this%rho,dir//'rho'//fortran_PS)
         call import_structured(this%all,dir//'all'//fortran_PS)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_export_now(this)
         implicit none
         type(export_now),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module export_plane_extend_mod
       use export_plane_mod
       implicit none

       private
       public :: init
       interface init;      module procedure init_EP;      end interface

       contains

       subroutine init_EP(EP,export_ever,dir,plane,suffix)
         implicit none
         type(export_plane),intent(inout) :: EP
         logical,intent(in) :: export_ever
         integer,intent(in) :: dir
         integer,intent(in) :: plane
         character(len=1),intent(in) :: suffix
         EP%export_ever = export_ever
         EP%dir         = dir
         EP%plane        = plane
         EP%suffix      = suffix
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module export_planes_mod
       use export_plane_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: export_planes
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_export_planes;              end interface
       interface delete;                 module procedure delete_export_planes;                 end interface
       interface display;                module procedure display_export_planes;                end interface
       interface display_short;          module procedure display_short_export_planes;          end interface
       interface display;                module procedure display_wrap_export_planes;           end interface
       interface print;                  module procedure print_export_planes;                  end interface
       interface print_short;            module procedure print_short_export_planes;            end interface
       interface export;                 module procedure export_export_planes;                 end interface
       interface export_primitives;      module procedure export_primitives_export_planes;      end interface
       interface import;                 module procedure import_export_planes;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_export_planes;end interface
       interface export_structured;      module procedure export_structured_D_export_planes;    end interface
       interface import_structured;      module procedure import_structured_D_export_planes;    end interface
       interface import_primitives;      module procedure import_primitives_export_planes;      end interface
       interface export;                 module procedure export_wrap_export_planes;            end interface
       interface import;                 module procedure import_wrap_export_planes;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_export_planes;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_export_planes;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_export_planes;      end interface

       type export_planes
         type(export_plane),dimension(:),allocatable :: EP
         integer :: N = 0
       end type

       contains

       subroutine init_copy_export_planes(this,that)
         implicit none
         type(export_planes),intent(inout) :: this
         type(export_planes),intent(in) :: that
         integer :: i_EP
         integer :: s_EP
         call delete(this)
         if (allocated(that%EP)) then
           s_EP = size(that%EP)
           if (s_EP.gt.0) then
             allocate(this%EP(s_EP))
             do i_EP=1,s_EP
               call init(this%EP(i_EP),that%EP(i_EP))
             enddo
           endif
         endif
         this%N = that%N
       end subroutine

       subroutine delete_export_planes(this)
         implicit none
         type(export_planes),intent(inout) :: this
         integer :: i_EP
         integer :: s_EP
         if (allocated(this%EP)) then
           s_EP = size(this%EP)
           do i_EP=1,s_EP
             call delete(this%EP(i_EP))
           enddo
           deallocate(this%EP)
         endif
         this%N = 0
       end subroutine

       subroutine display_export_planes(this,un)
         implicit none
         type(export_planes),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_EP
         integer :: s_EP
         if (allocated(this%EP)) then
           s_EP = size(this%EP)
           do i_EP=1,s_EP
             call display(this%EP(i_EP),un)
           enddo
         endif
         write(un,*) 'N  = ',this%N
       end subroutine

       subroutine display_short_export_planes(this,un)
         implicit none
         type(export_planes),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_EP
         integer :: s_EP
         if (allocated(this%EP)) then
           s_EP = size(this%EP)
           do i_EP=1,s_EP
             call display(this%EP(i_EP),un)
           enddo
         endif
         write(un,*) 'N  = ',this%N
       end subroutine

       subroutine display_wrap_export_planes(this,dir,name)
         implicit none
         type(export_planes),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_export_planes(this)
         implicit none
         type(export_planes),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_export_planes(this)
         implicit none
         type(export_planes),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_export_planes(this,un)
         implicit none
         type(export_planes),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_EP
         integer :: s_EP
         call export_primitives(this,un)
         if (allocated(this%EP)) then
           s_EP = size(this%EP)
           write(un,*) s_EP
           if (s_EP.gt.0) then
             do i_EP=1,s_EP
               call export(this%EP(i_EP),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
       end subroutine

       subroutine import_export_planes(this,un)
         implicit none
         type(export_planes),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_EP
         integer :: s_EP
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_EP
         if (s_EP.gt.0) then
           allocate(this%EP(s_EP))
           do i_EP=1,s_EP
             call import(this%EP(i_EP),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_export_planes(this,un)
         implicit none
         type(export_planes),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'N   = ';write(un,*) this%N
       end subroutine

       subroutine import_primitives_export_planes(this,un)
         implicit none
         type(export_planes),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%N
       end subroutine

       subroutine export_wrap_export_planes(this,dir,name)
         implicit none
         type(export_planes),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_export_planes(this,dir,name)
         implicit none
         type(export_planes),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_export_planes(this,dir)
         implicit none
         type(export_planes),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_EP
         integer :: s_EP
         call suppress_warnings(this)
         if (allocated(this%EP)) then
           s_EP = size(this%EP)
           do i_EP=1,s_EP
             call set_IO_dir(this%EP(i_EP),&
             dir//'EP_'//int2str(i_EP)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine make_IO_dir_export_planes(this,dir)
         implicit none
         type(export_planes),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_EP
         integer :: s_EP
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         if (allocated(this%EP)) then
           s_EP = size(this%EP)
           do i_EP=1,s_EP
             call make_IO_dir(this%EP(i_EP),&
             dir//'EP_'//int2str(i_EP)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine export_folder_structure_export_planes(this,dir)
         implicit none
         type(export_planes),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_EP
         integer :: s_EP
         integer :: un
         if (allocated(this%EP)) then
           s_EP = size(this%EP)
           write(un,*) s_EP
           do i_EP=1,s_EP
             call export_structured(this%EP(i_EP),&
             dir//'EP_'//int2str(i_EP)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
       end subroutine

       subroutine export_structured_D_export_planes(this,dir)
         implicit none
         type(export_planes),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_EP
         integer :: s_EP
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         if (allocated(this%EP)) then
           s_EP = size(this%EP)
           write(un,*) s_EP
           do i_EP=1,s_EP
             call export_structured(this%EP(i_EP),&
             dir//'EP_'//int2str(i_EP)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_export_planes(this,dir)
         implicit none
         type(export_planes),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_EP
         integer :: s_EP
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         read(un,*) s_EP
         if (s_EP.gt.0) then
           if (.not.allocated(this%EP)) then
             allocate(this%EP(s_EP))
           endif
           do i_EP=1,s_EP
             call import_structured(this%EP(i_EP),&
             dir//'EP_'//int2str(i_EP)//fortran_PS)
           enddo
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_export_planes(this)
         implicit none
         type(export_planes),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module export_safe_extend_mod
       use export_safe_mod
       use current_precision_mod
       implicit none

       private
       public :: export_safe
       public :: init,delete,display,export,import,print
       public :: update

       interface init;      module procedure init_ES;         end interface
       interface update;    module procedure update_ES;       end interface

       contains

       subroutine init_ES(ES,export_period_sec)
         implicit none
         type(export_safe),intent(inout) :: ES
         real(cp),intent(in) :: export_period_sec
         ES%export_period_sec = export_period_sec
         ES%export_now = .false.
         ES%mod_period = 0.0_cp
         ES%mod_period_last = 0.0_cp
       end subroutine

       subroutine update_ES(ES,t_sec)
         implicit none
         type(export_safe),intent(inout) :: ES
         real(cp),intent(in) :: t_sec
         ES%mod_period_last = ES%mod_period
         ES%mod_period = mod(t_sec,ES%export_period_sec)
         ES%export_now = ES%mod_period/ES%mod_period_last.lt.1.0_cp
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module induction_terms_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use equation_term_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: induction_terms
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_induction_terms;              end interface
       interface delete;                 module procedure delete_induction_terms;                 end interface
       interface display;                module procedure display_induction_terms;                end interface
       interface display_short;          module procedure display_short_induction_terms;          end interface
       interface display;                module procedure display_wrap_induction_terms;           end interface
       interface print;                  module procedure print_induction_terms;                  end interface
       interface print_short;            module procedure print_short_induction_terms;            end interface
       interface export;                 module procedure export_induction_terms;                 end interface
       interface export_primitives;      module procedure export_primitives_induction_terms;      end interface
       interface import;                 module procedure import_induction_terms;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_induction_terms;end interface
       interface export_structured;      module procedure export_structured_D_induction_terms;    end interface
       interface import_structured;      module procedure import_structured_D_induction_terms;    end interface
       interface import_primitives;      module procedure import_primitives_induction_terms;      end interface
       interface export;                 module procedure export_wrap_induction_terms;            end interface
       interface import;                 module procedure import_wrap_induction_terms;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_induction_terms;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_induction_terms;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_induction_terms;      end interface

       type induction_terms
         type(equation_term) :: advection
         type(equation_term) :: diffusion
         type(equation_term) :: diffusion_linear
         type(equation_term) :: unsteady_B0
         type(equation_term) :: constant_dB0dt
         type(equation_term) :: current
         type(equation_term) :: B_applied
         logical,dimension(3) :: zero_source_components = .false.
         logical :: zero_source_components_any = .false.
       end type

       contains

       subroutine init_copy_induction_terms(this,that)
         implicit none
         type(induction_terms),intent(inout) :: this
         type(induction_terms),intent(in) :: that
         call delete(this)
         call init(this%advection,that%advection)
         call init(this%diffusion,that%diffusion)
         call init(this%diffusion_linear,that%diffusion_linear)
         call init(this%unsteady_B0,that%unsteady_B0)
         call init(this%constant_dB0dt,that%constant_dB0dt)
         call init(this%current,that%current)
         call init(this%B_applied,that%B_applied)
         this%zero_source_components = that%zero_source_components
         this%zero_source_components_any = that%zero_source_components_any
       end subroutine

       subroutine delete_induction_terms(this)
         implicit none
         type(induction_terms),intent(inout) :: this
         call delete(this%advection)
         call delete(this%diffusion)
         call delete(this%diffusion_linear)
         call delete(this%unsteady_B0)
         call delete(this%constant_dB0dt)
         call delete(this%current)
         call delete(this%B_applied)
         this%zero_source_components = .false.
         this%zero_source_components_any = .false.
       end subroutine

       subroutine display_induction_terms(this,un)
         implicit none
         type(induction_terms),intent(in) :: this
         integer,intent(in) :: un
         call display(this%advection,un)
         call display(this%diffusion,un)
         call display(this%diffusion_linear,un)
         call display(this%unsteady_B0,un)
         call display(this%constant_dB0dt,un)
         call display(this%current,un)
         call display(this%B_applied,un)
         write(un,*) 'zero_source_components     = ',&
         this%zero_source_components
         write(un,*) 'zero_source_components_any = ',&
         this%zero_source_components_any
       end subroutine

       subroutine display_short_induction_terms(this,un)
         implicit none
         type(induction_terms),intent(in) :: this
         integer,intent(in) :: un
         call display(this%advection,un)
         call display(this%diffusion,un)
         call display(this%diffusion_linear,un)
         call display(this%unsteady_B0,un)
         call display(this%constant_dB0dt,un)
         call display(this%current,un)
         call display(this%B_applied,un)
         write(un,*) 'zero_source_components     = ',&
         this%zero_source_components
         write(un,*) 'zero_source_components_any = ',&
         this%zero_source_components_any
       end subroutine

       subroutine display_wrap_induction_terms(this,dir,name)
         implicit none
         type(induction_terms),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_induction_terms(this)
         implicit none
         type(induction_terms),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_induction_terms(this)
         implicit none
         type(induction_terms),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_induction_terms(this,un)
         implicit none
         type(induction_terms),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%advection,un)
         call export(this%diffusion,un)
         call export(this%diffusion_linear,un)
         call export(this%unsteady_B0,un)
         call export(this%constant_dB0dt,un)
         call export(this%current,un)
         call export(this%B_applied,un)
       end subroutine

       subroutine import_induction_terms(this,un)
         implicit none
         type(induction_terms),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%advection,un)
         call import(this%diffusion,un)
         call import(this%diffusion_linear,un)
         call import(this%unsteady_B0,un)
         call import(this%constant_dB0dt,un)
         call import(this%current,un)
         call import(this%B_applied,un)
       end subroutine

       subroutine export_primitives_induction_terms(this,un)
         implicit none
         type(induction_terms),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'zero_source_components      = ';write(un,*) this%zero_source_components
         write(un,*) 'zero_source_components_any  = ';write(un,*) this%zero_source_components_any
       end subroutine

       subroutine import_primitives_induction_terms(this,un)
         implicit none
         type(induction_terms),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%zero_source_components
         read(un,*); read(un,*) this%zero_source_components_any
       end subroutine

       subroutine export_wrap_induction_terms(this,dir,name)
         implicit none
         type(induction_terms),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_induction_terms(this,dir,name)
         implicit none
         type(induction_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_induction_terms(this,dir)
         implicit none
         type(induction_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%advection,dir//'advection'//fortran_PS)
         call set_IO_dir(this%diffusion,dir//'diffusion'//fortran_PS)
         call set_IO_dir(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call set_IO_dir(this%unsteady_B0,dir//'unsteady_B0'//fortran_PS)
         call set_IO_dir(this%constant_dB0dt,&
         dir//'constant_dB0dt'//fortran_PS)
         call set_IO_dir(this%current,dir//'current'//fortran_PS)
         call set_IO_dir(this%B_applied,dir//'B_applied'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_induction_terms(this,dir)
         implicit none
         type(induction_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%advection,dir//'advection'//fortran_PS)
         call make_IO_dir(this%diffusion,dir//'diffusion'//fortran_PS)
         call make_IO_dir(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call make_IO_dir(this%unsteady_B0,dir//'unsteady_B0'//fortran_PS)
         call make_IO_dir(this%constant_dB0dt,&
         dir//'constant_dB0dt'//fortran_PS)
         call make_IO_dir(this%current,dir//'current'//fortran_PS)
         call make_IO_dir(this%B_applied,dir//'B_applied'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_induction_terms(this,dir)
         implicit none
         type(induction_terms),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%advection,dir//'advection'//fortran_PS)
         call export_structured(this%diffusion,dir//'diffusion'//fortran_PS)
         call export_structured(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call export_structured(this%unsteady_B0,&
         dir//'unsteady_B0'//fortran_PS)
         call export_structured(this%constant_dB0dt,&
         dir//'constant_dB0dt'//fortran_PS)
         call export_structured(this%current,dir//'current'//fortran_PS)
         call export_structured(this%B_applied,dir//'B_applied'//fortran_PS)
       end subroutine

       subroutine export_structured_D_induction_terms(this,dir)
         implicit none
         type(induction_terms),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%advection,dir//'advection'//fortran_PS)
         call export_structured(this%diffusion,dir//'diffusion'//fortran_PS)
         call export_structured(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call export_structured(this%unsteady_B0,&
         dir//'unsteady_B0'//fortran_PS)
         call export_structured(this%constant_dB0dt,&
         dir//'constant_dB0dt'//fortran_PS)
         call export_structured(this%current,dir//'current'//fortran_PS)
         call export_structured(this%B_applied,dir//'B_applied'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_induction_terms(this,dir)
         implicit none
         type(induction_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%advection,dir//'advection'//fortran_PS)
         call import_structured(this%diffusion,dir//'diffusion'//fortran_PS)
         call import_structured(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call import_structured(this%unsteady_B0,&
         dir//'unsteady_B0'//fortran_PS)
         call import_structured(this%constant_dB0dt,&
         dir//'constant_dB0dt'//fortran_PS)
         call import_structured(this%current,dir//'current'//fortran_PS)
         call import_structured(this%B_applied,dir//'B_applied'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_induction_terms(this)
         implicit none
         type(induction_terms),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module iter_solver_params_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use exit_criteria_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: iter_solver_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_iter_solver_params;              end interface
       interface delete;                 module procedure delete_iter_solver_params;                 end interface
       interface display;                module procedure display_iter_solver_params;                end interface
       interface display_short;          module procedure display_short_iter_solver_params;          end interface
       interface display;                module procedure display_wrap_iter_solver_params;           end interface
       interface print;                  module procedure print_iter_solver_params;                  end interface
       interface print_short;            module procedure print_short_iter_solver_params;            end interface
       interface export;                 module procedure export_iter_solver_params;                 end interface
       interface export_primitives;      module procedure export_primitives_iter_solver_params;      end interface
       interface import;                 module procedure import_iter_solver_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_iter_solver_params;end interface
       interface export_structured;      module procedure export_structured_D_iter_solver_params;    end interface
       interface import_structured;      module procedure import_structured_D_iter_solver_params;    end interface
       interface import_primitives;      module procedure import_primitives_iter_solver_params;      end interface
       interface export;                 module procedure export_wrap_iter_solver_params;            end interface
       interface import;                 module procedure import_wrap_iter_solver_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_iter_solver_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_iter_solver_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_iter_solver_params;      end interface
       interface export;                 module procedure export_DN_iter_solver_params;              end interface
       interface import;                 module procedure import_DN_iter_solver_params;              end interface
       interface export_structured;      module procedure export_structured_DN_iter_solver_params;   end interface
       interface import_structured;      module procedure import_structured_DN_iter_solver_params;   end interface

       type iter_solver_params
         type(exit_criteria) :: EC
         logical,dimension(3) :: exit_loop = .false.
         integer :: un = 0
         type(string) :: dir
         type(string) :: name
         integer :: iter_total = 0
         integer :: iter_per_call = 0
         integer :: n_skip_check_res = 0
         logical :: export_convergence = .false.
         logical :: export_heavy = .false.
       end type

       contains

       subroutine init_copy_iter_solver_params(this,that)
         implicit none
         type(iter_solver_params),intent(inout) :: this
         type(iter_solver_params),intent(in) :: that
         call delete(this)
         call init(this%EC,that%EC)
         this%exit_loop = that%exit_loop
         this%un = that%un
         call init(this%dir,that%dir)
         call init(this%name,that%name)
         this%iter_total = that%iter_total
         this%iter_per_call = that%iter_per_call
         this%n_skip_check_res = that%n_skip_check_res
         this%export_convergence = that%export_convergence
         this%export_heavy = that%export_heavy
       end subroutine

       subroutine delete_iter_solver_params(this)
         implicit none
         type(iter_solver_params),intent(inout) :: this
         call delete(this%EC)
         this%exit_loop = .false.
         this%un = 0
         call delete(this%dir)
         call delete(this%name)
         this%iter_total = 0
         this%iter_per_call = 0
         this%n_skip_check_res = 0
         this%export_convergence = .false.
         this%export_heavy = .false.
       end subroutine

       subroutine display_iter_solver_params(this,un)
         implicit none
         type(iter_solver_params),intent(in) :: this
         integer,intent(in) :: un
         call display(this%EC,un)
         write(un,*) 'exit_loop          = ',this%exit_loop
         write(un,*) 'un                 = ',this%un
         call display(this%dir,un)
         call display(this%name,un)
         write(un,*) 'iter_total         = ',this%iter_total
         write(un,*) 'iter_per_call      = ',this%iter_per_call
         write(un,*) 'n_skip_check_res   = ',this%n_skip_check_res
         write(un,*) 'export_convergence = ',this%export_convergence
         write(un,*) 'export_heavy       = ',this%export_heavy
       end subroutine

       subroutine display_short_iter_solver_params(this,un)
         implicit none
         type(iter_solver_params),intent(in) :: this
         integer,intent(in) :: un
         call display(this%EC,un)
         write(un,*) 'exit_loop          = ',this%exit_loop
         write(un,*) 'un                 = ',this%un
         call display(this%dir,un)
         call display(this%name,un)
         write(un,*) 'iter_total         = ',this%iter_total
         write(un,*) 'iter_per_call      = ',this%iter_per_call
         write(un,*) 'n_skip_check_res   = ',this%n_skip_check_res
         write(un,*) 'export_convergence = ',this%export_convergence
         write(un,*) 'export_heavy       = ',this%export_heavy
       end subroutine

       subroutine display_wrap_iter_solver_params(this,dir,name)
         implicit none
         type(iter_solver_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_iter_solver_params(this)
         implicit none
         type(iter_solver_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_iter_solver_params(this)
         implicit none
         type(iter_solver_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_iter_solver_params(this,un)
         implicit none
         type(iter_solver_params),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%EC,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_iter_solver_params(this,un)
         implicit none
         type(iter_solver_params),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%EC,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_iter_solver_params(this,un)
         implicit none
         type(iter_solver_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'exit_loop           = ';write(un,*) this%exit_loop
         write(un,*) 'un                  = ';write(un,*) this%un
         write(un,*) 'iter_total          = ';write(un,*) this%iter_total
         write(un,*) 'iter_per_call       = ';write(un,*) this%iter_per_call
         write(un,*) 'n_skip_check_res    = ';write(un,*) this%n_skip_check_res
         write(un,*) 'export_convergence  = ';write(un,*) this%export_convergence
         write(un,*) 'export_heavy        = ';write(un,*) this%export_heavy
       end subroutine

       subroutine import_primitives_iter_solver_params(this,un)
         implicit none
         type(iter_solver_params),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%exit_loop
         read(un,*); read(un,*) this%un
         read(un,*); read(un,*) this%iter_total
         read(un,*); read(un,*) this%iter_per_call
         read(un,*); read(un,*) this%n_skip_check_res
         read(un,*); read(un,*) this%export_convergence
         read(un,*); read(un,*) this%export_heavy
       end subroutine

       subroutine export_wrap_iter_solver_params(this,dir,name)
         implicit none
         type(iter_solver_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_iter_solver_params(this,dir,name)
         implicit none
         type(iter_solver_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_iter_solver_params(this)
         implicit none
         type(iter_solver_params),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_iter_solver_params(this)
         implicit none
         type(iter_solver_params),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_iter_solver_params(this)
         implicit none
         type(iter_solver_params),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%EC,str(this%dir)//'EC'//fortran_PS)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_iter_solver_params(this)
         implicit none
         type(iter_solver_params),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%EC,str(this%dir)//'EC'//fortran_PS)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_iter_solver_params(this,dir)
         implicit none
         type(iter_solver_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%EC,dir//'EC'//fortran_PS)
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_iter_solver_params(this,dir)
         implicit none
         type(iter_solver_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%EC,dir//'EC'//fortran_PS)
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_iter_solver_params(this,dir)
         implicit none
         type(iter_solver_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%EC,dir//'EC'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_iter_solver_params(this,dir)
         implicit none
         type(iter_solver_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%EC,dir//'EC'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_iter_solver_params(this,dir)
         implicit none
         type(iter_solver_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%EC,dir//'EC'//fortran_PS)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_iter_solver_params(this)
         implicit none
         type(iter_solver_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module kill_switch_extend_mod
       use kill_switch_mod
       use string_mod
       use IO_tools_mod
       implicit none
       private
       public :: kill_switch
       public :: init,delete,export,import

       interface init;               module procedure init_KS;             end interface

       contains

       subroutine init_KS(KS,dir,name)
         implicit none
         type(kill_switch),intent(inout) :: KS
         character(len=*),intent(in) :: dir,name
         KS%terminate_loop = .false.
         call init(KS%dir,dir)
         call init(KS%name,name)
         call export(KS)
       end subroutine

       end module
      module matrix_free_params_extend_mod
      use matrix_free_params_mod
      use current_precision_mod
      implicit none

      private
      public :: prolongate
      interface prolongate; module procedure prolongate_MFP; end interface

      contains

      subroutine prolongate_MFP(m,coeff_multiplication_factor)
        implicit none
        type(matrix_free_params),intent(inout) :: m
        real(cp),intent(in) :: coeff_multiplication_factor
        m%coeff_natural = coeff_multiplication_factor*m%coeff_natural
        m%coeff_explicit = coeff_multiplication_factor*m%coeff_explicit
      end subroutine

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module mesh_params_mod
       use datatype_conversion_mod
       use segment_mod
       use IO_tools_mod
       use mesh_quality_params_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: mesh_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_mesh_params;              end interface
       interface delete;                 module procedure delete_mesh_params;                 end interface
       interface display;                module procedure display_mesh_params;                end interface
       interface display_short;          module procedure display_short_mesh_params;          end interface
       interface display;                module procedure display_wrap_mesh_params;           end interface
       interface print;                  module procedure print_mesh_params;                  end interface
       interface print_short;            module procedure print_short_mesh_params;            end interface
       interface export;                 module procedure export_mesh_params;                 end interface
       interface export_primitives;      module procedure export_primitives_mesh_params;      end interface
       interface import;                 module procedure import_mesh_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_mesh_params;end interface
       interface export_structured;      module procedure export_structured_D_mesh_params;    end interface
       interface import_structured;      module procedure import_structured_D_mesh_params;    end interface
       interface import_primitives;      module procedure import_primitives_mesh_params;      end interface
       interface export;                 module procedure export_wrap_mesh_params;            end interface
       interface import;                 module procedure import_wrap_mesh_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_mesh_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_mesh_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_mesh_params;      end interface

       type mesh_params
         type(mesh_quality_params) :: MQP
         type(segment),dimension(:),allocatable :: s_base
         type(segment),dimension(:),allocatable :: s_ext
         integer :: N_base = 0
         integer :: N_ext = 0
       end type

       contains

       subroutine init_copy_mesh_params(this,that)
         implicit none
         type(mesh_params),intent(inout) :: this
         type(mesh_params),intent(in) :: that
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         call delete(this)
         call init(this%MQP,that%MQP)
         if (allocated(that%s_base)) then
           s_s_base = size(that%s_base)
           if (s_s_base.gt.0) then
             allocate(this%s_base(s_s_base))
             do i_s_base=1,s_s_base
               call init(this%s_base(i_s_base),that%s_base(i_s_base))
             enddo
           endif
         endif
         if (allocated(that%s_ext)) then
           s_s_ext = size(that%s_ext)
           if (s_s_ext.gt.0) then
             allocate(this%s_ext(s_s_ext))
             do i_s_ext=1,s_s_ext
               call init(this%s_ext(i_s_ext),that%s_ext(i_s_ext))
             enddo
           endif
         endif
         this%N_base = that%N_base
         this%N_ext = that%N_ext
       end subroutine

       subroutine delete_mesh_params(this)
         implicit none
         type(mesh_params),intent(inout) :: this
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         call delete(this%MQP)
         if (allocated(this%s_base)) then
           s_s_base = size(this%s_base)
           do i_s_base=1,s_s_base
             call delete(this%s_base(i_s_base))
           enddo
           deallocate(this%s_base)
         endif
         if (allocated(this%s_ext)) then
           s_s_ext = size(this%s_ext)
           do i_s_ext=1,s_s_ext
             call delete(this%s_ext(i_s_ext))
           enddo
           deallocate(this%s_ext)
         endif
         this%N_base = 0
         this%N_ext = 0
       end subroutine

       subroutine display_mesh_params(this,un)
         implicit none
         type(mesh_params),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         call display(this%MQP,un)
         if (allocated(this%s_base)) then
           s_s_base = size(this%s_base)
           do i_s_base=1,s_s_base
             call display(this%s_base(i_s_base),un)
           enddo
         endif
         if (allocated(this%s_ext)) then
           s_s_ext = size(this%s_ext)
           do i_s_ext=1,s_s_ext
             call display(this%s_ext(i_s_ext),un)
           enddo
         endif
         write(un,*) 'N_base = ',this%N_base
         write(un,*) 'N_ext  = ',this%N_ext
       end subroutine

       subroutine display_short_mesh_params(this,un)
         implicit none
         type(mesh_params),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         call display(this%MQP,un)
         if (allocated(this%s_base)) then
           s_s_base = size(this%s_base)
           do i_s_base=1,s_s_base
             call display(this%s_base(i_s_base),un)
           enddo
         endif
         if (allocated(this%s_ext)) then
           s_s_ext = size(this%s_ext)
           do i_s_ext=1,s_s_ext
             call display(this%s_ext(i_s_ext),un)
           enddo
         endif
         write(un,*) 'N_base = ',this%N_base
         write(un,*) 'N_ext  = ',this%N_ext
       end subroutine

       subroutine display_wrap_mesh_params(this,dir,name)
         implicit none
         type(mesh_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_mesh_params(this)
         implicit none
         type(mesh_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_mesh_params(this)
         implicit none
         type(mesh_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_mesh_params(this,un)
         implicit none
         type(mesh_params),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         call export_primitives(this,un)
         call export(this%MQP,un)
         if (allocated(this%s_base)) then
           s_s_base = size(this%s_base)
           write(un,*) s_s_base
           if (s_s_base.gt.0) then
             do i_s_base=1,s_s_base
               call export(this%s_base(i_s_base),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
         if (allocated(this%s_ext)) then
           s_s_ext = size(this%s_ext)
           write(un,*) s_s_ext
           if (s_s_ext.gt.0) then
             do i_s_ext=1,s_s_ext
               call export(this%s_ext(i_s_ext),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
       end subroutine

       subroutine import_mesh_params(this,un)
         implicit none
         type(mesh_params),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         call delete(this)
         call import_primitives(this,un)
         call import(this%MQP,un)
         read(un,*) s_s_base
         if (s_s_base.gt.0) then
           allocate(this%s_base(s_s_base))
           do i_s_base=1,s_s_base
             call import(this%s_base(i_s_base),un)
           enddo
         endif
         read(un,*) s_s_ext
         if (s_s_ext.gt.0) then
           allocate(this%s_ext(s_s_ext))
           do i_s_ext=1,s_s_ext
             call import(this%s_ext(i_s_ext),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_mesh_params(this,un)
         implicit none
         type(mesh_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'N_base  = ';write(un,*) this%N_base
         write(un,*) 'N_ext   = ';write(un,*) this%N_ext
       end subroutine

       subroutine import_primitives_mesh_params(this,un)
         implicit none
         type(mesh_params),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%N_base
         read(un,*); read(un,*) this%N_ext
       end subroutine

       subroutine export_wrap_mesh_params(this,dir,name)
         implicit none
         type(mesh_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_mesh_params(this,dir,name)
         implicit none
         type(mesh_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_mesh_params(this,dir)
         implicit none
         type(mesh_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         call suppress_warnings(this)
         call set_IO_dir(this%MQP,dir//'MQP'//fortran_PS)
         if (allocated(this%s_base)) then
           s_s_base = size(this%s_base)
           do i_s_base=1,s_s_base
             call set_IO_dir(this%s_base(i_s_base),&
             dir//'s_base_'//int2str(i_s_base)//fortran_PS)
           enddo
         endif
         if (allocated(this%s_ext)) then
           s_s_ext = size(this%s_ext)
           do i_s_ext=1,s_s_ext
             call set_IO_dir(this%s_ext(i_s_ext),&
             dir//'s_ext_'//int2str(i_s_ext)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine make_IO_dir_mesh_params(this,dir)
         implicit none
         type(mesh_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%MQP,dir//'MQP'//fortran_PS)
         if (allocated(this%s_base)) then
           s_s_base = size(this%s_base)
           do i_s_base=1,s_s_base
             call make_IO_dir(this%s_base(i_s_base),&
             dir//'s_base_'//int2str(i_s_base)//fortran_PS)
           enddo
         endif
         if (allocated(this%s_ext)) then
           s_s_ext = size(this%s_ext)
           do i_s_ext=1,s_s_ext
             call make_IO_dir(this%s_ext(i_s_ext),&
             dir//'s_ext_'//int2str(i_s_ext)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine export_folder_structure_mesh_params(this,dir)
         implicit none
         type(mesh_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         integer :: un
         call export_structured(this%MQP,dir//'MQP'//fortran_PS)
         if (allocated(this%s_base)) then
           s_s_base = size(this%s_base)
           write(un,*) s_s_base
           do i_s_base=1,s_s_base
             call export_structured(this%s_base(i_s_base),&
             dir//'s_base_'//int2str(i_s_base)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         if (allocated(this%s_ext)) then
           s_s_ext = size(this%s_ext)
           write(un,*) s_s_ext
           do i_s_ext=1,s_s_ext
             call export_structured(this%s_ext(i_s_ext),&
             dir//'s_ext_'//int2str(i_s_ext)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
       end subroutine

       subroutine export_structured_D_mesh_params(this,dir)
         implicit none
         type(mesh_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%MQP,dir//'MQP'//fortran_PS)
         if (allocated(this%s_base)) then
           s_s_base = size(this%s_base)
           write(un,*) s_s_base
           do i_s_base=1,s_s_base
             call export_structured(this%s_base(i_s_base),&
             dir//'s_base_'//int2str(i_s_base)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         if (allocated(this%s_ext)) then
           s_s_ext = size(this%s_ext)
           write(un,*) s_s_ext
           do i_s_ext=1,s_s_ext
             call export_structured(this%s_ext(i_s_ext),&
             dir//'s_ext_'//int2str(i_s_ext)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_mesh_params(this,dir)
         implicit none
         type(mesh_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_s_base
         integer :: i_s_ext
         integer :: s_s_base
         integer :: s_s_ext
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%MQP,dir//'MQP'//fortran_PS)
         read(un,*) s_s_base
         if (s_s_base.gt.0) then
           if (.not.allocated(this%s_base)) then
             allocate(this%s_base(s_s_base))
           endif
           do i_s_base=1,s_s_base
             call import_structured(this%s_base(i_s_base),&
             dir//'s_base_'//int2str(i_s_base)//fortran_PS)
           enddo
         endif
         read(un,*) s_s_ext
         if (s_s_ext.gt.0) then
           if (.not.allocated(this%s_ext)) then
             allocate(this%s_ext(s_s_ext))
           endif
           do i_s_ext=1,s_s_ext
             call import_structured(this%s_ext(i_s_ext),&
             dir//'s_ext_'//int2str(i_s_ext)//fortran_PS)
           enddo
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_mesh_params(this)
         implicit none
         type(mesh_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module mesh_props_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use simple_int_tensor_mod
       use dir_manip_mod
       implicit none

       private
       public :: mesh_props
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_mesh_props;              end interface
       interface delete;                 module procedure delete_mesh_props;                 end interface
       interface display;                module procedure display_mesh_props;                end interface
       interface display_short;          module procedure display_short_mesh_props;          end interface
       interface display;                module procedure display_wrap_mesh_props;           end interface
       interface print;                  module procedure print_mesh_props;                  end interface
       interface print_short;            module procedure print_short_mesh_props;            end interface
       interface export;                 module procedure export_mesh_props;                 end interface
       interface export_primitives;      module procedure export_primitives_mesh_props;      end interface
       interface import;                 module procedure import_mesh_props;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_mesh_props;end interface
       interface export_structured;      module procedure export_structured_D_mesh_props;    end interface
       interface import_structured;      module procedure import_structured_D_mesh_props;    end interface
       interface import_primitives;      module procedure import_primitives_mesh_props;      end interface
       interface export;                 module procedure export_wrap_mesh_props;            end interface
       interface import;                 module procedure import_wrap_mesh_props;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_mesh_props;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_mesh_props;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_mesh_props;      end interface

       type mesh_props
         type(simple_int_tensor),dimension(3) :: int_tensor
         logical,dimension(3) :: plane = .false.
         integer,dimension(3) :: N_cells = 0
         logical :: plane_any = .false.
         integer :: N_cells_tot = 0
         real(cp) :: volume = 0.0_cp
         real(cp),dimension(3) :: hmax = 0.0_cp
         real(cp),dimension(3) :: hmin = 0.0_cp
         real(cp),dimension(3) :: dhmax = 0.0_cp
         real(cp),dimension(3) :: dhmin = 0.0_cp
         real(cp) :: dhmax_max = 0.0_cp
         real(cp) :: dhmin_min = 0.0_cp
       end type

       contains

       subroutine init_copy_mesh_props(this,that)
         implicit none
         type(mesh_props),intent(inout) :: this
         type(mesh_props),intent(in) :: that
         integer :: i_int_tensor
         integer :: s_int_tensor
         call delete(this)
         s_int_tensor = size(that%int_tensor)
         do i_int_tensor=1,s_int_tensor
           call init(this%int_tensor(i_int_tensor),&
           that%int_tensor(i_int_tensor))
         enddo
         this%plane = that%plane
         this%N_cells = that%N_cells
         this%plane_any = that%plane_any
         this%N_cells_tot = that%N_cells_tot
         this%volume = that%volume
         this%hmax = that%hmax
         this%hmin = that%hmin
         this%dhmax = that%dhmax
         this%dhmin = that%dhmin
         this%dhmax_max = that%dhmax_max
         this%dhmin_min = that%dhmin_min
       end subroutine

       subroutine delete_mesh_props(this)
         implicit none
         type(mesh_props),intent(inout) :: this
         integer :: i_int_tensor
         integer :: s_int_tensor
         s_int_tensor = size(this%int_tensor)
         do i_int_tensor=1,s_int_tensor
           call delete(this%int_tensor(i_int_tensor))
         enddo
         this%plane = .false.
         this%N_cells = 0
         this%plane_any = .false.
         this%N_cells_tot = 0
         this%volume = 0.0_cp
         this%hmax = 0.0_cp
         this%hmin = 0.0_cp
         this%dhmax = 0.0_cp
         this%dhmin = 0.0_cp
         this%dhmax_max = 0.0_cp
         this%dhmin_min = 0.0_cp
       end subroutine

       subroutine display_mesh_props(this,un)
         implicit none
         type(mesh_props),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_int_tensor
         integer :: s_int_tensor
         s_int_tensor = size(this%int_tensor)
         do i_int_tensor=1,s_int_tensor
           call display(this%int_tensor(i_int_tensor),un)
         enddo
         write(un,*) 'plane       = ',this%plane
         write(un,*) 'N_cells     = ',this%N_cells
         write(un,*) 'plane_any   = ',this%plane_any
         write(un,*) 'N_cells_tot = ',this%N_cells_tot
         write(un,*) 'volume      = ',this%volume
         write(un,*) 'hmax        = ',this%hmax
         write(un,*) 'hmin        = ',this%hmin
         write(un,*) 'dhmax       = ',this%dhmax
         write(un,*) 'dhmin       = ',this%dhmin
         write(un,*) 'dhmax_max   = ',this%dhmax_max
         write(un,*) 'dhmin_min   = ',this%dhmin_min
       end subroutine

       subroutine display_short_mesh_props(this,un)
         implicit none
         type(mesh_props),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_int_tensor
         integer :: s_int_tensor
         s_int_tensor = size(this%int_tensor)
         do i_int_tensor=1,s_int_tensor
           call display(this%int_tensor(i_int_tensor),un)
         enddo
         write(un,*) 'plane       = ',this%plane
         write(un,*) 'N_cells     = ',this%N_cells
         write(un,*) 'plane_any   = ',this%plane_any
         write(un,*) 'N_cells_tot = ',this%N_cells_tot
         write(un,*) 'volume      = ',this%volume
         write(un,*) 'hmax        = ',this%hmax
         write(un,*) 'hmin        = ',this%hmin
         write(un,*) 'dhmax       = ',this%dhmax
         write(un,*) 'dhmin       = ',this%dhmin
         write(un,*) 'dhmax_max   = ',this%dhmax_max
         write(un,*) 'dhmin_min   = ',this%dhmin_min
       end subroutine

       subroutine display_wrap_mesh_props(this,dir,name)
         implicit none
         type(mesh_props),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_mesh_props(this)
         implicit none
         type(mesh_props),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_mesh_props(this)
         implicit none
         type(mesh_props),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_mesh_props(this,un)
         implicit none
         type(mesh_props),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_int_tensor
         integer :: s_int_tensor
         call export_primitives(this,un)
         s_int_tensor = size(this%int_tensor)
         write(un,*) s_int_tensor
         do i_int_tensor=1,s_int_tensor
           call export(this%int_tensor(i_int_tensor),un)
         enddo
       end subroutine

       subroutine import_mesh_props(this,un)
         implicit none
         type(mesh_props),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_int_tensor
         integer :: s_int_tensor
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_int_tensor
         if (s_int_tensor.gt.0) then
           do i_int_tensor=1,s_int_tensor
             call import(this%int_tensor(i_int_tensor),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_mesh_props(this,un)
         implicit none
         type(mesh_props),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'plane        = ';write(un,*) this%plane
         write(un,*) 'N_cells      = ';write(un,*) this%N_cells
         write(un,*) 'plane_any    = ';write(un,*) this%plane_any
         write(un,*) 'N_cells_tot  = ';write(un,*) this%N_cells_tot
         write(un,*) 'volume       = ';write(un,*) this%volume
         write(un,*) 'hmax         = ';write(un,*) this%hmax
         write(un,*) 'hmin         = ';write(un,*) this%hmin
         write(un,*) 'dhmax        = ';write(un,*) this%dhmax
         write(un,*) 'dhmin        = ';write(un,*) this%dhmin
         write(un,*) 'dhmax_max    = ';write(un,*) this%dhmax_max
         write(un,*) 'dhmin_min    = ';write(un,*) this%dhmin_min
       end subroutine

       subroutine import_primitives_mesh_props(this,un)
         implicit none
         type(mesh_props),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%plane
         read(un,*); read(un,*) this%N_cells
         read(un,*); read(un,*) this%plane_any
         read(un,*); read(un,*) this%N_cells_tot
         read(un,*); read(un,*) this%volume
         read(un,*); read(un,*) this%hmax
         read(un,*); read(un,*) this%hmin
         read(un,*); read(un,*) this%dhmax
         read(un,*); read(un,*) this%dhmin
         read(un,*); read(un,*) this%dhmax_max
         read(un,*); read(un,*) this%dhmin_min
       end subroutine

       subroutine export_wrap_mesh_props(this,dir,name)
         implicit none
         type(mesh_props),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_mesh_props(this,dir,name)
         implicit none
         type(mesh_props),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_mesh_props(this,dir)
         implicit none
         type(mesh_props),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_int_tensor
         integer :: s_int_tensor
         call suppress_warnings(this)
         s_int_tensor = size(this%int_tensor)
         do i_int_tensor=1,s_int_tensor
           call set_IO_dir(this%int_tensor(i_int_tensor),&
           dir//'int_tensor_'//int2str(i_int_tensor)//fortran_PS)
         enddo
       end subroutine

       subroutine make_IO_dir_mesh_props(this,dir)
         implicit none
         type(mesh_props),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_int_tensor
         integer :: s_int_tensor
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         s_int_tensor = size(this%int_tensor)
         do i_int_tensor=1,s_int_tensor
           call make_IO_dir(this%int_tensor(i_int_tensor),&
           dir//'int_tensor_'//int2str(i_int_tensor)//fortran_PS)
         enddo
       end subroutine

       subroutine export_folder_structure_mesh_props(this,dir)
         implicit none
         type(mesh_props),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_int_tensor
         integer :: s_int_tensor
         integer :: un
         s_int_tensor = size(this%int_tensor)
         write(un,*) s_int_tensor
         do i_int_tensor=1,s_int_tensor
           call export_structured(this%int_tensor(i_int_tensor),&
           dir//'int_tensor_'//int2str(i_int_tensor)//fortran_PS)
         enddo
       end subroutine

       subroutine export_structured_D_mesh_props(this,dir)
         implicit none
         type(mesh_props),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_int_tensor
         integer :: s_int_tensor
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         s_int_tensor = size(this%int_tensor)
         write(un,*) s_int_tensor
         do i_int_tensor=1,s_int_tensor
           call export_structured(this%int_tensor(i_int_tensor),&
           dir//'int_tensor_'//int2str(i_int_tensor)//fortran_PS)
         enddo
         close(un)
       end subroutine

       subroutine import_structured_D_mesh_props(this,dir)
         implicit none
         type(mesh_props),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_int_tensor
         integer :: s_int_tensor
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         s_int_tensor = size(this%int_tensor)
         do i_int_tensor=1,s_int_tensor
           call import_structured(this%int_tensor(i_int_tensor),&
           dir//'int_tensor_'//int2str(i_int_tensor)//fortran_PS)
         enddo
         close(un)
       end subroutine

       subroutine suppress_warnings_mesh_props(this)
         implicit none
         type(mesh_props),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module mesh_quality_params_extend_mod
       use mesh_quality_params_mod
       use IO_tools_mod
       use current_precision_mod

       implicit none
       private
       public :: mesh_quality_params
       public :: init

       public :: manual

       interface init;     module procedure init_MQP;           end interface
       interface manual;   module procedure manual_MQP;         end interface

       contains

       subroutine init_MQP(MQP,auto_find_N,max_mesh_stretch_ratio,N_max_points_add)
         implicit none
         type(mesh_quality_params),intent(inout) :: MQP
         logical,intent(in) :: auto_find_N
         real(cp),intent(in) :: max_mesh_stretch_ratio
         integer,intent(in) :: N_max_points_add
         MQP%auto_find_N = auto_find_N
         MQP%max_mesh_stretch_ratio = max_mesh_stretch_ratio
         MQP%N_max_points_add = N_max_points_add
         if (MQP%auto_find_N) then
         MQP%N_iter = N_max_points_add+1
         else
         MQP%N_iter = 1
         endif
       end subroutine

       function manual_MQP() result(MQP)
         implicit none
         type(mesh_quality_params) :: MQP
         call init(MQP,.false.,1.0_cp,1)
       end function

       end module
       module mirror_props_extend_mod
       use mirror_props_mod
       use current_precision_mod
       use face_edge_corner_indexing_mod
       use IO_tools_mod

       implicit none
       private
       public :: mirror_props
       public :: init
       public :: anti_mirror

       interface init;           module procedure init_MP;           end interface
       interface anti_mirror;    module procedure anti_mirror_MP;    end interface

       contains

       subroutine init_MP(MP,mirror,mirror_face)
         implicit none
         type(mirror_props),intent(inout) :: MP
         logical,intent(in) :: mirror
         integer,intent(in) :: mirror_face
         integer :: dir
         MP%mirror      = mirror
         MP%mirror_face = mirror_face
         MP%mirror_sign = (/1.0_cp,1.0_cp,1.0_cp/)
         dir = dir_given_face(mirror_face)
         MP%mirror_sign_a = -MP%mirror_sign
         MP%mirror_sign_a(dir) = 1.0_cp
         MP%mirror_sign(dir) = -1.0_cp
       end subroutine

       function anti_mirror_MP(MP_in) result(MP)
         implicit none
         type(mirror_props),intent(in) :: MP_in
         real(cp),dimension(3) :: temp
         type(mirror_props) :: MP
         call init(MP,MP_in)
         temp = MP%mirror_sign
         MP%mirror_sign = MP%mirror_sign_a
         MP%mirror_sign_a = temp
       end function

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module momentum_terms_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use equation_term_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: momentum_terms
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_momentum_terms;              end interface
       interface delete;                 module procedure delete_momentum_terms;                 end interface
       interface display;                module procedure display_momentum_terms;                end interface
       interface display_short;          module procedure display_short_momentum_terms;          end interface
       interface display;                module procedure display_wrap_momentum_terms;           end interface
       interface print;                  module procedure print_momentum_terms;                  end interface
       interface print_short;            module procedure print_short_momentum_terms;            end interface
       interface export;                 module procedure export_momentum_terms;                 end interface
       interface export_primitives;      module procedure export_primitives_momentum_terms;      end interface
       interface import;                 module procedure import_momentum_terms;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_momentum_terms;end interface
       interface export_structured;      module procedure export_structured_D_momentum_terms;    end interface
       interface import_structured;      module procedure import_structured_D_momentum_terms;    end interface
       interface import_primitives;      module procedure import_primitives_momentum_terms;      end interface
       interface export;                 module procedure export_wrap_momentum_terms;            end interface
       interface import;                 module procedure import_wrap_momentum_terms;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_momentum_terms;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_momentum_terms;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_momentum_terms;      end interface

       type momentum_terms
         type(equation_term) :: pressure_grad
         type(equation_term) :: advection_divergence
         type(equation_term) :: advection_convection
         type(equation_term) :: advection_base_flow
         type(equation_term) :: diffusion
         type(equation_term) :: diffusion_linear
         type(equation_term) :: mean_pressure_grad
         type(equation_term) :: JCrossB
         type(equation_term) :: Q2D_JCrossB
         type(equation_term) :: Buoyancy
         type(equation_term) :: Gravity
         logical,dimension(3) :: zero_source_components = .false.
         logical :: zero_source_components_any = .false.
       end type

       contains

       subroutine init_copy_momentum_terms(this,that)
         implicit none
         type(momentum_terms),intent(inout) :: this
         type(momentum_terms),intent(in) :: that
         call delete(this)
         call init(this%pressure_grad,that%pressure_grad)
         call init(this%advection_divergence,that%advection_divergence)
         call init(this%advection_convection,that%advection_convection)
         call init(this%advection_base_flow,that%advection_base_flow)
         call init(this%diffusion,that%diffusion)
         call init(this%diffusion_linear,that%diffusion_linear)
         call init(this%mean_pressure_grad,that%mean_pressure_grad)
         call init(this%JCrossB,that%JCrossB)
         call init(this%Q2D_JCrossB,that%Q2D_JCrossB)
         call init(this%Buoyancy,that%Buoyancy)
         call init(this%Gravity,that%Gravity)
         this%zero_source_components = that%zero_source_components
         this%zero_source_components_any = that%zero_source_components_any
       end subroutine

       subroutine delete_momentum_terms(this)
         implicit none
         type(momentum_terms),intent(inout) :: this
         call delete(this%pressure_grad)
         call delete(this%advection_divergence)
         call delete(this%advection_convection)
         call delete(this%advection_base_flow)
         call delete(this%diffusion)
         call delete(this%diffusion_linear)
         call delete(this%mean_pressure_grad)
         call delete(this%JCrossB)
         call delete(this%Q2D_JCrossB)
         call delete(this%Buoyancy)
         call delete(this%Gravity)
         this%zero_source_components = .false.
         this%zero_source_components_any = .false.
       end subroutine

       subroutine display_momentum_terms(this,un)
         implicit none
         type(momentum_terms),intent(in) :: this
         integer,intent(in) :: un
         call display(this%pressure_grad,un)
         call display(this%advection_divergence,un)
         call display(this%advection_convection,un)
         call display(this%advection_base_flow,un)
         call display(this%diffusion,un)
         call display(this%diffusion_linear,un)
         call display(this%mean_pressure_grad,un)
         call display(this%JCrossB,un)
         call display(this%Q2D_JCrossB,un)
         call display(this%Buoyancy,un)
         call display(this%Gravity,un)
         write(un,*) 'zero_source_components     = ',&
         this%zero_source_components
         write(un,*) 'zero_source_components_any = ',&
         this%zero_source_components_any
       end subroutine

       subroutine display_short_momentum_terms(this,un)
         implicit none
         type(momentum_terms),intent(in) :: this
         integer,intent(in) :: un
         call display(this%pressure_grad,un)
         call display(this%advection_divergence,un)
         call display(this%advection_convection,un)
         call display(this%advection_base_flow,un)
         call display(this%diffusion,un)
         call display(this%diffusion_linear,un)
         call display(this%mean_pressure_grad,un)
         call display(this%JCrossB,un)
         call display(this%Q2D_JCrossB,un)
         call display(this%Buoyancy,un)
         call display(this%Gravity,un)
         write(un,*) 'zero_source_components     = ',&
         this%zero_source_components
         write(un,*) 'zero_source_components_any = ',&
         this%zero_source_components_any
       end subroutine

       subroutine display_wrap_momentum_terms(this,dir,name)
         implicit none
         type(momentum_terms),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_momentum_terms(this)
         implicit none
         type(momentum_terms),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_momentum_terms(this)
         implicit none
         type(momentum_terms),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_momentum_terms(this,un)
         implicit none
         type(momentum_terms),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%pressure_grad,un)
         call export(this%advection_divergence,un)
         call export(this%advection_convection,un)
         call export(this%advection_base_flow,un)
         call export(this%diffusion,un)
         call export(this%diffusion_linear,un)
         call export(this%mean_pressure_grad,un)
         call export(this%JCrossB,un)
         call export(this%Q2D_JCrossB,un)
         call export(this%Buoyancy,un)
         call export(this%Gravity,un)
       end subroutine

       subroutine import_momentum_terms(this,un)
         implicit none
         type(momentum_terms),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%pressure_grad,un)
         call import(this%advection_divergence,un)
         call import(this%advection_convection,un)
         call import(this%advection_base_flow,un)
         call import(this%diffusion,un)
         call import(this%diffusion_linear,un)
         call import(this%mean_pressure_grad,un)
         call import(this%JCrossB,un)
         call import(this%Q2D_JCrossB,un)
         call import(this%Buoyancy,un)
         call import(this%Gravity,un)
       end subroutine

       subroutine export_primitives_momentum_terms(this,un)
         implicit none
         type(momentum_terms),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'zero_source_components      = ';write(un,*) this%zero_source_components
         write(un,*) 'zero_source_components_any  = ';write(un,*) this%zero_source_components_any
       end subroutine

       subroutine import_primitives_momentum_terms(this,un)
         implicit none
         type(momentum_terms),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%zero_source_components
         read(un,*); read(un,*) this%zero_source_components_any
       end subroutine

       subroutine export_wrap_momentum_terms(this,dir,name)
         implicit none
         type(momentum_terms),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_momentum_terms(this,dir,name)
         implicit none
         type(momentum_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_momentum_terms(this,dir)
         implicit none
         type(momentum_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%pressure_grad,&
         dir//'pressure_grad'//fortran_PS)
         call set_IO_dir(this%advection_divergence,&
         dir//'advection_divergence'//fortran_PS)
         call set_IO_dir(this%advection_convection,&
         dir//'advection_convection'//fortran_PS)
         call set_IO_dir(this%advection_base_flow,&
         dir//'advection_base_flow'//fortran_PS)
         call set_IO_dir(this%diffusion,dir//'diffusion'//fortran_PS)
         call set_IO_dir(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call set_IO_dir(this%mean_pressure_grad,&
         dir//'mean_pressure_grad'//fortran_PS)
         call set_IO_dir(this%JCrossB,dir//'JCrossB'//fortran_PS)
         call set_IO_dir(this%Q2D_JCrossB,dir//'Q2D_JCrossB'//fortran_PS)
         call set_IO_dir(this%Buoyancy,dir//'Buoyancy'//fortran_PS)
         call set_IO_dir(this%Gravity,dir//'Gravity'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_momentum_terms(this,dir)
         implicit none
         type(momentum_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%pressure_grad,&
         dir//'pressure_grad'//fortran_PS)
         call make_IO_dir(this%advection_divergence,&
         dir//'advection_divergence'//fortran_PS)
         call make_IO_dir(this%advection_convection,&
         dir//'advection_convection'//fortran_PS)
         call make_IO_dir(this%advection_base_flow,&
         dir//'advection_base_flow'//fortran_PS)
         call make_IO_dir(this%diffusion,dir//'diffusion'//fortran_PS)
         call make_IO_dir(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call make_IO_dir(this%mean_pressure_grad,&
         dir//'mean_pressure_grad'//fortran_PS)
         call make_IO_dir(this%JCrossB,dir//'JCrossB'//fortran_PS)
         call make_IO_dir(this%Q2D_JCrossB,dir//'Q2D_JCrossB'//fortran_PS)
         call make_IO_dir(this%Buoyancy,dir//'Buoyancy'//fortran_PS)
         call make_IO_dir(this%Gravity,dir//'Gravity'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_momentum_terms(this,dir)
         implicit none
         type(momentum_terms),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%pressure_grad,&
         dir//'pressure_grad'//fortran_PS)
         call export_structured(this%advection_divergence,&
         dir//'advection_divergence'//fortran_PS)
         call export_structured(this%advection_convection,&
         dir//'advection_convection'//fortran_PS)
         call export_structured(this%advection_base_flow,&
         dir//'advection_base_flow'//fortran_PS)
         call export_structured(this%diffusion,dir//'diffusion'//fortran_PS)
         call export_structured(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call export_structured(this%mean_pressure_grad,&
         dir//'mean_pressure_grad'//fortran_PS)
         call export_structured(this%JCrossB,dir//'JCrossB'//fortran_PS)
         call export_structured(this%Q2D_JCrossB,&
         dir//'Q2D_JCrossB'//fortran_PS)
         call export_structured(this%Buoyancy,dir//'Buoyancy'//fortran_PS)
         call export_structured(this%Gravity,dir//'Gravity'//fortran_PS)
       end subroutine

       subroutine export_structured_D_momentum_terms(this,dir)
         implicit none
         type(momentum_terms),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%pressure_grad,&
         dir//'pressure_grad'//fortran_PS)
         call export_structured(this%advection_divergence,&
         dir//'advection_divergence'//fortran_PS)
         call export_structured(this%advection_convection,&
         dir//'advection_convection'//fortran_PS)
         call export_structured(this%advection_base_flow,&
         dir//'advection_base_flow'//fortran_PS)
         call export_structured(this%diffusion,dir//'diffusion'//fortran_PS)
         call export_structured(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call export_structured(this%mean_pressure_grad,&
         dir//'mean_pressure_grad'//fortran_PS)
         call export_structured(this%JCrossB,dir//'JCrossB'//fortran_PS)
         call export_structured(this%Q2D_JCrossB,&
         dir//'Q2D_JCrossB'//fortran_PS)
         call export_structured(this%Buoyancy,dir//'Buoyancy'//fortran_PS)
         call export_structured(this%Gravity,dir//'Gravity'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_momentum_terms(this,dir)
         implicit none
         type(momentum_terms),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%pressure_grad,&
         dir//'pressure_grad'//fortran_PS)
         call import_structured(this%advection_divergence,&
         dir//'advection_divergence'//fortran_PS)
         call import_structured(this%advection_convection,&
         dir//'advection_convection'//fortran_PS)
         call import_structured(this%advection_base_flow,&
         dir//'advection_base_flow'//fortran_PS)
         call import_structured(this%diffusion,dir//'diffusion'//fortran_PS)
         call import_structured(this%diffusion_linear,&
         dir//'diffusion_linear'//fortran_PS)
         call import_structured(this%mean_pressure_grad,&
         dir//'mean_pressure_grad'//fortran_PS)
         call import_structured(this%JCrossB,dir//'JCrossB'//fortran_PS)
         call import_structured(this%Q2D_JCrossB,&
         dir//'Q2D_JCrossB'//fortran_PS)
         call import_structured(this%Buoyancy,dir//'Buoyancy'//fortran_PS)
         call import_structured(this%Gravity,dir//'Gravity'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_momentum_terms(this)
         implicit none
         type(momentum_terms),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module path_extend_mod
      use path_mod
      use dir_manip_mod
      use string_mod
      implicit none

      private
      public :: path
      public :: init,str,rel,full
      public :: make

      interface init;          module procedure init_P;            end interface
      interface init;          module procedure init_ext_rel_str;  end interface
      interface init;          module procedure init_ext_rel_path; end interface
      interface make;          module procedure make_P;            end interface
      interface rel;           module procedure rel_P;             end interface
      interface str;           module procedure str_P;             end interface
      interface full;          module procedure full_P;            end interface

      contains

      subroutine init_P(P,root,rel,PS)
        implicit none
        type(path),intent(inout) :: P
        character(len=*),intent(in) :: root,rel,PS
        call init(P%absolute,root)
        call init(P%relative,rel//PS)
      end subroutine

      subroutine init_ext_rel_str(P,ext,PS)
        implicit none
        type(path),intent(inout) :: P
        character(len=*),intent(in) :: ext,PS
        type(path) :: temp
        call init(temp,P)
        call init(P,full(temp)//ext//PS,rel(temp)//ext,PS) ! calling init_P
        call delete(temp)
      end subroutine

      subroutine init_ext_rel_path(P,P_in,ext,PS)
        implicit none
        type(path),intent(inout) :: P
        type(path),intent(inout) :: P_in
        character(len=*),intent(in) :: ext,PS
        call init(P,full(P_in)//ext//PS,rel(P_in)//ext,PS) ! calling init_P
      end subroutine

      subroutine make_P(P)
        implicit none
        type(path),intent(in) :: P
        call make_dir(str(P%absolute))
      end subroutine

      function str_P(P) result (s)
        implicit none
        type(path),intent(in) :: P
        character(len=len(P%relative)) :: s
        s = str(P%relative)
      end function

      function rel_P(P) result (s)
        implicit none
        type(path),intent(in) :: P
        character(len=len(P%relative)) :: s
        s = str(P%relative)
      end function

      function full_P(P) result (s)
        implicit none
        type(path),intent(in) :: P
        character(len=len(P%absolute)) :: s
        s = str(P%absolute)
      end function

      end module
      module plane_op_mod
      use current_precision_mod
      use grid_field_mod
      implicit none

      private
      public :: plane_op

      abstract interface
      subroutine plane_op(GF,val)
        import grid_field,cp
        implicit none
        type(grid_field),intent(inout) :: GF
        real(cp),intent(in) :: val
      end subroutine
      end interface

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module probe_set_ind_mod
       use probe_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: probe_set_ind
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_probe_set_ind;              end interface
       interface delete;                 module procedure delete_probe_set_ind;                 end interface
       interface display;                module procedure display_probe_set_ind;                end interface
       interface display_short;          module procedure display_short_probe_set_ind;          end interface
       interface display;                module procedure display_wrap_probe_set_ind;           end interface
       interface print;                  module procedure print_probe_set_ind;                  end interface
       interface print_short;            module procedure print_short_probe_set_ind;            end interface
       interface export;                 module procedure export_probe_set_ind;                 end interface
       interface export_primitives;      module procedure export_primitives_probe_set_ind;      end interface
       interface import;                 module procedure import_probe_set_ind;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_probe_set_ind;end interface
       interface export_structured;      module procedure export_structured_D_probe_set_ind;    end interface
       interface import_structured;      module procedure import_structured_D_probe_set_ind;    end interface
       interface import_primitives;      module procedure import_primitives_probe_set_ind;      end interface
       interface export;                 module procedure export_wrap_probe_set_ind;            end interface
       interface import;                 module procedure import_wrap_probe_set_ind;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_probe_set_ind;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_probe_set_ind;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_probe_set_ind;      end interface

       type probe_set_ind
         type(probe) :: probe_divB
         type(probe) :: probe_divJ
         type(probe) :: JE
         type(probe) :: JE_fluid
         type(probe),dimension(3) :: ME
         type(probe),dimension(3) :: ME_fluid
         type(probe),dimension(3) :: ME_conductor
         type(probe),dimension(3) :: probe_dB0dt
         type(probe),dimension(3) :: Bx
         type(probe),dimension(3) :: By
         type(probe),dimension(3) :: Bz
         type(probe),dimension(3) :: probe_B0
         type(probe),dimension(3) :: probe_B1
         type(probe),dimension(3) :: probe_Btot
         type(probe) :: amax_JxB_x
         type(probe) :: amax_JxB_y
         type(probe) :: amax_JxB_z
         type(probe) :: amax_JxB
         type(probe) :: amax_stress_xx
         type(probe) :: amax_stress_xy
         type(probe) :: amax_stress_xz
         type(probe) :: amax_stress_yx
         type(probe) :: amax_stress_yy
         type(probe) :: amax_stress_yz
         type(probe) :: amax_stress_zx
         type(probe) :: amax_stress_zy
         type(probe) :: amax_stress_zz
         type(probe) :: amax_stress_walls_xx
         type(probe) :: amax_stress_walls_xy
         type(probe) :: amax_stress_walls_xz
         type(probe) :: amax_stress_walls_yx
         type(probe) :: amax_stress_walls_yy
         type(probe) :: amax_stress_walls_yz
         type(probe) :: amax_stress_walls_zx
         type(probe) :: amax_stress_walls_zy
         type(probe) :: amax_stress_walls_zz
       end type

       contains

       subroutine init_copy_probe_set_ind(this,that)
         implicit none
         type(probe_set_ind),intent(inout) :: this
         type(probe_set_ind),intent(in) :: that
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         call delete(this)
         call init(this%probe_divB,that%probe_divB)
         call init(this%probe_divJ,that%probe_divJ)
         call init(this%JE,that%JE)
         call init(this%JE_fluid,that%JE_fluid)
         s_ME = size(that%ME)
         do i_ME=1,s_ME
           call init(this%ME(i_ME),that%ME(i_ME))
         enddo
         s_ME_fluid = size(that%ME_fluid)
         do i_ME_fluid=1,s_ME_fluid
           call init(this%ME_fluid(i_ME_fluid),that%ME_fluid(i_ME_fluid))
         enddo
         s_ME_conductor = size(that%ME_conductor)
         do i_ME_conductor=1,s_ME_conductor
           call init(this%ME_conductor(i_ME_conductor),&
           that%ME_conductor(i_ME_conductor))
         enddo
         s_probe_dB0dt = size(that%probe_dB0dt)
         do i_probe_dB0dt=1,s_probe_dB0dt
           call init(this%probe_dB0dt(i_probe_dB0dt),&
           that%probe_dB0dt(i_probe_dB0dt))
         enddo
         s_Bx = size(that%Bx)
         do i_Bx=1,s_Bx
           call init(this%Bx(i_Bx),that%Bx(i_Bx))
         enddo
         s_By = size(that%By)
         do i_By=1,s_By
           call init(this%By(i_By),that%By(i_By))
         enddo
         s_Bz = size(that%Bz)
         do i_Bz=1,s_Bz
           call init(this%Bz(i_Bz),that%Bz(i_Bz))
         enddo
         s_probe_B0 = size(that%probe_B0)
         do i_probe_B0=1,s_probe_B0
           call init(this%probe_B0(i_probe_B0),that%probe_B0(i_probe_B0))
         enddo
         s_probe_B1 = size(that%probe_B1)
         do i_probe_B1=1,s_probe_B1
           call init(this%probe_B1(i_probe_B1),that%probe_B1(i_probe_B1))
         enddo
         s_probe_Btot = size(that%probe_Btot)
         do i_probe_Btot=1,s_probe_Btot
           call init(this%probe_Btot(i_probe_Btot),&
           that%probe_Btot(i_probe_Btot))
         enddo
         call init(this%amax_JxB_x,that%amax_JxB_x)
         call init(this%amax_JxB_y,that%amax_JxB_y)
         call init(this%amax_JxB_z,that%amax_JxB_z)
         call init(this%amax_JxB,that%amax_JxB)
         call init(this%amax_stress_xx,that%amax_stress_xx)
         call init(this%amax_stress_xy,that%amax_stress_xy)
         call init(this%amax_stress_xz,that%amax_stress_xz)
         call init(this%amax_stress_yx,that%amax_stress_yx)
         call init(this%amax_stress_yy,that%amax_stress_yy)
         call init(this%amax_stress_yz,that%amax_stress_yz)
         call init(this%amax_stress_zx,that%amax_stress_zx)
         call init(this%amax_stress_zy,that%amax_stress_zy)
         call init(this%amax_stress_zz,that%amax_stress_zz)
         call init(this%amax_stress_walls_xx,that%amax_stress_walls_xx)
         call init(this%amax_stress_walls_xy,that%amax_stress_walls_xy)
         call init(this%amax_stress_walls_xz,that%amax_stress_walls_xz)
         call init(this%amax_stress_walls_yx,that%amax_stress_walls_yx)
         call init(this%amax_stress_walls_yy,that%amax_stress_walls_yy)
         call init(this%amax_stress_walls_yz,that%amax_stress_walls_yz)
         call init(this%amax_stress_walls_zx,that%amax_stress_walls_zx)
         call init(this%amax_stress_walls_zy,that%amax_stress_walls_zy)
         call init(this%amax_stress_walls_zz,that%amax_stress_walls_zz)
       end subroutine

       subroutine delete_probe_set_ind(this)
         implicit none
         type(probe_set_ind),intent(inout) :: this
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         call delete(this%probe_divB)
         call delete(this%probe_divJ)
         call delete(this%JE)
         call delete(this%JE_fluid)
         s_ME = size(this%ME)
         do i_ME=1,s_ME
           call delete(this%ME(i_ME))
         enddo
         s_ME_fluid = size(this%ME_fluid)
         do i_ME_fluid=1,s_ME_fluid
           call delete(this%ME_fluid(i_ME_fluid))
         enddo
         s_ME_conductor = size(this%ME_conductor)
         do i_ME_conductor=1,s_ME_conductor
           call delete(this%ME_conductor(i_ME_conductor))
         enddo
         s_probe_dB0dt = size(this%probe_dB0dt)
         do i_probe_dB0dt=1,s_probe_dB0dt
           call delete(this%probe_dB0dt(i_probe_dB0dt))
         enddo
         s_Bx = size(this%Bx)
         do i_Bx=1,s_Bx
           call delete(this%Bx(i_Bx))
         enddo
         s_By = size(this%By)
         do i_By=1,s_By
           call delete(this%By(i_By))
         enddo
         s_Bz = size(this%Bz)
         do i_Bz=1,s_Bz
           call delete(this%Bz(i_Bz))
         enddo
         s_probe_B0 = size(this%probe_B0)
         do i_probe_B0=1,s_probe_B0
           call delete(this%probe_B0(i_probe_B0))
         enddo
         s_probe_B1 = size(this%probe_B1)
         do i_probe_B1=1,s_probe_B1
           call delete(this%probe_B1(i_probe_B1))
         enddo
         s_probe_Btot = size(this%probe_Btot)
         do i_probe_Btot=1,s_probe_Btot
           call delete(this%probe_Btot(i_probe_Btot))
         enddo
         call delete(this%amax_JxB_x)
         call delete(this%amax_JxB_y)
         call delete(this%amax_JxB_z)
         call delete(this%amax_JxB)
         call delete(this%amax_stress_xx)
         call delete(this%amax_stress_xy)
         call delete(this%amax_stress_xz)
         call delete(this%amax_stress_yx)
         call delete(this%amax_stress_yy)
         call delete(this%amax_stress_yz)
         call delete(this%amax_stress_zx)
         call delete(this%amax_stress_zy)
         call delete(this%amax_stress_zz)
         call delete(this%amax_stress_walls_xx)
         call delete(this%amax_stress_walls_xy)
         call delete(this%amax_stress_walls_xz)
         call delete(this%amax_stress_walls_yx)
         call delete(this%amax_stress_walls_yy)
         call delete(this%amax_stress_walls_yz)
         call delete(this%amax_stress_walls_zx)
         call delete(this%amax_stress_walls_zy)
         call delete(this%amax_stress_walls_zz)
       end subroutine

       subroutine display_probe_set_ind(this,un)
         implicit none
         type(probe_set_ind),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         call display(this%probe_divB,un)
         call display(this%probe_divJ,un)
         call display(this%JE,un)
         call display(this%JE_fluid,un)
         s_ME = size(this%ME)
         do i_ME=1,s_ME
           call display(this%ME(i_ME),un)
         enddo
         s_ME_fluid = size(this%ME_fluid)
         do i_ME_fluid=1,s_ME_fluid
           call display(this%ME_fluid(i_ME_fluid),un)
         enddo
         s_ME_conductor = size(this%ME_conductor)
         do i_ME_conductor=1,s_ME_conductor
           call display(this%ME_conductor(i_ME_conductor),un)
         enddo
         s_probe_dB0dt = size(this%probe_dB0dt)
         do i_probe_dB0dt=1,s_probe_dB0dt
           call display(this%probe_dB0dt(i_probe_dB0dt),un)
         enddo
         s_Bx = size(this%Bx)
         do i_Bx=1,s_Bx
           call display(this%Bx(i_Bx),un)
         enddo
         s_By = size(this%By)
         do i_By=1,s_By
           call display(this%By(i_By),un)
         enddo
         s_Bz = size(this%Bz)
         do i_Bz=1,s_Bz
           call display(this%Bz(i_Bz),un)
         enddo
         s_probe_B0 = size(this%probe_B0)
         do i_probe_B0=1,s_probe_B0
           call display(this%probe_B0(i_probe_B0),un)
         enddo
         s_probe_B1 = size(this%probe_B1)
         do i_probe_B1=1,s_probe_B1
           call display(this%probe_B1(i_probe_B1),un)
         enddo
         s_probe_Btot = size(this%probe_Btot)
         do i_probe_Btot=1,s_probe_Btot
           call display(this%probe_Btot(i_probe_Btot),un)
         enddo
         call display(this%amax_JxB_x,un)
         call display(this%amax_JxB_y,un)
         call display(this%amax_JxB_z,un)
         call display(this%amax_JxB,un)
         call display(this%amax_stress_xx,un)
         call display(this%amax_stress_xy,un)
         call display(this%amax_stress_xz,un)
         call display(this%amax_stress_yx,un)
         call display(this%amax_stress_yy,un)
         call display(this%amax_stress_yz,un)
         call display(this%amax_stress_zx,un)
         call display(this%amax_stress_zy,un)
         call display(this%amax_stress_zz,un)
         call display(this%amax_stress_walls_xx,un)
         call display(this%amax_stress_walls_xy,un)
         call display(this%amax_stress_walls_xz,un)
         call display(this%amax_stress_walls_yx,un)
         call display(this%amax_stress_walls_yy,un)
         call display(this%amax_stress_walls_yz,un)
         call display(this%amax_stress_walls_zx,un)
         call display(this%amax_stress_walls_zy,un)
         call display(this%amax_stress_walls_zz,un)
       end subroutine

       subroutine display_short_probe_set_ind(this,un)
         implicit none
         type(probe_set_ind),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         call display(this%probe_divB,un)
         call display(this%probe_divJ,un)
         call display(this%JE,un)
         call display(this%JE_fluid,un)
         s_ME = size(this%ME)
         do i_ME=1,s_ME
           call display(this%ME(i_ME),un)
         enddo
         s_ME_fluid = size(this%ME_fluid)
         do i_ME_fluid=1,s_ME_fluid
           call display(this%ME_fluid(i_ME_fluid),un)
         enddo
         s_ME_conductor = size(this%ME_conductor)
         do i_ME_conductor=1,s_ME_conductor
           call display(this%ME_conductor(i_ME_conductor),un)
         enddo
         s_probe_dB0dt = size(this%probe_dB0dt)
         do i_probe_dB0dt=1,s_probe_dB0dt
           call display(this%probe_dB0dt(i_probe_dB0dt),un)
         enddo
         s_Bx = size(this%Bx)
         do i_Bx=1,s_Bx
           call display(this%Bx(i_Bx),un)
         enddo
         s_By = size(this%By)
         do i_By=1,s_By
           call display(this%By(i_By),un)
         enddo
         s_Bz = size(this%Bz)
         do i_Bz=1,s_Bz
           call display(this%Bz(i_Bz),un)
         enddo
         s_probe_B0 = size(this%probe_B0)
         do i_probe_B0=1,s_probe_B0
           call display(this%probe_B0(i_probe_B0),un)
         enddo
         s_probe_B1 = size(this%probe_B1)
         do i_probe_B1=1,s_probe_B1
           call display(this%probe_B1(i_probe_B1),un)
         enddo
         s_probe_Btot = size(this%probe_Btot)
         do i_probe_Btot=1,s_probe_Btot
           call display(this%probe_Btot(i_probe_Btot),un)
         enddo
         call display(this%amax_JxB_x,un)
         call display(this%amax_JxB_y,un)
         call display(this%amax_JxB_z,un)
         call display(this%amax_JxB,un)
         call display(this%amax_stress_xx,un)
         call display(this%amax_stress_xy,un)
         call display(this%amax_stress_xz,un)
         call display(this%amax_stress_yx,un)
         call display(this%amax_stress_yy,un)
         call display(this%amax_stress_yz,un)
         call display(this%amax_stress_zx,un)
         call display(this%amax_stress_zy,un)
         call display(this%amax_stress_zz,un)
         call display(this%amax_stress_walls_xx,un)
         call display(this%amax_stress_walls_xy,un)
         call display(this%amax_stress_walls_xz,un)
         call display(this%amax_stress_walls_yx,un)
         call display(this%amax_stress_walls_yy,un)
         call display(this%amax_stress_walls_yz,un)
         call display(this%amax_stress_walls_zx,un)
         call display(this%amax_stress_walls_zy,un)
         call display(this%amax_stress_walls_zz,un)
       end subroutine

       subroutine display_wrap_probe_set_ind(this,dir,name)
         implicit none
         type(probe_set_ind),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_probe_set_ind(this)
         implicit none
         type(probe_set_ind),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_probe_set_ind(this)
         implicit none
         type(probe_set_ind),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_probe_set_ind(this,un)
         implicit none
         type(probe_set_ind),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         call export(this%probe_divB,un)
         call export(this%probe_divJ,un)
         call export(this%JE,un)
         call export(this%JE_fluid,un)
         s_ME = size(this%ME)
         write(un,*) s_ME
         do i_ME=1,s_ME
           call export(this%ME(i_ME),un)
         enddo
         s_ME_fluid = size(this%ME_fluid)
         write(un,*) s_ME_fluid
         do i_ME_fluid=1,s_ME_fluid
           call export(this%ME_fluid(i_ME_fluid),un)
         enddo
         s_ME_conductor = size(this%ME_conductor)
         write(un,*) s_ME_conductor
         do i_ME_conductor=1,s_ME_conductor
           call export(this%ME_conductor(i_ME_conductor),un)
         enddo
         s_probe_dB0dt = size(this%probe_dB0dt)
         write(un,*) s_probe_dB0dt
         do i_probe_dB0dt=1,s_probe_dB0dt
           call export(this%probe_dB0dt(i_probe_dB0dt),un)
         enddo
         s_Bx = size(this%Bx)
         write(un,*) s_Bx
         do i_Bx=1,s_Bx
           call export(this%Bx(i_Bx),un)
         enddo
         s_By = size(this%By)
         write(un,*) s_By
         do i_By=1,s_By
           call export(this%By(i_By),un)
         enddo
         s_Bz = size(this%Bz)
         write(un,*) s_Bz
         do i_Bz=1,s_Bz
           call export(this%Bz(i_Bz),un)
         enddo
         s_probe_B0 = size(this%probe_B0)
         write(un,*) s_probe_B0
         do i_probe_B0=1,s_probe_B0
           call export(this%probe_B0(i_probe_B0),un)
         enddo
         s_probe_B1 = size(this%probe_B1)
         write(un,*) s_probe_B1
         do i_probe_B1=1,s_probe_B1
           call export(this%probe_B1(i_probe_B1),un)
         enddo
         s_probe_Btot = size(this%probe_Btot)
         write(un,*) s_probe_Btot
         do i_probe_Btot=1,s_probe_Btot
           call export(this%probe_Btot(i_probe_Btot),un)
         enddo
         call export(this%amax_JxB_x,un)
         call export(this%amax_JxB_y,un)
         call export(this%amax_JxB_z,un)
         call export(this%amax_JxB,un)
         call export(this%amax_stress_xx,un)
         call export(this%amax_stress_xy,un)
         call export(this%amax_stress_xz,un)
         call export(this%amax_stress_yx,un)
         call export(this%amax_stress_yy,un)
         call export(this%amax_stress_yz,un)
         call export(this%amax_stress_zx,un)
         call export(this%amax_stress_zy,un)
         call export(this%amax_stress_zz,un)
         call export(this%amax_stress_walls_xx,un)
         call export(this%amax_stress_walls_xy,un)
         call export(this%amax_stress_walls_xz,un)
         call export(this%amax_stress_walls_yx,un)
         call export(this%amax_stress_walls_yy,un)
         call export(this%amax_stress_walls_yz,un)
         call export(this%amax_stress_walls_zx,un)
         call export(this%amax_stress_walls_zy,un)
         call export(this%amax_stress_walls_zz,un)
       end subroutine

       subroutine import_probe_set_ind(this,un)
         implicit none
         type(probe_set_ind),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         call delete(this)
         call import(this%probe_divB,un)
         call import(this%probe_divJ,un)
         call import(this%JE,un)
         call import(this%JE_fluid,un)
         read(un,*) s_ME
         if (s_ME.gt.0) then
           do i_ME=1,s_ME
             call import(this%ME(i_ME),un)
           enddo
         endif
         read(un,*) s_ME_fluid
         if (s_ME_fluid.gt.0) then
           do i_ME_fluid=1,s_ME_fluid
             call import(this%ME_fluid(i_ME_fluid),un)
           enddo
         endif
         read(un,*) s_ME_conductor
         if (s_ME_conductor.gt.0) then
           do i_ME_conductor=1,s_ME_conductor
             call import(this%ME_conductor(i_ME_conductor),un)
           enddo
         endif
         read(un,*) s_probe_dB0dt
         if (s_probe_dB0dt.gt.0) then
           do i_probe_dB0dt=1,s_probe_dB0dt
             call import(this%probe_dB0dt(i_probe_dB0dt),un)
           enddo
         endif
         read(un,*) s_Bx
         if (s_Bx.gt.0) then
           do i_Bx=1,s_Bx
             call import(this%Bx(i_Bx),un)
           enddo
         endif
         read(un,*) s_By
         if (s_By.gt.0) then
           do i_By=1,s_By
             call import(this%By(i_By),un)
           enddo
         endif
         read(un,*) s_Bz
         if (s_Bz.gt.0) then
           do i_Bz=1,s_Bz
             call import(this%Bz(i_Bz),un)
           enddo
         endif
         read(un,*) s_probe_B0
         if (s_probe_B0.gt.0) then
           do i_probe_B0=1,s_probe_B0
             call import(this%probe_B0(i_probe_B0),un)
           enddo
         endif
         read(un,*) s_probe_B1
         if (s_probe_B1.gt.0) then
           do i_probe_B1=1,s_probe_B1
             call import(this%probe_B1(i_probe_B1),un)
           enddo
         endif
         read(un,*) s_probe_Btot
         if (s_probe_Btot.gt.0) then
           do i_probe_Btot=1,s_probe_Btot
             call import(this%probe_Btot(i_probe_Btot),un)
           enddo
         endif
         call import(this%amax_JxB_x,un)
         call import(this%amax_JxB_y,un)
         call import(this%amax_JxB_z,un)
         call import(this%amax_JxB,un)
         call import(this%amax_stress_xx,un)
         call import(this%amax_stress_xy,un)
         call import(this%amax_stress_xz,un)
         call import(this%amax_stress_yx,un)
         call import(this%amax_stress_yy,un)
         call import(this%amax_stress_yz,un)
         call import(this%amax_stress_zx,un)
         call import(this%amax_stress_zy,un)
         call import(this%amax_stress_zz,un)
         call import(this%amax_stress_walls_xx,un)
         call import(this%amax_stress_walls_xy,un)
         call import(this%amax_stress_walls_xz,un)
         call import(this%amax_stress_walls_yx,un)
         call import(this%amax_stress_walls_yy,un)
         call import(this%amax_stress_walls_yz,un)
         call import(this%amax_stress_walls_zx,un)
         call import(this%amax_stress_walls_zy,un)
         call import(this%amax_stress_walls_zz,un)
       end subroutine

       subroutine export_primitives_probe_set_ind(this,un)
         implicit none
         type(probe_set_ind),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_probe_set_ind(this,un)
         implicit none
         type(probe_set_ind),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_probe_set_ind(this,dir,name)
         implicit none
         type(probe_set_ind),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_probe_set_ind(this,dir,name)
         implicit none
         type(probe_set_ind),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_probe_set_ind(this,dir)
         implicit none
         type(probe_set_ind),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         call suppress_warnings(this)
         call set_IO_dir(this%probe_divB,dir//'probe_divB'//fortran_PS)
         call set_IO_dir(this%probe_divJ,dir//'probe_divJ'//fortran_PS)
         call set_IO_dir(this%JE,dir//'JE'//fortran_PS)
         call set_IO_dir(this%JE_fluid,dir//'JE_fluid'//fortran_PS)
         s_ME = size(this%ME)
         do i_ME=1,s_ME
           call set_IO_dir(this%ME(i_ME),&
           dir//'ME_'//int2str(i_ME)//fortran_PS)
         enddo
         s_ME_fluid = size(this%ME_fluid)
         do i_ME_fluid=1,s_ME_fluid
           call set_IO_dir(this%ME_fluid(i_ME_fluid),&
           dir//'ME_fluid_'//int2str(i_ME_fluid)//fortran_PS)
         enddo
         s_ME_conductor = size(this%ME_conductor)
         do i_ME_conductor=1,s_ME_conductor
           call set_IO_dir(this%ME_conductor(i_ME_conductor),&
           dir//'ME_conductor_'//int2str(i_ME_conductor)//fortran_PS)
         enddo
         s_probe_dB0dt = size(this%probe_dB0dt)
         do i_probe_dB0dt=1,s_probe_dB0dt
           call set_IO_dir(this%probe_dB0dt(i_probe_dB0dt),&
           dir//'probe_dB0dt_'//int2str(i_probe_dB0dt)//fortran_PS)
         enddo
         s_Bx = size(this%Bx)
         do i_Bx=1,s_Bx
           call set_IO_dir(this%Bx(i_Bx),&
           dir//'Bx_'//int2str(i_Bx)//fortran_PS)
         enddo
         s_By = size(this%By)
         do i_By=1,s_By
           call set_IO_dir(this%By(i_By),&
           dir//'By_'//int2str(i_By)//fortran_PS)
         enddo
         s_Bz = size(this%Bz)
         do i_Bz=1,s_Bz
           call set_IO_dir(this%Bz(i_Bz),&
           dir//'Bz_'//int2str(i_Bz)//fortran_PS)
         enddo
         s_probe_B0 = size(this%probe_B0)
         do i_probe_B0=1,s_probe_B0
           call set_IO_dir(this%probe_B0(i_probe_B0),&
           dir//'probe_B0_'//int2str(i_probe_B0)//fortran_PS)
         enddo
         s_probe_B1 = size(this%probe_B1)
         do i_probe_B1=1,s_probe_B1
           call set_IO_dir(this%probe_B1(i_probe_B1),&
           dir//'probe_B1_'//int2str(i_probe_B1)//fortran_PS)
         enddo
         s_probe_Btot = size(this%probe_Btot)
         do i_probe_Btot=1,s_probe_Btot
           call set_IO_dir(this%probe_Btot(i_probe_Btot),&
           dir//'probe_Btot_'//int2str(i_probe_Btot)//fortran_PS)
         enddo
         call set_IO_dir(this%amax_JxB_x,dir//'amax_JxB_x'//fortran_PS)
         call set_IO_dir(this%amax_JxB_y,dir//'amax_JxB_y'//fortran_PS)
         call set_IO_dir(this%amax_JxB_z,dir//'amax_JxB_z'//fortran_PS)
         call set_IO_dir(this%amax_JxB,dir//'amax_JxB'//fortran_PS)
         call set_IO_dir(this%amax_stress_xx,&
         dir//'amax_stress_xx'//fortran_PS)
         call set_IO_dir(this%amax_stress_xy,&
         dir//'amax_stress_xy'//fortran_PS)
         call set_IO_dir(this%amax_stress_xz,&
         dir//'amax_stress_xz'//fortran_PS)
         call set_IO_dir(this%amax_stress_yx,&
         dir//'amax_stress_yx'//fortran_PS)
         call set_IO_dir(this%amax_stress_yy,&
         dir//'amax_stress_yy'//fortran_PS)
         call set_IO_dir(this%amax_stress_yz,&
         dir//'amax_stress_yz'//fortran_PS)
         call set_IO_dir(this%amax_stress_zx,&
         dir//'amax_stress_zx'//fortran_PS)
         call set_IO_dir(this%amax_stress_zy,&
         dir//'amax_stress_zy'//fortran_PS)
         call set_IO_dir(this%amax_stress_zz,&
         dir//'amax_stress_zz'//fortran_PS)
         call set_IO_dir(this%amax_stress_walls_xx,&
         dir//'amax_stress_walls_xx'//fortran_PS)
         call set_IO_dir(this%amax_stress_walls_xy,&
         dir//'amax_stress_walls_xy'//fortran_PS)
         call set_IO_dir(this%amax_stress_walls_xz,&
         dir//'amax_stress_walls_xz'//fortran_PS)
         call set_IO_dir(this%amax_stress_walls_yx,&
         dir//'amax_stress_walls_yx'//fortran_PS)
         call set_IO_dir(this%amax_stress_walls_yy,&
         dir//'amax_stress_walls_yy'//fortran_PS)
         call set_IO_dir(this%amax_stress_walls_yz,&
         dir//'amax_stress_walls_yz'//fortran_PS)
         call set_IO_dir(this%amax_stress_walls_zx,&
         dir//'amax_stress_walls_zx'//fortran_PS)
         call set_IO_dir(this%amax_stress_walls_zy,&
         dir//'amax_stress_walls_zy'//fortran_PS)
         call set_IO_dir(this%amax_stress_walls_zz,&
         dir//'amax_stress_walls_zz'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_probe_set_ind(this,dir)
         implicit none
         type(probe_set_ind),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%probe_divB,dir//'probe_divB'//fortran_PS)
         call make_IO_dir(this%probe_divJ,dir//'probe_divJ'//fortran_PS)
         call make_IO_dir(this%JE,dir//'JE'//fortran_PS)
         call make_IO_dir(this%JE_fluid,dir//'JE_fluid'//fortran_PS)
         s_ME = size(this%ME)
         do i_ME=1,s_ME
           call make_IO_dir(this%ME(i_ME),&
           dir//'ME_'//int2str(i_ME)//fortran_PS)
         enddo
         s_ME_fluid = size(this%ME_fluid)
         do i_ME_fluid=1,s_ME_fluid
           call make_IO_dir(this%ME_fluid(i_ME_fluid),&
           dir//'ME_fluid_'//int2str(i_ME_fluid)//fortran_PS)
         enddo
         s_ME_conductor = size(this%ME_conductor)
         do i_ME_conductor=1,s_ME_conductor
           call make_IO_dir(this%ME_conductor(i_ME_conductor),&
           dir//'ME_conductor_'//int2str(i_ME_conductor)//fortran_PS)
         enddo
         s_probe_dB0dt = size(this%probe_dB0dt)
         do i_probe_dB0dt=1,s_probe_dB0dt
           call make_IO_dir(this%probe_dB0dt(i_probe_dB0dt),&
           dir//'probe_dB0dt_'//int2str(i_probe_dB0dt)//fortran_PS)
         enddo
         s_Bx = size(this%Bx)
         do i_Bx=1,s_Bx
           call make_IO_dir(this%Bx(i_Bx),&
           dir//'Bx_'//int2str(i_Bx)//fortran_PS)
         enddo
         s_By = size(this%By)
         do i_By=1,s_By
           call make_IO_dir(this%By(i_By),&
           dir//'By_'//int2str(i_By)//fortran_PS)
         enddo
         s_Bz = size(this%Bz)
         do i_Bz=1,s_Bz
           call make_IO_dir(this%Bz(i_Bz),&
           dir//'Bz_'//int2str(i_Bz)//fortran_PS)
         enddo
         s_probe_B0 = size(this%probe_B0)
         do i_probe_B0=1,s_probe_B0
           call make_IO_dir(this%probe_B0(i_probe_B0),&
           dir//'probe_B0_'//int2str(i_probe_B0)//fortran_PS)
         enddo
         s_probe_B1 = size(this%probe_B1)
         do i_probe_B1=1,s_probe_B1
           call make_IO_dir(this%probe_B1(i_probe_B1),&
           dir//'probe_B1_'//int2str(i_probe_B1)//fortran_PS)
         enddo
         s_probe_Btot = size(this%probe_Btot)
         do i_probe_Btot=1,s_probe_Btot
           call make_IO_dir(this%probe_Btot(i_probe_Btot),&
           dir//'probe_Btot_'//int2str(i_probe_Btot)//fortran_PS)
         enddo
         call make_IO_dir(this%amax_JxB_x,dir//'amax_JxB_x'//fortran_PS)
         call make_IO_dir(this%amax_JxB_y,dir//'amax_JxB_y'//fortran_PS)
         call make_IO_dir(this%amax_JxB_z,dir//'amax_JxB_z'//fortran_PS)
         call make_IO_dir(this%amax_JxB,dir//'amax_JxB'//fortran_PS)
         call make_IO_dir(this%amax_stress_xx,&
         dir//'amax_stress_xx'//fortran_PS)
         call make_IO_dir(this%amax_stress_xy,&
         dir//'amax_stress_xy'//fortran_PS)
         call make_IO_dir(this%amax_stress_xz,&
         dir//'amax_stress_xz'//fortran_PS)
         call make_IO_dir(this%amax_stress_yx,&
         dir//'amax_stress_yx'//fortran_PS)
         call make_IO_dir(this%amax_stress_yy,&
         dir//'amax_stress_yy'//fortran_PS)
         call make_IO_dir(this%amax_stress_yz,&
         dir//'amax_stress_yz'//fortran_PS)
         call make_IO_dir(this%amax_stress_zx,&
         dir//'amax_stress_zx'//fortran_PS)
         call make_IO_dir(this%amax_stress_zy,&
         dir//'amax_stress_zy'//fortran_PS)
         call make_IO_dir(this%amax_stress_zz,&
         dir//'amax_stress_zz'//fortran_PS)
         call make_IO_dir(this%amax_stress_walls_xx,&
         dir//'amax_stress_walls_xx'//fortran_PS)
         call make_IO_dir(this%amax_stress_walls_xy,&
         dir//'amax_stress_walls_xy'//fortran_PS)
         call make_IO_dir(this%amax_stress_walls_xz,&
         dir//'amax_stress_walls_xz'//fortran_PS)
         call make_IO_dir(this%amax_stress_walls_yx,&
         dir//'amax_stress_walls_yx'//fortran_PS)
         call make_IO_dir(this%amax_stress_walls_yy,&
         dir//'amax_stress_walls_yy'//fortran_PS)
         call make_IO_dir(this%amax_stress_walls_yz,&
         dir//'amax_stress_walls_yz'//fortran_PS)
         call make_IO_dir(this%amax_stress_walls_zx,&
         dir//'amax_stress_walls_zx'//fortran_PS)
         call make_IO_dir(this%amax_stress_walls_zy,&
         dir//'amax_stress_walls_zy'//fortran_PS)
         call make_IO_dir(this%amax_stress_walls_zz,&
         dir//'amax_stress_walls_zz'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_probe_set_ind(this,dir)
         implicit none
         type(probe_set_ind),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         integer :: un
         call export_structured(this%probe_divB,&
         dir//'probe_divB'//fortran_PS)
         call export_structured(this%probe_divJ,&
         dir//'probe_divJ'//fortran_PS)
         call export_structured(this%JE,dir//'JE'//fortran_PS)
         call export_structured(this%JE_fluid,dir//'JE_fluid'//fortran_PS)
         s_ME = size(this%ME)
         write(un,*) s_ME
         do i_ME=1,s_ME
           call export_structured(this%ME(i_ME),&
           dir//'ME_'//int2str(i_ME)//fortran_PS)
         enddo
         s_ME_fluid = size(this%ME_fluid)
         write(un,*) s_ME_fluid
         do i_ME_fluid=1,s_ME_fluid
           call export_structured(this%ME_fluid(i_ME_fluid),&
           dir//'ME_fluid_'//int2str(i_ME_fluid)//fortran_PS)
         enddo
         s_ME_conductor = size(this%ME_conductor)
         write(un,*) s_ME_conductor
         do i_ME_conductor=1,s_ME_conductor
           call export_structured(this%ME_conductor(i_ME_conductor),&
           dir//'ME_conductor_'//int2str(i_ME_conductor)//fortran_PS)
         enddo
         s_probe_dB0dt = size(this%probe_dB0dt)
         write(un,*) s_probe_dB0dt
         do i_probe_dB0dt=1,s_probe_dB0dt
           call export_structured(this%probe_dB0dt(i_probe_dB0dt),&
           dir//'probe_dB0dt_'//int2str(i_probe_dB0dt)//fortran_PS)
         enddo
         s_Bx = size(this%Bx)
         write(un,*) s_Bx
         do i_Bx=1,s_Bx
           call export_structured(this%Bx(i_Bx),&
           dir//'Bx_'//int2str(i_Bx)//fortran_PS)
         enddo
         s_By = size(this%By)
         write(un,*) s_By
         do i_By=1,s_By
           call export_structured(this%By(i_By),&
           dir//'By_'//int2str(i_By)//fortran_PS)
         enddo
         s_Bz = size(this%Bz)
         write(un,*) s_Bz
         do i_Bz=1,s_Bz
           call export_structured(this%Bz(i_Bz),&
           dir//'Bz_'//int2str(i_Bz)//fortran_PS)
         enddo
         s_probe_B0 = size(this%probe_B0)
         write(un,*) s_probe_B0
         do i_probe_B0=1,s_probe_B0
           call export_structured(this%probe_B0(i_probe_B0),&
           dir//'probe_B0_'//int2str(i_probe_B0)//fortran_PS)
         enddo
         s_probe_B1 = size(this%probe_B1)
         write(un,*) s_probe_B1
         do i_probe_B1=1,s_probe_B1
           call export_structured(this%probe_B1(i_probe_B1),&
           dir//'probe_B1_'//int2str(i_probe_B1)//fortran_PS)
         enddo
         s_probe_Btot = size(this%probe_Btot)
         write(un,*) s_probe_Btot
         do i_probe_Btot=1,s_probe_Btot
           call export_structured(this%probe_Btot(i_probe_Btot),&
           dir//'probe_Btot_'//int2str(i_probe_Btot)//fortran_PS)
         enddo
         call export_structured(this%amax_JxB_x,&
         dir//'amax_JxB_x'//fortran_PS)
         call export_structured(this%amax_JxB_y,&
         dir//'amax_JxB_y'//fortran_PS)
         call export_structured(this%amax_JxB_z,&
         dir//'amax_JxB_z'//fortran_PS)
         call export_structured(this%amax_JxB,dir//'amax_JxB'//fortran_PS)
         call export_structured(this%amax_stress_xx,&
         dir//'amax_stress_xx'//fortran_PS)
         call export_structured(this%amax_stress_xy,&
         dir//'amax_stress_xy'//fortran_PS)
         call export_structured(this%amax_stress_xz,&
         dir//'amax_stress_xz'//fortran_PS)
         call export_structured(this%amax_stress_yx,&
         dir//'amax_stress_yx'//fortran_PS)
         call export_structured(this%amax_stress_yy,&
         dir//'amax_stress_yy'//fortran_PS)
         call export_structured(this%amax_stress_yz,&
         dir//'amax_stress_yz'//fortran_PS)
         call export_structured(this%amax_stress_zx,&
         dir//'amax_stress_zx'//fortran_PS)
         call export_structured(this%amax_stress_zy,&
         dir//'amax_stress_zy'//fortran_PS)
         call export_structured(this%amax_stress_zz,&
         dir//'amax_stress_zz'//fortran_PS)
         call export_structured(this%amax_stress_walls_xx,&
         dir//'amax_stress_walls_xx'//fortran_PS)
         call export_structured(this%amax_stress_walls_xy,&
         dir//'amax_stress_walls_xy'//fortran_PS)
         call export_structured(this%amax_stress_walls_xz,&
         dir//'amax_stress_walls_xz'//fortran_PS)
         call export_structured(this%amax_stress_walls_yx,&
         dir//'amax_stress_walls_yx'//fortran_PS)
         call export_structured(this%amax_stress_walls_yy,&
         dir//'amax_stress_walls_yy'//fortran_PS)
         call export_structured(this%amax_stress_walls_yz,&
         dir//'amax_stress_walls_yz'//fortran_PS)
         call export_structured(this%amax_stress_walls_zx,&
         dir//'amax_stress_walls_zx'//fortran_PS)
         call export_structured(this%amax_stress_walls_zy,&
         dir//'amax_stress_walls_zy'//fortran_PS)
         call export_structured(this%amax_stress_walls_zz,&
         dir//'amax_stress_walls_zz'//fortran_PS)
       end subroutine

       subroutine export_structured_D_probe_set_ind(this,dir)
         implicit none
         type(probe_set_ind),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%probe_divB,&
         dir//'probe_divB'//fortran_PS)
         call export_structured(this%probe_divJ,&
         dir//'probe_divJ'//fortran_PS)
         call export_structured(this%JE,dir//'JE'//fortran_PS)
         call export_structured(this%JE_fluid,dir//'JE_fluid'//fortran_PS)
         s_ME = size(this%ME)
         write(un,*) s_ME
         do i_ME=1,s_ME
           call export_structured(this%ME(i_ME),&
           dir//'ME_'//int2str(i_ME)//fortran_PS)
         enddo
         s_ME_fluid = size(this%ME_fluid)
         write(un,*) s_ME_fluid
         do i_ME_fluid=1,s_ME_fluid
           call export_structured(this%ME_fluid(i_ME_fluid),&
           dir//'ME_fluid_'//int2str(i_ME_fluid)//fortran_PS)
         enddo
         s_ME_conductor = size(this%ME_conductor)
         write(un,*) s_ME_conductor
         do i_ME_conductor=1,s_ME_conductor
           call export_structured(this%ME_conductor(i_ME_conductor),&
           dir//'ME_conductor_'//int2str(i_ME_conductor)//fortran_PS)
         enddo
         s_probe_dB0dt = size(this%probe_dB0dt)
         write(un,*) s_probe_dB0dt
         do i_probe_dB0dt=1,s_probe_dB0dt
           call export_structured(this%probe_dB0dt(i_probe_dB0dt),&
           dir//'probe_dB0dt_'//int2str(i_probe_dB0dt)//fortran_PS)
         enddo
         s_Bx = size(this%Bx)
         write(un,*) s_Bx
         do i_Bx=1,s_Bx
           call export_structured(this%Bx(i_Bx),&
           dir//'Bx_'//int2str(i_Bx)//fortran_PS)
         enddo
         s_By = size(this%By)
         write(un,*) s_By
         do i_By=1,s_By
           call export_structured(this%By(i_By),&
           dir//'By_'//int2str(i_By)//fortran_PS)
         enddo
         s_Bz = size(this%Bz)
         write(un,*) s_Bz
         do i_Bz=1,s_Bz
           call export_structured(this%Bz(i_Bz),&
           dir//'Bz_'//int2str(i_Bz)//fortran_PS)
         enddo
         s_probe_B0 = size(this%probe_B0)
         write(un,*) s_probe_B0
         do i_probe_B0=1,s_probe_B0
           call export_structured(this%probe_B0(i_probe_B0),&
           dir//'probe_B0_'//int2str(i_probe_B0)//fortran_PS)
         enddo
         s_probe_B1 = size(this%probe_B1)
         write(un,*) s_probe_B1
         do i_probe_B1=1,s_probe_B1
           call export_structured(this%probe_B1(i_probe_B1),&
           dir//'probe_B1_'//int2str(i_probe_B1)//fortran_PS)
         enddo
         s_probe_Btot = size(this%probe_Btot)
         write(un,*) s_probe_Btot
         do i_probe_Btot=1,s_probe_Btot
           call export_structured(this%probe_Btot(i_probe_Btot),&
           dir//'probe_Btot_'//int2str(i_probe_Btot)//fortran_PS)
         enddo
         call export_structured(this%amax_JxB_x,&
         dir//'amax_JxB_x'//fortran_PS)
         call export_structured(this%amax_JxB_y,&
         dir//'amax_JxB_y'//fortran_PS)
         call export_structured(this%amax_JxB_z,&
         dir//'amax_JxB_z'//fortran_PS)
         call export_structured(this%amax_JxB,dir//'amax_JxB'//fortran_PS)
         call export_structured(this%amax_stress_xx,&
         dir//'amax_stress_xx'//fortran_PS)
         call export_structured(this%amax_stress_xy,&
         dir//'amax_stress_xy'//fortran_PS)
         call export_structured(this%amax_stress_xz,&
         dir//'amax_stress_xz'//fortran_PS)
         call export_structured(this%amax_stress_yx,&
         dir//'amax_stress_yx'//fortran_PS)
         call export_structured(this%amax_stress_yy,&
         dir//'amax_stress_yy'//fortran_PS)
         call export_structured(this%amax_stress_yz,&
         dir//'amax_stress_yz'//fortran_PS)
         call export_structured(this%amax_stress_zx,&
         dir//'amax_stress_zx'//fortran_PS)
         call export_structured(this%amax_stress_zy,&
         dir//'amax_stress_zy'//fortran_PS)
         call export_structured(this%amax_stress_zz,&
         dir//'amax_stress_zz'//fortran_PS)
         call export_structured(this%amax_stress_walls_xx,&
         dir//'amax_stress_walls_xx'//fortran_PS)
         call export_structured(this%amax_stress_walls_xy,&
         dir//'amax_stress_walls_xy'//fortran_PS)
         call export_structured(this%amax_stress_walls_xz,&
         dir//'amax_stress_walls_xz'//fortran_PS)
         call export_structured(this%amax_stress_walls_yx,&
         dir//'amax_stress_walls_yx'//fortran_PS)
         call export_structured(this%amax_stress_walls_yy,&
         dir//'amax_stress_walls_yy'//fortran_PS)
         call export_structured(this%amax_stress_walls_yz,&
         dir//'amax_stress_walls_yz'//fortran_PS)
         call export_structured(this%amax_stress_walls_zx,&
         dir//'amax_stress_walls_zx'//fortran_PS)
         call export_structured(this%amax_stress_walls_zy,&
         dir//'amax_stress_walls_zy'//fortran_PS)
         call export_structured(this%amax_stress_walls_zz,&
         dir//'amax_stress_walls_zz'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_probe_set_ind(this,dir)
         implicit none
         type(probe_set_ind),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_ME
         integer :: i_ME_fluid
         integer :: i_ME_conductor
         integer :: i_probe_dB0dt
         integer :: i_Bx
         integer :: i_By
         integer :: i_Bz
         integer :: i_probe_B0
         integer :: i_probe_B1
         integer :: i_probe_Btot
         integer :: s_ME
         integer :: s_ME_fluid
         integer :: s_ME_conductor
         integer :: s_probe_dB0dt
         integer :: s_Bx
         integer :: s_By
         integer :: s_Bz
         integer :: s_probe_B0
         integer :: s_probe_B1
         integer :: s_probe_Btot
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%probe_divB,&
         dir//'probe_divB'//fortran_PS)
         call import_structured(this%probe_divJ,&
         dir//'probe_divJ'//fortran_PS)
         call import_structured(this%JE,dir//'JE'//fortran_PS)
         call import_structured(this%JE_fluid,dir//'JE_fluid'//fortran_PS)
         s_ME = size(this%ME)
         do i_ME=1,s_ME
           call import_structured(this%ME(i_ME),&
           dir//'ME_'//int2str(i_ME)//fortran_PS)
         enddo
         s_ME_fluid = size(this%ME_fluid)
         do i_ME_fluid=1,s_ME_fluid
           call import_structured(this%ME_fluid(i_ME_fluid),&
           dir//'ME_fluid_'//int2str(i_ME_fluid)//fortran_PS)
         enddo
         s_ME_conductor = size(this%ME_conductor)
         do i_ME_conductor=1,s_ME_conductor
           call import_structured(this%ME_conductor(i_ME_conductor),&
           dir//'ME_conductor_'//int2str(i_ME_conductor)//fortran_PS)
         enddo
         s_probe_dB0dt = size(this%probe_dB0dt)
         do i_probe_dB0dt=1,s_probe_dB0dt
           call import_structured(this%probe_dB0dt(i_probe_dB0dt),&
           dir//'probe_dB0dt_'//int2str(i_probe_dB0dt)//fortran_PS)
         enddo
         s_Bx = size(this%Bx)
         do i_Bx=1,s_Bx
           call import_structured(this%Bx(i_Bx),&
           dir//'Bx_'//int2str(i_Bx)//fortran_PS)
         enddo
         s_By = size(this%By)
         do i_By=1,s_By
           call import_structured(this%By(i_By),&
           dir//'By_'//int2str(i_By)//fortran_PS)
         enddo
         s_Bz = size(this%Bz)
         do i_Bz=1,s_Bz
           call import_structured(this%Bz(i_Bz),&
           dir//'Bz_'//int2str(i_Bz)//fortran_PS)
         enddo
         s_probe_B0 = size(this%probe_B0)
         do i_probe_B0=1,s_probe_B0
           call import_structured(this%probe_B0(i_probe_B0),&
           dir//'probe_B0_'//int2str(i_probe_B0)//fortran_PS)
         enddo
         s_probe_B1 = size(this%probe_B1)
         do i_probe_B1=1,s_probe_B1
           call import_structured(this%probe_B1(i_probe_B1),&
           dir//'probe_B1_'//int2str(i_probe_B1)//fortran_PS)
         enddo
         s_probe_Btot = size(this%probe_Btot)
         do i_probe_Btot=1,s_probe_Btot
           call import_structured(this%probe_Btot(i_probe_Btot),&
           dir//'probe_Btot_'//int2str(i_probe_Btot)//fortran_PS)
         enddo
         call import_structured(this%amax_JxB_x,&
         dir//'amax_JxB_x'//fortran_PS)
         call import_structured(this%amax_JxB_y,&
         dir//'amax_JxB_y'//fortran_PS)
         call import_structured(this%amax_JxB_z,&
         dir//'amax_JxB_z'//fortran_PS)
         call import_structured(this%amax_JxB,dir//'amax_JxB'//fortran_PS)
         call import_structured(this%amax_stress_xx,&
         dir//'amax_stress_xx'//fortran_PS)
         call import_structured(this%amax_stress_xy,&
         dir//'amax_stress_xy'//fortran_PS)
         call import_structured(this%amax_stress_xz,&
         dir//'amax_stress_xz'//fortran_PS)
         call import_structured(this%amax_stress_yx,&
         dir//'amax_stress_yx'//fortran_PS)
         call import_structured(this%amax_stress_yy,&
         dir//'amax_stress_yy'//fortran_PS)
         call import_structured(this%amax_stress_yz,&
         dir//'amax_stress_yz'//fortran_PS)
         call import_structured(this%amax_stress_zx,&
         dir//'amax_stress_zx'//fortran_PS)
         call import_structured(this%amax_stress_zy,&
         dir//'amax_stress_zy'//fortran_PS)
         call import_structured(this%amax_stress_zz,&
         dir//'amax_stress_zz'//fortran_PS)
         call import_structured(this%amax_stress_walls_xx,&
         dir//'amax_stress_walls_xx'//fortran_PS)
         call import_structured(this%amax_stress_walls_xy,&
         dir//'amax_stress_walls_xy'//fortran_PS)
         call import_structured(this%amax_stress_walls_xz,&
         dir//'amax_stress_walls_xz'//fortran_PS)
         call import_structured(this%amax_stress_walls_yx,&
         dir//'amax_stress_walls_yx'//fortran_PS)
         call import_structured(this%amax_stress_walls_yy,&
         dir//'amax_stress_walls_yy'//fortran_PS)
         call import_structured(this%amax_stress_walls_yz,&
         dir//'amax_stress_walls_yz'//fortran_PS)
         call import_structured(this%amax_stress_walls_zx,&
         dir//'amax_stress_walls_zx'//fortran_PS)
         call import_structured(this%amax_stress_walls_zy,&
         dir//'amax_stress_walls_zy'//fortran_PS)
         call import_structured(this%amax_stress_walls_zz,&
         dir//'amax_stress_walls_zz'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_probe_set_ind(this)
         implicit none
         type(probe_set_ind),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module probe_set_mom_mod
       use probe_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: probe_set_mom
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_probe_set_mom;              end interface
       interface delete;                 module procedure delete_probe_set_mom;                 end interface
       interface display;                module procedure display_probe_set_mom;                end interface
       interface display_short;          module procedure display_short_probe_set_mom;          end interface
       interface display;                module procedure display_wrap_probe_set_mom;           end interface
       interface print;                  module procedure print_probe_set_mom;                  end interface
       interface print_short;            module procedure print_short_probe_set_mom;            end interface
       interface export;                 module procedure export_probe_set_mom;                 end interface
       interface export_primitives;      module procedure export_primitives_probe_set_mom;      end interface
       interface import;                 module procedure import_probe_set_mom;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_probe_set_mom;end interface
       interface export_structured;      module procedure export_structured_D_probe_set_mom;    end interface
       interface import_structured;      module procedure import_structured_D_probe_set_mom;    end interface
       interface import_primitives;      module procedure import_primitives_probe_set_mom;      end interface
       interface export;                 module procedure export_wrap_probe_set_mom;            end interface
       interface import;                 module procedure import_wrap_probe_set_mom;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_probe_set_mom;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_probe_set_mom;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_probe_set_mom;      end interface

       type probe_set_mom
         type(probe) :: amax_U_x
         type(probe) :: amax_U_y
         type(probe) :: amax_U_z
         type(probe) :: probe_KE
         type(probe) :: probe_KE_2C
         type(probe) :: probe_divU
         type(probe) :: probe_Q
       end type

       contains

       subroutine init_copy_probe_set_mom(this,that)
         implicit none
         type(probe_set_mom),intent(inout) :: this
         type(probe_set_mom),intent(in) :: that
         call delete(this)
         call init(this%amax_U_x,that%amax_U_x)
         call init(this%amax_U_y,that%amax_U_y)
         call init(this%amax_U_z,that%amax_U_z)
         call init(this%probe_KE,that%probe_KE)
         call init(this%probe_KE_2C,that%probe_KE_2C)
         call init(this%probe_divU,that%probe_divU)
         call init(this%probe_Q,that%probe_Q)
       end subroutine

       subroutine delete_probe_set_mom(this)
         implicit none
         type(probe_set_mom),intent(inout) :: this
         call delete(this%amax_U_x)
         call delete(this%amax_U_y)
         call delete(this%amax_U_z)
         call delete(this%probe_KE)
         call delete(this%probe_KE_2C)
         call delete(this%probe_divU)
         call delete(this%probe_Q)
       end subroutine

       subroutine display_probe_set_mom(this,un)
         implicit none
         type(probe_set_mom),intent(in) :: this
         integer,intent(in) :: un
         call display(this%amax_U_x,un)
         call display(this%amax_U_y,un)
         call display(this%amax_U_z,un)
         call display(this%probe_KE,un)
         call display(this%probe_KE_2C,un)
         call display(this%probe_divU,un)
         call display(this%probe_Q,un)
       end subroutine

       subroutine display_short_probe_set_mom(this,un)
         implicit none
         type(probe_set_mom),intent(in) :: this
         integer,intent(in) :: un
         call display(this%amax_U_x,un)
         call display(this%amax_U_y,un)
         call display(this%amax_U_z,un)
         call display(this%probe_KE,un)
         call display(this%probe_KE_2C,un)
         call display(this%probe_divU,un)
         call display(this%probe_Q,un)
       end subroutine

       subroutine display_wrap_probe_set_mom(this,dir,name)
         implicit none
         type(probe_set_mom),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_probe_set_mom(this)
         implicit none
         type(probe_set_mom),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_probe_set_mom(this)
         implicit none
         type(probe_set_mom),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_probe_set_mom(this,un)
         implicit none
         type(probe_set_mom),intent(in) :: this
         integer,intent(in) :: un
         call export(this%amax_U_x,un)
         call export(this%amax_U_y,un)
         call export(this%amax_U_z,un)
         call export(this%probe_KE,un)
         call export(this%probe_KE_2C,un)
         call export(this%probe_divU,un)
         call export(this%probe_Q,un)
       end subroutine

       subroutine import_probe_set_mom(this,un)
         implicit none
         type(probe_set_mom),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%amax_U_x,un)
         call import(this%amax_U_y,un)
         call import(this%amax_U_z,un)
         call import(this%probe_KE,un)
         call import(this%probe_KE_2C,un)
         call import(this%probe_divU,un)
         call import(this%probe_Q,un)
       end subroutine

       subroutine export_primitives_probe_set_mom(this,un)
         implicit none
         type(probe_set_mom),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_probe_set_mom(this,un)
         implicit none
         type(probe_set_mom),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_probe_set_mom(this,dir,name)
         implicit none
         type(probe_set_mom),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_probe_set_mom(this,dir,name)
         implicit none
         type(probe_set_mom),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_probe_set_mom(this,dir)
         implicit none
         type(probe_set_mom),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%amax_U_x,dir//'amax_U_x'//fortran_PS)
         call set_IO_dir(this%amax_U_y,dir//'amax_U_y'//fortran_PS)
         call set_IO_dir(this%amax_U_z,dir//'amax_U_z'//fortran_PS)
         call set_IO_dir(this%probe_KE,dir//'probe_KE'//fortran_PS)
         call set_IO_dir(this%probe_KE_2C,dir//'probe_KE_2C'//fortran_PS)
         call set_IO_dir(this%probe_divU,dir//'probe_divU'//fortran_PS)
         call set_IO_dir(this%probe_Q,dir//'probe_Q'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_probe_set_mom(this,dir)
         implicit none
         type(probe_set_mom),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%amax_U_x,dir//'amax_U_x'//fortran_PS)
         call make_IO_dir(this%amax_U_y,dir//'amax_U_y'//fortran_PS)
         call make_IO_dir(this%amax_U_z,dir//'amax_U_z'//fortran_PS)
         call make_IO_dir(this%probe_KE,dir//'probe_KE'//fortran_PS)
         call make_IO_dir(this%probe_KE_2C,dir//'probe_KE_2C'//fortran_PS)
         call make_IO_dir(this%probe_divU,dir//'probe_divU'//fortran_PS)
         call make_IO_dir(this%probe_Q,dir//'probe_Q'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_probe_set_mom(this,dir)
         implicit none
         type(probe_set_mom),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%amax_U_x,dir//'amax_U_x'//fortran_PS)
         call export_structured(this%amax_U_y,dir//'amax_U_y'//fortran_PS)
         call export_structured(this%amax_U_z,dir//'amax_U_z'//fortran_PS)
         call export_structured(this%probe_KE,dir//'probe_KE'//fortran_PS)
         call export_structured(this%probe_KE_2C,&
         dir//'probe_KE_2C'//fortran_PS)
         call export_structured(this%probe_divU,&
         dir//'probe_divU'//fortran_PS)
         call export_structured(this%probe_Q,dir//'probe_Q'//fortran_PS)
       end subroutine

       subroutine export_structured_D_probe_set_mom(this,dir)
         implicit none
         type(probe_set_mom),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%amax_U_x,dir//'amax_U_x'//fortran_PS)
         call export_structured(this%amax_U_y,dir//'amax_U_y'//fortran_PS)
         call export_structured(this%amax_U_z,dir//'amax_U_z'//fortran_PS)
         call export_structured(this%probe_KE,dir//'probe_KE'//fortran_PS)
         call export_structured(this%probe_KE_2C,&
         dir//'probe_KE_2C'//fortran_PS)
         call export_structured(this%probe_divU,&
         dir//'probe_divU'//fortran_PS)
         call export_structured(this%probe_Q,dir//'probe_Q'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_probe_set_mom(this,dir)
         implicit none
         type(probe_set_mom),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%amax_U_x,dir//'amax_U_x'//fortran_PS)
         call import_structured(this%amax_U_y,dir//'amax_U_y'//fortran_PS)
         call import_structured(this%amax_U_z,dir//'amax_U_z'//fortran_PS)
         call import_structured(this%probe_KE,dir//'probe_KE'//fortran_PS)
         call import_structured(this%probe_KE_2C,&
         dir//'probe_KE_2C'//fortran_PS)
         call import_structured(this%probe_divU,&
         dir//'probe_divU'//fortran_PS)
         call import_structured(this%probe_Q,dir//'probe_Q'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_probe_set_mom(this)
         implicit none
         type(probe_set_mom),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module probe_set_nrg_mod
       use probe_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: probe_set_nrg
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_probe_set_nrg;              end interface
       interface delete;                 module procedure delete_probe_set_nrg;                 end interface
       interface display;                module procedure display_probe_set_nrg;                end interface
       interface display_short;          module procedure display_short_probe_set_nrg;          end interface
       interface display;                module procedure display_wrap_probe_set_nrg;           end interface
       interface print;                  module procedure print_probe_set_nrg;                  end interface
       interface print_short;            module procedure print_short_probe_set_nrg;            end interface
       interface export;                 module procedure export_probe_set_nrg;                 end interface
       interface export_primitives;      module procedure export_primitives_probe_set_nrg;      end interface
       interface import;                 module procedure import_probe_set_nrg;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_probe_set_nrg;end interface
       interface export_structured;      module procedure export_structured_D_probe_set_nrg;    end interface
       interface import_structured;      module procedure import_structured_D_probe_set_nrg;    end interface
       interface import_primitives;      module procedure import_primitives_probe_set_nrg;      end interface
       interface export;                 module procedure export_wrap_probe_set_nrg;            end interface
       interface import;                 module procedure import_wrap_probe_set_nrg;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_probe_set_nrg;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_probe_set_nrg;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_probe_set_nrg;      end interface

       type probe_set_nrg
         type(probe) :: probe_divQ
       end type

       contains

       subroutine init_copy_probe_set_nrg(this,that)
         implicit none
         type(probe_set_nrg),intent(inout) :: this
         type(probe_set_nrg),intent(in) :: that
         call delete(this)
         call init(this%probe_divQ,that%probe_divQ)
       end subroutine

       subroutine delete_probe_set_nrg(this)
         implicit none
         type(probe_set_nrg),intent(inout) :: this
         call delete(this%probe_divQ)
       end subroutine

       subroutine display_probe_set_nrg(this,un)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         integer,intent(in) :: un
         call display(this%probe_divQ,un)
       end subroutine

       subroutine display_short_probe_set_nrg(this,un)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         integer,intent(in) :: un
         call display(this%probe_divQ,un)
       end subroutine

       subroutine display_wrap_probe_set_nrg(this,dir,name)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_probe_set_nrg(this)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_probe_set_nrg(this)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_probe_set_nrg(this,un)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         integer,intent(in) :: un
         call export(this%probe_divQ,un)
       end subroutine

       subroutine import_probe_set_nrg(this,un)
         implicit none
         type(probe_set_nrg),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%probe_divQ,un)
       end subroutine

       subroutine export_primitives_probe_set_nrg(this,un)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_probe_set_nrg(this,un)
         implicit none
         type(probe_set_nrg),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_probe_set_nrg(this,dir,name)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_probe_set_nrg(this,dir,name)
         implicit none
         type(probe_set_nrg),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_probe_set_nrg(this,dir)
         implicit none
         type(probe_set_nrg),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%probe_divQ,dir//'probe_divQ'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_probe_set_nrg(this,dir)
         implicit none
         type(probe_set_nrg),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%probe_divQ,dir//'probe_divQ'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_probe_set_nrg(this,dir)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%probe_divQ,&
         dir//'probe_divQ'//fortran_PS)
       end subroutine

       subroutine export_structured_D_probe_set_nrg(this,dir)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%probe_divQ,&
         dir//'probe_divQ'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_probe_set_nrg(this,dir)
         implicit none
         type(probe_set_nrg),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%probe_divQ,&
         dir//'probe_divQ'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_probe_set_nrg(this)
         implicit none
         type(probe_set_nrg),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module segment_extend_mod
       use IO_tools_mod
       use current_precision_mod
       use segment_mod
       use string_mod
       use mesh_quality_params_mod
       implicit none

       private
       public :: seg_1d

       interface seg_1d;   module procedure seg_1d_segment_minmax;      end interface
       interface seg_1d;   module procedure seg_1d_segment_length;      end interface
       interface seg_1d;   module procedure seg_1d_segment_N_cells;     end interface

       contains

       function seg_1d_segment_minmax(dir,distribution,n_cells,hmin,hmax,buffer) result(s)
         implicit none
         character(len=*),intent(in) :: distribution
         integer,intent(in) :: dir,n_cells
         real(cp),intent(in) :: hmin,hmax,buffer
         type(segment) :: s
         s%n_cells = n_cells
         call init(s%distribution,distribution)
         s%hmax = hmax
         s%hmin = hmin
         s%dir = dir
         s%buffer = buffer
       end function

       function seg_1d_segment_length(dir,distribution,n_cells,L,buffer) result(s)
         implicit none
         character(len=*),intent(in) :: distribution
         integer,intent(in) :: dir,n_cells
         real(cp),intent(in) :: L,buffer
         type(segment) :: s
         s%n_cells = n_cells
         call init(s%distribution,distribution)
         s%l = l
         s%dir = dir
         s%buffer = buffer
       end function

       function seg_1d_segment_N_cells(dir,distribution,n_cells) result(s)
         implicit none
         character(len=*),intent(in) :: distribution
         integer,intent(in) :: dir,n_cells
         type(segment) :: s
         s%n_cells = n_cells
         call init(s%distribution,distribution)
         s%dir = dir
         s%buffer = 1.0_cp
       end function

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module single_boundary_mod
       use grid_field_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use bctype_mod
       use dir_manip_mod
       implicit none

       private
       public :: single_boundary
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_single_boundary;              end interface
       interface delete;                 module procedure delete_single_boundary;                 end interface
       interface display;                module procedure display_single_boundary;                end interface
       interface display_short;          module procedure display_short_single_boundary;          end interface
       interface display;                module procedure display_wrap_single_boundary;           end interface
       interface print;                  module procedure print_single_boundary;                  end interface
       interface print_short;            module procedure print_short_single_boundary;            end interface
       interface export;                 module procedure export_single_boundary;                 end interface
       interface export_primitives;      module procedure export_primitives_single_boundary;      end interface
       interface import;                 module procedure import_single_boundary;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_single_boundary;end interface
       interface export_structured;      module procedure export_structured_D_single_boundary;    end interface
       interface import_structured;      module procedure import_structured_D_single_boundary;    end interface
       interface import_primitives;      module procedure import_primitives_single_boundary;      end interface
       interface export;                 module procedure export_wrap_single_boundary;            end interface
       interface import;                 module procedure import_wrap_single_boundary;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_single_boundary;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_single_boundary;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_single_boundary;      end interface

       type single_boundary
         type(bctype) :: bct
         type(grid_field) :: b
         type(grid_field) :: b_modified
         type(grid_field) :: b_total
       end type

       contains

       subroutine init_copy_single_boundary(this,that)
         implicit none
         type(single_boundary),intent(inout) :: this
         type(single_boundary),intent(in) :: that
         call delete(this)
         call init(this%bct,that%bct)
         call init(this%b,that%b)
         call init(this%b_modified,that%b_modified)
         call init(this%b_total,that%b_total)
       end subroutine

       subroutine delete_single_boundary(this)
         implicit none
         type(single_boundary),intent(inout) :: this
         call delete(this%bct)
         call delete(this%b)
         call delete(this%b_modified)
         call delete(this%b_total)
       end subroutine

       subroutine display_single_boundary(this,un)
         implicit none
         type(single_boundary),intent(in) :: this
         integer,intent(in) :: un
         call display(this%bct,un)
         call display(this%b,un)
         call display(this%b_modified,un)
         call display(this%b_total,un)
       end subroutine

       subroutine display_short_single_boundary(this,un)
         implicit none
         type(single_boundary),intent(in) :: this
         integer,intent(in) :: un
         call display(this%bct,un)
         call display(this%b,un)
         call display(this%b_modified,un)
         call display(this%b_total,un)
       end subroutine

       subroutine display_wrap_single_boundary(this,dir,name)
         implicit none
         type(single_boundary),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_single_boundary(this)
         implicit none
         type(single_boundary),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_single_boundary(this)
         implicit none
         type(single_boundary),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_single_boundary(this,un)
         implicit none
         type(single_boundary),intent(in) :: this
         integer,intent(in) :: un
         call export(this%bct,un)
         call export(this%b,un)
         call export(this%b_modified,un)
         call export(this%b_total,un)
       end subroutine

       subroutine import_single_boundary(this,un)
         implicit none
         type(single_boundary),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%bct,un)
         call import(this%b,un)
         call import(this%b_modified,un)
         call import(this%b_total,un)
       end subroutine

       subroutine export_primitives_single_boundary(this,un)
         implicit none
         type(single_boundary),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_single_boundary(this,un)
         implicit none
         type(single_boundary),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_single_boundary(this,dir,name)
         implicit none
         type(single_boundary),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_single_boundary(this,dir,name)
         implicit none
         type(single_boundary),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_single_boundary(this,dir)
         implicit none
         type(single_boundary),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%bct,dir//'bct'//fortran_PS)
         call set_IO_dir(this%b,dir//'b'//fortran_PS)
         call set_IO_dir(this%b_modified,dir//'b_modified'//fortran_PS)
         call set_IO_dir(this%b_total,dir//'b_total'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_single_boundary(this,dir)
         implicit none
         type(single_boundary),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%bct,dir//'bct'//fortran_PS)
         call make_IO_dir(this%b,dir//'b'//fortran_PS)
         call make_IO_dir(this%b_modified,dir//'b_modified'//fortran_PS)
         call make_IO_dir(this%b_total,dir//'b_total'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_single_boundary(this,dir)
         implicit none
         type(single_boundary),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%bct,dir//'bct'//fortran_PS)
         call export_structured(this%b,dir//'b'//fortran_PS)
         call export_structured(this%b_modified,&
         dir//'b_modified'//fortran_PS)
         call export_structured(this%b_total,dir//'b_total'//fortran_PS)
       end subroutine

       subroutine export_structured_D_single_boundary(this,dir)
         implicit none
         type(single_boundary),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%bct,dir//'bct'//fortran_PS)
         call export_structured(this%b,dir//'b'//fortran_PS)
         call export_structured(this%b_modified,&
         dir//'b_modified'//fortran_PS)
         call export_structured(this%b_total,dir//'b_total'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_single_boundary(this,dir)
         implicit none
         type(single_boundary),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%bct,dir//'bct'//fortran_PS)
         call import_structured(this%b,dir//'b'//fortran_PS)
         call import_structured(this%b_modified,&
         dir//'b_modified'//fortran_PS)
         call import_structured(this%b_total,dir//'b_total'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_single_boundary(this)
         implicit none
         type(single_boundary),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module solver_settings_extend_mod
       use solver_settings_mod
       implicit none

       private
       public :: init
       public :: get_SS

       interface init;    module procedure init_SS;      end interface
       interface get_SS;  module procedure get_SS_SS;    end interface

       contains

       subroutine init_SS(SS,initialize,solve,restart,prescribed_BCs,solve_method)
         implicit none
         type(solver_settings),intent(inout) :: SS
         logical,intent(in) :: initialize,solve,restart,prescribed_BCs
         integer,intent(in) :: solve_method
         SS%initialize = initialize
         SS%solve = solve
         SS%restart = restart
         SS%solve_method = solve_method
         SS%prescribed_BCs = prescribed_BCs
       end subroutine

       function get_SS_SS(initialize,solve,restart,prescribed_BCs,solve_method) result(SS)
         implicit none
         type(solver_settings) :: SS
         logical,intent(in) :: initialize,solve,restart,prescribed_BCs
         integer,intent(in) :: solve_method
         call init(SS,initialize,solve,restart,prescribed_BCs,solve_method)
       end function

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module sparse_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use array_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: sparse
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_sparse;              end interface
       interface delete;                 module procedure delete_sparse;                 end interface
       interface display;                module procedure display_sparse;                end interface
       interface display_short;          module procedure display_short_sparse;          end interface
       interface display;                module procedure display_wrap_sparse;           end interface
       interface print;                  module procedure print_sparse;                  end interface
       interface print_short;            module procedure print_short_sparse;            end interface
       interface export;                 module procedure export_sparse;                 end interface
       interface export_primitives;      module procedure export_primitives_sparse;      end interface
       interface import;                 module procedure import_sparse;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_sparse;end interface
       interface export_structured;      module procedure export_structured_D_sparse;    end interface
       interface import_structured;      module procedure import_structured_D_sparse;    end interface
       interface import_primitives;      module procedure import_primitives_sparse;      end interface
       interface export;                 module procedure export_wrap_sparse;            end interface
       interface import;                 module procedure import_wrap_sparse;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_sparse;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_sparse;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_sparse;      end interface

       type sparse
         type(array) :: L
         type(array) :: D
         type(array) :: U
         logical :: staggered = .false.
       end type

       contains

       subroutine init_copy_sparse(this,that)
         implicit none
         type(sparse),intent(inout) :: this
         type(sparse),intent(in) :: that
         call delete(this)
         call init(this%L,that%L)
         call init(this%D,that%D)
         call init(this%U,that%U)
         this%staggered = that%staggered
       end subroutine

       subroutine delete_sparse(this)
         implicit none
         type(sparse),intent(inout) :: this
         call delete(this%L)
         call delete(this%D)
         call delete(this%U)
         this%staggered = .false.
       end subroutine

       subroutine display_sparse(this,un)
         implicit none
         type(sparse),intent(in) :: this
         integer,intent(in) :: un
         call display(this%L,un)
         call display(this%D,un)
         call display(this%U,un)
         write(un,*) 'staggered = ',this%staggered
       end subroutine

       subroutine display_short_sparse(this,un)
         implicit none
         type(sparse),intent(in) :: this
         integer,intent(in) :: un
         call display(this%L,un)
         call display(this%D,un)
         call display(this%U,un)
         write(un,*) 'staggered = ',this%staggered
       end subroutine

       subroutine display_wrap_sparse(this,dir,name)
         implicit none
         type(sparse),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_sparse(this)
         implicit none
         type(sparse),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_sparse(this)
         implicit none
         type(sparse),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_sparse(this,un)
         implicit none
         type(sparse),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%L,un)
         call export(this%D,un)
         call export(this%U,un)
       end subroutine

       subroutine import_sparse(this,un)
         implicit none
         type(sparse),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%L,un)
         call import(this%D,un)
         call import(this%U,un)
       end subroutine

       subroutine export_primitives_sparse(this,un)
         implicit none
         type(sparse),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'staggered  = ';write(un,*) this%staggered
       end subroutine

       subroutine import_primitives_sparse(this,un)
         implicit none
         type(sparse),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%staggered
       end subroutine

       subroutine export_wrap_sparse(this,dir,name)
         implicit none
         type(sparse),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_sparse(this,dir,name)
         implicit none
         type(sparse),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_sparse(this,dir)
         implicit none
         type(sparse),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%L,dir//'L'//fortran_PS)
         call set_IO_dir(this%D,dir//'D'//fortran_PS)
         call set_IO_dir(this%U,dir//'U'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_sparse(this,dir)
         implicit none
         type(sparse),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%L,dir//'L'//fortran_PS)
         call make_IO_dir(this%D,dir//'D'//fortran_PS)
         call make_IO_dir(this%U,dir//'U'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_sparse(this,dir)
         implicit none
         type(sparse),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%L,dir//'L'//fortran_PS)
         call export_structured(this%D,dir//'D'//fortran_PS)
         call export_structured(this%U,dir//'U'//fortran_PS)
       end subroutine

       subroutine export_structured_D_sparse(this,dir)
         implicit none
         type(sparse),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%L,dir//'L'//fortran_PS)
         call export_structured(this%D,dir//'D'//fortran_PS)
         call export_structured(this%U,dir//'U'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_sparse(this,dir)
         implicit none
         type(sparse),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%L,dir//'L'//fortran_PS)
         call import_structured(this%D,dir//'D'//fortran_PS)
         call import_structured(this%U,dir//'U'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_sparse(this)
         implicit none
         type(sparse),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module step_extend_mod
       use step_mod
       use string_mod
       use IO_tools_mod
       implicit none
       private
       public :: step
       public :: init,delete,display,export,import
       public :: update
       interface update;   module procedure update_step;   end interface

       contains

       subroutine update_step(s)
         implicit none
         type(step),intent(inout) :: s
         s%this = s%next
         s%next = .false.
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module stop_clock_mod
       use current_precision_mod
       use clock_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use unit_conversion_mod
       use dir_manip_mod
       implicit none

       private
       public :: stop_clock
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_stop_clock;              end interface
       interface delete;                 module procedure delete_stop_clock;                 end interface
       interface display;                module procedure display_stop_clock;                end interface
       interface display_short;          module procedure display_short_stop_clock;          end interface
       interface display;                module procedure display_wrap_stop_clock;           end interface
       interface print;                  module procedure print_stop_clock;                  end interface
       interface print_short;            module procedure print_short_stop_clock;            end interface
       interface export;                 module procedure export_stop_clock;                 end interface
       interface export_primitives;      module procedure export_primitives_stop_clock;      end interface
       interface import;                 module procedure import_stop_clock;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_stop_clock;end interface
       interface export_structured;      module procedure export_structured_D_stop_clock;    end interface
       interface import_structured;      module procedure import_structured_D_stop_clock;    end interface
       interface import_primitives;      module procedure import_primitives_stop_clock;      end interface
       interface export;                 module procedure export_wrap_stop_clock;            end interface
       interface import;                 module procedure import_wrap_stop_clock;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_stop_clock;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_stop_clock;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_stop_clock;      end interface
       interface export;                 module procedure export_DN_stop_clock;              end interface
       interface import;                 module procedure import_DN_stop_clock;              end interface
       interface export_structured;      module procedure export_structured_DN_stop_clock;   end interface
       interface import_structured;      module procedure import_structured_DN_stop_clock;   end interface

       type stop_clock
         type(string) :: dir
         type(string) :: name
         type(string) :: dir_tec
         type(string) :: name_tec
         type(clock) :: c
         type(unit_conversion) :: uc
         real(cp) :: percentage_complete_RB = 0.0_cp
         real(cp) :: percentage_complete_SB = 0.0_cp
         real(cp) :: seconds_per_step = 0.0_cp
         real(cp) :: sim_time_per_sec = 0.0_cp
         real(cp) :: t_passed = 0.0_cp
         real(cp) :: estimated_total = 0.0_cp
         real(cp) :: estimated_remaining = 0.0_cp
         real(cp) :: percentage_complete = 0.0_cp
         real(cp) :: percentage_complete_wc = 0.0_cp
         real(cp) :: t_elapsed = 0.0_cp
         logical :: frozen_elapsed = .false.
         integer :: un_plot = 0
       end type

       contains

       subroutine init_copy_stop_clock(this,that)
         implicit none
         type(stop_clock),intent(inout) :: this
         type(stop_clock),intent(in) :: that
         call delete(this)
         call init(this%dir,that%dir)
         call init(this%name,that%name)
         call init(this%dir_tec,that%dir_tec)
         call init(this%name_tec,that%name_tec)
         call init(this%c,that%c)
         call init(this%uc,that%uc)
         this%percentage_complete_RB = that%percentage_complete_RB
         this%percentage_complete_SB = that%percentage_complete_SB
         this%seconds_per_step = that%seconds_per_step
         this%sim_time_per_sec = that%sim_time_per_sec
         this%t_passed = that%t_passed
         this%estimated_total = that%estimated_total
         this%estimated_remaining = that%estimated_remaining
         this%percentage_complete = that%percentage_complete
         this%percentage_complete_wc = that%percentage_complete_wc
         this%t_elapsed = that%t_elapsed
         this%frozen_elapsed = that%frozen_elapsed
         this%un_plot = that%un_plot
       end subroutine

       subroutine delete_stop_clock(this)
         implicit none
         type(stop_clock),intent(inout) :: this
         call delete(this%dir)
         call delete(this%name)
         call delete(this%dir_tec)
         call delete(this%name_tec)
         call delete(this%c)
         call delete(this%uc)
         this%percentage_complete_RB = 0.0_cp
         this%percentage_complete_SB = 0.0_cp
         this%seconds_per_step = 0.0_cp
         this%sim_time_per_sec = 0.0_cp
         this%t_passed = 0.0_cp
         this%estimated_total = 0.0_cp
         this%estimated_remaining = 0.0_cp
         this%percentage_complete = 0.0_cp
         this%percentage_complete_wc = 0.0_cp
         this%t_elapsed = 0.0_cp
         this%frozen_elapsed = .false.
         this%un_plot = 0
       end subroutine

       subroutine display_stop_clock(this,un)
         implicit none
         type(stop_clock),intent(in) :: this
         integer,intent(in) :: un
         call display(this%dir,un)
         call display(this%name,un)
         call display(this%dir_tec,un)
         call display(this%name_tec,un)
         call display(this%c,un)
         call display(this%uc,un)
         write(un,*) 'percentage_complete_RB = ',this%percentage_complete_RB
         write(un,*) 'percentage_complete_SB = ',this%percentage_complete_SB
         write(un,*) 'seconds_per_step       = ',this%seconds_per_step
         write(un,*) 'sim_time_per_sec       = ',this%sim_time_per_sec
         write(un,*) 't_passed               = ',this%t_passed
         write(un,*) 'estimated_total        = ',this%estimated_total
         write(un,*) 'estimated_remaining    = ',this%estimated_remaining
         write(un,*) 'percentage_complete    = ',this%percentage_complete
         write(un,*) 'percentage_complete_wc = ',this%percentage_complete_wc
         write(un,*) 't_elapsed              = ',this%t_elapsed
         write(un,*) 'frozen_elapsed         = ',this%frozen_elapsed
         write(un,*) 'un_plot                = ',this%un_plot
       end subroutine

       subroutine display_short_stop_clock(this,un)
         implicit none
         type(stop_clock),intent(in) :: this
         integer,intent(in) :: un
         call display(this%dir,un)
         call display(this%name,un)
         call display(this%dir_tec,un)
         call display(this%name_tec,un)
         call display(this%c,un)
         call display(this%uc,un)
         write(un,*) 'percentage_complete_RB = ',this%percentage_complete_RB
         write(un,*) 'percentage_complete_SB = ',this%percentage_complete_SB
         write(un,*) 'seconds_per_step       = ',this%seconds_per_step
         write(un,*) 'sim_time_per_sec       = ',this%sim_time_per_sec
         write(un,*) 't_passed               = ',this%t_passed
         write(un,*) 'estimated_total        = ',this%estimated_total
         write(un,*) 'estimated_remaining    = ',this%estimated_remaining
         write(un,*) 'percentage_complete    = ',this%percentage_complete
         write(un,*) 'percentage_complete_wc = ',this%percentage_complete_wc
         write(un,*) 't_elapsed              = ',this%t_elapsed
         write(un,*) 'frozen_elapsed         = ',this%frozen_elapsed
         write(un,*) 'un_plot                = ',this%un_plot
       end subroutine

       subroutine display_wrap_stop_clock(this,dir,name)
         implicit none
         type(stop_clock),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_stop_clock(this)
         implicit none
         type(stop_clock),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_stop_clock(this)
         implicit none
         type(stop_clock),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_stop_clock(this,un)
         implicit none
         type(stop_clock),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%dir,un)
         call export(this%name,un)
         call export(this%dir_tec,un)
         call export(this%name_tec,un)
         call export(this%c,un)
         call export(this%uc,un)
       end subroutine

       subroutine import_stop_clock(this,un)
         implicit none
         type(stop_clock),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%dir,un)
         call import(this%name,un)
         call import(this%dir_tec,un)
         call import(this%name_tec,un)
         call import(this%c,un)
         call import(this%uc,un)
       end subroutine

       subroutine export_primitives_stop_clock(this,un)
         implicit none
         type(stop_clock),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'percentage_complete_RB  = ';write(un,*) this%percentage_complete_RB
         write(un,*) 'percentage_complete_SB  = ';write(un,*) this%percentage_complete_SB
         write(un,*) 'seconds_per_step        = ';write(un,*) this%seconds_per_step
         write(un,*) 'sim_time_per_sec        = ';write(un,*) this%sim_time_per_sec
         write(un,*) 't_passed                = ';write(un,*) this%t_passed
         write(un,*) 'estimated_total         = ';write(un,*) this%estimated_total
         write(un,*) 'estimated_remaining     = ';write(un,*) this%estimated_remaining
         write(un,*) 'percentage_complete     = ';write(un,*) this%percentage_complete
         write(un,*) 'percentage_complete_wc  = ';write(un,*) this%percentage_complete_wc
         write(un,*) 't_elapsed               = ';write(un,*) this%t_elapsed
         write(un,*) 'frozen_elapsed          = ';write(un,*) this%frozen_elapsed
         write(un,*) 'un_plot                 = ';write(un,*) this%un_plot
       end subroutine

       subroutine import_primitives_stop_clock(this,un)
         implicit none
         type(stop_clock),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%percentage_complete_RB
         read(un,*); read(un,*) this%percentage_complete_SB
         read(un,*); read(un,*) this%seconds_per_step
         read(un,*); read(un,*) this%sim_time_per_sec
         read(un,*); read(un,*) this%t_passed
         read(un,*); read(un,*) this%estimated_total
         read(un,*); read(un,*) this%estimated_remaining
         read(un,*); read(un,*) this%percentage_complete
         read(un,*); read(un,*) this%percentage_complete_wc
         read(un,*); read(un,*) this%t_elapsed
         read(un,*); read(un,*) this%frozen_elapsed
         read(un,*); read(un,*) this%un_plot
       end subroutine

       subroutine export_wrap_stop_clock(this,dir,name)
         implicit none
         type(stop_clock),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_stop_clock(this,dir,name)
         implicit none
         type(stop_clock),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_stop_clock(this)
         implicit none
         type(stop_clock),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_stop_clock(this)
         implicit none
         type(stop_clock),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_stop_clock(this)
         implicit none
         type(stop_clock),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         call export_structured(this%dir_tec,&
         str(this%dir)//'dir_tec'//fortran_PS)
         call export_structured(this%name_tec,&
         str(this%dir)//'name_tec'//fortran_PS)
         call export_structured(this%c,str(this%dir)//'c'//fortran_PS)
         call export_structured(this%uc,str(this%dir)//'uc'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_stop_clock(this)
         implicit none
         type(stop_clock),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         call import_structured(this%dir_tec,&
         str(this%dir)//'dir_tec'//fortran_PS)
         call import_structured(this%name_tec,&
         str(this%dir)//'name_tec'//fortran_PS)
         call import_structured(this%c,str(this%dir)//'c'//fortran_PS)
         call import_structured(this%uc,str(this%dir)//'uc'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_stop_clock(this,dir)
         implicit none
         type(stop_clock),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
         call set_IO_dir(this%dir_tec,dir//'dir_tec'//fortran_PS)
         call set_IO_dir(this%name_tec,dir//'name_tec'//fortran_PS)
         call set_IO_dir(this%c,dir//'c'//fortran_PS)
         call set_IO_dir(this%uc,dir//'uc'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_stop_clock(this,dir)
         implicit none
         type(stop_clock),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
         call make_IO_dir(this%dir_tec,dir//'dir_tec'//fortran_PS)
         call make_IO_dir(this%name_tec,dir//'name_tec'//fortran_PS)
         call make_IO_dir(this%c,dir//'c'//fortran_PS)
         call make_IO_dir(this%uc,dir//'uc'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_stop_clock(this,dir)
         implicit none
         type(stop_clock),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         call export_structured(this%dir_tec,dir//'dir_tec'//fortran_PS)
         call export_structured(this%name_tec,dir//'name_tec'//fortran_PS)
         call export_structured(this%c,dir//'c'//fortran_PS)
         call export_structured(this%uc,dir//'uc'//fortran_PS)
       end subroutine

       subroutine export_structured_D_stop_clock(this,dir)
         implicit none
         type(stop_clock),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         call export_structured(this%dir_tec,dir//'dir_tec'//fortran_PS)
         call export_structured(this%name_tec,dir//'name_tec'//fortran_PS)
         call export_structured(this%c,dir//'c'//fortran_PS)
         call export_structured(this%uc,dir//'uc'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_stop_clock(this,dir)
         implicit none
         type(stop_clock),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         call import_structured(this%dir_tec,dir//'dir_tec'//fortran_PS)
         call import_structured(this%name_tec,dir//'name_tec'//fortran_PS)
         call import_structured(this%c,dir//'c'//fortran_PS)
         call import_structured(this%uc,dir//'uc'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_stop_clock(this)
         implicit none
         type(stop_clock),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module sub_domain_mod
       use datatype_conversion_mod
       use overlap_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: sub_domain
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_sub_domain;              end interface
       interface delete;                 module procedure delete_sub_domain;                 end interface
       interface display;                module procedure display_sub_domain;                end interface
       interface display_short;          module procedure display_short_sub_domain;          end interface
       interface display;                module procedure display_wrap_sub_domain;           end interface
       interface print;                  module procedure print_sub_domain;                  end interface
       interface print_short;            module procedure print_short_sub_domain;            end interface
       interface export;                 module procedure export_sub_domain;                 end interface
       interface export_primitives;      module procedure export_primitives_sub_domain;      end interface
       interface import;                 module procedure import_sub_domain;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_sub_domain;end interface
       interface export_structured;      module procedure export_structured_D_sub_domain;    end interface
       interface import_structured;      module procedure import_structured_D_sub_domain;    end interface
       interface import_primitives;      module procedure import_primitives_sub_domain;      end interface
       interface export;                 module procedure export_wrap_sub_domain;            end interface
       interface import;                 module procedure import_wrap_sub_domain;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_sub_domain;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_sub_domain;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_sub_domain;      end interface

       type sub_domain
         type(overlap),dimension(3) :: C
         type(overlap),dimension(3) :: N
         type(overlap),dimension(3) :: M
         logical :: defined = .false.
         integer :: g_R1_id = 0
         integer :: g_R2_id = 0
       end type

       contains

       subroutine init_copy_sub_domain(this,that)
         implicit none
         type(sub_domain),intent(inout) :: this
         type(sub_domain),intent(in) :: that
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         call delete(this)
         s_C = size(that%C)
         do i_C=1,s_C
           call init(this%C(i_C),that%C(i_C))
         enddo
         s_N = size(that%N)
         do i_N=1,s_N
           call init(this%N(i_N),that%N(i_N))
         enddo
         s_M = size(that%M)
         do i_M=1,s_M
           call init(this%M(i_M),that%M(i_M))
         enddo
         this%defined = that%defined
         this%g_R1_id = that%g_R1_id
         this%g_R2_id = that%g_R2_id
       end subroutine

       subroutine delete_sub_domain(this)
         implicit none
         type(sub_domain),intent(inout) :: this
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         s_C = size(this%C)
         do i_C=1,s_C
           call delete(this%C(i_C))
         enddo
         s_N = size(this%N)
         do i_N=1,s_N
           call delete(this%N(i_N))
         enddo
         s_M = size(this%M)
         do i_M=1,s_M
           call delete(this%M(i_M))
         enddo
         this%defined = .false.
         this%g_R1_id = 0
         this%g_R2_id = 0
       end subroutine

       subroutine display_sub_domain(this,un)
         implicit none
         type(sub_domain),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         s_C = size(this%C)
         do i_C=1,s_C
           call display(this%C(i_C),un)
         enddo
         s_N = size(this%N)
         do i_N=1,s_N
           call display(this%N(i_N),un)
         enddo
         s_M = size(this%M)
         do i_M=1,s_M
           call display(this%M(i_M),un)
         enddo
         write(un,*) 'defined = ',this%defined
         write(un,*) 'g_R1_id = ',this%g_R1_id
         write(un,*) 'g_R2_id = ',this%g_R2_id
       end subroutine

       subroutine display_short_sub_domain(this,un)
         implicit none
         type(sub_domain),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         s_C = size(this%C)
         do i_C=1,s_C
           call display(this%C(i_C),un)
         enddo
         s_N = size(this%N)
         do i_N=1,s_N
           call display(this%N(i_N),un)
         enddo
         s_M = size(this%M)
         do i_M=1,s_M
           call display(this%M(i_M),un)
         enddo
         write(un,*) 'defined = ',this%defined
         write(un,*) 'g_R1_id = ',this%g_R1_id
         write(un,*) 'g_R2_id = ',this%g_R2_id
       end subroutine

       subroutine display_wrap_sub_domain(this,dir,name)
         implicit none
         type(sub_domain),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_sub_domain(this)
         implicit none
         type(sub_domain),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_sub_domain(this)
         implicit none
         type(sub_domain),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_sub_domain(this,un)
         implicit none
         type(sub_domain),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         call export_primitives(this,un)
         s_C = size(this%C)
         write(un,*) s_C
         do i_C=1,s_C
           call export(this%C(i_C),un)
         enddo
         s_N = size(this%N)
         write(un,*) s_N
         do i_N=1,s_N
           call export(this%N(i_N),un)
         enddo
         s_M = size(this%M)
         write(un,*) s_M
         do i_M=1,s_M
           call export(this%M(i_M),un)
         enddo
       end subroutine

       subroutine import_sub_domain(this,un)
         implicit none
         type(sub_domain),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_C
         if (s_C.gt.0) then
           do i_C=1,s_C
             call import(this%C(i_C),un)
           enddo
         endif
         read(un,*) s_N
         if (s_N.gt.0) then
           do i_N=1,s_N
             call import(this%N(i_N),un)
           enddo
         endif
         read(un,*) s_M
         if (s_M.gt.0) then
           do i_M=1,s_M
             call import(this%M(i_M),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_sub_domain(this,un)
         implicit none
         type(sub_domain),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined  = ';write(un,*) this%defined
         write(un,*) 'g_R1_id  = ';write(un,*) this%g_R1_id
         write(un,*) 'g_R2_id  = ';write(un,*) this%g_R2_id
       end subroutine

       subroutine import_primitives_sub_domain(this,un)
         implicit none
         type(sub_domain),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%defined
         read(un,*); read(un,*) this%g_R1_id
         read(un,*); read(un,*) this%g_R2_id
       end subroutine

       subroutine export_wrap_sub_domain(this,dir,name)
         implicit none
         type(sub_domain),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_sub_domain(this,dir,name)
         implicit none
         type(sub_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_sub_domain(this,dir)
         implicit none
         type(sub_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         call suppress_warnings(this)
         s_C = size(this%C)
         do i_C=1,s_C
           call set_IO_dir(this%C(i_C),dir//'C_'//int2str(i_C)//fortran_PS)
         enddo
         s_N = size(this%N)
         do i_N=1,s_N
           call set_IO_dir(this%N(i_N),dir//'N_'//int2str(i_N)//fortran_PS)
         enddo
         s_M = size(this%M)
         do i_M=1,s_M
           call set_IO_dir(this%M(i_M),dir//'M_'//int2str(i_M)//fortran_PS)
         enddo
       end subroutine

       subroutine make_IO_dir_sub_domain(this,dir)
         implicit none
         type(sub_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         s_C = size(this%C)
         do i_C=1,s_C
           call make_IO_dir(this%C(i_C),dir//'C_'//int2str(i_C)//fortran_PS)
         enddo
         s_N = size(this%N)
         do i_N=1,s_N
           call make_IO_dir(this%N(i_N),dir//'N_'//int2str(i_N)//fortran_PS)
         enddo
         s_M = size(this%M)
         do i_M=1,s_M
           call make_IO_dir(this%M(i_M),dir//'M_'//int2str(i_M)//fortran_PS)
         enddo
       end subroutine

       subroutine export_folder_structure_sub_domain(this,dir)
         implicit none
         type(sub_domain),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         integer :: un
         s_C = size(this%C)
         write(un,*) s_C
         do i_C=1,s_C
           call export_structured(this%C(i_C),&
           dir//'C_'//int2str(i_C)//fortran_PS)
         enddo
         s_N = size(this%N)
         write(un,*) s_N
         do i_N=1,s_N
           call export_structured(this%N(i_N),&
           dir//'N_'//int2str(i_N)//fortran_PS)
         enddo
         s_M = size(this%M)
         write(un,*) s_M
         do i_M=1,s_M
           call export_structured(this%M(i_M),&
           dir//'M_'//int2str(i_M)//fortran_PS)
         enddo
       end subroutine

       subroutine export_structured_D_sub_domain(this,dir)
         implicit none
         type(sub_domain),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         s_C = size(this%C)
         write(un,*) s_C
         do i_C=1,s_C
           call export_structured(this%C(i_C),&
           dir//'C_'//int2str(i_C)//fortran_PS)
         enddo
         s_N = size(this%N)
         write(un,*) s_N
         do i_N=1,s_N
           call export_structured(this%N(i_N),&
           dir//'N_'//int2str(i_N)//fortran_PS)
         enddo
         s_M = size(this%M)
         write(un,*) s_M
         do i_M=1,s_M
           call export_structured(this%M(i_M),&
           dir//'M_'//int2str(i_M)//fortran_PS)
         enddo
         close(un)
       end subroutine

       subroutine import_structured_D_sub_domain(this,dir)
         implicit none
         type(sub_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_C
         integer :: i_N
         integer :: i_M
         integer :: s_C
         integer :: s_N
         integer :: s_M
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         s_C = size(this%C)
         do i_C=1,s_C
           call import_structured(this%C(i_C),&
           dir//'C_'//int2str(i_C)//fortran_PS)
         enddo
         s_N = size(this%N)
         do i_N=1,s_N
           call import_structured(this%N(i_N),&
           dir//'N_'//int2str(i_N)//fortran_PS)
         enddo
         s_M = size(this%M)
         do i_M=1,s_M
           call import_structured(this%M(i_M),&
           dir//'M_'//int2str(i_M)//fortran_PS)
         enddo
         close(un)
       end subroutine

       subroutine suppress_warnings_sub_domain(this)
         implicit none
         type(sub_domain),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module time_statistics_params_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use stats_period_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: time_statistics_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_time_statistics_params;              end interface
       interface delete;                 module procedure delete_time_statistics_params;                 end interface
       interface display;                module procedure display_time_statistics_params;                end interface
       interface display_short;          module procedure display_short_time_statistics_params;          end interface
       interface display;                module procedure display_wrap_time_statistics_params;           end interface
       interface print;                  module procedure print_time_statistics_params;                  end interface
       interface print_short;            module procedure print_short_time_statistics_params;            end interface
       interface export;                 module procedure export_time_statistics_params;                 end interface
       interface export_primitives;      module procedure export_primitives_time_statistics_params;      end interface
       interface import;                 module procedure import_time_statistics_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_time_statistics_params;end interface
       interface export_structured;      module procedure export_structured_D_time_statistics_params;    end interface
       interface import_structured;      module procedure import_structured_D_time_statistics_params;    end interface
       interface import_primitives;      module procedure import_primitives_time_statistics_params;      end interface
       interface export;                 module procedure export_wrap_time_statistics_params;            end interface
       interface import;                 module procedure import_wrap_time_statistics_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_time_statistics_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_time_statistics_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_time_statistics_params;      end interface

       type time_statistics_params
         logical :: collect = .false.
         type(stats_period) :: O1_stats
         type(stats_period) :: O2_stats
       end type

       contains

       subroutine init_copy_time_statistics_params(this,that)
         implicit none
         type(time_statistics_params),intent(inout) :: this
         type(time_statistics_params),intent(in) :: that
         call delete(this)
         this%collect = that%collect
         call init(this%O1_stats,that%O1_stats)
         call init(this%O2_stats,that%O2_stats)
       end subroutine

       subroutine delete_time_statistics_params(this)
         implicit none
         type(time_statistics_params),intent(inout) :: this
         this%collect = .false.
         call delete(this%O1_stats)
         call delete(this%O2_stats)
       end subroutine

       subroutine display_time_statistics_params(this,un)
         implicit none
         type(time_statistics_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'collect  = ',this%collect
         call display(this%O1_stats,un)
         call display(this%O2_stats,un)
       end subroutine

       subroutine display_short_time_statistics_params(this,un)
         implicit none
         type(time_statistics_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'collect  = ',this%collect
         call display(this%O1_stats,un)
         call display(this%O2_stats,un)
       end subroutine

       subroutine display_wrap_time_statistics_params(this,dir,name)
         implicit none
         type(time_statistics_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_time_statistics_params(this)
         implicit none
         type(time_statistics_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_time_statistics_params(this)
         implicit none
         type(time_statistics_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_time_statistics_params(this,un)
         implicit none
         type(time_statistics_params),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%O1_stats,un)
         call export(this%O2_stats,un)
       end subroutine

       subroutine import_time_statistics_params(this,un)
         implicit none
         type(time_statistics_params),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%O1_stats,un)
         call import(this%O2_stats,un)
       end subroutine

       subroutine export_primitives_time_statistics_params(this,un)
         implicit none
         type(time_statistics_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'collect   = ';write(un,*) this%collect
       end subroutine

       subroutine import_primitives_time_statistics_params(this,un)
         implicit none
         type(time_statistics_params),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%collect
       end subroutine

       subroutine export_wrap_time_statistics_params(this,dir,name)
         implicit none
         type(time_statistics_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_time_statistics_params(this,dir,name)
         implicit none
         type(time_statistics_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_time_statistics_params(this,dir)
         implicit none
         type(time_statistics_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%O1_stats,dir//'O1_stats'//fortran_PS)
         call set_IO_dir(this%O2_stats,dir//'O2_stats'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_time_statistics_params(this,dir)
         implicit none
         type(time_statistics_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%O1_stats,dir//'O1_stats'//fortran_PS)
         call make_IO_dir(this%O2_stats,dir//'O2_stats'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_time_statistics_params(this,dir)
         implicit none
         type(time_statistics_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%O1_stats,dir//'O1_stats'//fortran_PS)
         call export_structured(this%O2_stats,dir//'O2_stats'//fortran_PS)
       end subroutine

       subroutine export_structured_D_time_statistics_params(this,dir)
         implicit none
         type(time_statistics_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%O1_stats,dir//'O1_stats'//fortran_PS)
         call export_structured(this%O2_stats,dir//'O2_stats'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_time_statistics_params(this,dir)
         implicit none
         type(time_statistics_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%O1_stats,dir//'O1_stats'//fortran_PS)
         call import_structured(this%O2_stats,dir//'O2_stats'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_time_statistics_params(this)
         implicit none
         type(time_statistics_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module unit_conversion_extend_mod
       use unit_conversion_mod
       use current_precision_mod
       implicit none

       private
       public :: init
       interface init;   module procedure init_uc;       end interface

       contains

       subroutine init_uc(uc)
         implicit none
         type(unit_conversion),intent(inout) :: uc
         uc%days_per_year      = 365.2422_cp ! Includes leap year
         uc%seconds_per_second = 1.0_cp

         uc%seconds_per_minute = 60.0_cp
         uc%seconds_per_hour   = 60.0_cp*60.0_cp
         uc%seconds_per_day    = 60.0_cp*60.0_cp*24.0_cp
         uc%seconds_per_year   = uc%seconds_per_day*uc%days_per_year

         uc%minute_per_seconds = 1.0_cp/uc%seconds_per_minute
         uc%hour_per_seconds   = 1.0_cp/uc%seconds_per_hour
         uc%day_per_seconds    = 1.0_cp/uc%seconds_per_day
         uc%year_per_seconds   = 1.0_cp/uc%seconds_per_year
       end subroutine

       end module
       module RK_params_extend_mod
       ! Pre-processor directives: (_DEBUG_RK_PARAMS_)
       use RK_Params_mod
       use array_mod
       use array_extend_mod
       use current_precision_mod
       implicit none

       private
       public :: init,print
       public :: assign_stage
       public :: update_time

       interface init;               module procedure init_RKP;               end interface
       interface print;              module procedure print_RKP_location;     end interface
       interface assign_stage;       module procedure assign_stage_RKP;       end interface
       interface update_time;        module procedure update_time_RKP;        end interface

#ifdef _DEBUG_RK_PARAMS_
       interface insist_allocated;   module procedure insist_allocated_RKP;   end interface
#endif

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_RKP(RKP,n_stages,RK_active)
         ! Coefficients taken from:
         ! Lundbladh, Anders, et al. "An efficient spectral method
         ! for simulation of incompressible flow over a flat plate."
         ! Trita-mek. Tech. Rep 11 (1999).
         implicit none
         type(RK_Params),intent(inout) :: RKP
         integer,intent(in) :: n_stages
         logical,intent(in) :: RK_active
         call delete(RKP)
         RKP%RK_active = RK_active
         if (RK_active) then; RKP%n_stages = n_stages
         else;                RKP%n_stages = 1
         endif
         call verify_valid_order(n_stages,'init_RKP')
         RKP%n = 1
         call init(RKP%gamma,RKP%n_stages)
         call init(RKP%zeta,RKP%n_stages)
         call init(RKP%alpha,RKP%n_stages)
         call init(RKP%beta,RKP%n_stages)
         if (.not.RK_active) then
         RKP%gamma%f = 1.0_cp
         RKP%zeta%f = 1.0_cp
         RKP%alpha%f = 1.0_cp
         RKP%beta%f = 1.0_cp
         elseif (RKP%n_stages.eq.3) then
         RKP%gamma%f(1) = 8.0_cp/15.0_cp;  RKP%zeta%f(1) =  0.0_cp        ; RKP%alpha%f(1) = 4.0_cp/15.0_cp
         RKP%gamma%f(2) = 5.0_cp/12.0_cp;  RKP%zeta%f(2) =-17.0_cp/60.0_cp; RKP%alpha%f(2) = 1.0_cp/15.0_cp
         RKP%gamma%f(3) = 3.0_cp/ 4.0_cp;  RKP%zeta%f(3) =- 5.0_cp/12.0_cp; RKP%alpha%f(3) = 1.0_cp/ 6.0_cp
         RKP%beta%f = RKP%alpha%f
         else; stop 'Error: bad input to init_RKP in RK_Params.f90'
         endif
       end subroutine

       subroutine print_RKP_location(RKP,message)
         implicit none
         character(len=*),intent(in) :: message
         type(RK_Params),intent(in) :: RKP
         write(*,*) message
         call display(RKP,6)
       end subroutine

       subroutine update_time_RKP(RKP,t,dt)
         implicit none
         type(RK_Params),intent(in) :: RKP
         real(cp),intent(inout) :: t
         real(cp),intent(in) :: dt
#ifdef _DEBUG_RK_PARAMS_
         call insist_allocated(RKP)
#endif
         if (RKP%RK_active) then; t = t + RKP%alpha%f(RKP%n)*dt
         else;                    t = t + dt
         endif
       end subroutine

       subroutine assign_stage_RKP(RKP,n)
         implicit none
         type(RK_Params),intent(inout) :: RKP
         integer,intent(in) :: n
         RKP%n = n
       end subroutine

#ifdef _DEBUG_RK_PARAMS_
       subroutine insist_allocated_RKP(RKP)
         implicit none
         type(RK_Params),intent(in) :: RKP
         call insist_allocated(RKP%gamma,'insist_allocated_RKP')
         call insist_allocated(RKP%zeta,'insist_allocated_RKP')
         call insist_allocated(RKP%alpha,'insist_allocated_RKP')
         call insist_allocated(RKP%beta,'insist_allocated_RKP')
       end subroutine
#endif

       subroutine verify_valid_order(n_stages,location)
         implicit none
         character(len=*),intent(in) :: location
         integer,intent(in) :: n_stages
         if ((n_stages.ne.3).and.(n_stages.ne.4)) then
           write(*,*) 'Error: bad n_stages in '//location
           write(*,*) 'Done in RK_Params.f90'
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module boundary_mod
       use datatype_conversion_mod
       use single_boundary_mod
       use IO_tools_mod
       use string_mod
       use BC_logicals_mod
       use dir_manip_mod
       implicit none

       private
       public :: boundary
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_boundary;              end interface
       interface delete;                 module procedure delete_boundary;                 end interface
       interface display;                module procedure display_boundary;                end interface
       interface display_short;          module procedure display_short_boundary;          end interface
       interface display;                module procedure display_wrap_boundary;           end interface
       interface print;                  module procedure print_boundary;                  end interface
       interface print_short;            module procedure print_short_boundary;            end interface
       interface export;                 module procedure export_boundary;                 end interface
       interface export_primitives;      module procedure export_primitives_boundary;      end interface
       interface import;                 module procedure import_boundary;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_boundary;end interface
       interface export_structured;      module procedure export_structured_D_boundary;    end interface
       interface import_structured;      module procedure import_structured_D_boundary;    end interface
       interface import_primitives;      module procedure import_primitives_boundary;      end interface
       interface export;                 module procedure export_wrap_boundary;            end interface
       interface import;                 module procedure import_wrap_boundary;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_boundary;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_boundary;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_boundary;      end interface

       type boundary
         type(BC_logicals) :: BCL
         integer :: n = 0
         type(single_boundary),dimension(:),allocatable :: SB
         type(string) :: name
       end type

       contains

       subroutine init_copy_boundary(this,that)
         implicit none
         type(boundary),intent(inout) :: this
         type(boundary),intent(in) :: that
         integer :: i_SB
         integer :: s_SB
         call delete(this)
         call init(this%BCL,that%BCL)
         this%n = that%n
         if (allocated(that%SB)) then
           s_SB = size(that%SB)
           if (s_SB.gt.0) then
             allocate(this%SB(s_SB))
             do i_SB=1,s_SB
               call init(this%SB(i_SB),that%SB(i_SB))
             enddo
           endif
         endif
         call init(this%name,that%name)
       end subroutine

       subroutine delete_boundary(this)
         implicit none
         type(boundary),intent(inout) :: this
         integer :: i_SB
         integer :: s_SB
         call delete(this%BCL)
         this%n = 0
         if (allocated(this%SB)) then
           s_SB = size(this%SB)
           do i_SB=1,s_SB
             call delete(this%SB(i_SB))
           enddo
           deallocate(this%SB)
         endif
         call delete(this%name)
       end subroutine

       subroutine display_boundary(this,un)
         implicit none
         type(boundary),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_SB
         integer :: s_SB
         call display(this%BCL,un)
         write(un,*) 'n    = ',this%n
         if (allocated(this%SB)) then
           s_SB = size(this%SB)
           do i_SB=1,s_SB
             call display(this%SB(i_SB),un)
           enddo
         endif
         call display(this%name,un)
       end subroutine

       subroutine display_short_boundary(this,un)
         implicit none
         type(boundary),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_SB
         integer :: s_SB
         call display(this%BCL,un)
         write(un,*) 'n    = ',this%n
         if (allocated(this%SB)) then
           s_SB = size(this%SB)
           do i_SB=1,s_SB
             call display(this%SB(i_SB),un)
           enddo
         endif
         call display(this%name,un)
       end subroutine

       subroutine display_wrap_boundary(this,dir,name)
         implicit none
         type(boundary),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_boundary(this)
         implicit none
         type(boundary),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_boundary(this)
         implicit none
         type(boundary),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_boundary(this,un)
         implicit none
         type(boundary),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_SB
         integer :: s_SB
         call export_primitives(this,un)
         call export(this%BCL,un)
         if (allocated(this%SB)) then
           s_SB = size(this%SB)
           write(un,*) s_SB
           if (s_SB.gt.0) then
             do i_SB=1,s_SB
               call export(this%SB(i_SB),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
         call export(this%name,un)
       end subroutine

       subroutine import_boundary(this,un)
         implicit none
         type(boundary),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_SB
         integer :: s_SB
         call delete(this)
         call import_primitives(this,un)
         call import(this%BCL,un)
         read(un,*) s_SB
         if (s_SB.gt.0) then
           allocate(this%SB(s_SB))
           do i_SB=1,s_SB
             call import(this%SB(i_SB),un)
           enddo
         endif
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_boundary(this,un)
         implicit none
         type(boundary),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'n     = ';write(un,*) this%n
       end subroutine

       subroutine import_primitives_boundary(this,un)
         implicit none
         type(boundary),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%n
       end subroutine

       subroutine export_wrap_boundary(this,dir,name)
         implicit none
         type(boundary),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_boundary(this,dir,name)
         implicit none
         type(boundary),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_boundary(this,dir)
         implicit none
         type(boundary),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SB
         integer :: s_SB
         call suppress_warnings(this)
         call set_IO_dir(this%BCL,dir//'BCL'//fortran_PS)
         if (allocated(this%SB)) then
           s_SB = size(this%SB)
           do i_SB=1,s_SB
             call set_IO_dir(this%SB(i_SB),&
             dir//'SB_'//int2str(i_SB)//fortran_PS)
           enddo
         endif
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_boundary(this,dir)
         implicit none
         type(boundary),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SB
         integer :: s_SB
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%BCL,dir//'BCL'//fortran_PS)
         if (allocated(this%SB)) then
           s_SB = size(this%SB)
           do i_SB=1,s_SB
             call make_IO_dir(this%SB(i_SB),&
             dir//'SB_'//int2str(i_SB)//fortran_PS)
           enddo
         endif
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_boundary(this,dir)
         implicit none
         type(boundary),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SB
         integer :: s_SB
         integer :: un
         call export_structured(this%BCL,dir//'BCL'//fortran_PS)
         if (allocated(this%SB)) then
           s_SB = size(this%SB)
           write(un,*) s_SB
           do i_SB=1,s_SB
             call export_structured(this%SB(i_SB),&
             dir//'SB_'//int2str(i_SB)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_boundary(this,dir)
         implicit none
         type(boundary),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SB
         integer :: s_SB
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%BCL,dir//'BCL'//fortran_PS)
         if (allocated(this%SB)) then
           s_SB = size(this%SB)
           write(un,*) s_SB
           do i_SB=1,s_SB
             call export_structured(this%SB(i_SB),&
             dir//'SB_'//int2str(i_SB)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_boundary(this,dir)
         implicit none
         type(boundary),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SB
         integer :: s_SB
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%BCL,dir//'BCL'//fortran_PS)
         read(un,*) s_SB
         if (s_SB.gt.0) then
           if (.not.allocated(this%SB)) then
             allocate(this%SB(s_SB))
           endif
           do i_SB=1,s_SB
             call import_structured(this%SB(i_SB),&
             dir//'SB_'//int2str(i_SB)//fortran_PS)
           enddo
         endif
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_boundary(this)
         implicit none
         type(boundary),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module construct_suffix_mod
      use string_mod
      use data_location_extend_mod
      use face_edge_corner_indexing_mod
      use datatype_conversion_mod
      implicit none

      private
      public :: construct_suffix
      interface construct_suffix; module procedure construct_suffix_SF; end interface
      interface construct_suffix; module procedure construct_suffix_VF; end interface

      contains

      subroutine construct_suffix_SF(s,name,DL)
        implicit none
        type(string),intent(inout) :: s
        type(data_location),intent(in) :: DL
        character(len=*),intent(in) :: name
        call init(s,name//get_char(DL))
            if (is_Face(DL)) then; call append(s,'_'//xyz_given_dir(get_Face(DL)))
        elseif (is_Edge(DL)) then; call append(s,'_'//xyz_given_dir(get_Edge(DL)))
        endif
      end subroutine

      subroutine construct_suffix_VF(s,name,DL)
        implicit none
        type(string),intent(inout) :: s
        type(data_location),intent(in),dimension(3) :: DL
        character(len=*),intent(in) :: name
#ifdef _DEBUG_IO_EXPORT_
        call insist_collocated(DL,'construct_name_VF')
#endif

        call init(s,name//get_char(DL(1)))
        if (is_Face(DL(1))) call append(s,'_'//xyz_given_dir(get_Face(DL(1))))
        if (is_Edge(DL(1))) call append(s,'_'//xyz_given_dir(get_Edge(DL(1))))
      end subroutine

      end module
       module coordinate_distribution_funcs_iterate_mod
       use current_precision_mod
       use array_mod
       use array_extend_mod
       use mesh_quality_params_mod
       use coordinate_distribution_funcs_mod
       implicit none

       private
       public :: uniform_iterate
       public :: linspace_iterate
       public :: uniformLeft_iterate
       public :: uniformRight_iterate
       public :: robertsLeft_iterate
       public :: robertsRight_iterate
       public :: robertsBoth_iterate
       public :: cluster_iterate
       public :: needs_more_points
       interface uniform_iterate;      module procedure uniform_A;              end interface
       interface linspace_iterate;     module procedure linspace_A;             end interface
       interface uniformLeft_iterate;  module procedure uniformLeft_A;          end interface
       interface uniformRight_iterate; module procedure uniformRight_A;         end interface
       interface robertsLeft_iterate;  module procedure robertsLeft_A;          end interface
       interface robertsRight_iterate; module procedure robertsRight_A;         end interface
       interface robertsBoth_iterate;  module procedure robertsBoth_A;          end interface
       interface cluster_iterate;      module procedure cluster_A;              end interface
       interface needs_more_points;    module procedure needs_more_points_A;    end interface
       interface needs_more_points;    module procedure needs_more_points_func; end interface

       contains

       function uniform_A(hmin,hmax,N) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),intent(in) :: hmin,hmax
         type(array) :: hn
         call init(hn,uniform(hmin,hmax,N))
       end function

       function linspace_A(hmin,hmax,N) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),intent(in) :: hmin,hmax
         type(array) :: hn
         call init(hn,linspace(hmin,hmax,N))
       end function

       function uniformLeft_A(hstart,dh,N) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),intent(in) :: hstart,dh
         type(array) :: hn
         call init(hn,uniformLeft(hstart,dh,N))
       end function

       function uniformRight_A(hstart,dh,N) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),intent(in) :: hstart,dh
         type(array) :: hn
         call init(hn,uniformRight(hstart,dh,N))
       end function

       function robertsLeft_A(hmin,hmax,N,beta,MQP) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),intent(in) :: hmin,hmax,beta
         type(mesh_quality_params),intent(in) :: MQP
         type(array) :: hn
         integer :: i,temp
         temp = N
         do i=1,MQP%N_iter
           call init(hn,robertsLeft(hmin,hmax,temp,beta))
           if (needs_more_points(hn,MQP)) then; temp = temp+1
           else; exit
           endif
         enddo
       end function

       function robertsRight_A(hmin,hmax,N,beta,MQP) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),intent(in) :: hmin,hmax,beta
         type(mesh_quality_params),intent(in) :: MQP
         type(array) :: hn
         integer :: i,temp
         temp = N
         do i=1,MQP%N_iter
           call init(hn,robertsRight(hmin,hmax,temp,beta))
           if (needs_more_points(hn,MQP)) then; temp = temp+1
           else; exit
           endif
         enddo
       end function

       function robertsBoth_A(hmin,hmax,N,beta,MQP) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),intent(in) :: hmin,hmax,beta
         type(mesh_quality_params),intent(in) :: MQP
         type(array) :: hn
         integer :: i,temp
         temp = N
         do i=1,MQP%N_iter
           call init(hn,robertsBoth(hmin,hmax,temp,beta))
           if (needs_more_points(hn,MQP)) then; temp = temp+1
           else; exit
           endif
         enddo
       end function

       function cluster_A(hmin,hmax,N,yc,tau,MQP) result(hn)
         implicit none
         integer,intent(in) :: N
         real(cp),intent(in) :: hmin,hmax,yc,tau
         type(mesh_quality_params),intent(in) :: MQP
         type(array) :: hn
         integer :: i,temp
         temp = N
         do i=1,MQP%N_iter
           call init(hn,cluster(hmin,hmax,temp,yc,tau))
           if (needs_more_points(hn,MQP)) then; temp = temp+1
           else; exit
           endif
         enddo
       end function

       function needs_more_points_A(hn,MQP) result(L)
         implicit none
         type(array),intent(in) :: hn
         type(mesh_quality_params),intent(in) :: MQP
         logical :: L
         L = needs_more_points(hn%f,hn%N,MQP)
       end function

       function needs_more_points_func(hn,N,MQP) result(L)
         implicit none
         real(cp),dimension(N),intent(in) :: hn
         type(mesh_quality_params),intent(in) :: MQP
         integer,intent(in) :: N
         real(cp),dimension(N-1) :: dhn
         real(cp),dimension(N-2) :: R
         integer :: i
         logical :: L
         L = .false.
         if (N.gt.2) then
           do i=1,N-1; dhn(i) = hn(i+1)-hn(i); enddo
           do i=1,N-2; R(i) = maxval((/dhn(i)/dhn(i+1),dhn(i+1)/dhn(i)/)); enddo
           L = maxval(R).gt.MQP%max_mesh_stretch_ratio
         endif
       end function

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module coordinates_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use array_mod
       use string_mod
       use sparse_mod
       use dir_manip_mod
       implicit none

       private
       public :: coordinates
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_coordinates;              end interface
       interface delete;                 module procedure delete_coordinates;                 end interface
       interface display;                module procedure display_coordinates;                end interface
       interface display_short;          module procedure display_short_coordinates;          end interface
       interface display;                module procedure display_wrap_coordinates;           end interface
       interface print;                  module procedure print_coordinates;                  end interface
       interface print_short;            module procedure print_short_coordinates;            end interface
       interface export;                 module procedure export_coordinates;                 end interface
       interface export_primitives;      module procedure export_primitives_coordinates;      end interface
       interface import;                 module procedure import_coordinates;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_coordinates;end interface
       interface export_structured;      module procedure export_structured_D_coordinates;    end interface
       interface import_structured;      module procedure import_structured_D_coordinates;    end interface
       interface import_primitives;      module procedure import_primitives_coordinates;      end interface
       interface export;                 module procedure export_wrap_coordinates;            end interface
       interface import;                 module procedure import_wrap_coordinates;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_coordinates;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_coordinates;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_coordinates;      end interface

       type coordinates
         real(cp) :: hmin = 0.0_cp
         real(cp) :: hmax = 0.0_cp
         real(cp) :: amin = 0.0_cp
         real(cp) :: amax = 0.0_cp
         real(cp) :: maxRange = 0.0_cp
         real(cp) :: dhMin = 0.0_cp
         real(cp) :: dhMax = 0.0_cp
         real(cp) :: dhc_e = 0.0_cp
         real(cp) :: dhn_e = 0.0_cp
         real(cp) :: hc_e = 0.0_cp
         real(cp) :: hn_e = 0.0_cp
         integer :: sc = 0
         integer :: sn = 0
         integer :: N = 0
         logical :: defined = .false.
         integer :: i_midplane = 0
         logical :: stencils_defined = .false.
         logical,dimension(2) :: stencils_modified = .false.
         type(sparse) :: stagCC2N
         type(sparse) :: stagN2CC
         type(sparse) :: theta
         type(sparse),dimension(2) :: colCC
         type(sparse),dimension(2) :: colN
         type(sparse),dimension(2) :: colCC_centered
         type(array) :: hn
         type(array) :: hc
         type(array) :: dhn
         type(array) :: dhc
       end type

       contains

       subroutine init_copy_coordinates(this,that)
         implicit none
         type(coordinates),intent(inout) :: this
         type(coordinates),intent(in) :: that
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         call delete(this)
         this%hmin = that%hmin
         this%hmax = that%hmax
         this%amin = that%amin
         this%amax = that%amax
         this%maxRange = that%maxRange
         this%dhMin = that%dhMin
         this%dhMax = that%dhMax
         this%dhc_e = that%dhc_e
         this%dhn_e = that%dhn_e
         this%hc_e = that%hc_e
         this%hn_e = that%hn_e
         this%sc = that%sc
         this%sn = that%sn
         this%N = that%N
         this%defined = that%defined
         this%i_midplane = that%i_midplane
         this%stencils_defined = that%stencils_defined
         this%stencils_modified = that%stencils_modified
         call init(this%stagCC2N,that%stagCC2N)
         call init(this%stagN2CC,that%stagN2CC)
         call init(this%theta,that%theta)
         s_colCC = size(that%colCC)
         do i_colCC=1,s_colCC
           call init(this%colCC(i_colCC),that%colCC(i_colCC))
         enddo
         s_colN = size(that%colN)
         do i_colN=1,s_colN
           call init(this%colN(i_colN),that%colN(i_colN))
         enddo
         s_colCC_centered = size(that%colCC_centered)
         do i_colCC_centered=1,s_colCC_centered
           call init(this%colCC_centered(i_colCC_centered),&
           that%colCC_centered(i_colCC_centered))
         enddo
         call init(this%hn,that%hn)
         call init(this%hc,that%hc)
         call init(this%dhn,that%dhn)
         call init(this%dhc,that%dhc)
       end subroutine

       subroutine delete_coordinates(this)
         implicit none
         type(coordinates),intent(inout) :: this
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         this%hmin = 0.0_cp
         this%hmax = 0.0_cp
         this%amin = 0.0_cp
         this%amax = 0.0_cp
         this%maxRange = 0.0_cp
         this%dhMin = 0.0_cp
         this%dhMax = 0.0_cp
         this%dhc_e = 0.0_cp
         this%dhn_e = 0.0_cp
         this%hc_e = 0.0_cp
         this%hn_e = 0.0_cp
         this%sc = 0
         this%sn = 0
         this%N = 0
         this%defined = .false.
         this%i_midplane = 0
         this%stencils_defined = .false.
         this%stencils_modified = .false.
         call delete(this%stagCC2N)
         call delete(this%stagN2CC)
         call delete(this%theta)
         s_colCC = size(this%colCC)
         do i_colCC=1,s_colCC
           call delete(this%colCC(i_colCC))
         enddo
         s_colN = size(this%colN)
         do i_colN=1,s_colN
           call delete(this%colN(i_colN))
         enddo
         s_colCC_centered = size(this%colCC_centered)
         do i_colCC_centered=1,s_colCC_centered
           call delete(this%colCC_centered(i_colCC_centered))
         enddo
         call delete(this%hn)
         call delete(this%hc)
         call delete(this%dhn)
         call delete(this%dhc)
       end subroutine

       subroutine display_coordinates(this,un)
         implicit none
         type(coordinates),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         write(un,*) 'hmin              = ',this%hmin
         write(un,*) 'hmax              = ',this%hmax
         write(un,*) 'amin              = ',this%amin
         write(un,*) 'amax              = ',this%amax
         write(un,*) 'maxRange          = ',this%maxRange
         write(un,*) 'dhMin             = ',this%dhMin
         write(un,*) 'dhMax             = ',this%dhMax
         write(un,*) 'dhc_e             = ',this%dhc_e
         write(un,*) 'dhn_e             = ',this%dhn_e
         write(un,*) 'hc_e              = ',this%hc_e
         write(un,*) 'hn_e              = ',this%hn_e
         write(un,*) 'sc                = ',this%sc
         write(un,*) 'sn                = ',this%sn
         write(un,*) 'N                 = ',this%N
         write(un,*) 'defined           = ',this%defined
         write(un,*) 'i_midplane        = ',this%i_midplane
         write(un,*) 'stencils_defined  = ',this%stencils_defined
         write(un,*) 'stencils_modified = ',this%stencils_modified
         call display(this%stagCC2N,un)
         call display(this%stagN2CC,un)
         call display(this%theta,un)
         s_colCC = size(this%colCC)
         do i_colCC=1,s_colCC
           call display(this%colCC(i_colCC),un)
         enddo
         s_colN = size(this%colN)
         do i_colN=1,s_colN
           call display(this%colN(i_colN),un)
         enddo
         s_colCC_centered = size(this%colCC_centered)
         do i_colCC_centered=1,s_colCC_centered
           call display(this%colCC_centered(i_colCC_centered),un)
         enddo
         call display(this%hn,un)
         call display(this%hc,un)
         call display(this%dhn,un)
         call display(this%dhc,un)
       end subroutine

       subroutine display_short_coordinates(this,un)
         implicit none
         type(coordinates),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         write(un,*) 'hmin              = ',this%hmin
         write(un,*) 'hmax              = ',this%hmax
         write(un,*) 'amin              = ',this%amin
         write(un,*) 'amax              = ',this%amax
         write(un,*) 'maxRange          = ',this%maxRange
         write(un,*) 'dhMin             = ',this%dhMin
         write(un,*) 'dhMax             = ',this%dhMax
         write(un,*) 'dhc_e             = ',this%dhc_e
         write(un,*) 'dhn_e             = ',this%dhn_e
         write(un,*) 'hc_e              = ',this%hc_e
         write(un,*) 'hn_e              = ',this%hn_e
         write(un,*) 'sc                = ',this%sc
         write(un,*) 'sn                = ',this%sn
         write(un,*) 'N                 = ',this%N
         write(un,*) 'defined           = ',this%defined
         write(un,*) 'i_midplane        = ',this%i_midplane
         write(un,*) 'stencils_defined  = ',this%stencils_defined
         write(un,*) 'stencils_modified = ',this%stencils_modified
         call display(this%stagCC2N,un)
         call display(this%stagN2CC,un)
         call display(this%theta,un)
         s_colCC = size(this%colCC)
         do i_colCC=1,s_colCC
           call display(this%colCC(i_colCC),un)
         enddo
         s_colN = size(this%colN)
         do i_colN=1,s_colN
           call display(this%colN(i_colN),un)
         enddo
         s_colCC_centered = size(this%colCC_centered)
         do i_colCC_centered=1,s_colCC_centered
           call display(this%colCC_centered(i_colCC_centered),un)
         enddo
         call display(this%hn,un)
         call display(this%hc,un)
         call display(this%dhn,un)
         call display(this%dhc,un)
       end subroutine

       subroutine display_wrap_coordinates(this,dir,name)
         implicit none
         type(coordinates),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_coordinates(this)
         implicit none
         type(coordinates),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_coordinates(this)
         implicit none
         type(coordinates),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_coordinates(this,un)
         implicit none
         type(coordinates),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         call export_primitives(this,un)
         call export(this%stagCC2N,un)
         call export(this%stagN2CC,un)
         call export(this%theta,un)
         s_colCC = size(this%colCC)
         write(un,*) s_colCC
         do i_colCC=1,s_colCC
           call export(this%colCC(i_colCC),un)
         enddo
         s_colN = size(this%colN)
         write(un,*) s_colN
         do i_colN=1,s_colN
           call export(this%colN(i_colN),un)
         enddo
         s_colCC_centered = size(this%colCC_centered)
         write(un,*) s_colCC_centered
         do i_colCC_centered=1,s_colCC_centered
           call export(this%colCC_centered(i_colCC_centered),un)
         enddo
         call export(this%hn,un)
         call export(this%hc,un)
         call export(this%dhn,un)
         call export(this%dhc,un)
       end subroutine

       subroutine import_coordinates(this,un)
         implicit none
         type(coordinates),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         call delete(this)
         call import_primitives(this,un)
         call import(this%stagCC2N,un)
         call import(this%stagN2CC,un)
         call import(this%theta,un)
         read(un,*) s_colCC
         if (s_colCC.gt.0) then
           do i_colCC=1,s_colCC
             call import(this%colCC(i_colCC),un)
           enddo
         endif
         read(un,*) s_colN
         if (s_colN.gt.0) then
           do i_colN=1,s_colN
             call import(this%colN(i_colN),un)
           enddo
         endif
         read(un,*) s_colCC_centered
         if (s_colCC_centered.gt.0) then
           do i_colCC_centered=1,s_colCC_centered
             call import(this%colCC_centered(i_colCC_centered),un)
           enddo
         endif
         call import(this%hn,un)
         call import(this%hc,un)
         call import(this%dhn,un)
         call import(this%dhc,un)
       end subroutine

       subroutine export_primitives_coordinates(this,un)
         implicit none
         type(coordinates),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'hmin               = ';write(un,*) this%hmin
         write(un,*) 'hmax               = ';write(un,*) this%hmax
         write(un,*) 'amin               = ';write(un,*) this%amin
         write(un,*) 'amax               = ';write(un,*) this%amax
         write(un,*) 'maxRange           = ';write(un,*) this%maxRange
         write(un,*) 'dhMin              = ';write(un,*) this%dhMin
         write(un,*) 'dhMax              = ';write(un,*) this%dhMax
         write(un,*) 'dhc_e              = ';write(un,*) this%dhc_e
         write(un,*) 'dhn_e              = ';write(un,*) this%dhn_e
         write(un,*) 'hc_e               = ';write(un,*) this%hc_e
         write(un,*) 'hn_e               = ';write(un,*) this%hn_e
         write(un,*) 'sc                 = ';write(un,*) this%sc
         write(un,*) 'sn                 = ';write(un,*) this%sn
         write(un,*) 'N                  = ';write(un,*) this%N
         write(un,*) 'defined            = ';write(un,*) this%defined
         write(un,*) 'i_midplane         = ';write(un,*) this%i_midplane
         write(un,*) 'stencils_defined   = ';write(un,*) this%stencils_defined
         write(un,*) 'stencils_modified  = ';write(un,*) this%stencils_modified
       end subroutine

       subroutine import_primitives_coordinates(this,un)
         implicit none
         type(coordinates),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%hmin
         read(un,*); read(un,*) this%hmax
         read(un,*); read(un,*) this%amin
         read(un,*); read(un,*) this%amax
         read(un,*); read(un,*) this%maxRange
         read(un,*); read(un,*) this%dhMin
         read(un,*); read(un,*) this%dhMax
         read(un,*); read(un,*) this%dhc_e
         read(un,*); read(un,*) this%dhn_e
         read(un,*); read(un,*) this%hc_e
         read(un,*); read(un,*) this%hn_e
         read(un,*); read(un,*) this%sc
         read(un,*); read(un,*) this%sn
         read(un,*); read(un,*) this%N
         read(un,*); read(un,*) this%defined
         read(un,*); read(un,*) this%i_midplane
         read(un,*); read(un,*) this%stencils_defined
         read(un,*); read(un,*) this%stencils_modified
       end subroutine

       subroutine export_wrap_coordinates(this,dir,name)
         implicit none
         type(coordinates),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_coordinates(this,dir,name)
         implicit none
         type(coordinates),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_coordinates(this,dir)
         implicit none
         type(coordinates),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         call suppress_warnings(this)
         call set_IO_dir(this%stagCC2N,dir//'stagCC2N'//fortran_PS)
         call set_IO_dir(this%stagN2CC,dir//'stagN2CC'//fortran_PS)
         call set_IO_dir(this%theta,dir//'theta'//fortran_PS)
         s_colCC = size(this%colCC)
         do i_colCC=1,s_colCC
           call set_IO_dir(this%colCC(i_colCC),&
           dir//'colCC_'//int2str(i_colCC)//fortran_PS)
         enddo
         s_colN = size(this%colN)
         do i_colN=1,s_colN
           call set_IO_dir(this%colN(i_colN),&
           dir//'colN_'//int2str(i_colN)//fortran_PS)
         enddo
         s_colCC_centered = size(this%colCC_centered)
         do i_colCC_centered=1,s_colCC_centered
           call set_IO_dir(this%colCC_centered(i_colCC_centered),&
           dir//'colCC_centered_'//int2str(i_colCC_centered)//fortran_PS)
         enddo
         call set_IO_dir(this%hn,dir//'hn'//fortran_PS)
         call set_IO_dir(this%hc,dir//'hc'//fortran_PS)
         call set_IO_dir(this%dhn,dir//'dhn'//fortran_PS)
         call set_IO_dir(this%dhc,dir//'dhc'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_coordinates(this,dir)
         implicit none
         type(coordinates),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%stagCC2N,dir//'stagCC2N'//fortran_PS)
         call make_IO_dir(this%stagN2CC,dir//'stagN2CC'//fortran_PS)
         call make_IO_dir(this%theta,dir//'theta'//fortran_PS)
         s_colCC = size(this%colCC)
         do i_colCC=1,s_colCC
           call make_IO_dir(this%colCC(i_colCC),&
           dir//'colCC_'//int2str(i_colCC)//fortran_PS)
         enddo
         s_colN = size(this%colN)
         do i_colN=1,s_colN
           call make_IO_dir(this%colN(i_colN),&
           dir//'colN_'//int2str(i_colN)//fortran_PS)
         enddo
         s_colCC_centered = size(this%colCC_centered)
         do i_colCC_centered=1,s_colCC_centered
           call make_IO_dir(this%colCC_centered(i_colCC_centered),&
           dir//'colCC_centered_'//int2str(i_colCC_centered)//fortran_PS)
         enddo
         call make_IO_dir(this%hn,dir//'hn'//fortran_PS)
         call make_IO_dir(this%hc,dir//'hc'//fortran_PS)
         call make_IO_dir(this%dhn,dir//'dhn'//fortran_PS)
         call make_IO_dir(this%dhc,dir//'dhc'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_coordinates(this,dir)
         implicit none
         type(coordinates),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         integer :: un
         call export_structured(this%stagCC2N,dir//'stagCC2N'//fortran_PS)
         call export_structured(this%stagN2CC,dir//'stagN2CC'//fortran_PS)
         call export_structured(this%theta,dir//'theta'//fortran_PS)
         s_colCC = size(this%colCC)
         write(un,*) s_colCC
         do i_colCC=1,s_colCC
           call export_structured(this%colCC(i_colCC),&
           dir//'colCC_'//int2str(i_colCC)//fortran_PS)
         enddo
         s_colN = size(this%colN)
         write(un,*) s_colN
         do i_colN=1,s_colN
           call export_structured(this%colN(i_colN),&
           dir//'colN_'//int2str(i_colN)//fortran_PS)
         enddo
         s_colCC_centered = size(this%colCC_centered)
         write(un,*) s_colCC_centered
         do i_colCC_centered=1,s_colCC_centered
           call export_structured(this%colCC_centered(i_colCC_centered),&
           dir//'colCC_centered_'//int2str(i_colCC_centered)//fortran_PS)
         enddo
         call export_structured(this%hn,dir//'hn'//fortran_PS)
         call export_structured(this%hc,dir//'hc'//fortran_PS)
         call export_structured(this%dhn,dir//'dhn'//fortran_PS)
         call export_structured(this%dhc,dir//'dhc'//fortran_PS)
       end subroutine

       subroutine export_structured_D_coordinates(this,dir)
         implicit none
         type(coordinates),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%stagCC2N,dir//'stagCC2N'//fortran_PS)
         call export_structured(this%stagN2CC,dir//'stagN2CC'//fortran_PS)
         call export_structured(this%theta,dir//'theta'//fortran_PS)
         s_colCC = size(this%colCC)
         write(un,*) s_colCC
         do i_colCC=1,s_colCC
           call export_structured(this%colCC(i_colCC),&
           dir//'colCC_'//int2str(i_colCC)//fortran_PS)
         enddo
         s_colN = size(this%colN)
         write(un,*) s_colN
         do i_colN=1,s_colN
           call export_structured(this%colN(i_colN),&
           dir//'colN_'//int2str(i_colN)//fortran_PS)
         enddo
         s_colCC_centered = size(this%colCC_centered)
         write(un,*) s_colCC_centered
         do i_colCC_centered=1,s_colCC_centered
           call export_structured(this%colCC_centered(i_colCC_centered),&
           dir//'colCC_centered_'//int2str(i_colCC_centered)//fortran_PS)
         enddo
         call export_structured(this%hn,dir//'hn'//fortran_PS)
         call export_structured(this%hc,dir//'hc'//fortran_PS)
         call export_structured(this%dhn,dir//'dhn'//fortran_PS)
         call export_structured(this%dhc,dir//'dhc'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_coordinates(this,dir)
         implicit none
         type(coordinates),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_colCC
         integer :: i_colN
         integer :: i_colCC_centered
         integer :: s_colCC
         integer :: s_colN
         integer :: s_colCC_centered
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%stagCC2N,dir//'stagCC2N'//fortran_PS)
         call import_structured(this%stagN2CC,dir//'stagN2CC'//fortran_PS)
         call import_structured(this%theta,dir//'theta'//fortran_PS)
         s_colCC = size(this%colCC)
         do i_colCC=1,s_colCC
           call import_structured(this%colCC(i_colCC),&
           dir//'colCC_'//int2str(i_colCC)//fortran_PS)
         enddo
         s_colN = size(this%colN)
         do i_colN=1,s_colN
           call import_structured(this%colN(i_colN),&
           dir//'colN_'//int2str(i_colN)//fortran_PS)
         enddo
         s_colCC_centered = size(this%colCC_centered)
         do i_colCC_centered=1,s_colCC_centered
           call import_structured(this%colCC_centered(i_colCC_centered),&
           dir//'colCC_centered_'//int2str(i_colCC_centered)//fortran_PS)
         enddo
         call import_structured(this%hn,dir//'hn'//fortran_PS)
         call import_structured(this%hc,dir//'hc'//fortran_PS)
         call import_structured(this%dhn,dir//'dhn'//fortran_PS)
         call import_structured(this%dhc,dir//'dhc'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_coordinates(this)
         implicit none
         type(coordinates),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module dir_group_extend_mod
      use dir_group_mod
      use dir_manip_mod
      use string_mod
      use path_mod
      use path_extend_mod
      implicit none

      private
      public :: init
      public :: make_dir_group

      interface init;     module procedure init_DG;     end interface

      contains

      subroutine init_DG(DG,root,name,PS)
        implicit none
        type(dir_group),intent(inout) :: DG
        type(path),intent(in) :: root
        character(len=*),intent(in) :: name,PS
        type(path) :: temp
        call init(temp,root)
        call init(DG%base    ,temp   ,name      ,PS)
        call init(DG%field   ,DG%base,'field'   ,PS)
        call init(DG%debug   ,DG%base,'debug'   ,PS)
        call init(DG%energy  ,DG%base,'energy'  ,PS)
        call init(DG%local   ,DG%base,'local'   ,PS)
        call init(DG%residual,DG%base,'residual',PS)
        call init(DG%unsteady,DG%base,'unsteady',PS)
        call init(DG%stats   ,DG%base,'stats'   ,PS)
        call init(DG%BCs     ,DG%base,'BCs'     ,PS)
        call delete(temp)
      end subroutine

      subroutine make_dir_group(DG)
        implicit none
        type(dir_group),intent(in) :: DG
        call make_dir(str(DG%base))
        call make_dir(str(DG%field))
        call make_dir(str(DG%debug))
        call make_dir(str(DG%energy))
        call make_dir(str(DG%local))
        call make_dir(str(DG%residual))
        call make_dir(str(DG%unsteady))
        call make_dir(str(DG%stats))
        call make_dir(str(DG%BCs))
      end subroutine

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module dir_tree_mod
       use datatype_conversion_mod
       use dir_group_mod
       use IO_tools_mod
       use path_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: dir_tree
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_dir_tree;              end interface
       interface delete;                 module procedure delete_dir_tree;                 end interface
       interface display;                module procedure display_dir_tree;                end interface
       interface display_short;          module procedure display_short_dir_tree;          end interface
       interface display;                module procedure display_wrap_dir_tree;           end interface
       interface print;                  module procedure print_dir_tree;                  end interface
       interface print_short;            module procedure print_short_dir_tree;            end interface
       interface export;                 module procedure export_dir_tree;                 end interface
       interface export_primitives;      module procedure export_primitives_dir_tree;      end interface
       interface import;                 module procedure import_dir_tree;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_dir_tree;end interface
       interface export_structured;      module procedure export_structured_D_dir_tree;    end interface
       interface import_structured;      module procedure import_structured_D_dir_tree;    end interface
       interface import_primitives;      module procedure import_primitives_dir_tree;      end interface
       interface export;                 module procedure export_wrap_dir_tree;            end interface
       interface import;                 module procedure import_wrap_dir_tree;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_dir_tree;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_dir_tree;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_dir_tree;      end interface

       type dir_tree
         type(path) :: tar_p
         type(path) :: out_dir
         type(path) :: LDC
         type(path) :: mat
         type(path) :: config
         type(path) :: meshes
         type(path) :: BEM
         type(path) :: wall_clock
         type(path) :: matrix_visualization
         type(path) :: dimensionless_params
         type(path) :: params
         type(path) :: ISP
         type(path) :: TMP
         type(path) :: EF
         type(path) :: export_now
         type(path) :: e_budget
         type(path) :: e_budget_N
         type(path) :: e_budget_C
         type(path) :: restart_root
         type(path) :: restart1
         type(path) :: restart2
         type(path) :: restart
         type(path) :: unknowns
         type(path) :: governing_equations
         type(string) :: PS
         type(string) :: tar
         type(dir_group) :: U
         type(dir_group) :: B
         type(dir_group) :: jCrossB
         type(dir_group) :: stresses
         type(dir_group) :: J
         type(dir_group) :: T
         type(dir_group) :: p
         type(dir_group) :: phi
         type(dir_group) :: rho
         type(dir_group) :: test
       end type

       contains

       subroutine init_copy_dir_tree(this,that)
         implicit none
         type(dir_tree),intent(inout) :: this
         type(dir_tree),intent(in) :: that
         call delete(this)
         call init(this%tar_p,that%tar_p)
         call init(this%out_dir,that%out_dir)
         call init(this%LDC,that%LDC)
         call init(this%mat,that%mat)
         call init(this%config,that%config)
         call init(this%meshes,that%meshes)
         call init(this%BEM,that%BEM)
         call init(this%wall_clock,that%wall_clock)
         call init(this%matrix_visualization,that%matrix_visualization)
         call init(this%dimensionless_params,that%dimensionless_params)
         call init(this%params,that%params)
         call init(this%ISP,that%ISP)
         call init(this%TMP,that%TMP)
         call init(this%EF,that%EF)
         call init(this%export_now,that%export_now)
         call init(this%e_budget,that%e_budget)
         call init(this%e_budget_N,that%e_budget_N)
         call init(this%e_budget_C,that%e_budget_C)
         call init(this%restart_root,that%restart_root)
         call init(this%restart1,that%restart1)
         call init(this%restart2,that%restart2)
         call init(this%restart,that%restart)
         call init(this%unknowns,that%unknowns)
         call init(this%governing_equations,that%governing_equations)
         call init(this%PS,that%PS)
         call init(this%tar,that%tar)
         call init(this%U,that%U)
         call init(this%B,that%B)
         call init(this%jCrossB,that%jCrossB)
         call init(this%stresses,that%stresses)
         call init(this%J,that%J)
         call init(this%T,that%T)
         call init(this%p,that%p)
         call init(this%phi,that%phi)
         call init(this%rho,that%rho)
         call init(this%test,that%test)
       end subroutine

       subroutine delete_dir_tree(this)
         implicit none
         type(dir_tree),intent(inout) :: this
         call delete(this%tar_p)
         call delete(this%out_dir)
         call delete(this%LDC)
         call delete(this%mat)
         call delete(this%config)
         call delete(this%meshes)
         call delete(this%BEM)
         call delete(this%wall_clock)
         call delete(this%matrix_visualization)
         call delete(this%dimensionless_params)
         call delete(this%params)
         call delete(this%ISP)
         call delete(this%TMP)
         call delete(this%EF)
         call delete(this%export_now)
         call delete(this%e_budget)
         call delete(this%e_budget_N)
         call delete(this%e_budget_C)
         call delete(this%restart_root)
         call delete(this%restart1)
         call delete(this%restart2)
         call delete(this%restart)
         call delete(this%unknowns)
         call delete(this%governing_equations)
         call delete(this%PS)
         call delete(this%tar)
         call delete(this%U)
         call delete(this%B)
         call delete(this%jCrossB)
         call delete(this%stresses)
         call delete(this%J)
         call delete(this%T)
         call delete(this%p)
         call delete(this%phi)
         call delete(this%rho)
         call delete(this%test)
       end subroutine

       subroutine display_dir_tree(this,un)
         implicit none
         type(dir_tree),intent(in) :: this
         integer,intent(in) :: un
         call display(this%tar_p,un)
         call display(this%out_dir,un)
         call display(this%LDC,un)
         call display(this%mat,un)
         call display(this%config,un)
         call display(this%meshes,un)
         call display(this%BEM,un)
         call display(this%wall_clock,un)
         call display(this%matrix_visualization,un)
         call display(this%dimensionless_params,un)
         call display(this%params,un)
         call display(this%ISP,un)
         call display(this%TMP,un)
         call display(this%EF,un)
         call display(this%export_now,un)
         call display(this%e_budget,un)
         call display(this%e_budget_N,un)
         call display(this%e_budget_C,un)
         call display(this%restart_root,un)
         call display(this%restart1,un)
         call display(this%restart2,un)
         call display(this%restart,un)
         call display(this%unknowns,un)
         call display(this%governing_equations,un)
         call display(this%PS,un)
         call display(this%tar,un)
         call display(this%U,un)
         call display(this%B,un)
         call display(this%jCrossB,un)
         call display(this%stresses,un)
         call display(this%J,un)
         call display(this%T,un)
         call display(this%p,un)
         call display(this%phi,un)
         call display(this%rho,un)
         call display(this%test,un)
       end subroutine

       subroutine display_short_dir_tree(this,un)
         implicit none
         type(dir_tree),intent(in) :: this
         integer,intent(in) :: un
         call display(this%tar_p,un)
         call display(this%out_dir,un)
         call display(this%LDC,un)
         call display(this%mat,un)
         call display(this%config,un)
         call display(this%meshes,un)
         call display(this%BEM,un)
         call display(this%wall_clock,un)
         call display(this%matrix_visualization,un)
         call display(this%dimensionless_params,un)
         call display(this%params,un)
         call display(this%ISP,un)
         call display(this%TMP,un)
         call display(this%EF,un)
         call display(this%export_now,un)
         call display(this%e_budget,un)
         call display(this%e_budget_N,un)
         call display(this%e_budget_C,un)
         call display(this%restart_root,un)
         call display(this%restart1,un)
         call display(this%restart2,un)
         call display(this%restart,un)
         call display(this%unknowns,un)
         call display(this%governing_equations,un)
         call display(this%PS,un)
         call display(this%tar,un)
         call display(this%U,un)
         call display(this%B,un)
         call display(this%jCrossB,un)
         call display(this%stresses,un)
         call display(this%J,un)
         call display(this%T,un)
         call display(this%p,un)
         call display(this%phi,un)
         call display(this%rho,un)
         call display(this%test,un)
       end subroutine

       subroutine display_wrap_dir_tree(this,dir,name)
         implicit none
         type(dir_tree),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_dir_tree(this)
         implicit none
         type(dir_tree),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_dir_tree(this)
         implicit none
         type(dir_tree),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_dir_tree(this,un)
         implicit none
         type(dir_tree),intent(in) :: this
         integer,intent(in) :: un
         call export(this%tar_p,un)
         call export(this%out_dir,un)
         call export(this%LDC,un)
         call export(this%mat,un)
         call export(this%config,un)
         call export(this%meshes,un)
         call export(this%BEM,un)
         call export(this%wall_clock,un)
         call export(this%matrix_visualization,un)
         call export(this%dimensionless_params,un)
         call export(this%params,un)
         call export(this%ISP,un)
         call export(this%TMP,un)
         call export(this%EF,un)
         call export(this%export_now,un)
         call export(this%e_budget,un)
         call export(this%e_budget_N,un)
         call export(this%e_budget_C,un)
         call export(this%restart_root,un)
         call export(this%restart1,un)
         call export(this%restart2,un)
         call export(this%restart,un)
         call export(this%unknowns,un)
         call export(this%governing_equations,un)
         call export(this%PS,un)
         call export(this%tar,un)
         call export(this%U,un)
         call export(this%B,un)
         call export(this%jCrossB,un)
         call export(this%stresses,un)
         call export(this%J,un)
         call export(this%T,un)
         call export(this%p,un)
         call export(this%phi,un)
         call export(this%rho,un)
         call export(this%test,un)
       end subroutine

       subroutine import_dir_tree(this,un)
         implicit none
         type(dir_tree),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%tar_p,un)
         call import(this%out_dir,un)
         call import(this%LDC,un)
         call import(this%mat,un)
         call import(this%config,un)
         call import(this%meshes,un)
         call import(this%BEM,un)
         call import(this%wall_clock,un)
         call import(this%matrix_visualization,un)
         call import(this%dimensionless_params,un)
         call import(this%params,un)
         call import(this%ISP,un)
         call import(this%TMP,un)
         call import(this%EF,un)
         call import(this%export_now,un)
         call import(this%e_budget,un)
         call import(this%e_budget_N,un)
         call import(this%e_budget_C,un)
         call import(this%restart_root,un)
         call import(this%restart1,un)
         call import(this%restart2,un)
         call import(this%restart,un)
         call import(this%unknowns,un)
         call import(this%governing_equations,un)
         call import(this%PS,un)
         call import(this%tar,un)
         call import(this%U,un)
         call import(this%B,un)
         call import(this%jCrossB,un)
         call import(this%stresses,un)
         call import(this%J,un)
         call import(this%T,un)
         call import(this%p,un)
         call import(this%phi,un)
         call import(this%rho,un)
         call import(this%test,un)
       end subroutine

       subroutine export_primitives_dir_tree(this,un)
         implicit none
         type(dir_tree),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_dir_tree(this,un)
         implicit none
         type(dir_tree),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_dir_tree(this,dir,name)
         implicit none
         type(dir_tree),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_dir_tree(this,dir,name)
         implicit none
         type(dir_tree),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_dir_tree(this,dir)
         implicit none
         type(dir_tree),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%tar_p,dir//'tar_p'//fortran_PS)
         call set_IO_dir(this%out_dir,dir//'out_dir'//fortran_PS)
         call set_IO_dir(this%LDC,dir//'LDC'//fortran_PS)
         call set_IO_dir(this%mat,dir//'mat'//fortran_PS)
         call set_IO_dir(this%config,dir//'config'//fortran_PS)
         call set_IO_dir(this%meshes,dir//'meshes'//fortran_PS)
         call set_IO_dir(this%BEM,dir//'BEM'//fortran_PS)
         call set_IO_dir(this%wall_clock,dir//'wall_clock'//fortran_PS)
         call set_IO_dir(this%matrix_visualization,&
         dir//'matrix_visualization'//fortran_PS)
         call set_IO_dir(this%dimensionless_params,&
         dir//'dimensionless_params'//fortran_PS)
         call set_IO_dir(this%params,dir//'params'//fortran_PS)
         call set_IO_dir(this%ISP,dir//'ISP'//fortran_PS)
         call set_IO_dir(this%TMP,dir//'TMP'//fortran_PS)
         call set_IO_dir(this%EF,dir//'EF'//fortran_PS)
         call set_IO_dir(this%export_now,dir//'export_now'//fortran_PS)
         call set_IO_dir(this%e_budget,dir//'e_budget'//fortran_PS)
         call set_IO_dir(this%e_budget_N,dir//'e_budget_N'//fortran_PS)
         call set_IO_dir(this%e_budget_C,dir//'e_budget_C'//fortran_PS)
         call set_IO_dir(this%restart_root,dir//'restart_root'//fortran_PS)
         call set_IO_dir(this%restart1,dir//'restart1'//fortran_PS)
         call set_IO_dir(this%restart2,dir//'restart2'//fortran_PS)
         call set_IO_dir(this%restart,dir//'restart'//fortran_PS)
         call set_IO_dir(this%unknowns,dir//'unknowns'//fortran_PS)
         call set_IO_dir(this%governing_equations,&
         dir//'governing_equations'//fortran_PS)
         call set_IO_dir(this%PS,dir//'PS'//fortran_PS)
         call set_IO_dir(this%tar,dir//'tar'//fortran_PS)
         call set_IO_dir(this%U,dir//'U'//fortran_PS)
         call set_IO_dir(this%B,dir//'B'//fortran_PS)
         call set_IO_dir(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call set_IO_dir(this%stresses,dir//'stresses'//fortran_PS)
         call set_IO_dir(this%J,dir//'J'//fortran_PS)
         call set_IO_dir(this%T,dir//'T'//fortran_PS)
         call set_IO_dir(this%p,dir//'p'//fortran_PS)
         call set_IO_dir(this%phi,dir//'phi'//fortran_PS)
         call set_IO_dir(this%rho,dir//'rho'//fortran_PS)
         call set_IO_dir(this%test,dir//'test'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_dir_tree(this,dir)
         implicit none
         type(dir_tree),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%tar_p,dir//'tar_p'//fortran_PS)
         call make_IO_dir(this%out_dir,dir//'out_dir'//fortran_PS)
         call make_IO_dir(this%LDC,dir//'LDC'//fortran_PS)
         call make_IO_dir(this%mat,dir//'mat'//fortran_PS)
         call make_IO_dir(this%config,dir//'config'//fortran_PS)
         call make_IO_dir(this%meshes,dir//'meshes'//fortran_PS)
         call make_IO_dir(this%BEM,dir//'BEM'//fortran_PS)
         call make_IO_dir(this%wall_clock,dir//'wall_clock'//fortran_PS)
         call make_IO_dir(this%matrix_visualization,&
         dir//'matrix_visualization'//fortran_PS)
         call make_IO_dir(this%dimensionless_params,&
         dir//'dimensionless_params'//fortran_PS)
         call make_IO_dir(this%params,dir//'params'//fortran_PS)
         call make_IO_dir(this%ISP,dir//'ISP'//fortran_PS)
         call make_IO_dir(this%TMP,dir//'TMP'//fortran_PS)
         call make_IO_dir(this%EF,dir//'EF'//fortran_PS)
         call make_IO_dir(this%export_now,dir//'export_now'//fortran_PS)
         call make_IO_dir(this%e_budget,dir//'e_budget'//fortran_PS)
         call make_IO_dir(this%e_budget_N,dir//'e_budget_N'//fortran_PS)
         call make_IO_dir(this%e_budget_C,dir//'e_budget_C'//fortran_PS)
         call make_IO_dir(this%restart_root,dir//'restart_root'//fortran_PS)
         call make_IO_dir(this%restart1,dir//'restart1'//fortran_PS)
         call make_IO_dir(this%restart2,dir//'restart2'//fortran_PS)
         call make_IO_dir(this%restart,dir//'restart'//fortran_PS)
         call make_IO_dir(this%unknowns,dir//'unknowns'//fortran_PS)
         call make_IO_dir(this%governing_equations,&
         dir//'governing_equations'//fortran_PS)
         call make_IO_dir(this%PS,dir//'PS'//fortran_PS)
         call make_IO_dir(this%tar,dir//'tar'//fortran_PS)
         call make_IO_dir(this%U,dir//'U'//fortran_PS)
         call make_IO_dir(this%B,dir//'B'//fortran_PS)
         call make_IO_dir(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call make_IO_dir(this%stresses,dir//'stresses'//fortran_PS)
         call make_IO_dir(this%J,dir//'J'//fortran_PS)
         call make_IO_dir(this%T,dir//'T'//fortran_PS)
         call make_IO_dir(this%p,dir//'p'//fortran_PS)
         call make_IO_dir(this%phi,dir//'phi'//fortran_PS)
         call make_IO_dir(this%rho,dir//'rho'//fortran_PS)
         call make_IO_dir(this%test,dir//'test'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_dir_tree(this,dir)
         implicit none
         type(dir_tree),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%tar_p,dir//'tar_p'//fortran_PS)
         call export_structured(this%out_dir,dir//'out_dir'//fortran_PS)
         call export_structured(this%LDC,dir//'LDC'//fortran_PS)
         call export_structured(this%mat,dir//'mat'//fortran_PS)
         call export_structured(this%config,dir//'config'//fortran_PS)
         call export_structured(this%meshes,dir//'meshes'//fortran_PS)
         call export_structured(this%BEM,dir//'BEM'//fortran_PS)
         call export_structured(this%wall_clock,&
         dir//'wall_clock'//fortran_PS)
         call export_structured(this%matrix_visualization,&
         dir//'matrix_visualization'//fortran_PS)
         call export_structured(this%dimensionless_params,&
         dir//'dimensionless_params'//fortran_PS)
         call export_structured(this%params,dir//'params'//fortran_PS)
         call export_structured(this%ISP,dir//'ISP'//fortran_PS)
         call export_structured(this%TMP,dir//'TMP'//fortran_PS)
         call export_structured(this%EF,dir//'EF'//fortran_PS)
         call export_structured(this%export_now,&
         dir//'export_now'//fortran_PS)
         call export_structured(this%e_budget,dir//'e_budget'//fortran_PS)
         call export_structured(this%e_budget_N,&
         dir//'e_budget_N'//fortran_PS)
         call export_structured(this%e_budget_C,&
         dir//'e_budget_C'//fortran_PS)
         call export_structured(this%restart_root,&
         dir//'restart_root'//fortran_PS)
         call export_structured(this%restart1,dir//'restart1'//fortran_PS)
         call export_structured(this%restart2,dir//'restart2'//fortran_PS)
         call export_structured(this%restart,dir//'restart'//fortran_PS)
         call export_structured(this%unknowns,dir//'unknowns'//fortran_PS)
         call export_structured(this%governing_equations,&
         dir//'governing_equations'//fortran_PS)
         call export_structured(this%PS,dir//'PS'//fortran_PS)
         call export_structured(this%tar,dir//'tar'//fortran_PS)
         call export_structured(this%U,dir//'U'//fortran_PS)
         call export_structured(this%B,dir//'B'//fortran_PS)
         call export_structured(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call export_structured(this%stresses,dir//'stresses'//fortran_PS)
         call export_structured(this%J,dir//'J'//fortran_PS)
         call export_structured(this%T,dir//'T'//fortran_PS)
         call export_structured(this%p,dir//'p'//fortran_PS)
         call export_structured(this%phi,dir//'phi'//fortran_PS)
         call export_structured(this%rho,dir//'rho'//fortran_PS)
         call export_structured(this%test,dir//'test'//fortran_PS)
       end subroutine

       subroutine export_structured_D_dir_tree(this,dir)
         implicit none
         type(dir_tree),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%tar_p,dir//'tar_p'//fortran_PS)
         call export_structured(this%out_dir,dir//'out_dir'//fortran_PS)
         call export_structured(this%LDC,dir//'LDC'//fortran_PS)
         call export_structured(this%mat,dir//'mat'//fortran_PS)
         call export_structured(this%config,dir//'config'//fortran_PS)
         call export_structured(this%meshes,dir//'meshes'//fortran_PS)
         call export_structured(this%BEM,dir//'BEM'//fortran_PS)
         call export_structured(this%wall_clock,&
         dir//'wall_clock'//fortran_PS)
         call export_structured(this%matrix_visualization,&
         dir//'matrix_visualization'//fortran_PS)
         call export_structured(this%dimensionless_params,&
         dir//'dimensionless_params'//fortran_PS)
         call export_structured(this%params,dir//'params'//fortran_PS)
         call export_structured(this%ISP,dir//'ISP'//fortran_PS)
         call export_structured(this%TMP,dir//'TMP'//fortran_PS)
         call export_structured(this%EF,dir//'EF'//fortran_PS)
         call export_structured(this%export_now,&
         dir//'export_now'//fortran_PS)
         call export_structured(this%e_budget,dir//'e_budget'//fortran_PS)
         call export_structured(this%e_budget_N,&
         dir//'e_budget_N'//fortran_PS)
         call export_structured(this%e_budget_C,&
         dir//'e_budget_C'//fortran_PS)
         call export_structured(this%restart_root,&
         dir//'restart_root'//fortran_PS)
         call export_structured(this%restart1,dir//'restart1'//fortran_PS)
         call export_structured(this%restart2,dir//'restart2'//fortran_PS)
         call export_structured(this%restart,dir//'restart'//fortran_PS)
         call export_structured(this%unknowns,dir//'unknowns'//fortran_PS)
         call export_structured(this%governing_equations,&
         dir//'governing_equations'//fortran_PS)
         call export_structured(this%PS,dir//'PS'//fortran_PS)
         call export_structured(this%tar,dir//'tar'//fortran_PS)
         call export_structured(this%U,dir//'U'//fortran_PS)
         call export_structured(this%B,dir//'B'//fortran_PS)
         call export_structured(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call export_structured(this%stresses,dir//'stresses'//fortran_PS)
         call export_structured(this%J,dir//'J'//fortran_PS)
         call export_structured(this%T,dir//'T'//fortran_PS)
         call export_structured(this%p,dir//'p'//fortran_PS)
         call export_structured(this%phi,dir//'phi'//fortran_PS)
         call export_structured(this%rho,dir//'rho'//fortran_PS)
         call export_structured(this%test,dir//'test'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_dir_tree(this,dir)
         implicit none
         type(dir_tree),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%tar_p,dir//'tar_p'//fortran_PS)
         call import_structured(this%out_dir,dir//'out_dir'//fortran_PS)
         call import_structured(this%LDC,dir//'LDC'//fortran_PS)
         call import_structured(this%mat,dir//'mat'//fortran_PS)
         call import_structured(this%config,dir//'config'//fortran_PS)
         call import_structured(this%meshes,dir//'meshes'//fortran_PS)
         call import_structured(this%BEM,dir//'BEM'//fortran_PS)
         call import_structured(this%wall_clock,&
         dir//'wall_clock'//fortran_PS)
         call import_structured(this%matrix_visualization,&
         dir//'matrix_visualization'//fortran_PS)
         call import_structured(this%dimensionless_params,&
         dir//'dimensionless_params'//fortran_PS)
         call import_structured(this%params,dir//'params'//fortran_PS)
         call import_structured(this%ISP,dir//'ISP'//fortran_PS)
         call import_structured(this%TMP,dir//'TMP'//fortran_PS)
         call import_structured(this%EF,dir//'EF'//fortran_PS)
         call import_structured(this%export_now,&
         dir//'export_now'//fortran_PS)
         call import_structured(this%e_budget,dir//'e_budget'//fortran_PS)
         call import_structured(this%e_budget_N,&
         dir//'e_budget_N'//fortran_PS)
         call import_structured(this%e_budget_C,&
         dir//'e_budget_C'//fortran_PS)
         call import_structured(this%restart_root,&
         dir//'restart_root'//fortran_PS)
         call import_structured(this%restart1,dir//'restart1'//fortran_PS)
         call import_structured(this%restart2,dir//'restart2'//fortran_PS)
         call import_structured(this%restart,dir//'restart'//fortran_PS)
         call import_structured(this%unknowns,dir//'unknowns'//fortran_PS)
         call import_structured(this%governing_equations,&
         dir//'governing_equations'//fortran_PS)
         call import_structured(this%PS,dir//'PS'//fortran_PS)
         call import_structured(this%tar,dir//'tar'//fortran_PS)
         call import_structured(this%U,dir//'U'//fortran_PS)
         call import_structured(this%B,dir//'B'//fortran_PS)
         call import_structured(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call import_structured(this%stresses,dir//'stresses'//fortran_PS)
         call import_structured(this%J,dir//'J'//fortran_PS)
         call import_structured(this%T,dir//'T'//fortran_PS)
         call import_structured(this%p,dir//'p'//fortran_PS)
         call import_structured(this%phi,dir//'phi'//fortran_PS)
         call import_structured(this%rho,dir//'rho'//fortran_PS)
         call import_structured(this%test,dir//'test'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_dir_tree(this)
         implicit none
         type(dir_tree),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module export_lines_extend_mod
       use export_lines_mod
       use export_line_mod
       use export_line_extend_mod
       implicit none

       private
       public :: init
       public :: add

       interface init;      module procedure init_ELS;      end interface
       interface add;       module procedure add_ELS;       end interface
       interface add;       module procedure add_ELS_EL;    end interface

       contains

       subroutine init_ELS(ELS,export_ever,dir,line,suffix)
         implicit none
         type(export_lines),intent(inout) :: ELS
         logical,intent(in) :: export_ever
         integer,intent(in) :: dir
         integer,dimension(2),intent(in) :: line
         character(len=1),intent(in) :: suffix
         call delete(ELS)
         allocate(ELS%EL(1))
         call init(ELS%EL(1),export_ever,dir,line,suffix)
         ELS%N = 1
       end subroutine

       subroutine add_ELS(ELS,export_ever,dir,line,suffix)
         implicit none
         type(export_lines),intent(inout) :: ELS
         logical,intent(in) :: export_ever
         integer,intent(in) :: dir
         integer,dimension(2),intent(in) :: line
         character(len=1),intent(in) :: suffix
         type(export_lines) :: temp
         integer :: i
         if (allocated(ELS%EL)) then
           if (size(ELS%EL).gt.0) then
             call init(temp,ELS)
             call delete(ELS)
             allocate(ELS%EL(temp%N+1))
             ELS%N = temp%N+1
             do i=1,temp%N
               call init(ELS%EL(i),temp%EL(i))
             enddo
             call init(ELS%EL(ELS%N),export_ever,dir,line,suffix)
             call delete(temp)
           else; call init(ELS,export_ever,dir,line,suffix)
           endif
         else; call init(ELS,export_ever,dir,line,suffix)
         endif
       end subroutine

       subroutine add_ELS_EL(ELS,EL_in)
         implicit none
         type(export_lines),intent(inout) :: ELS
         type(export_line),intent(in) :: EL_in
         call add(ELS,EL_in%export_ever,EL_in%dir,EL_in%line,EL_in%suffix)
       end subroutine

       end module
       module export_now_extend_mod
       use export_now_mod
       use step_mod
       use step_extend_mod
       use string_mod
       use IO_tools_mod
       implicit none
       private
       public :: export_now
       public :: init,delete,display,export,import
       public :: update

       interface init;     module procedure init_EN;     end interface
       interface update;   module procedure update_EN;   end interface

       contains

       subroutine init_EN(EN,dir,name)
         implicit none
         type(export_now),intent(inout) :: EN
         character(len=*),intent(in) :: dir,name
         call delete(EN%T)
         call delete(EN%rho)
         call delete(EN%U)
         call delete(EN%B)
         call delete(EN%all)
         EN%any_next = .false.
         call init(EN%dir,dir)
         call init(EN%name,name)
       end subroutine

       subroutine update_EN(EN,export_safe)
         implicit none
         type(export_now),intent(inout) :: EN
         logical,intent(in) :: export_safe
         if (export_safe) EN%all%next = .true.
         EN%any_next = any((/EN%T%next,EN%rho%next,EN%U%next,EN%B%next,EN%all%next/))
         EN%any_now  = any((/EN%T%this,EN%rho%this,EN%U%this,EN%B%this,EN%all%this/))
         call update(EN%T)
         call update(EN%rho)
         call update(EN%U)
         call update(EN%B)
         call update(EN%all)
       end subroutine

       end module
       module export_planes_extend_mod
       use export_planes_mod
       use export_plane_mod
       use export_plane_extend_mod
       implicit none

       private
       public :: init
       public :: add

       interface init;      module procedure init_EPS;      end interface
       interface add;       module procedure add_EPS;       end interface
       interface add;       module procedure add_EPS_EP;    end interface

       contains

       subroutine init_EPS(EPS,export_ever,dir,plane,suffix)
         implicit none
         type(export_planes),intent(inout) :: EPS
         logical,intent(in) :: export_ever
         integer,intent(in) :: dir
         integer,intent(in) :: plane
         character(len=1),intent(in) :: suffix
         call delete(EPS)
         allocate(EPS%EP(1))
         call init(EPS%EP(1),export_ever,dir,plane,suffix)
         EPS%N = 1
       end subroutine

       subroutine add_EPS(EPS,export_ever,dir,plane,suffix)
         implicit none
         type(export_planes),intent(inout) :: EPS
         logical,intent(in) :: export_ever
         integer,intent(in) :: dir
         integer,intent(in) :: plane
         character(len=1),intent(in) :: suffix
         type(export_planes) :: temp
         integer :: i
         if (allocated(EPS%EP)) then
           if (size(EPS%EP).gt.0) then
             call init(temp,EPS)
             call delete(EPS)
             allocate(EPS%EP(temp%N+1))
             EPS%N = temp%N+1
             do i=1,temp%N
               call init(EPS%EP(i),temp%EP(i))
             enddo
             call init(EPS%EP(EPS%N),export_ever,dir,plane,suffix)
             call delete(temp)
           else; call init(EPS,export_ever,dir,plane,suffix)
           endif
         else; call init(EPS,export_ever,dir,plane,suffix)
         endif
       end subroutine

       subroutine add_EPS_EP(EPS,EP_in)
         implicit none
         type(export_planes),intent(inout) :: EPS
         type(export_plane),intent(in) :: EP_in
         call add(EPS,EP_in%export_ever,EP_in%dir,EP_in%plane,EP_in%suffix)
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module face_SD_mod
       use current_precision_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use index_2D_mod
       use sub_domain_mod
       use dir_manip_mod
       implicit none

       private
       public :: face_SD
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_face_SD;              end interface
       interface delete;                 module procedure delete_face_SD;                 end interface
       interface display;                module procedure display_face_SD;                end interface
       interface display_short;          module procedure display_short_face_SD;          end interface
       interface display;                module procedure display_wrap_face_SD;           end interface
       interface print;                  module procedure print_face_SD;                  end interface
       interface print_short;            module procedure print_short_face_SD;            end interface
       interface export;                 module procedure export_face_SD;                 end interface
       interface export_primitives;      module procedure export_primitives_face_SD;      end interface
       interface import;                 module procedure import_face_SD;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_face_SD;end interface
       interface export_structured;      module procedure export_structured_D_face_SD;    end interface
       interface import_structured;      module procedure import_structured_D_face_SD;    end interface
       interface import_primitives;      module procedure import_primitives_face_SD;      end interface
       interface export;                 module procedure export_wrap_face_SD;            end interface
       interface import;                 module procedure import_wrap_face_SD;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_face_SD;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_face_SD;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_face_SD;      end interface

       type face_SD
         integer :: s = 0
         type(sub_domain),dimension(6) :: G
         type(sub_domain),dimension(6) :: G_periodic_N
         type(sub_domain),dimension(6) :: B
         type(sub_domain),dimension(6) :: I
         type(sub_domain),dimension(6) :: I_OPP
         type(sub_domain),dimension(6) :: I_OPP_periodic_N
         type(index_2D),dimension(6) :: i_2D
         real(cp),dimension(6) :: dh = 0.0_cp
         real(cp),dimension(6) :: nhat = 0.0_cp
         real(cp),dimension(6) :: c_w = 0.0_cp
         real(cp),dimension(6) :: Robin_coeff = 0.0_cp
       end type

       contains

       subroutine init_copy_face_SD(this,that)
         implicit none
         type(face_SD),intent(inout) :: this
         type(face_SD),intent(in) :: that
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         call delete(this)
         this%s = that%s
         s_G = size(that%G)
         do i_G=1,s_G
           call init(this%G(i_G),that%G(i_G))
         enddo
         s_G_periodic_N = size(that%G_periodic_N)
         do i_G_periodic_N=1,s_G_periodic_N
           call init(this%G_periodic_N(i_G_periodic_N),&
           that%G_periodic_N(i_G_periodic_N))
         enddo
         s_B = size(that%B)
         do i_B=1,s_B
           call init(this%B(i_B),that%B(i_B))
         enddo
         s_I = size(that%I)
         do i_I=1,s_I
           call init(this%I(i_I),that%I(i_I))
         enddo
         s_I_OPP = size(that%I_OPP)
         do i_I_OPP=1,s_I_OPP
           call init(this%I_OPP(i_I_OPP),that%I_OPP(i_I_OPP))
         enddo
         s_I_OPP_periodic_N = size(that%I_OPP_periodic_N)
         do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
           call init(this%I_OPP_periodic_N(i_I_OPP_periodic_N),&
           that%I_OPP_periodic_N(i_I_OPP_periodic_N))
         enddo
         s_i_2D = size(that%i_2D)
         do i_i_2D=1,s_i_2D
           call init(this%i_2D(i_i_2D),that%i_2D(i_i_2D))
         enddo
         this%dh = that%dh
         this%nhat = that%nhat
         this%c_w = that%c_w
         this%Robin_coeff = that%Robin_coeff
       end subroutine

       subroutine delete_face_SD(this)
         implicit none
         type(face_SD),intent(inout) :: this
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         this%s = 0
         s_G = size(this%G)
         do i_G=1,s_G
           call delete(this%G(i_G))
         enddo
         s_G_periodic_N = size(this%G_periodic_N)
         do i_G_periodic_N=1,s_G_periodic_N
           call delete(this%G_periodic_N(i_G_periodic_N))
         enddo
         s_B = size(this%B)
         do i_B=1,s_B
           call delete(this%B(i_B))
         enddo
         s_I = size(this%I)
         do i_I=1,s_I
           call delete(this%I(i_I))
         enddo
         s_I_OPP = size(this%I_OPP)
         do i_I_OPP=1,s_I_OPP
           call delete(this%I_OPP(i_I_OPP))
         enddo
         s_I_OPP_periodic_N = size(this%I_OPP_periodic_N)
         do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
           call delete(this%I_OPP_periodic_N(i_I_OPP_periodic_N))
         enddo
         s_i_2D = size(this%i_2D)
         do i_i_2D=1,s_i_2D
           call delete(this%i_2D(i_i_2D))
         enddo
         this%dh = 0.0_cp
         this%nhat = 0.0_cp
         this%c_w = 0.0_cp
         this%Robin_coeff = 0.0_cp
       end subroutine

       subroutine display_face_SD(this,un)
         implicit none
         type(face_SD),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         write(un,*) 's                = ',this%s
         s_G = size(this%G)
         do i_G=1,s_G
           call display(this%G(i_G),un)
         enddo
         s_G_periodic_N = size(this%G_periodic_N)
         do i_G_periodic_N=1,s_G_periodic_N
           call display(this%G_periodic_N(i_G_periodic_N),un)
         enddo
         s_B = size(this%B)
         do i_B=1,s_B
           call display(this%B(i_B),un)
         enddo
         s_I = size(this%I)
         do i_I=1,s_I
           call display(this%I(i_I),un)
         enddo
         s_I_OPP = size(this%I_OPP)
         do i_I_OPP=1,s_I_OPP
           call display(this%I_OPP(i_I_OPP),un)
         enddo
         s_I_OPP_periodic_N = size(this%I_OPP_periodic_N)
         do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
           call display(this%I_OPP_periodic_N(i_I_OPP_periodic_N),un)
         enddo
         s_i_2D = size(this%i_2D)
         do i_i_2D=1,s_i_2D
           call display(this%i_2D(i_i_2D),un)
         enddo
         write(un,*) 'dh               = ',this%dh
         write(un,*) 'nhat             = ',this%nhat
         write(un,*) 'c_w              = ',this%c_w
         write(un,*) 'Robin_coeff      = ',this%Robin_coeff
       end subroutine

       subroutine display_short_face_SD(this,un)
         implicit none
         type(face_SD),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         write(un,*) 's                = ',this%s
         s_G = size(this%G)
         do i_G=1,s_G
           call display(this%G(i_G),un)
         enddo
         s_G_periodic_N = size(this%G_periodic_N)
         do i_G_periodic_N=1,s_G_periodic_N
           call display(this%G_periodic_N(i_G_periodic_N),un)
         enddo
         s_B = size(this%B)
         do i_B=1,s_B
           call display(this%B(i_B),un)
         enddo
         s_I = size(this%I)
         do i_I=1,s_I
           call display(this%I(i_I),un)
         enddo
         s_I_OPP = size(this%I_OPP)
         do i_I_OPP=1,s_I_OPP
           call display(this%I_OPP(i_I_OPP),un)
         enddo
         s_I_OPP_periodic_N = size(this%I_OPP_periodic_N)
         do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
           call display(this%I_OPP_periodic_N(i_I_OPP_periodic_N),un)
         enddo
         s_i_2D = size(this%i_2D)
         do i_i_2D=1,s_i_2D
           call display(this%i_2D(i_i_2D),un)
         enddo
         write(un,*) 'dh               = ',this%dh
         write(un,*) 'nhat             = ',this%nhat
         write(un,*) 'c_w              = ',this%c_w
         write(un,*) 'Robin_coeff      = ',this%Robin_coeff
       end subroutine

       subroutine display_wrap_face_SD(this,dir,name)
         implicit none
         type(face_SD),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_face_SD(this)
         implicit none
         type(face_SD),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_face_SD(this)
         implicit none
         type(face_SD),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_face_SD(this,un)
         implicit none
         type(face_SD),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         call export_primitives(this,un)
         s_G = size(this%G)
         write(un,*) s_G
         do i_G=1,s_G
           call export(this%G(i_G),un)
         enddo
         s_G_periodic_N = size(this%G_periodic_N)
         write(un,*) s_G_periodic_N
         do i_G_periodic_N=1,s_G_periodic_N
           call export(this%G_periodic_N(i_G_periodic_N),un)
         enddo
         s_B = size(this%B)
         write(un,*) s_B
         do i_B=1,s_B
           call export(this%B(i_B),un)
         enddo
         s_I = size(this%I)
         write(un,*) s_I
         do i_I=1,s_I
           call export(this%I(i_I),un)
         enddo
         s_I_OPP = size(this%I_OPP)
         write(un,*) s_I_OPP
         do i_I_OPP=1,s_I_OPP
           call export(this%I_OPP(i_I_OPP),un)
         enddo
         s_I_OPP_periodic_N = size(this%I_OPP_periodic_N)
         write(un,*) s_I_OPP_periodic_N
         do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
           call export(this%I_OPP_periodic_N(i_I_OPP_periodic_N),un)
         enddo
         s_i_2D = size(this%i_2D)
         write(un,*) s_i_2D
         do i_i_2D=1,s_i_2D
           call export(this%i_2D(i_i_2D),un)
         enddo
       end subroutine

       subroutine import_face_SD(this,un)
         implicit none
         type(face_SD),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_G
         if (s_G.gt.0) then
           do i_G=1,s_G
             call import(this%G(i_G),un)
           enddo
         endif
         read(un,*) s_G_periodic_N
         if (s_G_periodic_N.gt.0) then
           do i_G_periodic_N=1,s_G_periodic_N
             call import(this%G_periodic_N(i_G_periodic_N),un)
           enddo
         endif
         read(un,*) s_B
         if (s_B.gt.0) then
           do i_B=1,s_B
             call import(this%B(i_B),un)
           enddo
         endif
         read(un,*) s_I
         if (s_I.gt.0) then
           do i_I=1,s_I
             call import(this%I(i_I),un)
           enddo
         endif
         read(un,*) s_I_OPP
         if (s_I_OPP.gt.0) then
           do i_I_OPP=1,s_I_OPP
             call import(this%I_OPP(i_I_OPP),un)
           enddo
         endif
         read(un,*) s_I_OPP_periodic_N
         if (s_I_OPP_periodic_N.gt.0) then
           do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
             call import(this%I_OPP_periodic_N(i_I_OPP_periodic_N),un)
           enddo
         endif
         read(un,*) s_i_2D
         if (s_i_2D.gt.0) then
           do i_i_2D=1,s_i_2D
             call import(this%i_2D(i_i_2D),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_face_SD(this,un)
         implicit none
         type(face_SD),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 's                 = ';write(un,*) this%s
         write(un,*) 'dh                = ';write(un,*) this%dh
         write(un,*) 'nhat              = ';write(un,*) this%nhat
         write(un,*) 'c_w               = ';write(un,*) this%c_w
         write(un,*) 'Robin_coeff       = ';write(un,*) this%Robin_coeff
       end subroutine

       subroutine import_primitives_face_SD(this,un)
         implicit none
         type(face_SD),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%s
         read(un,*); read(un,*) this%dh
         read(un,*); read(un,*) this%nhat
         read(un,*); read(un,*) this%c_w
         read(un,*); read(un,*) this%Robin_coeff
       end subroutine

       subroutine export_wrap_face_SD(this,dir,name)
         implicit none
         type(face_SD),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_face_SD(this,dir,name)
         implicit none
         type(face_SD),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_face_SD(this,dir)
         implicit none
         type(face_SD),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         call suppress_warnings(this)
         s_G = size(this%G)
         do i_G=1,s_G
           call set_IO_dir(this%G(i_G),dir//'G_'//int2str(i_G)//fortran_PS)
         enddo
         s_G_periodic_N = size(this%G_periodic_N)
         do i_G_periodic_N=1,s_G_periodic_N
           call set_IO_dir(this%G_periodic_N(i_G_periodic_N),&
           dir//'G_periodic_N_'//int2str(i_G_periodic_N)//fortran_PS)
         enddo
         s_B = size(this%B)
         do i_B=1,s_B
           call set_IO_dir(this%B(i_B),dir//'B_'//int2str(i_B)//fortran_PS)
         enddo
         s_I = size(this%I)
         do i_I=1,s_I
           call set_IO_dir(this%I(i_I),dir//'I_'//int2str(i_I)//fortran_PS)
         enddo
         s_I_OPP = size(this%I_OPP)
         do i_I_OPP=1,s_I_OPP
           call set_IO_dir(this%I_OPP(i_I_OPP),&
           dir//'I_OPP_'//int2str(i_I_OPP)//fortran_PS)
         enddo
         s_I_OPP_periodic_N = size(this%I_OPP_periodic_N)
         do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
           call set_IO_dir(this%I_OPP_periodic_N(i_I_OPP_periodic_N),&
           dir//'I_OPP_periodic_N_'//int2str(i_I_OPP_periodic_N)//fortran_PS)
         enddo
         s_i_2D = size(this%i_2D)
         do i_i_2D=1,s_i_2D
           call set_IO_dir(this%i_2D(i_i_2D),&
           dir//'i_2D_'//int2str(i_i_2D)//fortran_PS)
         enddo
       end subroutine

       subroutine make_IO_dir_face_SD(this,dir)
         implicit none
         type(face_SD),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         s_G = size(this%G)
         do i_G=1,s_G
           call make_IO_dir(this%G(i_G),dir//'G_'//int2str(i_G)//fortran_PS)
         enddo
         s_G_periodic_N = size(this%G_periodic_N)
         do i_G_periodic_N=1,s_G_periodic_N
           call make_IO_dir(this%G_periodic_N(i_G_periodic_N),&
           dir//'G_periodic_N_'//int2str(i_G_periodic_N)//fortran_PS)
         enddo
         s_B = size(this%B)
         do i_B=1,s_B
           call make_IO_dir(this%B(i_B),dir//'B_'//int2str(i_B)//fortran_PS)
         enddo
         s_I = size(this%I)
         do i_I=1,s_I
           call make_IO_dir(this%I(i_I),dir//'I_'//int2str(i_I)//fortran_PS)
         enddo
         s_I_OPP = size(this%I_OPP)
         do i_I_OPP=1,s_I_OPP
           call make_IO_dir(this%I_OPP(i_I_OPP),&
           dir//'I_OPP_'//int2str(i_I_OPP)//fortran_PS)
         enddo
         s_I_OPP_periodic_N = size(this%I_OPP_periodic_N)
         do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
           call make_IO_dir(this%I_OPP_periodic_N(i_I_OPP_periodic_N),&
           dir//'I_OPP_periodic_N_'//int2str(i_I_OPP_periodic_N)//fortran_PS)
         enddo
         s_i_2D = size(this%i_2D)
         do i_i_2D=1,s_i_2D
           call make_IO_dir(this%i_2D(i_i_2D),&
           dir//'i_2D_'//int2str(i_i_2D)//fortran_PS)
         enddo
       end subroutine

       subroutine export_folder_structure_face_SD(this,dir)
         implicit none
         type(face_SD),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         integer :: un
         s_G = size(this%G)
         write(un,*) s_G
         do i_G=1,s_G
           call export_structured(this%G(i_G),&
           dir//'G_'//int2str(i_G)//fortran_PS)
         enddo
         s_G_periodic_N = size(this%G_periodic_N)
         write(un,*) s_G_periodic_N
         do i_G_periodic_N=1,s_G_periodic_N
           call export_structured(this%G_periodic_N(i_G_periodic_N),&
           dir//'G_periodic_N_'//int2str(i_G_periodic_N)//fortran_PS)
         enddo
         s_B = size(this%B)
         write(un,*) s_B
         do i_B=1,s_B
           call export_structured(this%B(i_B),&
           dir//'B_'//int2str(i_B)//fortran_PS)
         enddo
         s_I = size(this%I)
         write(un,*) s_I
         do i_I=1,s_I
           call export_structured(this%I(i_I),&
           dir//'I_'//int2str(i_I)//fortran_PS)
         enddo
         s_I_OPP = size(this%I_OPP)
         write(un,*) s_I_OPP
         do i_I_OPP=1,s_I_OPP
           call export_structured(this%I_OPP(i_I_OPP),&
           dir//'I_OPP_'//int2str(i_I_OPP)//fortran_PS)
         enddo
         s_I_OPP_periodic_N = size(this%I_OPP_periodic_N)
         write(un,*) s_I_OPP_periodic_N
         do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
           call export_structured(this%I_OPP_periodic_N(i_I_OPP_periodic_N),&
           dir//'I_OPP_periodic_N_'//int2str(i_I_OPP_periodic_N)//fortran_PS)
         enddo
         s_i_2D = size(this%i_2D)
         write(un,*) s_i_2D
         do i_i_2D=1,s_i_2D
           call export_structured(this%i_2D(i_i_2D),&
           dir//'i_2D_'//int2str(i_i_2D)//fortran_PS)
         enddo
       end subroutine

       subroutine export_structured_D_face_SD(this,dir)
         implicit none
         type(face_SD),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         s_G = size(this%G)
         write(un,*) s_G
         do i_G=1,s_G
           call export_structured(this%G(i_G),&
           dir//'G_'//int2str(i_G)//fortran_PS)
         enddo
         s_G_periodic_N = size(this%G_periodic_N)
         write(un,*) s_G_periodic_N
         do i_G_periodic_N=1,s_G_periodic_N
           call export_structured(this%G_periodic_N(i_G_periodic_N),&
           dir//'G_periodic_N_'//int2str(i_G_periodic_N)//fortran_PS)
         enddo
         s_B = size(this%B)
         write(un,*) s_B
         do i_B=1,s_B
           call export_structured(this%B(i_B),&
           dir//'B_'//int2str(i_B)//fortran_PS)
         enddo
         s_I = size(this%I)
         write(un,*) s_I
         do i_I=1,s_I
           call export_structured(this%I(i_I),&
           dir//'I_'//int2str(i_I)//fortran_PS)
         enddo
         s_I_OPP = size(this%I_OPP)
         write(un,*) s_I_OPP
         do i_I_OPP=1,s_I_OPP
           call export_structured(this%I_OPP(i_I_OPP),&
           dir//'I_OPP_'//int2str(i_I_OPP)//fortran_PS)
         enddo
         s_I_OPP_periodic_N = size(this%I_OPP_periodic_N)
         write(un,*) s_I_OPP_periodic_N
         do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
           call export_structured(this%I_OPP_periodic_N(i_I_OPP_periodic_N),&
           dir//'I_OPP_periodic_N_'//int2str(i_I_OPP_periodic_N)//fortran_PS)
         enddo
         s_i_2D = size(this%i_2D)
         write(un,*) s_i_2D
         do i_i_2D=1,s_i_2D
           call export_structured(this%i_2D(i_i_2D),&
           dir//'i_2D_'//int2str(i_i_2D)//fortran_PS)
         enddo
         close(un)
       end subroutine

       subroutine import_structured_D_face_SD(this,dir)
         implicit none
         type(face_SD),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_G
         integer :: i_G_periodic_N
         integer :: i_B
         integer :: i_I
         integer :: i_I_OPP
         integer :: i_I_OPP_periodic_N
         integer :: i_i_2D
         integer :: s_G
         integer :: s_G_periodic_N
         integer :: s_B
         integer :: s_I
         integer :: s_I_OPP
         integer :: s_I_OPP_periodic_N
         integer :: s_i_2D
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         s_G = size(this%G)
         do i_G=1,s_G
           call import_structured(this%G(i_G),&
           dir//'G_'//int2str(i_G)//fortran_PS)
         enddo
         s_G_periodic_N = size(this%G_periodic_N)
         do i_G_periodic_N=1,s_G_periodic_N
           call import_structured(this%G_periodic_N(i_G_periodic_N),&
           dir//'G_periodic_N_'//int2str(i_G_periodic_N)//fortran_PS)
         enddo
         s_B = size(this%B)
         do i_B=1,s_B
           call import_structured(this%B(i_B),&
           dir//'B_'//int2str(i_B)//fortran_PS)
         enddo
         s_I = size(this%I)
         do i_I=1,s_I
           call import_structured(this%I(i_I),&
           dir//'I_'//int2str(i_I)//fortran_PS)
         enddo
         s_I_OPP = size(this%I_OPP)
         do i_I_OPP=1,s_I_OPP
           call import_structured(this%I_OPP(i_I_OPP),&
           dir//'I_OPP_'//int2str(i_I_OPP)//fortran_PS)
         enddo
         s_I_OPP_periodic_N = size(this%I_OPP_periodic_N)
         do i_I_OPP_periodic_N=1,s_I_OPP_periodic_N
           call import_structured(this%I_OPP_periodic_N(i_I_OPP_periodic_N),&
           dir//'I_OPP_periodic_N_'//int2str(i_I_OPP_periodic_N)//fortran_PS)
         enddo
         s_i_2D = size(this%i_2D)
         do i_i_2D=1,s_i_2D
           call import_structured(this%i_2D(i_i_2D),&
           dir//'i_2D_'//int2str(i_i_2D)//fortran_PS)
         enddo
         close(un)
       end subroutine

       subroutine suppress_warnings_face_SD(this)
         implicit none
         type(face_SD),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module iter_solver_params_extend_mod
       use iter_solver_params_mod
       use current_precision_mod
       use datatype_conversion_mod
       use string_mod
       use IO_tools_mod
       implicit none

       private
       public :: init
       public :: display_exit_loop
       public :: print_exit_loop

       public :: check_res
       public :: solve_exact
       public :: update_exit_loop
       public :: update_iter
       public :: init_iter_per_call

       public :: boost,reset

       interface init;                 module procedure init_ISP;                 end interface
       interface display_exit_loop;    module procedure display_exit_loop_ISP;    end interface
       interface print_exit_loop;      module procedure print_exit_loop_ISP;      end interface

       interface check_res;            module procedure check_res_ISP;            end interface
       interface update_exit_loop;     module procedure update_exit_loop_ISP;     end interface
       interface update_exit_loop;     module procedure update_exit_loop_ISP2;    end interface
       interface update_iter;          module procedure update_iter_ISP;          end interface
       interface init_iter_per_call;   module procedure init_iter_per_call_ISP;   end interface

       interface boost;                module procedure boost_ISP;                end interface
       interface reset;                module procedure reset_ISP;                end interface

       interface solve_exact;          module procedure solve_exact_ISP;          end interface
       interface solve_exact;          module procedure solve_exact_N_ISP;        end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_ISP(ISP,iter_max,tol_rel,tol_abs,n_skip_check_res,export_convergence,export_heavy)
         implicit none
         type(iter_solver_params),intent(inout) :: ISP
         integer,intent(in) :: iter_max,n_skip_check_res
         real(cp),intent(in) :: tol_rel,tol_abs
         logical,intent(in) :: export_convergence,export_heavy
         ISP%iter_total = 0
         ISP%iter_per_call = 0
         ISP%EC%iter_max = iter_max
         ISP%EC%tol_rel = tol_rel
         ISP%EC%tol_abs = tol_abs
         ISP%export_convergence = export_convergence
         ISP%export_heavy = export_heavy
         ISP%n_skip_check_res = n_skip_check_res
         ISP%exit_loop = .false.
       end subroutine

       subroutine display_exit_loop_ISP(ISP,un)
         implicit none
         type(iter_solver_params),intent(in) :: ISP
         integer,intent(in) :: un
         write(un,*) 'tol (rel,abs)      = ',ISP%EC%tol_rel,ISP%EC%tol_abs
         write(un,*) 'exit_loop,iter_max = ',ISP%exit_loop,ISP%EC%iter_max
       end subroutine

       subroutine print_exit_loop_ISP(ISP)
         implicit none
         type(iter_solver_params),intent(in) :: ISP
         call display_exit_loop(ISP,6)
       end subroutine

       subroutine boost_ISP(ISP)
         implicit none
         type(iter_solver_params),intent(inout) :: ISP
         ISP%EC%iter_max = 4*ISP%EC%iter_max
       end subroutine
       subroutine reset_ISP(ISP)
         implicit none
         type(iter_solver_params),intent(inout) :: ISP
         ISP%EC%iter_max = ISP%EC%iter_max/4
       end subroutine

       subroutine update_exit_loop_ISP(ISP,res,res0)
         implicit none
         type(iter_solver_params),intent(inout) :: ISP
         real(cp),intent(in) :: res,res0
         ISP%exit_loop(1) = res/res0.lt.ISP%EC%tol_rel
         ISP%exit_loop(2) = res.lt.ISP%EC%tol_abs
         ISP%exit_loop(3) = ISP%iter_per_call.ge.ISP%EC%iter_max
       end subroutine

       subroutine update_exit_loop_ISP2(ISP)
         implicit none
         type(iter_solver_params),intent(inout) :: ISP
         ISP%exit_loop(3) = ISP%iter_per_call.ge.ISP%EC%iter_max
       end subroutine

       subroutine update_iter_ISP(ISP)
         implicit none
         type(iter_solver_params),intent(inout) :: ISP
         ISP%iter_total = ISP%iter_total + 1
         ISP%iter_per_call = ISP%iter_per_call + 1
       end subroutine

       function check_res_ISP(ISP) result(L)
         implicit none
         type(iter_solver_params),intent(in) :: ISP
         logical :: L
         L = mod(ISP%iter_per_call,ISP%n_skip_check_res).eq.0
       end function

       subroutine init_iter_per_call_ISP(ISP)
         implicit none
         type(iter_solver_params),intent(inout) :: ISP
         ISP%iter_per_call = 0
       end subroutine

       function solve_exact_ISP(dir) result(ISP)
         implicit none
         character(len=*),intent(in) :: dir
         type(iter_solver_params) :: ISP
         real(cp) :: tol_rel,tol_abs
         integer :: iter_max,n_skip_check_res
         logical :: export_heavy
         tol_rel = 0.0_cp
         tol_abs = 10.0_cp*machine_epsilon
         iter_max = 10000
         n_skip_check_res = 100
         export_heavy = .true.
         call init(ISP,iter_max,tol_rel,tol_abs,n_skip_check_res,.false.,export_heavy)
         call init(ISP%dir,dir)
         call init(ISP%name,'solve_exact')
       end function

       function solve_exact_N_ISP(dir,N) result(ISP)
         implicit none
         character(len=*),intent(in) :: dir
         integer,intent(in) :: N
         type(iter_solver_params) :: ISP
         real(cp) :: tol_rel,tol_abs
         integer :: iter_max,n_skip_check_res
         logical :: export_heavy
         tol_rel = 0.0_cp
         tol_abs = 10.0_cp*machine_epsilon
         iter_max = N
         n_skip_check_res = 100
         export_heavy = .true.
         call init(ISP,iter_max,tol_rel,tol_abs,&
         n_skip_check_res,.false.,export_heavy)
         call init(ISP%dir,dir)
         call init(ISP%name,'solve_in_'//int2str(N)//'_iter')
       end function

       end module
       module mesh_params_extend_mod
       use IO_tools_mod
       use mesh_quality_params_mod
       use segment_mod
       use mesh_params_mod
       implicit none

       private
       public :: init
       public :: add_base
       public :: add_ext

       interface init;        module procedure init_MQP;           end interface
       interface add_base;    module procedure add_base_MP;        end interface
       interface add_ext;     module procedure add_ext_MP;         end interface

       contains

       subroutine init_MQP(MP,MQP)
         implicit none
         type(mesh_params),intent(inout) :: MP
         type(mesh_quality_params),intent(in) :: MQP
         call init(MP%MQP,MQP)
       end subroutine

       subroutine add_base_MP(MP,S)
         implicit none
         type(mesh_params),intent(inout) :: MP
         type(segment),intent(in) :: S
         type(mesh_params) :: temp
         integer :: i
         if (allocated(MP%s_base)) then
           if (MP%n_base.lt.1) then
             write(*,*) 'Error: allocated mesh_params but size<1 in add_base_MP'
             stop 'Done in mesh_params_extend.f90'
           endif
           call init(temp,MP)
           do i=1,size(MP%s_base)
             call delete(MP%s_base(i))
           enddo
           deallocate(MP%s_base)
           MP%n_base = temp%n_base + 1
           allocate(MP%s_base(MP%n_base))
           do i=1,temp%n_base; call init(MP%s_base(i),temp%s_base(i)); enddo
           call init(MP%s_base(MP%n_base),S)
           call delete(temp)
         else
           allocate(MP%s_base(1))
           call init(MP%s_base(1),S); MP%n_base = 1
         endif
       end subroutine

       subroutine add_ext_MP(MP,S)
         implicit none
         type(mesh_params),intent(inout) :: MP
         type(segment),intent(in) :: S
         type(mesh_params) :: temp
         integer :: i
         if (allocated(MP%s_ext)) then
           if (MP%n_ext.lt.1) then
             write(*,*) 'Error: allocated mesh_params but size<1 in add_ext_MP'
             stop 'Done in mesh_params_extend.f90'
           endif
           call init(temp,MP)
           do i=1,size(MP%s_ext)
             call delete(MP%s_ext(i))
           enddo
           deallocate(MP%s_ext)
           MP%n_ext = temp%n_ext + 1
           allocate(MP%s_ext(MP%n_ext))
           do i=1,temp%n_ext; call init(MP%s_ext(i),temp%s_ext(i)); enddo
           call init(MP%s_ext(MP%n_ext),S)
           call delete(temp)
         else
           allocate(MP%s_ext(1))
           call init(MP%s_ext(1),S); MP%n_ext = 1
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module physical_sub_domain_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use sub_domain_mod
       use dir_manip_mod
       implicit none

       private
       public :: physical_sub_domain
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_physical_sub_domain;              end interface
       interface delete;                 module procedure delete_physical_sub_domain;                 end interface
       interface display;                module procedure display_physical_sub_domain;                end interface
       interface display_short;          module procedure display_short_physical_sub_domain;          end interface
       interface display;                module procedure display_wrap_physical_sub_domain;           end interface
       interface print;                  module procedure print_physical_sub_domain;                  end interface
       interface print_short;            module procedure print_short_physical_sub_domain;            end interface
       interface export;                 module procedure export_physical_sub_domain;                 end interface
       interface export_primitives;      module procedure export_primitives_physical_sub_domain;      end interface
       interface import;                 module procedure import_physical_sub_domain;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_physical_sub_domain;end interface
       interface export_structured;      module procedure export_structured_D_physical_sub_domain;    end interface
       interface import_structured;      module procedure import_structured_D_physical_sub_domain;    end interface
       interface import_primitives;      module procedure import_primitives_physical_sub_domain;      end interface
       interface export;                 module procedure export_wrap_physical_sub_domain;            end interface
       interface import;                 module procedure import_wrap_physical_sub_domain;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_physical_sub_domain;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_physical_sub_domain;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_physical_sub_domain;      end interface

       type physical_sub_domain
         type(sub_domain) :: total
         type(sub_domain) :: physical
         logical :: defined = .false.
       end type

       contains

       subroutine init_copy_physical_sub_domain(this,that)
         implicit none
         type(physical_sub_domain),intent(inout) :: this
         type(physical_sub_domain),intent(in) :: that
         call delete(this)
         call init(this%total,that%total)
         call init(this%physical,that%physical)
         this%defined = that%defined
       end subroutine

       subroutine delete_physical_sub_domain(this)
         implicit none
         type(physical_sub_domain),intent(inout) :: this
         call delete(this%total)
         call delete(this%physical)
         this%defined = .false.
       end subroutine

       subroutine display_physical_sub_domain(this,un)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         integer,intent(in) :: un
         call display(this%total,un)
         call display(this%physical,un)
         write(un,*) 'defined  = ',this%defined
       end subroutine

       subroutine display_short_physical_sub_domain(this,un)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         integer,intent(in) :: un
         call display(this%total,un)
         call display(this%physical,un)
         write(un,*) 'defined  = ',this%defined
       end subroutine

       subroutine display_wrap_physical_sub_domain(this,dir,name)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_physical_sub_domain(this)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_physical_sub_domain(this)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_physical_sub_domain(this,un)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%total,un)
         call export(this%physical,un)
       end subroutine

       subroutine import_physical_sub_domain(this,un)
         implicit none
         type(physical_sub_domain),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%total,un)
         call import(this%physical,un)
       end subroutine

       subroutine export_primitives_physical_sub_domain(this,un)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined   = ';write(un,*) this%defined
       end subroutine

       subroutine import_primitives_physical_sub_domain(this,un)
         implicit none
         type(physical_sub_domain),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%defined
       end subroutine

       subroutine export_wrap_physical_sub_domain(this,dir,name)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_physical_sub_domain(this,dir,name)
         implicit none
         type(physical_sub_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_physical_sub_domain(this,dir)
         implicit none
         type(physical_sub_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%total,dir//'total'//fortran_PS)
         call set_IO_dir(this%physical,dir//'physical'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_physical_sub_domain(this,dir)
         implicit none
         type(physical_sub_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%total,dir//'total'//fortran_PS)
         call make_IO_dir(this%physical,dir//'physical'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_physical_sub_domain(this,dir)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%total,dir//'total'//fortran_PS)
         call export_structured(this%physical,dir//'physical'//fortran_PS)
       end subroutine

       subroutine export_structured_D_physical_sub_domain(this,dir)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%total,dir//'total'//fortran_PS)
         call export_structured(this%physical,dir//'physical'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_physical_sub_domain(this,dir)
         implicit none
         type(physical_sub_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%total,dir//'total'//fortran_PS)
         call import_structured(this%physical,dir//'physical'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_physical_sub_domain(this)
         implicit none
         type(physical_sub_domain),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module single_procedure_plane_op_mod
       use plane_op_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: single_procedure_plane_op
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_single_procedure_plane_op;              end interface
       interface delete;                 module procedure delete_single_procedure_plane_op;                 end interface
       interface display;                module procedure display_single_procedure_plane_op;                end interface
       interface display_short;          module procedure display_short_single_procedure_plane_op;          end interface
       interface display;                module procedure display_wrap_single_procedure_plane_op;           end interface
       interface print;                  module procedure print_single_procedure_plane_op;                  end interface
       interface print_short;            module procedure print_short_single_procedure_plane_op;            end interface
       interface export;                 module procedure export_single_procedure_plane_op;                 end interface
       interface export_primitives;      module procedure export_primitives_single_procedure_plane_op;      end interface
       interface import;                 module procedure import_single_procedure_plane_op;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_single_procedure_plane_op;end interface
       interface export_structured;      module procedure export_structured_D_single_procedure_plane_op;    end interface
       interface import_structured;      module procedure import_structured_D_single_procedure_plane_op;    end interface
       interface import_primitives;      module procedure import_primitives_single_procedure_plane_op;      end interface
       interface export;                 module procedure export_wrap_single_procedure_plane_op;            end interface
       interface import;                 module procedure import_wrap_single_procedure_plane_op;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_single_procedure_plane_op;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_single_procedure_plane_op;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_single_procedure_plane_op;      end interface

       type single_procedure_plane_op
         procedure(plane_op),pointer,nopass :: P
         logical :: defined = .false.
         integer :: ID = 0
       end type

       contains

       subroutine init_copy_single_procedure_plane_op(this,that)
         implicit none
         type(single_procedure_plane_op),intent(inout) :: this
         type(single_procedure_plane_op),intent(in) :: that
         call delete(this)
         this%P => that%P
         this%defined = that%defined
         this%ID = that%ID
       end subroutine

       subroutine delete_single_procedure_plane_op(this)
         implicit none
         type(single_procedure_plane_op),intent(inout) :: this
         nullify(this%P)
         this%defined = .false.
         this%ID = 0
       end subroutine

       subroutine display_single_procedure_plane_op(this,un)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined = ',this%defined
         write(un,*) 'ID      = ',this%ID
       end subroutine

       subroutine display_short_single_procedure_plane_op(this,un)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined = ',this%defined
         write(un,*) 'ID      = ',this%ID
       end subroutine

       subroutine display_wrap_single_procedure_plane_op(this,dir,name)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_single_procedure_plane_op(this)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_single_procedure_plane_op(this)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_single_procedure_plane_op(this,un)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_single_procedure_plane_op(this,un)
         implicit none
         type(single_procedure_plane_op),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_single_procedure_plane_op(this,un)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined  = ';write(un,*) this%defined
         write(un,*) 'ID       = ';write(un,*) this%ID
       end subroutine

       subroutine import_primitives_single_procedure_plane_op(this,un)
         implicit none
         type(single_procedure_plane_op),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%defined
         read(un,*); read(un,*) this%ID
       end subroutine

       subroutine export_wrap_single_procedure_plane_op(this,dir,name)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_single_procedure_plane_op(this,dir,name)
         implicit none
         type(single_procedure_plane_op),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_single_procedure_plane_op(this,dir)
         implicit none
         type(single_procedure_plane_op),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_single_procedure_plane_op(this,dir)
         implicit none
         type(single_procedure_plane_op),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_single_procedure_plane_op(this,&
       dir)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_single_procedure_plane_op(this,dir)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_single_procedure_plane_op(this,dir)
         implicit none
         type(single_procedure_plane_op),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_single_procedure_plane_op(this)
         implicit none
         type(single_procedure_plane_op),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module sparse_extend_mod
      use sparse_mod
      use array_mod
      use array_extend_mod
      use current_precision_mod
      implicit none
      private
      public :: sparse
      public :: init

      public :: assign
      public :: multiply

      public :: init_L,init_D,init_U
      public :: check
      public :: insist_allocated

      interface init;                module procedure init_sparse_size;           end interface
      interface init;                module procedure init_sparse_3;              end interface
      interface init;                module procedure init_sparse_3_array;        end interface
      interface init;                module procedure init_sparse_1;              end interface
      interface init_L;              module procedure init_sparse_L;              end interface
      interface init_D;              module procedure init_sparse_D;              end interface
      interface init_U;              module procedure init_sparse_U;              end interface

      interface check;               module procedure check_sparse;               end interface
      interface insist_allocated;    module procedure insist_allocated_sparse;    end interface

      interface assign;              module procedure assign_sparse;              end interface
      interface multiply;            module procedure multiply_sparse;            end interface

      contains

      subroutine init_sparse_size(S,N)
        implicit none
        type(sparse),intent(inout) :: S
        integer,intent(in) :: N
        call delete(S)
        call init(S%L,N)
        call init(S%D,N)
        call init(S%U,N)
        S%staggered = S%L%N.eq.1
      end subroutine

      subroutine init_sparse_3_array(S,L,D,U)
        implicit none
        type(sparse),intent(inout) :: S
        type(array),intent(in) :: L,D,U
        call delete(S)
        call init(S%L,L)
        call init(S%D,D)
        call init(S%U,U)
        S%staggered = S%L%N.eq.1
      end subroutine

      subroutine init_sparse_3(S,L,D,U,N_L,N_D,N_U)
        implicit none
        type(sparse),intent(inout) :: S
        integer,intent(in) :: N_L,N_D,N_U
        real(cp),dimension(N_L),intent(in) :: L
        real(cp),dimension(N_D),intent(in) :: D
        real(cp),dimension(N_U),intent(in) :: U
        call delete(S)
        call init(S%L,L,N_L)
        call init(S%D,D,N_D)
        call init(S%U,U,N_U)
        S%staggered = S%L%N.eq.1
      end subroutine

      subroutine init_sparse_1(S,L,D,U,N)
        implicit none
        type(sparse),intent(inout) :: S
        integer,intent(in) :: N
        real(cp),dimension(N),intent(in) :: L
        real(cp),dimension(N),intent(in) :: D
        real(cp),dimension(N),intent(in) :: U
        call delete(S)
        call init(S%L,L,N)
        call init(S%D,D,N)
        call init(S%U,U,N)
        S%staggered = S%L%N.eq.1
      end subroutine

      subroutine init_sparse_L(S,L,N)
        implicit none
        type(sparse),intent(inout) :: S
        integer,intent(in) :: N
        real(cp),dimension(N),intent(in) :: L
        call init(S%L,L,N)
        S%staggered = S%L%N.eq.1
      end subroutine

      subroutine init_sparse_D(S,D,N)
        implicit none
        type(sparse),intent(inout) :: S
        integer,intent(in) :: N
        real(cp),dimension(N),intent(in) :: D
        call init(S%D,D,N)
      end subroutine

      subroutine init_sparse_U(S,U,N)
        implicit none
        type(sparse),intent(inout) :: S
        integer,intent(in) :: N
        real(cp),dimension(N),intent(in) :: U
        call init(S%U,U,N)
      end subroutine

      ! *********************************************************************

      subroutine check_sparse(S)
        implicit none
        type(sparse),intent(in) :: S
        logical,dimension(3) :: L
        L(1) = allocated(S%L%f)
        L(2) = allocated(S%D%f)
        L(3) = allocated(S%U%f)
        if (all(L)) then
          write(*,*) 'The sum of the stencils should be zero:'
          call print(S%L)
          call print(S%D)
          call print(S%U)
        elseif (L(2).and.L(3)) then
            write(*,*) 'The sum of the stencils should be zero:'
            call print(S%D)
            call print(S%U)
        else; stop 'Error: case not found in check_sparse in sparse.f90'
        endif
      end subroutine

      subroutine insist_allocated_sparse(S,caller)
        implicit none
        type(sparse),intent(in) :: S
        character(len=*),intent(in) :: caller
        call insist_allocated(S%L,caller//' sparse(L)')
        call insist_allocated(S%D,caller//' sparse(D)')
        call insist_allocated(S%U,caller//' sparse(U)')
      end subroutine

      subroutine assign_sparse(S,val)
        implicit none
        type(sparse),intent(inout) :: S
        real(cp),intent(in) :: val
        call assign(S%L,val)
        call assign(S%D,val)
        call assign(S%U,val)
      end subroutine

      subroutine multiply_sparse(S,val)
        implicit none
        type(sparse),intent(inout) :: S
        real(cp),intent(in) :: val
        call multiply(S%L,val)
        call multiply(S%D,val)
        call multiply(S%U,val)
      end subroutine

      end module
      module stencils_mod
      use current_precision_mod
      use sparse_mod
      implicit none
      private

      abstract interface
        pure subroutine stencils_stag(dfdh,f,SP,s,sdfdh,gt)
          import :: sparse,cp
          implicit none
          integer,intent(in) :: s,sdfdh
          real(cp),dimension(sdfdh),intent(inout) :: dfdh
          real(cp),dimension(s),intent(in) :: f
          type(sparse),intent(in) :: SP
          integer,intent(in) :: gt
        end subroutine
      end interface

      abstract interface
        pure subroutine stencils_col(dfdh,f,SP,s,pad1,pad2)
          import :: sparse,cp
          implicit none
          integer,intent(in) :: s,pad1,pad2
          real(cp),dimension(s),intent(inout) :: dfdh
          real(cp),dimension(s),intent(in) :: f
          type(sparse),intent(in) :: SP
        end subroutine
      end interface

      public :: stencils_col
      public :: stencils_stag

      public :: stag_assign
      public :: col_CC_assign
      public :: col_N_assign

      public :: stag_add
      public :: col_CC_add
      public :: col_N_add

      public :: stag_subtract
      public :: col_CC_subtract
      public :: col_N_subtract

      contains

      pure subroutine stag_assign(dfdh,f,SP,s,sdfdh,gt)
        implicit none
        integer,intent(in) :: s,sdfdh
        real(cp),dimension(sdfdh),intent(inout) :: dfdh
        real(cp),dimension(s),intent(in) :: f
        type(sparse),intent(in) :: SP
        integer,intent(in) :: gt
        integer :: i
        dfdh(1) = 0.0_cp; dfdh(sdfdh) = 0.0_cp ! Intentially overwritten for gt = 0
        do i=1,s-1
          dfdh(i+gt) = f(i)*SP%D%f(i) + f(i+1)*SP%U%f(i)
        enddo
      end subroutine
      pure subroutine col_CC_assign(dfdh,f,SP,s,pad1,pad2)
        implicit none
        integer,intent(in) :: s,pad1,pad2
        real(cp),dimension(s),intent(inout) :: dfdh
        real(cp),dimension(s),intent(in) :: f
        type(sparse),intent(in) :: SP
        integer :: i
        do i=3,s-2
          dfdh(i) = f(i-1)*SP%L%f(i-1) + &
                    f( i )*SP%D%f(i-1) + &
                    f(i+1)*SP%U%f(i-1)
        enddo

        dfdh(2) = 0.5*(f(1)+f(2))*SP%L%f(1)*(1.0_cp-pad1) + & ! pad1==0
                             f(1)*SP%L%f(1)*pad1 + &          ! pad1==1
                             f(2)*SP%D%f(1) + &
                             f(3)*SP%U%f(1)

        dfdh(s-1) =            f(s-2)*SP%L%f(s-2) + &
                               f(s-1)*SP%D%f(s-2) + &
                    0.5*(f(s-1)+f(s))*SP%U%f(s-2)*(1.0_cp-pad2) + &  ! pad2==0
                                 f(s)*SP%U%f(s-2)*pad2               ! pad2==1

        dfdh(1) = 0.0_cp; dfdh(s) = 0.0_cp
      end subroutine
      pure subroutine col_N_assign(dfdh,f,SP,s,pad1,pad2)
        implicit none
        integer,intent(in) :: s,pad1,pad2
        real(cp),dimension(s),intent(inout) :: dfdh
        real(cp),dimension(s),intent(in) :: f
        type(sparse),intent(in) :: SP
        integer :: i
        do i=3,s-2
          dfdh(i) = f(i-1)*SP%L%f(i-1) + &
                    f( i )*SP%D%f(i-1) + &
                    f(i+1)*SP%U%f(i-1)
        enddo
        dfdh(2) = f(2-pad1)*SP%L%f(1) + &
                  f(3-pad1)*SP%D%f(1) + &
                  f(4-pad1)*SP%U%f(1)

        dfdh(s-1) = f(s-3+pad2)*SP%L%f(s-2) + &
                    f(s-2+pad2)*SP%D%f(s-2) + &
                    f(s-1+pad2)*SP%U%f(s-2)

        dfdh(1) = 0.0_cp; dfdh(s) = 0.0_cp
      end subroutine

      pure subroutine stag_add(dfdh,f,SP,s,sdfdh,gt)
        implicit none
        integer,intent(in) :: s,sdfdh
        real(cp),dimension(sdfdh),intent(inout) :: dfdh
        real(cp),dimension(s),intent(in) :: f
        type(sparse),intent(in) :: SP
        integer,intent(in) :: gt
        integer :: i
        dfdh(1) = 0.0_cp; dfdh(sdfdh) = 0.0_cp ! Intentially overwritten for gt = 0
        do i=1,s-1
          dfdh(i+gt) = dfdh(i+gt) + f(i)*SP%D%f(i) + f(i+1)*SP%U%f(i)
        enddo
      end subroutine
      pure subroutine col_CC_add(dfdh,f,SP,s,pad1,pad2)
        implicit none
        integer,intent(in) :: s,pad1,pad2
        real(cp),dimension(s),intent(inout) :: dfdh
        real(cp),dimension(s),intent(in) :: f
        type(sparse),intent(in) :: SP
        integer :: i
        do i=3,s-2
          dfdh(i) = dfdh(i) + f(i-1)*SP%L%f(i-1) + &
                              f( i )*SP%D%f(i-1) + &
                              f(i+1)*SP%U%f(i-1)
        enddo

        dfdh(2) = dfdh(2) + 0.5*(f(1)+f(2))*SP%L%f(1)*(1.0_cp-pad1) + & ! pad1==0
                                       f(1)*SP%L%f(1)*pad1 + &          ! pad1==1
                                       f(2)*SP%D%f(1) + &
                                       f(3)*SP%U%f(1)

        dfdh(s-1) = dfdh(s-1) +          f(s-2)*SP%L%f(s-2) + &
                                         f(s-1)*SP%D%f(s-2) + &
                              0.5*(f(s-1)+f(s))*SP%U%f(s-2)*(1.0_cp-pad2) + &  ! pad2==0
                                           f(s)*SP%U%f(s-2)*pad2               ! pad2==1

        dfdh(1) = 0.0_cp; dfdh(s) = 0.0_cp
      end subroutine
      pure subroutine col_N_add(dfdh,f,SP,s,pad1,pad2)
        implicit none
        integer,intent(in) :: s,pad1,pad2
        real(cp),dimension(s),intent(inout) :: dfdh
        real(cp),dimension(s),intent(in) :: f
        type(sparse),intent(in) :: SP
        integer :: i
        do i=3,s-2
          dfdh(i) = dfdh(i) + f(i-1)*SP%L%f(i-1) + &
                              f( i )*SP%D%f(i-1) + &
                              f(i+1)*SP%U%f(i-1)
        enddo
        dfdh(2) = dfdh(2) + f(2-pad1)*SP%L%f(1) + &
                            f(3-pad1)*SP%D%f(1) + &
                            f(4-pad1)*SP%U%f(1)

        dfdh(s-1) = dfdh(s-1) + f(s-3+pad2)*SP%L%f(s-2) + &
                                f(s-2+pad2)*SP%D%f(s-2) + &
                                f(s-1+pad2)*SP%U%f(s-2)

        dfdh(1) = 0.0_cp; dfdh(s) = 0.0_cp
      end subroutine

      pure subroutine stag_subtract(dfdh,f,SP,s,sdfdh,gt)
        implicit none
        integer,intent(in) :: s,sdfdh
        real(cp),dimension(sdfdh),intent(inout) :: dfdh
        real(cp),dimension(s),intent(in) :: f
        type(sparse),intent(in) :: SP
        integer,intent(in) :: gt
        integer :: i
        dfdh(1) = 0.0_cp; dfdh(sdfdh) = 0.0_cp ! Intentially overwritten for gt = 0
        do i=1,s-1
          dfdh(i+gt) = dfdh(i+gt) - (f(i)*SP%D%f(i) + f(i+1)*SP%U%f(i))
        enddo
      end subroutine
      pure subroutine col_CC_subtract(dfdh,f,SP,s,pad1,pad2)
        implicit none
        integer,intent(in) :: s,pad1,pad2
        real(cp),dimension(s),intent(inout) :: dfdh
        real(cp),dimension(s),intent(in) :: f
        type(sparse),intent(in) :: SP
        integer :: i
        do i=3,s-2
          dfdh(i) = dfdh(i) - (f(i-1)*SP%L%f(i-1) + &
                               f( i )*SP%D%f(i-1) + &
                               f(i+1)*SP%U%f(i-1))
        enddo

        dfdh(2) = dfdh(2) - (0.5*(f(1)+f(2))*SP%L%f(1)*(1.0_cp-pad1) + & ! pad1==0
                                        f(1)*SP%L%f(1)*pad1 + &          ! pad1==1
                                        f(2)*SP%D%f(1) + &
                                        f(3)*SP%U%f(1))

        dfdh(s-1) = dfdh(s-1) - (           f(s-2)*SP%L%f(s-2) + &
                                            f(s-1)*SP%D%f(s-2) + &
                                 0.5*(f(s-1)+f(s))*SP%U%f(s-2)*(1.0_cp-pad2) + &  ! pad2==0
                                 f(s)*SP%U%f(s-2)*pad2)                           ! pad2==1

        dfdh(1) = 0.0_cp; dfdh(s) = 0.0_cp
      end subroutine
      pure subroutine col_N_subtract(dfdh,f,SP,s,pad1,pad2)
        implicit none
        integer,intent(in) :: s,pad1,pad2
        real(cp),dimension(s),intent(inout) :: dfdh
        real(cp),dimension(s),intent(in) :: f
        type(sparse),intent(in) :: SP
        integer :: i
        do i=3,s-2
          dfdh(i) = dfdh(i) - (f(i-1)*SP%L%f(i-1) + &
                               f( i )*SP%D%f(i-1) + &
                               f(i+1)*SP%U%f(i-1))
        enddo
        dfdh(2) = dfdh(2) - (f(2-pad1)*SP%L%f(1) + &
                             f(3-pad1)*SP%D%f(1) + &
                             f(4-pad1)*SP%U%f(1))

        dfdh(s-1) = dfdh(s-1) - (f(s-3+pad2)*SP%L%f(s-2) + &
                                 f(s-2+pad2)*SP%D%f(s-2) + &
                                 f(s-1+pad2)*SP%U%f(s-2))

        dfdh(1) = 0.0_cp; dfdh(s) = 0.0_cp
      end subroutine

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module time_marching_params_mod
       use current_precision_mod
       use RK_params_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use time_step_mod
       use dir_manip_mod
       implicit none

       private
       public :: time_marching_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_time_marching_params;              end interface
       interface delete;                 module procedure delete_time_marching_params;                 end interface
       interface display;                module procedure display_time_marching_params;                end interface
       interface display_short;          module procedure display_short_time_marching_params;          end interface
       interface display;                module procedure display_wrap_time_marching_params;           end interface
       interface print;                  module procedure print_time_marching_params;                  end interface
       interface print_short;            module procedure print_short_time_marching_params;            end interface
       interface export;                 module procedure export_time_marching_params;                 end interface
       interface export_primitives;      module procedure export_primitives_time_marching_params;      end interface
       interface import;                 module procedure import_time_marching_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_time_marching_params;end interface
       interface export_structured;      module procedure export_structured_D_time_marching_params;    end interface
       interface import_structured;      module procedure import_structured_D_time_marching_params;    end interface
       interface import_primitives;      module procedure import_primitives_time_marching_params;      end interface
       interface export;                 module procedure export_wrap_time_marching_params;            end interface
       interface import;                 module procedure import_wrap_time_marching_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_time_marching_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_time_marching_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_time_marching_params;      end interface

       type time_marching_params
         type(RK_Params) :: RKP
         type(time_step) :: TS
         integer :: multistep_iter = 0
         integer :: un = 0
         integer(li) :: n_step = 0
         integer(li) :: n_step_stop = 0
         integer(li) :: n_step_start = 0
         real(cp) :: t = 0.0_cp
         real(cp) :: C_max = 0.0_cp
       end type

       contains

       subroutine init_copy_time_marching_params(this,that)
         implicit none
         type(time_marching_params),intent(inout) :: this
         type(time_marching_params),intent(in) :: that
         call delete(this)
         call init(this%RKP,that%RKP)
         call init(this%TS,that%TS)
         this%multistep_iter = that%multistep_iter
         this%un = that%un
         this%n_step = that%n_step
         this%n_step_stop = that%n_step_stop
         this%n_step_start = that%n_step_start
         this%t = that%t
         this%C_max = that%C_max
       end subroutine

       subroutine delete_time_marching_params(this)
         implicit none
         type(time_marching_params),intent(inout) :: this
         call delete(this%RKP)
         call delete(this%TS)
         this%multistep_iter = 0
         this%un = 0
         this%n_step = 0
         this%n_step_stop = 0
         this%n_step_start = 0
         this%t = 0.0_cp
         this%C_max = 0.0_cp
       end subroutine

       subroutine display_time_marching_params(this,un)
         implicit none
         type(time_marching_params),intent(in) :: this
         integer,intent(in) :: un
         call display(this%RKP,un)
         call display(this%TS,un)
         write(un,*) 'multistep_iter = ',this%multistep_iter
         write(un,*) 'un             = ',this%un
         write(un,*) 'n_step         = ',this%n_step
         write(un,*) 'n_step_stop    = ',this%n_step_stop
         write(un,*) 'n_step_start   = ',this%n_step_start
         write(un,*) 't              = ',this%t
         write(un,*) 'C_max          = ',this%C_max
       end subroutine

       subroutine display_short_time_marching_params(this,un)
         implicit none
         type(time_marching_params),intent(in) :: this
         integer,intent(in) :: un
         call display(this%RKP,un)
         call display(this%TS,un)
         write(un,*) 'multistep_iter = ',this%multistep_iter
         write(un,*) 'un             = ',this%un
         write(un,*) 'n_step         = ',this%n_step
         write(un,*) 'n_step_stop    = ',this%n_step_stop
         write(un,*) 'n_step_start   = ',this%n_step_start
         write(un,*) 't              = ',this%t
         write(un,*) 'C_max          = ',this%C_max
       end subroutine

       subroutine display_wrap_time_marching_params(this,dir,name)
         implicit none
         type(time_marching_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_time_marching_params(this)
         implicit none
         type(time_marching_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_time_marching_params(this)
         implicit none
         type(time_marching_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_time_marching_params(this,un)
         implicit none
         type(time_marching_params),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%RKP,un)
         call export(this%TS,un)
       end subroutine

       subroutine import_time_marching_params(this,un)
         implicit none
         type(time_marching_params),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%RKP,un)
         call import(this%TS,un)
       end subroutine

       subroutine export_primitives_time_marching_params(this,un)
         implicit none
         type(time_marching_params),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'multistep_iter  = ';write(un,*) this%multistep_iter
         write(un,*) 'un              = ';write(un,*) this%un
         write(un,*) 'n_step          = ';write(un,*) this%n_step
         write(un,*) 'n_step_stop     = ';write(un,*) this%n_step_stop
         write(un,*) 'n_step_start    = ';write(un,*) this%n_step_start
         write(un,*) 't               = ';write(un,*) this%t
         write(un,*) 'C_max           = ';write(un,*) this%C_max
       end subroutine

       subroutine import_primitives_time_marching_params(this,un)
         implicit none
         type(time_marching_params),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%multistep_iter
         read(un,*); read(un,*) this%un
         read(un,*); read(un,*) this%n_step
         read(un,*); read(un,*) this%n_step_stop
         read(un,*); read(un,*) this%n_step_start
         read(un,*); read(un,*) this%t
         read(un,*); read(un,*) this%C_max
       end subroutine

       subroutine export_wrap_time_marching_params(this,dir,name)
         implicit none
         type(time_marching_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_time_marching_params(this,dir,name)
         implicit none
         type(time_marching_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_time_marching_params(this,dir)
         implicit none
         type(time_marching_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%RKP,dir//'RKP'//fortran_PS)
         call set_IO_dir(this%TS,dir//'TS'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_time_marching_params(this,dir)
         implicit none
         type(time_marching_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%RKP,dir//'RKP'//fortran_PS)
         call make_IO_dir(this%TS,dir//'TS'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_time_marching_params(this,dir)
         implicit none
         type(time_marching_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%RKP,dir//'RKP'//fortran_PS)
         call export_structured(this%TS,dir//'TS'//fortran_PS)
       end subroutine

       subroutine export_structured_D_time_marching_params(this,dir)
         implicit none
         type(time_marching_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%RKP,dir//'RKP'//fortran_PS)
         call export_structured(this%TS,dir//'TS'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_time_marching_params(this,dir)
         implicit none
         type(time_marching_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%RKP,dir//'RKP'//fortran_PS)
         call import_structured(this%TS,dir//'TS'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_time_marching_params(this)
         implicit none
         type(time_marching_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module apply_face_BC_op_mod
      use current_precision_mod
      use grid_field_mod
      use face_SD_mod
      implicit none

      private
      public :: apply_face_BC_op

      abstract interface
      subroutine apply_face_BC_op(GF,surf,FSD,face)
        import grid_field,face_SD
        implicit none
        type(grid_field),intent(inout) :: GF
        type(grid_field),intent(in) :: surf
        type(face_SD),intent(in) :: FSD
        integer,intent(in) :: face
      end subroutine
      end interface

      end module
      module derivative_stencils_mod
      use current_precision_mod
      use array_mod
      use array_extend_mod
      use sparse_mod
      use sparse_extend_mod
      implicit none

      private
      public :: staggered_CC2N
      public :: staggered_N2CC

      public :: collocated_Node_1 ! use modified stencils near boundary
      public :: collocated_Node_2 ! use modified stencils near boundary
      public :: collocated_CC_1   ! use modified stencils near boundary
      public :: collocated_CC_2   ! use modified stencils near boundary

      public :: consecutive_stag_CC ! consecutive staggered derivatives (central diff near boundary)
      public :: consecutive_stag_N  ! consecutive staggered derivatives (central diff near boundary)

      ! Depricated
      public :: collocated_CC_1_centered ! not used, and may be incorrectly written
      public :: collocated_CC_2_centered ! not used, and may be incorrectly written

      contains

      ! *****************************************************************
      ! *************************** STAGGERED ***************************
      ! *****************************************************************

      function staggered_CC2N(dh,s) result(SP)
        implicit none
        integer,intent(in) :: s
        real(cp),dimension(s-1),intent(in) :: dh
        type(sparse) :: SP
        real(cp),dimension(:),allocatable :: L,D,U
        integer :: i
        call check_valid_size(s,'staggered_CC2N')
        if (s.gt.1) then
          allocate(L( 1 )); L = 0.0_cp
          allocate(D(s-2)); D = 0.0_cp
          allocate(U(s-2)); U = 0.0_cp
          D = -(/(1.0_cp/dh(i),i=1,s-1)/)
          U =  (/(1.0_cp/dh(i),i=1,s-1)/)
          call init(SP,L,D,U,1,s-1,s-1)
          deallocate(L,D,U)
        else
          call init(SP,(/0.0_cp/),(/0.0_cp/),(/0.0_cp/),1)
        endif
        SP%staggered = .true.
      end function

      function staggered_N2CC(dh,s) result(SP)
        implicit none
        integer,intent(in) :: s
        real(cp),dimension(s-1),intent(in) :: dh
        type(sparse) :: SP
        real(cp),dimension(:),allocatable :: L,D,U
        integer :: i
        call check_valid_size(s,'staggered_N2CC')
        if (s.gt.1) then
          allocate(L( 1 )); L = 0.0_cp
          allocate(D(s-2)); D = 0.0_cp
          allocate(U(s-2)); U = 0.0_cp
          D = -(/(1.0_cp/dh(i),i=1,s-1)/)
          U =  (/(1.0_cp/dh(i),i=1,s-1)/)
          call init(SP,L,D,U,1,s-1,s-1)
          deallocate(L,D,U)
        else
          call init(SP,(/0.0_cp/),(/0.0_cp/),(/0.0_cp/),1)
        endif
        SP%staggered = .true.
      end function

      ! *****************************************************************
      ! *************************** COLLOCATED **************************
      ! *****************************************************************

      function collocated_Node_1(dh,s) result(SP)
        implicit none
        integer,intent(in) :: s
        real(cp),dimension(s-1),intent(in) :: dh
        type(sparse) :: SP
        real(cp),dimension(:),allocatable :: L,D,U
        integer :: i
        call check_valid_size(s,'collocated_Node_1')
        if (s.gt.3) then
          allocate(L(s-2)); L = 0.0_cp
          allocate(D(s-2)); D = 0.0_cp
          allocate(U(s-2)); U = 0.0_cp
          i = 2 ! Front
          L(1) = -(dh(i+1)+2.0_cp*dh(i))/(dh(i)*(dh(i+1)+dh(i)))
          D(1) = (dh(i+1)+dh(i))/(dh(i+1)*dh(i))
          U(1) = -dh(i)/(dh(i+1)*(dh(i+1)+dh(i)))
          ! Interior
          L(2:s-3) = -(/( (dh(i)/(dh(i-1)*(dh(i-1)+dh(i))))   ,i=3,s-2 )/)
          D(2:s-3) =  (/( ((-dh(i-1)+dh(i))/(dh(i-1)*dh(i)))  ,i=3,s-2 )/)
          U(2:s-3) =  (/( (dh(i-1)/(dh( i )*(dh(i-1)+dh(i)))) ,i=3,s-2 )/)
          i = s-1 ! Back
          L(s-2) = dh(i-1)/(dh(i-2)*(dh(i-1)+dh(i-2)))
          D(s-2) = -(dh(i-1)+dh(i-2))/(dh(i-1)*dh(i-2))
          U(s-2) = (2.0_cp*dh(i-1)+dh(i-2))/(dh(i-1)*(dh(i-1)+dh(i-2)))
          call init(SP,L,D,U,s-2)
          deallocate(L,D,U)
        else
          call init(SP,(/0.0_cp/),(/0.0_cp/),(/0.0_cp/),1)
        endif
        SP%staggered = .false.
      end function

      function collocated_Node_2(dh,s) result(SP)
        implicit none
        integer,intent(in) :: s
        real(cp),dimension(s-1),intent(in) :: dh
        type(sparse) :: SP
        real(cp),dimension(:),allocatable :: L,D,U
        integer :: i
        call check_valid_size(s,'collocated_Node_2')
        if (s.gt.3) then
          allocate(L(s-2)); L = 0.0_cp
          allocate(D(s-2)); D = 0.0_cp
          allocate(U(s-2)); U = 0.0_cp
          ! Front
          i = 2
          L(1) =  2.0_cp/(dh( i )*(dh(i+1)+dh(i)))
          D(1) = -2.0_cp/(dh(i+1)*dh(i))
          U(1) =  2.0_cp/(dh(i+1)*(dh(i+1)+dh(i)))
          ! Interior
          L(2:s-3) =  (/( 2.0_cp/(dh(i-1)*(dh(i-1)+dh(i))) ,i=3,s-2 )/)
          D(2:s-3) =  (/(-2.0_cp/(dh(i-1)*dh(i))           ,i=3,s-2 )/)
          U(2:s-3) =  (/( 2.0_cp/(dh( i )*(dh(i-1)+dh(i))) ,i=3,s-2 )/)
          ! Back
          i = s-1
          L(s-2) =  2.0_cp/(dh(i-2)*(dh(i-1)+dh(i-2)))
          D(s-2) = -2.0_cp/(dh(i-1)*dh(i-2))
          U(s-2) =  2.0_cp/(dh(i-1)*(dh(i-1)+dh(i-2)))
          call init(SP,L,D,U,s-2)
          deallocate(L,D,U)
        else; call init(SP,(/0.0_cp/),(/0.0_cp/),(/0.0_cp/),1)
        endif
        SP%staggered = .false.
      end function

      function collocated_CC_1(dh,s) result(SP)
        implicit none
        integer,intent(in) :: s
        real(cp),dimension(s-1),intent(in) :: dh
        type(sparse) :: SP
        real(cp),dimension(:),allocatable :: L,D,U
        integer :: i
        call check_valid_size(s,'collocated_CC_1')
        if (s.gt.2) then
          allocate(L(s-2)); L = 0.0_cp
          allocate(D(s-2)); D = 0.0_cp
          allocate(U(s-2)); U = 0.0_cp
          ! Front, dh(i-1) => 0.5 dh(i-1)
          i = 2
          L(1) = (-(dh(i))/((0.5_cp*dh(i-1))*((0.5_cp*dh(i-1))+dh(i))))
          D(1) = ((-(0.5_cp*dh(i-1))+dh(i))/((0.5_cp*dh(i-1))*dh(i)))
          U(1) = ((0.5_cp*dh(i-1))/(dh(i)*((0.5_cp*dh(i-1))+dh(i))))
          ! Interior
          L(2:s-3) = (/( (-dh(i)/(dh(i-1)*(dh(i-1)+dh(i))))   ,i=3,s-2 )/)
          D(2:s-3) = (/( ((-dh(i-1)+dh(i))/(dh(i-1)*dh(i)))   ,i=3,s-2 )/)
          U(2:s-3) = (/( (dh(i-1)/(dh(i)*(dh(i-1)+dh(i))))    ,i=3,s-2 )/)
          ! Back, dh(i) => 0.5 dh(i)
          i = s-1
          L(s-2) = (-0.5_cp*dh(i)/(dh(i-1)*(dh(i-1)+(0.5_cp*dh(i)))))
          D(s-2) = ((-dh(i-1)+(0.5_cp*dh(i)))/(dh(i-1)*(0.5_cp*dh(i))))
          U(s-2) = (dh(i-1)/((0.5_cp*dh(i))*(dh(i-1)+(0.5_cp*dh(i)))))
          call init(SP,L,D,U,s-2)
          deallocate(L,D,U)
        else
          call init(SP,(/0.0_cp/),(/0.0_cp/),(/0.0_cp/),1)
        endif
        SP%staggered = .false.
      end function

      function collocated_CC_2(dh,s) result(SP)
        implicit none
        integer,intent(in) :: s
        real(cp),dimension(s-1),intent(in) :: dh
        type(sparse) :: SP
        real(cp),dimension(:),allocatable :: L,D,U
        integer :: i
        call check_valid_size(s,'collocated_CC_2')
        if (s.gt.2) then
          allocate(L(s-2)); L = 0.0_cp
          allocate(D(s-2)); D = 0.0_cp
          allocate(U(s-2)); U = 0.0_cp
          ! Front, dh(i-1) => 0.5 dh(i-1)
          i = 2
          L(1) =  2.0_cp/((0.5_cp*dh(i-1))*((0.5_cp*dh(i-1))+dh(i)))
          D(1) = -2.0_cp/((0.5_cp*dh(i-1))*dh(i))
          U(1) =  2.0_cp/(dh(i)*((0.5_cp*dh(i-1))+dh(i)))
          ! Interior
          L(2:s-3) =  (/( 2.0_cp/(dh(i-1)*(dh(i-1)+dh(i))) ,i=3,s-2 )/)
          D(2:s-3) = -(/( 2.0_cp/(dh(i-1)*dh(i))           ,i=3,s-2 )/)
          U(2:s-3) =  (/( 2.0_cp/(dh( i )*(dh(i-1)+dh(i))) ,i=3,s-2 )/)
          ! Back, dh(i) => 0.5 dh(i)
          i = s-1
          L(s-2) =  2.0_cp/(dh(i-1)*(dh(i-1)+(0.5_cp*dh(i))))
          D(s-2) = -2.0_cp/(dh(i-1)*(0.5_cp*dh(i)))
          U(s-2) =  2.0_cp/((0.5_cp*dh(i))*(dh(i-1)+(0.5_cp*dh(i))))
          call init(SP,L,D,U,s-2)
          deallocate(L,D,U)
        else
          call init(SP,(/0.0_cp/),(/0.0_cp/),(/0.0_cp/),1)
        endif
        SP%staggered = .false.
      end function

      ! *****************************************************************
      ! ************************** CONSECUTIVE **************************
      ! *****************************************************************

      function consecutive_stag_CC(CC,N) result(S)
        implicit none
        type(sparse),intent(in) :: CC,N
        type(sparse) :: S
        type(array) :: L_CC,U_CC
        type(array) :: L_N,U_N
        type(array),dimension(2) :: D_CC,D_N,D_combined
        integer :: e,i
        call init(L_CC,(/CC%D%f,0.0_cp/),CC%D%N+1)
        call init(D_CC(1),(/CC%D%f,0.0_cp/),CC%D%N+1)
        call init(D_CC(2),(/0.0_cp,CC%U%f/),CC%U%N+1)
        call init(U_CC,(/0.0_cp,CC%U%f/),CC%U%N+1)
        e = N%D%N; call init(L_N   ,N%D%f,N%D%N)
        e = N%D%N; call init(D_N(1),N%D%f,N%D%N)
        e = N%U%N; call init(D_N(2),N%U%f,N%U%N)
        e = N%U%N; call init(U_N   ,N%U%f,N%U%N)
        call init(S,L_CC%N)
        call init(D_combined(1),D_CC(1)%N)
        call init(D_combined(2),D_CC(2)%N)
        call multiply(S%L,L_CC,L_N)
        call multiply(S%U,U_CC,U_N)
        call multiply(D_combined(1),D_CC(1),D_N(1))
        call multiply(D_combined(2),D_CC(2),D_N(2))
        call add(S%D,D_combined(1),D_combined(2))
        do i=1,2; call delete(D_CC(i)); enddo
        do i=1,2; call delete(D_N(i)); enddo
        do i=1,2; call delete(D_combined(i)); enddo
        call delete(L_N)
        call delete(U_N)
        call delete(L_CC)
        call delete(U_CC)
        S%staggered = .false.
      end function

      function consecutive_stag_N(CC2N,N2CC) result(S)
        implicit none
        type(sparse) :: S
        type(sparse),intent(in) :: CC2N,N2CC
        type(array) :: L_CC,U_CC
        type(array) :: L_N,U_N
        type(array),dimension(2) :: D_CC,D_N,D_combined
        integer :: i,s_result
        call init(L_CC,CC2N%D);   call insert(L_CC,0.0_cp);    call append(L_CC,0.0_cp)
        call init(D_CC(1),CC2N%D);call insert(D_CC(1),0.0_cp); call append(D_CC(1),0.0_cp)
        call init(D_CC(2),CC2N%U);call insert(D_CC(2),0.0_cp); call append(D_CC(2),0.0_cp)
        call init(U_CC,CC2N%U);   call insert(U_CC,0.0_cp);    call append(U_CC,0.0_cp)

        call init(L_N,N2CC%D);    call insert(L_N,0.0_cp)
        call init(D_N(1),N2CC%D); call append(D_N(1),0.0_cp)
        call init(D_N(2),N2CC%U); call append(D_N(2),0.0_cp)
        call init(U_N,N2CC%U);    call append(U_N,0.0_cp)

        s_result = N2CC%D%N+1
        call init(S,s_result)
        call init(D_combined(1),s_result)
        call init(D_combined(2),s_result)
        call multiply(S%L,L_CC,L_N)
        call multiply(S%U,U_CC,U_N)
        call multiply(D_combined(1),D_CC(1),D_N(1))
        call multiply(D_combined(2),D_CC(2),D_N(2))
        call add(S%D,D_combined(1),D_combined(2))

        do i=1,2; call delete(D_CC(i)); enddo
        do i=1,2; call delete(D_N(i)); enddo
        do i=1,2; call delete(D_combined(i)); enddo
        call delete(L_N)
        call delete(U_N)
        call delete(L_CC)
        call delete(U_CC)
        S%staggered = .false.
      end function

      ! *****************************************************************
      ! ***************************** DEBUG *****************************
      ! *****************************************************************

      subroutine check_valid_size(s,caller)
        implicit none
        integer,intent(in) :: s
        character(len=*),intent(in) :: caller
        if (s.lt.0) then
          write(*,*) 'Error: s < 0 in ',caller,' in derivative_stencils.f90'
        endif
      end subroutine

      ! *****************************************************************
      ! ****************************** OLD ******************************
      ! *****************************************************************

      function collocated_CC_2_centered(dh,s) result(SP)
        implicit none
        integer,intent(in) :: s
        real(cp),dimension(s-1),intent(in) :: dh
        type(sparse) :: SP
        real(cp),dimension(:),allocatable :: L,D,U
        integer :: i
        call check_valid_size(s,'collocated_CC_2_centered')
        if (s.gt.2) then
          allocate(L(s-2)); L = 0.0_cp
          allocate(D(s-2)); D = 0.0_cp
          allocate(U(s-2)); U = 0.0_cp
          ! Interior
          L(1:s-2) =  (/( 2.0_cp/(dh(i-1)*(dh(i-1)+dh(i))) ,i=2,s-1 )/)
          D(1:s-2) = -(/( 2.0_cp/(dh(i-1)*dh(i))           ,i=2,s-1 )/)
          U(1:s-2) =  (/( 2.0_cp/(dh( i )*(dh(i-1)+dh(i))) ,i=2,s-1 )/)
          call init(SP,L,D,U,s-2)
          deallocate(L,D,U)
        else
          call init(SP,(/0.0_cp/),(/0.0_cp/),(/0.0_cp/),1)
        endif
        SP%staggered = .false.
      end function

      function collocated_CC_1_centered(dh,s) result(SP)
        implicit none
        integer,intent(in) :: s
        real(cp),dimension(s-1),intent(in) :: dh
        type(sparse) :: SP
        real(cp),dimension(:),allocatable :: L,D,U
        integer :: i
        call check_valid_size(s,'collocated_CC_1_centered')
        if (s.gt.2) then
          allocate(L(s-2)); L = 0.0_cp
          allocate(D(s-2)); D = 0.0_cp
          allocate(U(s-2)); U = 0.0_cp
          ! Interior
          L(1:s-2) = (/( (-dh(i)/(dh(i-1)*(dh(i-1)+dh(i))))   ,i=2,s-1 )/)
          D(1:s-2) = (/( ((-dh(i-1)+dh(i))/(dh(i-1)*dh(i)))   ,i=2,s-1 )/)
          U(1:s-2) = (/( (dh(i-1)/(dh(i)*(dh(i-1)+dh(i))))    ,i=2,s-1 )/)
          call init(SP,L,D,U,s-2)
          deallocate(L,D,U)
        else
          call init(SP,(/0.0_cp/),(/0.0_cp/),(/0.0_cp/),1)
        endif
        SP%staggered = .false.
      end function
      end module
      module dir_tree_extend_mod
      use dir_tree_mod
      use string_mod
      use dir_manip_mod
      use path_mod
      use path_extend_mod
      use dir_group_mod
      use dir_group_extend_mod
      implicit none

      private
      public :: dir_tree
      public :: init,delete,display,export,import
      public :: make_dir_tree

      interface init;     module procedure init_DT;     end interface

      contains

      subroutine init_DT(DT,dir_target)
        implicit none
        type(dir_tree),intent(inout) :: DT
        character(len=*),intent(in) :: dir_target
#ifdef _OS_LINUX_
       character(len=1),parameter :: PS = '/'
#else
       character(len=1),parameter :: PS = '\'
#endif
        call init(DT%PS,PS)
        call init(DT%tar,dir_target)
        call compress(DT%tar)
        call draw_DT()
        call append(DT%tar,str(DT%PS))
        call init(DT%tar_p,str(DT%tar),'.',str(DT%PS)) ! Cannot use '' (n must > 0)

        call init(DT%out_dir     ,DT%tar_p       ,'out'        ,str(DT%PS))
        call init(DT%LDC         ,DT%out_dir     ,'LDC'        ,str(DT%PS))

        call init(DT%e_budget    ,DT%LDC         ,'e_budget'   ,str(DT%PS))
        call init(DT%mat         ,DT%LDC         ,'material'   ,str(DT%PS))
        call init(DT%meshes      ,DT%LDC         ,'meshes'     ,str(DT%PS))
        call init(DT%config      ,DT%LDC         ,'config'     ,str(DT%PS))
        call init(DT%matrix_visualization,DT%LDC ,'matrix_visualization',str(DT%PS))
        call init(DT%params      ,DT%LDC         ,'parameters' ,str(DT%PS))
        call init(DT%wall_clock  ,DT%LDC         ,'wall_clock' ,str(DT%PS))
        call init(DT%TMP         ,DT%params      ,'TMP'        ,str(DT%PS))
        call init(DT%ISP         ,DT%params      ,'ISP'        ,str(DT%PS))
        call init(DT%dimensionless_params,DT%params,'dimensionless_params',str(DT%PS))
        call init(DT%EF          ,DT%params      ,'EF'         ,str(DT%PS))
        call init(DT%export_now  ,DT%params      ,'export_now' ,str(DT%PS))
        call init(DT%BEM         ,DT%LDC         ,'BEM'        ,str(DT%PS))
        call init(DT%restart_root,DT%LDC         ,'restart'    ,str(DT%PS))

        call init(DT%restart1    ,DT%restart_root,'restart1'   ,str(DT%PS))
        call init(DT%restart2    ,DT%restart_root,'restart2'   ,str(DT%PS))
        call init(DT%e_budget_N  ,DT%e_budget    ,'e_budget_N' ,str(DT%PS))
        call init(DT%e_budget_C  ,DT%e_budget    ,'e_budget_C' ,str(DT%PS))

        call init(DT%restart,DT%restart1)

        call init(DT%unknowns    ,DT%LDC         ,'unknowns'   ,str(DT%PS))
        call init(DT%governing_equations,DT%LDC,'governing_equations',str(DT%PS))
        call init(DT%U   ,DT%unknowns,'U'   ,str(DT%PS))
        call init(DT%T   ,DT%unknowns,'T'   ,str(DT%PS))
        call init(DT%B   ,DT%unknowns,'B'   ,str(DT%PS))
        call init(DT%jCrossB   ,DT%unknowns,'jCrossB'   ,str(DT%PS))
        call init(DT%stresses  ,DT%unknowns,'stresses'  ,str(DT%PS))
        call init(DT%J   ,DT%unknowns,'J'   ,str(DT%PS))
        call init(DT%p   ,DT%unknowns,'p'   ,str(DT%PS))
        call init(DT%phi ,DT%unknowns,'phi' ,str(DT%PS))
        call init(DT%rho ,DT%unknowns,'rho' ,str(DT%PS))
        call init(DT%test,DT%unknowns,'test',str(DT%PS))

        call make_dir_tree(DT)
      end subroutine

      subroutine make_dir_tree(DT)
        implicit none
        type(dir_tree),intent(in) :: DT
        call make_dir(full(DT%out_dir))
        call make_dir(full(DT%LDC))

        call make_dir(str(DT%params))
        call make_dir(str(DT%wall_clock))
        call make_dir(str(DT%ISP))
        call make_dir(str(DT%TMP))
        call make_dir(str(DT%EF))
        call make_dir(str(DT%export_now))
        call make_dir(str(DT%e_budget))
        call make_dir(str(DT%e_budget_C))
        call make_dir(str(DT%e_budget_N))
        call make_dir(str(DT%mat))
        call make_dir(str(DT%meshes))
        call make_dir(str(DT%config))
        call make_dir(str(DT%matrix_visualization))
        call make_dir(str(DT%dimensionless_params))
        call make_dir(str(DT%BEM))
        call make_dir(str(DT%restart_root))
        call make_dir(str(DT%restart))
        call make_dir(str(DT%restart1))
        call make_dir(str(DT%restart2))

        call make_dir(str(DT%unknowns))
        call make_dir(str(DT%governing_equations))
        call make_dir_group(DT%U)
        call make_dir_group(DT%T)
        call make_dir_group(DT%B)
        call make_dir_group(DT%jCrossB)
        call make_dir_group(DT%stresses)
        call make_dir_group(DT%J)
        call make_dir_group(DT%p)
        call make_dir_group(DT%phi)
        call make_dir_group(DT%rho)
        call make_dir_group(DT%test)
      end subroutine

      subroutine draw_DT()
        implicit none
        write(*,*) ' ------------------- Directory Tree ------------------- '
        write(*,*) '                           |                            '
        write(*,*) '                       ----------                       '
        write(*,*) '                       |        |                       '
        write(*,*) '                  -------------------                   '
        write(*,*) '                  |        |        |                   '
        write(*,*) '             -------------------------------            '
        write(*,*) '             |        |        |           |            '
        write(*,*) '        -----------------------------------------       '
        write(*,*) '        |        |        |           |         |       '
        write(*,*) ''
      end subroutine

      end module
       module export_frequency_params_extend_mod
       use export_frequency_params_mod
       use current_precision_mod
       use time_marching_params_mod
       use IO_tools_mod
       implicit none
       private
       public :: init
       public :: update

       interface init;    module procedure init_EFP;      end interface
       interface update;  module procedure update_EFP;    end interface

       contains

       subroutine init_EFP(EFP,export_ever,export_first_step,N_points_in_window,&
         t_window_start,t_window_stop,dt_window_factor)
         implicit none
         type(export_frequency_params),intent(inout) :: EFP
         logical,intent(in) :: export_ever,export_first_step
         integer,intent(in) :: N_points_in_window
         real(cp),intent(in) :: t_window_start,t_window_stop,dt_window_factor
         EFP%export_ever       = export_ever
         EFP%export_now        = .false.
         EFP%export_first_step = export_first_step
         EFP%N_points_in_window= N_points_in_window
         EFP%t_window_start    = t_window_start
         EFP%t_window_stop     = t_window_stop
         EFP%dt_window_factor  = dt_window_factor
       end subroutine

       function in_window_range(t,t_star,range) result(L)
         implicit none
         real(cp),intent(in) :: t,t_star,range
         logical :: L
         L = (t.gt.t_star-range).and.(t.lt.t_star+range)
       end function

       function in_window_AB(t,a,b,dt) result(L)
         implicit none
         real(cp),intent(in) :: t,a,b,dt
         logical :: L
         L = (t.gt.a-0.01_cp*dt).and.(t.lt.b+0.01_cp*dt)
       end function

       function get_export_now(t,dt,t_star_left,t_star_right,dt_star_range) result(export_now)
         ! Two possible cases:
         !      between 3 tested points, either 1 or 2 points
         !      will fall between t*-.5 dt*w and t*+.5 dt*w.
         !      We choose to export when either
         !           1) The center point alone is within the window
         !           2) The left  and center points are within the window
         !           3) The right and center points are within the window
         ! The particular case can be easily tested for a given set of parameters
         !
         ! Case 1 - 1 point inside
         !                          dt     t
         !           |       |       |     |                     |                     |
         !           |       |<------|---->|                     |                     |
         !           |       |       |     |                     |                     |
         ! ----------|---------------------|---------------------|---------------------|
         !           |          |          |          |          |                     |
         !           |          |<---------|--------->|          |                     |
         !           |          |          |          |          |                     |
         !                            dt*w t*
         !
         ! Case 2 - 2 points inside
         !                         t     dt
         !           |             |       |     |               |                     |
         !           |             |<------|---->|               |                     |
         !           |             |       |     |               |                     |
         ! ----------|---------------------|---------------------|---------------------|
         !           |          |          |          |          |                     |
         !           |          |<---------|--------->|          |                     |
         !           |          |          |          |          |                     |
         !                            dt*w t*
         implicit none
         real(cp),intent(in) :: t,dt,t_star_left,t_star_right,dt_star_range
         logical,dimension(3) :: L
         logical,dimension(3) :: condition_set
         logical :: export_now
         real(cp) :: t_star
         ! Compare with nearest t_star:
         if (abs(t_star_left-t).gt.abs(t_star_right-t)) then
          t_star = t_star_right
         else
          t_star = t_star_left
         endif
         L(1) =  in_window_range(t-dt,t_star,dt_star_range)
         L(2) =  in_window_range( t  ,t_star,dt_star_range)
         L(3) =  in_window_range(t+dt,t_star,dt_star_range)
         condition_set(1) = L(2).and.(.not.L(1)).and.(.not.L(3)) ! single (center only) point inside
         condition_set(2) = L(2).and.(     L(1)).and.(.not.L(3)) ! two                  point inside
         condition_set(3) = L(2).and.(     L(3)).and.(.not.L(1)) ! two                  point inside
         if (any(condition_set)) then
           export_now = .true.
         else
           export_now = .false.
         endif
       end function

       subroutine update_EFP(EFP,TMP,substep)
         implicit none
         type(export_frequency_params),intent(inout) :: EFP
         type(time_marching_params),intent(in) :: TMP
         logical,intent(in) :: substep
         logical :: first_step,last_step,past_first_step
         if ((EFP%export_ever).and.(in_window_AB(TMP%t,EFP%t_window_start,EFP%t_window_stop,TMP%TS%dt))) then
           if (EFP%N_points_in_window.gt.0) then

             EFP%dt_star = (EFP%t_window_stop-EFP%t_window_start)/real(EFP%N_points_in_window,cp)
             if (TMP%TS%dt.gt.EFP%dt_star) then
               EFP%dt_star = TMP%TS%dt ! Avoid undersampling for short sims
               EFP%N_points_in_window = ceiling((EFP%t_window_stop-EFP%t_window_start)/EFP%dt_star)
             endif
             EFP%dt_star_range = 0.5_cp*TMP%TS%dt*(1.0_cp+EFP%dt_window_factor)
             EFP%left_point_export = floor((TMP%t - EFP%t_window_start)/EFP%dt_star)
             EFP%right_point_export = ceiling((TMP%t - EFP%t_window_start)/EFP%dt_star)

             EFP%t_star_left = EFP%t_window_start  + EFP%dt_star*EFP%left_point_export
             EFP%t_star_right = EFP%t_window_start + EFP%dt_star*EFP%right_point_export

             EFP%export_now = get_export_now(TMP%t,TMP%TS%dt,EFP%t_star_left,EFP%t_star_right,EFP%dt_star_range)

             first_step = in_window_range(TMP%t,EFP%t_window_start,EFP%dt_star_range)
             last_step  = in_window_range(TMP%t,EFP%t_window_stop,EFP%dt_star_range)
             past_first_step = .not.(first_step)
             if (EFP%export_first_step) then; EFP%export_now = EFP%export_now.or.first_step.or.last_step
             else;                            EFP%export_now = EFP%export_now.and.past_first_step.or.last_step
             endif
           endif
         else; EFP%export_now = .false.
         endif
         if (substep) EFP%export_now = .false.
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module grid_mod
       use coordinates_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: grid
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_grid;              end interface
       interface delete;                 module procedure delete_grid;                 end interface
       interface display;                module procedure display_grid;                end interface
       interface display_short;          module procedure display_short_grid;          end interface
       interface display;                module procedure display_wrap_grid;           end interface
       interface print;                  module procedure print_grid;                  end interface
       interface print_short;            module procedure print_short_grid;            end interface
       interface export;                 module procedure export_grid;                 end interface
       interface export_primitives;      module procedure export_primitives_grid;      end interface
       interface import;                 module procedure import_grid;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_grid;end interface
       interface export_structured;      module procedure export_structured_D_grid;    end interface
       interface import_structured;      module procedure import_structured_D_grid;    end interface
       interface import_primitives;      module procedure import_primitives_grid;      end interface
       interface export;                 module procedure export_wrap_grid;            end interface
       interface import;                 module procedure import_wrap_grid;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_grid;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_grid;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_grid;      end interface

       type grid
         type(coordinates),dimension(3) :: c
         real(cp) :: volume = 0.0_cp
         logical :: defined = .false.
       end type

       contains

       subroutine init_copy_grid(this,that)
         implicit none
         type(grid),intent(inout) :: this
         type(grid),intent(in) :: that
         integer :: i_c
         integer :: s_c
         call delete(this)
         s_c = size(that%c)
         do i_c=1,s_c
           call init(this%c(i_c),that%c(i_c))
         enddo
         this%volume = that%volume
         this%defined = that%defined
       end subroutine

       subroutine delete_grid(this)
         implicit none
         type(grid),intent(inout) :: this
         integer :: i_c
         integer :: s_c
         s_c = size(this%c)
         do i_c=1,s_c
           call delete(this%c(i_c))
         enddo
         this%volume = 0.0_cp
         this%defined = .false.
       end subroutine

       subroutine display_grid(this,un)
         implicit none
         type(grid),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_c
         integer :: s_c
         s_c = size(this%c)
         do i_c=1,s_c
           call display(this%c(i_c),un)
         enddo
         write(un,*) 'volume  = ',this%volume
         write(un,*) 'defined = ',this%defined
       end subroutine

       subroutine display_short_grid(this,un)
         implicit none
         type(grid),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_c
         integer :: s_c
         s_c = size(this%c)
         do i_c=1,s_c
           call display(this%c(i_c),un)
         enddo
         write(un,*) 'volume  = ',this%volume
         write(un,*) 'defined = ',this%defined
       end subroutine

       subroutine display_wrap_grid(this,dir,name)
         implicit none
         type(grid),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_grid(this)
         implicit none
         type(grid),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_grid(this)
         implicit none
         type(grid),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_grid(this,un)
         implicit none
         type(grid),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_c
         integer :: s_c
         call export_primitives(this,un)
         s_c = size(this%c)
         write(un,*) s_c
         do i_c=1,s_c
           call export(this%c(i_c),un)
         enddo
       end subroutine

       subroutine import_grid(this,un)
         implicit none
         type(grid),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_c
         integer :: s_c
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_c
         if (s_c.gt.0) then
           do i_c=1,s_c
             call import(this%c(i_c),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_grid(this,un)
         implicit none
         type(grid),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'volume   = ';write(un,*) this%volume
         write(un,*) 'defined  = ';write(un,*) this%defined
       end subroutine

       subroutine import_primitives_grid(this,un)
         implicit none
         type(grid),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%volume
         read(un,*); read(un,*) this%defined
       end subroutine

       subroutine export_wrap_grid(this,dir,name)
         implicit none
         type(grid),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_grid(this,dir,name)
         implicit none
         type(grid),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_grid(this,dir)
         implicit none
         type(grid),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_c
         integer :: s_c
         call suppress_warnings(this)
         s_c = size(this%c)
         do i_c=1,s_c
           call set_IO_dir(this%c(i_c),dir//'c_'//int2str(i_c)//fortran_PS)
         enddo
       end subroutine

       subroutine make_IO_dir_grid(this,dir)
         implicit none
         type(grid),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_c
         integer :: s_c
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         s_c = size(this%c)
         do i_c=1,s_c
           call make_IO_dir(this%c(i_c),dir//'c_'//int2str(i_c)//fortran_PS)
         enddo
       end subroutine

       subroutine export_folder_structure_grid(this,dir)
         implicit none
         type(grid),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_c
         integer :: s_c
         integer :: un
         s_c = size(this%c)
         write(un,*) s_c
         do i_c=1,s_c
           call export_structured(this%c(i_c),&
           dir//'c_'//int2str(i_c)//fortran_PS)
         enddo
       end subroutine

       subroutine export_structured_D_grid(this,dir)
         implicit none
         type(grid),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_c
         integer :: s_c
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         s_c = size(this%c)
         write(un,*) s_c
         do i_c=1,s_c
           call export_structured(this%c(i_c),&
           dir//'c_'//int2str(i_c)//fortran_PS)
         enddo
         close(un)
       end subroutine

       subroutine import_structured_D_grid(this,dir)
         implicit none
         type(grid),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_c
         integer :: s_c
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         s_c = size(this%c)
         do i_c=1,s_c
           call import_structured(this%c(i_c),&
           dir//'c_'//int2str(i_c)//fortran_PS)
         enddo
         close(un)
       end subroutine

       subroutine suppress_warnings_grid(this)
         implicit none
         type(grid),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module interpolation_stencils_mod
      use current_precision_mod
      use sparse_mod
      use sparse_extend_mod
      implicit none

      private
      public :: interpolation_stencil

      contains

      function interpolation_stencil(hc,hn,sc,sn) result(SP)
        implicit none
        integer,intent(in) :: sc,sn
        real(cp),dimension(sc),intent(in) :: hc
        real(cp),dimension(sn),intent(in) :: hn
        type(sparse) :: SP
        real(cp),dimension(:),allocatable :: L,D,U
        integer :: i,s
        s = sc
        call check_valid_size(s,'interpolation_stencil')
        if (sc.gt.1) then
          allocate(L( 1 )); L = 0.0_cp
          allocate(D(s-1)); D = 0.0_cp
          allocate(U(s-1)); U = 0.0_cp
          call init(SP,sc-1)
          D = (/((hn(i+1) - hc(i))/(hc(i+1) - hc(i)),i=1,s-1)/)
          U = (/(1.0_cp - D(i),i=1,s-1)/)
          call init(SP,L,D,U,1,s-1,s-1)
          deallocate(L,D,U)
        elseif (sc.eq.1) then
          call init(SP,(/0.0_cp/),(/0.0_cp/),(/0.0_cp/),1)
        else; stop 'Error: sc must > 1 in init_interpStencil in coordinates.f90'
        endif
      end function

      subroutine check_valid_size(s,caller)
        implicit none
        integer,intent(in) :: s
        character(len=*),intent(in) :: caller
        if (s.lt.0) then
          write(*,*) 'Error: s < 0 in ',caller,' in interpolation_stencils.f90'
        endif
      end subroutine

      end module
       module overlap_extend_mod
       ! i1(1) and i1(2) are indexes for start and end of overlapping region 1
       ! i2(1) and i2(2) are indexes for start and end of overlapping region 2
       ! L is a logical of whether overlap exists or not
       ! For example:
       !                           i1(1)     i1(2)
       !                            |----------------R1----------------|
       !     |-------------R2---------------|
       !                           i2(2)     i2(2)
       !

       ! Consider R1 is CC and R2 is node data:
       !                       i1(1)=i1(2)
       !                            |      <-- (R1)
       !     |-------------R2---------------|
       !                       i2(1)=i2(2)
       ! Clearly, CI indexes are not valid
       use overlap_mod
       use current_precision_mod
       use coordinates_mod
       implicit none

       private
       public :: overlap
       public :: init,display,print ! Essentials

       public :: inside,init_props
       public :: is_overlap_physical
       public :: is_overlap_any
       public :: is_overlap

       public :: pick_extrema_top
       public :: pick_extrema_bot

       public :: valid_range

       public :: get_N_overlap
       public :: get_C_overlap

       public :: get_p_from_boundary_N
       public :: get_p_from_boundary_C

       public :: compare
       public :: same_point

       interface init;                 module procedure init_overlap;                end interface
       interface display;              module procedure display3_overlap;            end interface
       interface print;                module procedure print3_overlap;              end interface

       interface get_p_from_boundary_N;module procedure get_p_from_boundary_N_OL;    end interface
       interface get_p_from_boundary_C;module procedure get_p_from_boundary_C_OL;    end interface

       interface pick_extrema_bot;     module procedure pick_extrema_bot_OL;         end interface
       interface pick_extrema_top;     module procedure pick_extrema_top_OL;         end interface

       interface get_N_overlap;        module procedure get_N_overlap_OL;            end interface
       interface get_C_overlap;        module procedure get_C_overlap_OL;            end interface

       interface compare;              module procedure compare_overlap;             end interface
       interface same_point;           module procedure same_point_OL;               end interface
       interface same_point;           module procedure same_point_OL_2;             end interface
       interface init_props;           module procedure init_props_OL;               end interface
       interface is_overlap;           module procedure is_overlap_coordinates;      end interface
       interface valid_range;          module procedure valid_range_overlap;         end interface
       interface inside;               module procedure inside_OL;                   end interface

       contains

       subroutine init_overlap(OL,i1,i2)
         implicit none
         type(overlap),intent(inout) :: OL
         integer,dimension(2),intent(in) :: i1,i2
         OL%i1 = i1
         OL%i2 = i2
         call init_props(OL)
       end subroutine

       subroutine init_props_OL(OL)
         implicit none
         type(overlap),intent(inout) :: OL
         OL%iR = OL%i1(2) - OL%i1(1) + 1
         OL%success = .not.any((/OL%i1(1).eq.0,OL%i1(2).eq.0,OL%i2(1).eq.0,OL%i2(2).eq.0/))
       end subroutine

       subroutine display3_overlap(OL,un)
         implicit none
         type(overlap),dimension(3),intent(in) :: OL
         integer,intent(in) :: un
         integer :: i
         write(un,*) '(1:3)%i1(1) = ',(/(OL(i)%i1(1),i=1,3)/)
         write(un,*) '(1:3)%i1(2) = ',(/(OL(i)%i1(2),i=1,3)/)
         write(un,*) '(1:3)%i2(1) = ',(/(OL(i)%i2(1),i=1,3)/)
         write(un,*) '(1:3)%i2(2) = ',(/(OL(i)%i2(2),i=1,3)/)
         write(un,*) '(1:3)%iR = ',(/(OL(i)%iR,i=1,3)/)
       end subroutine

       subroutine print3_overlap(OL)
         implicit none
         type(overlap),dimension(3),intent(in) :: OL
         call display(OL,6)
       end subroutine

       function compare_overlap(a,b) result(L_all)
         implicit none
         type(overlap),intent(in) :: a
         type(overlap),intent(in) :: b
         logical :: L_all
         logical,dimension(6) :: L
         L(1) = a%i1(1) - b%i1(1).eq.0
         L(2) = a%i2(1) - b%i2(1).eq.0
         L(3) = a%i1(2) - b%i1(2).eq.0
         L(4) = a%i2(2) - b%i2(2).eq.0
         L(5) = a%iR - b%iR.eq.0
         L(6) = a%success .eqv. b%success
         L_all = all(L)
       end function

       ! ************************************************************************
       ! *************************** BOUNDARY OVERLAPS **************************
       ! ************************************************************************

       function get_p_from_boundary_N_OL(OL,c,tol,p) result(G)
         implicit none
         type(overlap),intent(in) :: OL
         type(coordinates),dimension(2),intent(in) :: c
         real(cp),intent(in) :: tol
         integer,intent(in) :: p
         type(overlap) :: G
         call init(G,OL)
         if (p.lt.1) stop 'Error: p must be > 1 in get_p_from_boundary_N_overlap in overlap.f90'
         if (G%iR.eq.3) then ! Surface overlap
           if (p.gt.G%iR) stop 'Error: bad input to get_p_from_boundary_N_overlap in overlap.f90'
               if (inside_OL(c(1)%hn%f(p),c(2)%hn%f(p),c(2)%hn%f(p),tol)) then
           G%i2(2) = G%i2(1)-1+p ! move to far left side. Too far! go p back!
           G%i2(1) = G%i2(2) ! copy end
           G%i1(2) = G%i1(1)-1+p ! move to far left side. Too far! go p back!
           G%i1(1) = G%i1(2) ! copy end
           elseif (inside_OL(c(1)%hn%f(c(1)%sn+1-p),c(2)%hn%f(c(2)%sn+1-p),&
           c(2)%hn%f(c(2)%sn+1-p),tol)) then
           G%i2(1) = G%i2(2)+1-p ! move to far right side. Too far! go p back!
           G%i2(2) = G%i2(1) ! copy end
           G%i1(1) = G%i1(2)+1-p ! move to far right side. Too far! go p back!
           G%i1(2) = G%i1(1) ! copy end
           endif
         endif
         call init_props(G)
       end function

       function get_p_from_boundary_C_OL(OL,c,tol,p) result(G)
         implicit none
         type(overlap),intent(in) :: OL
         type(coordinates),dimension(2),intent(in) :: c
         real(cp),intent(in) :: tol
         integer,intent(in) :: p
         type(overlap) :: G
         call init(G,OL)
         if (p.lt.1) stop 'Error: p must be > 1 in get_p_from_boundary_N_overlap in overlap.f90'
         if (G%iR.eq.2) then ! Surface overlap
           if (p.gt.G%iR) stop 'Error: bad input to get_p_from_boundary_N_overlap in overlap.f90'
               if (inside_OL(c(1)%hc%f(p),c(2)%hc%f(p),c(2)%hc%f(p),tol)) then
           G%i2(2) = G%i2(1)-1+p ! move to far left side. Too far! go p back!
           G%i2(1) = G%i2(2) ! copy end
           G%i1(2) = G%i1(1)-1+p ! move to far left side. Too far! go p back!
           G%i1(1) = G%i1(2) ! copy end
           elseif (inside_OL(c(1)%hc%f(c(1)%sc+1-p),c(2)%hc%f(c(2)%sc+1-p),&
           c(2)%hc%f(c(2)%sc+1-p),tol)) then
           G%i2(1) = G%i2(2)+1-p ! move to far right side. Too far! go p back!
           G%i2(2) = G%i2(1) ! copy end
           G%i1(1) = G%i1(2)+1-p ! move to far right side. Too far! go p back!
           G%i1(2) = G%i1(1) ! copy end
           endif
         endif
         call init_props(G)
       end function

       ! ************************************************************************
       ! ******************************** EXTREMA *******************************
       ! ************************************************************************

       subroutine pick_extrema_top_OL(A,B)
         implicit none
         type(overlap),intent(inout) :: A
         type(overlap),intent(in) :: B
         integer,dimension(2) :: i1,i2
         i1(1) = A%i1(1); i1(2) = maxval((/A%i1(2),B%i1(2)/))
         i2(1) = A%i2(1); i2(2) = maxval((/A%i2(2),B%i2(2)/))
         call init(A,i1,i2)
       end subroutine

       subroutine pick_extrema_bot_OL(A,B)
         implicit none
         type(overlap),intent(inout) :: A
         type(overlap),intent(in) :: B
         integer,dimension(2) :: i1,i2
         i1(1) = A%i1(1); i1(2) = minval((/A%i1(2),B%i1(2)/))
         i2(1) = A%i2(1); i2(2) = minval((/A%i2(2),B%i2(2)/))
         call init(A,i1,i2)
       end subroutine

       ! ************************************************************************
       ! ****************************** GET OVERLAP *****************************
       ! ************************************************************************

       function get_N_overlap_OL(c,tol,p) result (OL)
         implicit none
         type(coordinates),dimension(2),intent(in) :: c
         real(cp),intent(in) :: tol
         integer,intent(in) :: p
         type(overlap) :: OL
         if (p.ge.0) then
           if ((c(1)%sn-p.gt.0).and.(c(2)%sn-p.gt.0)) then;OL = get_N_overlap_OL_blind(c,tol,p)
           else;                                           OL = get_N_overlap_OL_blind(c,tol,0)
           endif
         else; stop 'Error: bad input to get_N_overlap_OL in overlap.f90'
         endif
       end function
       function get_N_overlap_OL_blind(c,tol,p) result (OL)
         implicit none
         type(coordinates),dimension(2),intent(in) :: c
         real(cp),intent(in) :: tol
         integer,intent(in) :: p
         type(overlap) :: OL
         integer :: i,j,p1,p2
         OL%i1 = 0; OL%i2 = 0
         p1 = p; p2 = p
         if (p.gt.0) then
         if (c(1)%sc.eq.1) p1 = 0
         if (c(2)%sc.eq.1) p2 = 0
         else; p1 = 0; p2 = 0
         endif
         do i=c(1)%sn-p1,1+p1,-1; do j=1+p2,c(2)%sn-p2
         if (inside_OL(c(2)%hn%f(j),c(1)%hn%f(i),c(1)%hn%f(i),tol)) then
           if (OL%i1(1).eq.0) then; OL%i1(1) = i; else; OL%i1(1) = minval((/OL%i1(1),i/));endif
           if (OL%i1(2).eq.0) then; OL%i1(2) = i; else; OL%i1(2) = maxval((/OL%i1(2),i/));endif
           if (OL%i2(1).eq.0) then; OL%i2(1) = j; else; OL%i2(1) = minval((/OL%i2(1),j/));endif
           if (OL%i2(2).eq.0) then; OL%i2(2) = j; else; OL%i2(2) = maxval((/OL%i2(2),j/));endif
         endif
         enddo; enddo
         call init_props(OL)
       end function

       function get_C_overlap_OL(c,tol,p) result (OL)
         implicit none
         type(coordinates),dimension(2),intent(in) :: c
         real(cp),intent(in) :: tol
         integer,intent(in) :: p
         type(overlap) :: OL
         if (p.ge.0) then
           if ((c(1)%sc-p.gt.0).and.(c(2)%sc-p.gt.0)) then;OL = get_C_overlap_OL_blind(c,tol,p)
           else;                                           OL = get_C_overlap_OL_blind(c,tol,0)
           endif
         else; stop 'Error: bad input to get_C_overlap_OL in overlap.f90'
         endif
       end function
       function get_C_overlap_OL_blind(c,tol,p) result (OL)
         implicit none
         type(coordinates),dimension(2),intent(in) :: c
         real(cp),intent(in) :: tol
         integer,intent(in) :: p
         type(overlap) :: OL
         integer :: i,j,p1,p2
         OL%i1 = 0; OL%i2 = 0
         p1 = p; p2 = p
         if (p.gt.0) then
         if (c(1)%sc.eq.1) p1 = 0
         if (c(2)%sc.eq.1) p2 = 0
         else; p1 = 0; p2 = 0
         endif
         do i=c(1)%sc-p1,1+p1,-1; do j=1+p2,c(2)%sc-p2
         if (inside_OL(c(2)%hc%f(j),c(1)%hc%f(i),c(1)%hc%f(i),tol)) then
           if (OL%i1(1).eq.0) then; OL%i1(1) = i; else; OL%i1(1) = minval((/OL%i1(1),i/));endif
           if (OL%i1(2).eq.0) then; OL%i1(2) = i; else; OL%i1(2) = maxval((/OL%i1(2),i/));endif
           if (OL%i2(1).eq.0) then; OL%i2(1) = j; else; OL%i2(1) = minval((/OL%i2(1),j/));endif
           if (OL%i2(2).eq.0) then; OL%i2(2) = j; else; OL%i2(2) = maxval((/OL%i2(2),j/));endif
         endif
         enddo; enddo
         call init_props(OL)
       end function

       ! ************************* VALID OVERLAP RANGE? *************************

       function valid_range_overlap(OL) result (L)
         implicit none
         type(overlap),intent(in) :: OL
         logical :: L
         L = (OL%i1(2) - OL%i1(1) + 1).eq.(OL%i2(2) - OL%i2(1) + 1)
       end function

       ! ************************* DOES AN OVERLAP EXIST? *************************

       function is_overlap_coordinates(R1,R2,tol) result(L)
         implicit none
         type(coordinates),intent(in) :: R1,R2
         real(cp),intent(in) :: tol
         logical :: L
         L = is_overlap_any(R1,R2,tol)
       end function

       function is_overlap_any(R1,R2,tol) result(L)
         implicit none
         type(coordinates),intent(in) :: R1,R2
         real(cp),intent(in) :: tol
         logical :: L
         L = is_overlap_general(R1%amin,R1%amax,R2%amin,R2%amax,tol)
       end function

       function is_overlap_physical(R1,R2,tol) result(L)
         implicit none
         type(coordinates),intent(in) :: R1,R2
         real(cp),intent(in) :: tol
         logical :: L
         L = is_overlap_general(R1%amin,R1%amax,R2%amin,R2%amax,tol)
       end function

       function is_overlap_general(R1_hmin,R1_hmax,R2_hmin,R2_hmax,tol) result(L_any)
         ! L = overlapp
         ! 6 possibilities:
         !
         !       1)
         !                 |-----R1-----|
         !             |-----R2-----|
         !       2)
         !         |-----R1-----|
         !             |-----R2-----|
         !       3)
         !             |---R1---|      |-------R1-------|
         !             |-----R2-----|  |-----R2-----|
         !       4)
         !                 |---R1---|  |-------R1-------|
         !             |-----R2-----|      |-----R2-----|
         !       5)
         !               |---R1---|      |-------R1-------|
         !             |-----R2-----|      |-----R2-----|
         !       6)
         !               |---R2---|      |-------R2-------|
         !             |-----R1-----|      |-----R1-----|
         implicit none
         real(cp),intent(in) :: R1_hmin,R1_hmax,R2_hmin,R2_hmax
         real(cp),intent(in) :: tol
         logical,dimension(6) :: L
         logical :: L_any
         L(1) = (R1_hmin.gt.R2_hmin).and.(R1_hmin.lt.R2_hmax)
         L(2) = (R1_hmax.gt.R2_hmin).and.(R1_hmax.lt.R2_hmax)
         L(3) = abs(R2_hmin-R1_hmin).lt.tol
         L(4) = abs(R2_hmax-R1_hmax).lt.tol
         L(5) = (R1_hmin.gt.R2_hmin).and.(R1_hmax.lt.R2_hmax)
         L(6) = (R2_hmin.gt.R1_hmin).and.(R2_hmax.lt.R1_hmax)
         L_any = any(L)
       end function

       function same_point_OL_2(p1,p2) result(L)
         real(cp),intent(in) :: p1,p2
         logical :: L
         L = inside_OL(p1,p2,p2,10.0_cp**(-10.0_cp))
       end function

       function same_point_OL(p1,p2,tol) result(L)
         real(cp),intent(in) :: p1,p2
         real(cp),intent(in) :: tol
         logical :: L
         L = inside_OL(p1,p2,p2,tol)
       end function

       function inside_OL(p,hmin,hmax,tol) result(L_any)
         ! L = point_inside
         ! 3 possibilities:
         !
         !       1)
         !                 *
         !             |-----R-----|
         !       2)
         !             *
         !             |-----R-----|
         !       3)
         !                         *
         !             |-----R-----|
         ! Note:
         !       4) not needed since this is a special case of 2 and 3
         !             *     (hmin = hmax)
         !             |
         !
         real(cp),intent(in) :: p,hmin,hmax
         real(cp),intent(in) :: tol
         logical,dimension(3) :: L
         logical :: L_any
         L(1) = (p.gt.hmin).and.(p.lt.hmax)
         L(2) = abs(p-hmin).lt.tol
         L(3) = abs(p-hmax).lt.tol
         L_any = any(L)
       end function

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module physical_domain_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use physical_sub_domain_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: physical_domain
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_physical_domain;              end interface
       interface delete;                 module procedure delete_physical_domain;                 end interface
       interface display;                module procedure display_physical_domain;                end interface
       interface display_short;          module procedure display_short_physical_domain;          end interface
       interface display;                module procedure display_wrap_physical_domain;           end interface
       interface print;                  module procedure print_physical_domain;                  end interface
       interface print_short;            module procedure print_short_physical_domain;            end interface
       interface export;                 module procedure export_physical_domain;                 end interface
       interface export_primitives;      module procedure export_primitives_physical_domain;      end interface
       interface import;                 module procedure import_physical_domain;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_physical_domain;end interface
       interface export_structured;      module procedure export_structured_D_physical_domain;    end interface
       interface import_structured;      module procedure import_structured_D_physical_domain;    end interface
       interface import_primitives;      module procedure import_primitives_physical_domain;      end interface
       interface export;                 module procedure export_wrap_physical_domain;            end interface
       interface import;                 module procedure import_wrap_physical_domain;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_physical_domain;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_physical_domain;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_physical_domain;      end interface

       type physical_domain
         integer :: s = 0
         type(physical_sub_domain),dimension(:),allocatable :: sd
         logical :: defined = .false.
       end type

       contains

       subroutine init_copy_physical_domain(this,that)
         implicit none
         type(physical_domain),intent(inout) :: this
         type(physical_domain),intent(in) :: that
         integer :: i_sd
         integer :: s_sd
         call delete(this)
         this%s = that%s
         if (allocated(that%sd)) then
           s_sd = size(that%sd)
           if (s_sd.gt.0) then
             allocate(this%sd(s_sd))
             do i_sd=1,s_sd
               call init(this%sd(i_sd),that%sd(i_sd))
             enddo
           endif
         endif
         this%defined = that%defined
       end subroutine

       subroutine delete_physical_domain(this)
         implicit none
         type(physical_domain),intent(inout) :: this
         integer :: i_sd
         integer :: s_sd
         this%s = 0
         if (allocated(this%sd)) then
           s_sd = size(this%sd)
           do i_sd=1,s_sd
             call delete(this%sd(i_sd))
           enddo
           deallocate(this%sd)
         endif
         this%defined = .false.
       end subroutine

       subroutine display_physical_domain(this,un)
         implicit none
         type(physical_domain),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_sd
         integer :: s_sd
         write(un,*) 's       = ',this%s
         if (allocated(this%sd)) then
           s_sd = size(this%sd)
           do i_sd=1,s_sd
             call display(this%sd(i_sd),un)
           enddo
         endif
         write(un,*) 'defined = ',this%defined
       end subroutine

       subroutine display_short_physical_domain(this,un)
         implicit none
         type(physical_domain),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_sd
         integer :: s_sd
         write(un,*) 's       = ',this%s
         if (allocated(this%sd)) then
           s_sd = size(this%sd)
           do i_sd=1,s_sd
             call display(this%sd(i_sd),un)
           enddo
         endif
         write(un,*) 'defined = ',this%defined
       end subroutine

       subroutine display_wrap_physical_domain(this,dir,name)
         implicit none
         type(physical_domain),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_physical_domain(this)
         implicit none
         type(physical_domain),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_physical_domain(this)
         implicit none
         type(physical_domain),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_physical_domain(this,un)
         implicit none
         type(physical_domain),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_sd
         integer :: s_sd
         call export_primitives(this,un)
         if (allocated(this%sd)) then
           s_sd = size(this%sd)
           write(un,*) s_sd
           if (s_sd.gt.0) then
             do i_sd=1,s_sd
               call export(this%sd(i_sd),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
       end subroutine

       subroutine import_physical_domain(this,un)
         implicit none
         type(physical_domain),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_sd
         integer :: s_sd
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_sd
         if (s_sd.gt.0) then
           allocate(this%sd(s_sd))
           do i_sd=1,s_sd
             call import(this%sd(i_sd),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_physical_domain(this,un)
         implicit none
         type(physical_domain),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 's        = ';write(un,*) this%s
         write(un,*) 'defined  = ';write(un,*) this%defined
       end subroutine

       subroutine import_primitives_physical_domain(this,un)
         implicit none
         type(physical_domain),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%s
         read(un,*); read(un,*) this%defined
       end subroutine

       subroutine export_wrap_physical_domain(this,dir,name)
         implicit none
         type(physical_domain),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_physical_domain(this,dir,name)
         implicit none
         type(physical_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_physical_domain(this,dir)
         implicit none
         type(physical_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_sd
         integer :: s_sd
         call suppress_warnings(this)
         if (allocated(this%sd)) then
           s_sd = size(this%sd)
           do i_sd=1,s_sd
             call set_IO_dir(this%sd(i_sd),&
             dir//'sd_'//int2str(i_sd)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine make_IO_dir_physical_domain(this,dir)
         implicit none
         type(physical_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_sd
         integer :: s_sd
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         if (allocated(this%sd)) then
           s_sd = size(this%sd)
           do i_sd=1,s_sd
             call make_IO_dir(this%sd(i_sd),&
             dir//'sd_'//int2str(i_sd)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine export_folder_structure_physical_domain(this,dir)
         implicit none
         type(physical_domain),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_sd
         integer :: s_sd
         integer :: un
         if (allocated(this%sd)) then
           s_sd = size(this%sd)
           write(un,*) s_sd
           do i_sd=1,s_sd
             call export_structured(this%sd(i_sd),&
             dir//'sd_'//int2str(i_sd)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
       end subroutine

       subroutine export_structured_D_physical_domain(this,dir)
         implicit none
         type(physical_domain),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_sd
         integer :: s_sd
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         if (allocated(this%sd)) then
           s_sd = size(this%sd)
           write(un,*) s_sd
           do i_sd=1,s_sd
             call export_structured(this%sd(i_sd),&
             dir//'sd_'//int2str(i_sd)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_physical_domain(this,dir)
         implicit none
         type(physical_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_sd
         integer :: s_sd
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         read(un,*) s_sd
         if (s_sd.gt.0) then
           if (.not.allocated(this%sd)) then
             allocate(this%sd(s_sd))
           endif
           do i_sd=1,s_sd
             call import_structured(this%sd(i_sd),&
             dir//'sd_'//int2str(i_sd)//fortran_PS)
           enddo
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_physical_domain(this)
         implicit none
         type(physical_domain),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module procedure_array_plane_op_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use single_procedure_plane_op_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: procedure_array_plane_op
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_procedure_array_plane_op;              end interface
       interface delete;                 module procedure delete_procedure_array_plane_op;                 end interface
       interface display;                module procedure display_procedure_array_plane_op;                end interface
       interface display_short;          module procedure display_short_procedure_array_plane_op;          end interface
       interface display;                module procedure display_wrap_procedure_array_plane_op;           end interface
       interface print;                  module procedure print_procedure_array_plane_op;                  end interface
       interface print_short;            module procedure print_short_procedure_array_plane_op;            end interface
       interface export;                 module procedure export_procedure_array_plane_op;                 end interface
       interface export_primitives;      module procedure export_primitives_procedure_array_plane_op;      end interface
       interface import;                 module procedure import_procedure_array_plane_op;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_procedure_array_plane_op;end interface
       interface export_structured;      module procedure export_structured_D_procedure_array_plane_op;    end interface
       interface import_structured;      module procedure import_structured_D_procedure_array_plane_op;    end interface
       interface import_primitives;      module procedure import_primitives_procedure_array_plane_op;      end interface
       interface export;                 module procedure export_wrap_procedure_array_plane_op;            end interface
       interface import;                 module procedure import_wrap_procedure_array_plane_op;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_procedure_array_plane_op;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_procedure_array_plane_op;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_procedure_array_plane_op;      end interface

       type procedure_array_plane_op
         integer :: N = 0
         type(single_procedure_plane_op),dimension(:),allocatable :: SP
         logical :: defined = .false.
       end type

       contains

       subroutine init_copy_procedure_array_plane_op(this,that)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: this
         type(procedure_array_plane_op),intent(in) :: that
         integer :: i_SP
         integer :: s_SP
         call delete(this)
         this%N = that%N
         if (allocated(that%SP)) then
           s_SP = size(that%SP)
           if (s_SP.gt.0) then
             allocate(this%SP(s_SP))
             do i_SP=1,s_SP
               call init(this%SP(i_SP),that%SP(i_SP))
             enddo
           endif
         endif
         this%defined = that%defined
       end subroutine

       subroutine delete_procedure_array_plane_op(this)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: this
         integer :: i_SP
         integer :: s_SP
         this%N = 0
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           do i_SP=1,s_SP
             call delete(this%SP(i_SP))
           enddo
           deallocate(this%SP)
         endif
         this%defined = .false.
       end subroutine

       subroutine display_procedure_array_plane_op(this,un)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_SP
         integer :: s_SP
         write(un,*) 'N       = ',this%N
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           do i_SP=1,s_SP
             call display(this%SP(i_SP),un)
           enddo
         endif
         write(un,*) 'defined = ',this%defined
       end subroutine

       subroutine display_short_procedure_array_plane_op(this,un)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_SP
         integer :: s_SP
         write(un,*) 'N       = ',this%N
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           do i_SP=1,s_SP
             call display(this%SP(i_SP),un)
           enddo
         endif
         write(un,*) 'defined = ',this%defined
       end subroutine

       subroutine display_wrap_procedure_array_plane_op(this,dir,name)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_procedure_array_plane_op(this)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_procedure_array_plane_op(this)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_procedure_array_plane_op(this,un)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_SP
         integer :: s_SP
         call export_primitives(this,un)
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           write(un,*) s_SP
           if (s_SP.gt.0) then
             do i_SP=1,s_SP
               call export(this%SP(i_SP),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
       end subroutine

       subroutine import_procedure_array_plane_op(this,un)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_SP
         integer :: s_SP
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_SP
         if (s_SP.gt.0) then
           allocate(this%SP(s_SP))
           do i_SP=1,s_SP
             call import(this%SP(i_SP),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_procedure_array_plane_op(this,un)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'N        = ';write(un,*) this%N
         write(un,*) 'defined  = ';write(un,*) this%defined
       end subroutine

       subroutine import_primitives_procedure_array_plane_op(this,un)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%N
         read(un,*); read(un,*) this%defined
       end subroutine

       subroutine export_wrap_procedure_array_plane_op(this,dir,name)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_procedure_array_plane_op(this,dir,name)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_procedure_array_plane_op(this,dir)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SP
         integer :: s_SP
         call suppress_warnings(this)
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           do i_SP=1,s_SP
             call set_IO_dir(this%SP(i_SP),&
             dir//'SP_'//int2str(i_SP)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine make_IO_dir_procedure_array_plane_op(this,dir)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SP
         integer :: s_SP
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           do i_SP=1,s_SP
             call make_IO_dir(this%SP(i_SP),&
             dir//'SP_'//int2str(i_SP)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine export_folder_structure_procedure_array_plane_op(this,dir)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SP
         integer :: s_SP
         integer :: un
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           write(un,*) s_SP
           do i_SP=1,s_SP
             call export_structured(this%SP(i_SP),&
             dir//'SP_'//int2str(i_SP)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
       end subroutine

       subroutine export_structured_D_procedure_array_plane_op(this,dir)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SP
         integer :: s_SP
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           write(un,*) s_SP
           do i_SP=1,s_SP
             call export_structured(this%SP(i_SP),&
             dir//'SP_'//int2str(i_SP)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_procedure_array_plane_op(this,dir)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SP
         integer :: s_SP
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         read(un,*) s_SP
         if (s_SP.gt.0) then
           if (.not.allocated(this%SP)) then
             allocate(this%SP(s_SP))
           endif
           do i_SP=1,s_SP
             call import_structured(this%SP(i_SP),&
             dir//'SP_'//int2str(i_SP)//fortran_PS)
           enddo
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_procedure_array_plane_op(this)
         implicit none
         type(procedure_array_plane_op),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module stats_period_extend_mod
       use stats_period_mod
       use current_precision_mod
       use time_marching_params_mod

       implicit none
       private

       public :: init

       public :: update
       public :: set_exported_stats
       public :: add_stat

       interface init;               module procedure init_SP;               end interface
       interface update;             module procedure update_SP;             end interface
       interface set_t_start_actual; module procedure set_t_start_actual_SP; end interface
       interface set_exported_stats; module procedure set_exported_stats_SP; end interface
       interface add_stat;           module procedure add_stat_SP;           end interface

       contains

       subroutine init_SP(SP,t_start,t_stop)
         implicit none
         type(stats_period),intent(inout) :: SP
         real(cp),intent(in) :: t_start,t_stop
         SP%period = t_stop - t_start
         if (SP%period.le.0.0_cp) stop 'Error: period must be > 0 in stats_period.f90'
         SP%t_start                = t_start
         SP%t_start_actual         = t_start
         SP%t_stop                 = t_stop
         SP%exported_stats         = .false.
         SP%export_stats           = .false.
         SP%N_stats_collected      = 0
         SP%compute_stats          = .false.
         SP%define_t_start_actual  = .false.
         SP%t_start_actual_defined = .false.
       end subroutine

       subroutine update_SP(SP,TMP)
         implicit none
         type(stats_period),intent(inout) :: SP
         type(time_marching_params),intent(in) :: TMP
         logical,dimension(4) :: L
         real(cp) :: tol
         tol = TMP%TS%dt*10.0_cp**(-6.0_cp)
         L(1) = TMP%t.gt.SP%t_start+tol
         L(2) = TMP%t.lt.SP%t_stop+tol
         L(3) = .not.SP%exported_stats
         L(4) = TMP%t.gt.SP%t_stop+tol
         SP%compute_stats = all(L(1:2))
         SP%export_stats = all(L(3:4))
         if (.not.SP%t_start_actual_defined) call set_t_start_actual(SP,TMP)
       end subroutine

       subroutine set_t_start_actual_SP(SP,TMP)
         !
         !
         !           |
         !           |          t_start specified
         !           |             |
         !           |             v
         !           |---|---|---|---|---|---|---|---|---|--->t
         !           |           ^
         !           |           |
         !           |      t_start_actual (due to potentially variable dt)
         !
         ! Condition: t_start_actual = t WHEN:
         !                1) t_start>t-dt
         !                1) t_start<t
         !
         implicit none
         type(stats_period),intent(inout) :: SP
         type(time_marching_params),intent(in) :: TMP
         logical,dimension(2) :: L
         real(cp) :: tol
         tol = TMP%TS%dt*10.0_cp**(-6.0_cp)
         L(1) = SP%t_start.gt.TMP%t-TMP%TS%dt-tol
         L(2) = SP%t_start.lt.TMP%t+tol
         SP%define_t_start_actual = all(L).and.(.not.SP%t_start_actual_defined)
         if (SP%define_t_start_actual) then
           SP%t_start_actual = TMP%t
           SP%t_start_actual_defined = .true.
         endif
       end subroutine

       subroutine set_exported_stats_SP(SP)
         implicit none
         type(stats_period),intent(inout) :: SP
         SP%exported_stats = .true.
       end subroutine

       subroutine add_stat_SP(SP)
         implicit none
         type(stats_period),intent(inout) :: SP
         SP%N_stats_collected = SP%N_stats_collected+1
       end subroutine

       end module
       module stop_clock_extend_mod
       use stop_clock_mod
       ! Fixes/improvements:
       ! - include output time to file (similar to myError)
       ! - make set/get functions to make components accessable to myEfficiency

       ! - include parallel clock?
       ! - efficiency = runtime/step (optional)
       ! - efficiency = runtime*L2norm (think error vs run time ~ 1/t, we want closest to origin)
       use current_precision_mod
       use IO_tools_mod
       use clock_mod
       use clock_extend_mod
       use string_mod
       use time_marching_params_mod
       use unit_conversion_mod
       use unit_conversion_extend_mod
       implicit none

       private
       public :: init,delete,display,print,export,import
       public :: export_light,print_light
       public :: tic,toc

       interface init;         module procedure init_sc;         end interface
       interface tic;          module procedure tic_sc;          end interface
       interface toc;          module procedure toc_sc;          end interface
       interface print_light;  module procedure print_light_sc;  end interface
       interface export;       module procedure export_sc;       end interface
       interface export_light; module procedure export_light_sc; end interface
       interface export;       module procedure export_sc_dir;   end interface
       interface print;        module procedure print_sc;        end interface
       interface export;       module procedure export_plot_sc;  end interface

       contains

      subroutine init_sc(sc,dir_tec,name_tec)
        implicit none
        type(stop_clock),intent(inout) :: sc
        character(len=*),intent(in) :: dir_tec,name_tec
        type(string) :: vars
        call delete(sc)
        call init(sc%c)
        call init(sc%dir_tec,dir_tec)
        call init(sc%name_tec,name_tec)

        sc%un_plot = new_and_open(dir_tec,name_tec//'_plot')

        call init(vars,'VARIABLES = ')
        call append(vars,'t,')
        call append(vars,'t_elapsed,')
        call append(vars,'t_elapsed(raw),')
        call append(vars,'estimated_total_m,')
        call append(vars,'estimated_total_h,')
        call append(vars,'estimated_total_d')

        write(sc%un_plot,*) 'TITLE = "WALL_CLOCK_TIME_INFO"'
        write(sc%un_plot,*) str(vars)
        write(sc%un_plot,*) 'ZONE DATAPACKING = POINT'
        flush(sc%un_plot)
        call delete(vars)
        call init(sc%uc)
      end subroutine

      subroutine tic_sc(sc)
        implicit none
        type(stop_clock),intent(inout) :: sc
        call tic(sc%c)
      end subroutine

      subroutine toc_sc(sc,TMP)
        implicit none
        type(stop_clock),intent(inout) :: sc
        type(time_marching_params),intent(in) :: TMP
        call toc(sc%c)
        if (sc%c%t_elapsed.lt.0.0_cp) then; sc%frozen_elapsed = .true.
        else;                               sc%t_elapsed = sc%c%t_elapsed
        endif
        sc%t_passed = sc%t_passed + sc%t_elapsed
        sc%seconds_per_step = sc%t_elapsed
        sc%sim_time_per_sec = TMP%TS%dt/sc%seconds_per_step
        sc%estimated_remaining = (TMP%TS%t_final-TMP%t)/sc%sim_time_per_sec
        sc%estimated_total = sc%t_passed + sc%estimated_remaining
        sc%percentage_complete_RB = (sc%estimated_total-sc%estimated_remaining)/sc%estimated_total*100.0_cp
        sc%percentage_complete_SB = TMP%t/TMP%TS%t_final*100.0_cp
      end subroutine

      subroutine export_plot_sc(sc,t)
        implicit none
        type(stop_clock),intent(in) :: sc
        real(cp),intent(in) :: t
        write(sc%un_plot,*) t,sc%t_elapsed,sc%c%t_elapsed,&
                            sc%estimated_total/sc%uc%seconds_per_minute,&
                            sc%estimated_total/sc%uc%seconds_per_hour,&
                            sc%estimated_total/sc%uc%seconds_per_day
        flush(sc%un_plot)
      end subroutine

      subroutine export_sc_dir(sc,TMP)
        implicit none
        type(stop_clock),intent(in) :: sc
        type(time_marching_params),intent(in) :: TMP
        integer :: un
        un = new_and_open(str(sc%dir_tec),str(sc%name_tec))
        call export(sc,TMP,un)
        call close_and_message(un,str(sc%dir_tec),str(sc%name_tec))
      end subroutine

      subroutine print_sc(sc,TMP)
        implicit none
        type(stop_clock),intent(in) :: sc
        type(time_marching_params),intent(in) :: TMP
        call export(sc,TMP,6)
      end subroutine

      subroutine export_sc(sc,TMP,un)
        implicit none
        type(stop_clock),intent(in) :: sc
        type(time_marching_params),intent(in) :: TMP
        integer,intent(in) :: un
        real(cp) :: temp
        character(len=1) :: u
        write(un,*) ''
        write(un,*) '*********************** CLOCK INFO ***********************'
        call negative_time_elapsed_reported(sc)

        write(un,*) 'Convective time'
        write(un,*) '     per hour             = ',sc%sim_time_per_sec*sc%uc%seconds_per_hour
        write(un,*) '     per day              = ',sc%sim_time_per_sec*sc%uc%seconds_per_day
        ! Or, as Eldredge did it:
        ! CPU_TIME/(convective unit)
        ! CPU_TIME/(convective unit)/unknown
        ! Where unknowns = (3 momentum + 3 induction)*problem size
        write(un,*) '     now                  = ',TMP%t
        write(un,*) '     final                = ',TMP%TS%t_final
        write(un,*) ''

        write(un,*) 'Wall clock time '
        temp = sc%seconds_per_step; call getTimeWithUnits(temp,u,sc%uc)
        write(un,*) '     per step         (', u,') = ',temp
        temp = sc%estimated_total; call getTimeWithUnits(temp,u,sc%uc)
        write(un,*) '     total            (', u,') = ',temp

        temp = sc%estimated_remaining; call getTimeWithUnits(temp,u,sc%uc)
        write(un,*) '     remaining        (', u,') = ',temp

        temp = sc%t_passed; call getTimeWithUnits(temp,u,sc%uc)
        write(un,*) '     completed        (', u,') = ',temp
        write(un,*) ''
        write(un,*) 'Percentage complete'
        write(un,*) '     Rate  based estimate = ',sc%percentage_complete_RB
        write(un,*) '     State based estimate = ',sc%percentage_complete_SB

        write(un,*) '**********************************************************'
      end subroutine

      subroutine print_light_sc(sc,TMP)
        implicit none
        type(stop_clock),intent(in) :: sc
        type(time_marching_params),intent(in) :: TMP
        call export_light(sc,TMP,6)
      end subroutine

      subroutine export_light_sc(sc,TMP,un)
        implicit none
        type(stop_clock),intent(in) :: sc
        type(time_marching_params),intent(in) :: TMP
        integer,intent(in) :: un
        real(cp) :: temp
        character(len=1) :: u
        call negative_time_elapsed_reported(sc)
        temp = sc%t_passed; call getTimeWithUnits(temp,u,sc%uc)
        write(un,*) ''
        write(un,*) 'Wall clock time *completed* (', u,') = ',temp
        write(un,*) 'Time (convective),n_step = ',TMP%t,TMP%n_step
        write(un,*) 'Convective time'
        write(un,*) '     per hour       = ',sc%uc%seconds_per_hour/sc%seconds_per_step*TMP%TS%dt
        write(un,*) '     per day        = ',sc%uc%seconds_per_day/sc%seconds_per_step*TMP%TS%dt
        write(un,*) '--------------------------------------------------------------'
      end subroutine

      subroutine getTimeWithUnits(t,u,uc)
        implicit none
        real(cp),intent(inout) :: t
        character(len=1),intent(inout) :: u
        type(unit_conversion),intent(in) :: uc
        if (t.lt.uc%seconds_per_minute) then
         u = 's'; t = t
        elseif ((t.ge.uc%seconds_per_minute).and.(t.lt.uc%seconds_per_hour)) then
         u = 'm'; t = t*uc%minute_per_seconds
        elseif ((t.ge.uc%seconds_per_hour).and.(t.lt.uc%seconds_per_day)) then
         u = 'h'; t = t*uc%hour_per_seconds
        elseif ((t.ge.uc%seconds_per_day).and.(t.lt.uc%seconds_per_year)) then
         u = 'd'; t = t*uc%day_per_seconds
        elseif (t.ge.uc%seconds_per_year) then
         u = 'y'; t = t*uc%year_per_seconds
        endif
       end subroutine

      subroutine negative_time_elapsed_reported(sc)
        implicit none
        type(stop_clock),intent(in) :: sc
        if (sc%frozen_elapsed) then
          write(*,*) 'WARNING: negative time estimate in stop_clock.f90'
          write(*,*) 'Using last positive elapsed time for time estimates'
        endif
       end subroutine

       end module
       module time_marching_params_extend_mod
       use time_marching_params_mod
       use current_precision_mod
       use string_mod
       use RK_Params_mod
       use RK_Params_extend_mod
       use IO_tools_mod
       implicit none

       private
       public :: init
       public :: iterate_step
       public :: iterate_RK
       public :: assign_RK_stage
       public :: couple_time_step
       public :: prolongate
       public :: update_dt

       interface init;              module procedure init_TMP;                end interface
       interface iterate_step;      module procedure iterate_step_TMP;        end interface
       interface iterate_RK;        module procedure iterate_RK_TMP;          end interface
       interface assign_RK_stage;   module procedure assign_RK_stage_TMP;     end interface

       interface couple_time_step;  module procedure couple_time_step_TMP;    end interface

       interface prolongate;        module procedure prolongate_TMP;          end interface
       interface update_dt;         module procedure update_dt_TMP;           end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_TMP(TMP,n_stages,active,multistep_iter,t_start,t_final,dt)
         implicit none
         type(time_marching_params),intent(inout) :: TMP
         integer,intent(in) :: n_stages,multistep_iter
         logical,intent(in) :: active
         real(cp),intent(in) :: t_start,t_final,dt
         call init(TMP%RKP,n_stages,active)
         TMP%n_step_start = 0
         TMP%n_step = 0
         TMP%multistep_iter = multistep_iter
         TMP%t = t_start
         TMP%C_max = 0.1_cp
         TMP%TS%dt = dt
         TMP%TS%t_final = t_final
         TMP%TS%t_start = t_start
         TMP%n_step_stop = int((t_final-t_start)/dt,li)
         if (TMP%n_step_stop.lt.1) then
           stop 'Error: TMP%n_step_stop<1 in time_marching_params.f90'
         endif
       end subroutine

       subroutine iterate_step_TMP(TMP)
         implicit none
         type(time_marching_params),intent(inout) :: TMP
         TMP%n_step = TMP%n_step + 1
       end subroutine

       subroutine iterate_RK_TMP(TMP)
         implicit none
         type(time_marching_params),intent(inout) :: TMP
         call update_time(TMP%RKP,TMP%t,TMP%TS%dt)
       end subroutine

       subroutine assign_RK_stage_TMP(TMP,RK_stage)
         implicit none
         type(time_marching_params),intent(inout) :: TMP
         integer,intent(in) :: RK_stage
         call assign_stage(TMP%RKP,RK_stage)
       end subroutine

       subroutine couple_time_step_TMP(TMP,coupled)
         implicit none
         type(time_marching_params),intent(inout) :: TMP
         type(time_marching_params),intent(in) :: coupled
         TMP%t = coupled%t
         TMP%multistep_iter = 1
         TMP%TS%t_final = coupled%TS%t_final
         TMP%TS%t_start = coupled%TS%t_start
         TMP%TS%dt = coupled%TS%dt
         TMP%n_step_start = coupled%n_step_start
         TMP%n_step_stop = coupled%n_step_stop
         TMP%C_max = coupled%C_max
         TMP%n_step = coupled%n_step
       end subroutine

       subroutine prolongate_TMP(TMP,dt_reduction_factor)
         implicit none
         type(time_marching_params),intent(inout) :: TMP
         real(cp),intent(in) :: dt_reduction_factor
         TMP%TS%dt = TMP%TS%dt*dt_reduction_factor
         TMP%C_max = TMP%C_max*dt_reduction_factor
         TMP%n_step_stop = TMP%n_step_stop*ceiling(1.0_cp/dt_reduction_factor)
       end subroutine

       subroutine update_dt_TMP(TMP,dt)
         implicit none
         type(time_marching_params),intent(inout) :: TMP
         real(cp),intent(in) :: dt
         TMP%TS%dt = dt
         TMP%n_step_stop = ceiling((TMP%TS%t_final-TMP%TS%t_start)/TMP%TS%dt)
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module var_mod
       use string_mod
       use solver_settings_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use export_lines_mod
       use time_marching_params_mod
       use export_field_mod
       use matrix_free_params_mod
       use iter_solver_params_mod
       use export_planes_mod
       use dir_manip_mod
       implicit none

       private
       public :: var
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_var;              end interface
       interface delete;                 module procedure delete_var;                 end interface
       interface display;                module procedure display_var;                end interface
       interface display_short;          module procedure display_short_var;          end interface
       interface display;                module procedure display_wrap_var;           end interface
       interface print;                  module procedure print_var;                  end interface
       interface print_short;            module procedure print_short_var;            end interface
       interface export;                 module procedure export_var;                 end interface
       interface export_primitives;      module procedure export_primitives_var;      end interface
       interface import;                 module procedure import_var;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_var;end interface
       interface export_structured;      module procedure export_structured_D_var;    end interface
       interface import_structured;      module procedure import_structured_D_var;    end interface
       interface import_primitives;      module procedure import_primitives_var;      end interface
       interface export;                 module procedure export_wrap_var;            end interface
       interface import;                 module procedure import_wrap_var;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_var;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_var;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_var;      end interface

       type var
         integer :: IC = 0
         integer :: BC = 0
         type(solver_settings) :: SS
         type(matrix_free_params) :: MFP
         type(time_marching_params) :: TMP
         type(iter_solver_params) :: ISP
         type(export_lines) :: unsteady_lines
         type(export_planes) :: unsteady_planes
         type(export_field) :: unsteady_field
       end type

       contains

       subroutine init_copy_var(this,that)
         implicit none
         type(var),intent(inout) :: this
         type(var),intent(in) :: that
         call delete(this)
         this%IC = that%IC
         this%BC = that%BC
         call init(this%SS,that%SS)
         call init(this%MFP,that%MFP)
         call init(this%TMP,that%TMP)
         call init(this%ISP,that%ISP)
         call init(this%unsteady_lines,that%unsteady_lines)
         call init(this%unsteady_planes,that%unsteady_planes)
         call init(this%unsteady_field,that%unsteady_field)
       end subroutine

       subroutine delete_var(this)
         implicit none
         type(var),intent(inout) :: this
         this%IC = 0
         this%BC = 0
         call delete(this%SS)
         call delete(this%MFP)
         call delete(this%TMP)
         call delete(this%ISP)
         call delete(this%unsteady_lines)
         call delete(this%unsteady_planes)
         call delete(this%unsteady_field)
       end subroutine

       subroutine display_var(this,un)
         implicit none
         type(var),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'IC              = ',this%IC
         write(un,*) 'BC              = ',this%BC
         call display(this%SS,un)
         call display(this%MFP,un)
         call display(this%TMP,un)
         call display(this%ISP,un)
         call display(this%unsteady_lines,un)
         call display(this%unsteady_planes,un)
         call display(this%unsteady_field,un)
       end subroutine

       subroutine display_short_var(this,un)
         implicit none
         type(var),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'IC              = ',this%IC
         write(un,*) 'BC              = ',this%BC
         call display(this%SS,un)
         call display(this%MFP,un)
         call display(this%TMP,un)
         call display(this%ISP,un)
         call display(this%unsteady_lines,un)
         call display(this%unsteady_planes,un)
         call display(this%unsteady_field,un)
       end subroutine

       subroutine display_wrap_var(this,dir,name)
         implicit none
         type(var),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_var(this)
         implicit none
         type(var),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_var(this)
         implicit none
         type(var),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_var(this,un)
         implicit none
         type(var),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%SS,un)
         call export(this%MFP,un)
         call export(this%TMP,un)
         call export(this%ISP,un)
         call export(this%unsteady_lines,un)
         call export(this%unsteady_planes,un)
         call export(this%unsteady_field,un)
       end subroutine

       subroutine import_var(this,un)
         implicit none
         type(var),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%SS,un)
         call import(this%MFP,un)
         call import(this%TMP,un)
         call import(this%ISP,un)
         call import(this%unsteady_lines,un)
         call import(this%unsteady_planes,un)
         call import(this%unsteady_field,un)
       end subroutine

       subroutine export_primitives_var(this,un)
         implicit none
         type(var),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'IC               = ';write(un,*) this%IC
         write(un,*) 'BC               = ';write(un,*) this%BC
       end subroutine

       subroutine import_primitives_var(this,un)
         implicit none
         type(var),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%IC
         read(un,*); read(un,*) this%BC
       end subroutine

       subroutine export_wrap_var(this,dir,name)
         implicit none
         type(var),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_var(this,dir,name)
         implicit none
         type(var),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_var(this,dir)
         implicit none
         type(var),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%SS,dir//'SS'//fortran_PS)
         call set_IO_dir(this%MFP,dir//'MFP'//fortran_PS)
         call set_IO_dir(this%TMP,dir//'TMP'//fortran_PS)
         call set_IO_dir(this%ISP,dir//'ISP'//fortran_PS)
         call set_IO_dir(this%unsteady_lines,&
         dir//'unsteady_lines'//fortran_PS)
         call set_IO_dir(this%unsteady_planes,&
         dir//'unsteady_planes'//fortran_PS)
         call set_IO_dir(this%unsteady_field,&
         dir//'unsteady_field'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_var(this,dir)
         implicit none
         type(var),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%SS,dir//'SS'//fortran_PS)
         call make_IO_dir(this%MFP,dir//'MFP'//fortran_PS)
         call make_IO_dir(this%TMP,dir//'TMP'//fortran_PS)
         call make_IO_dir(this%ISP,dir//'ISP'//fortran_PS)
         call make_IO_dir(this%unsteady_lines,&
         dir//'unsteady_lines'//fortran_PS)
         call make_IO_dir(this%unsteady_planes,&
         dir//'unsteady_planes'//fortran_PS)
         call make_IO_dir(this%unsteady_field,&
         dir//'unsteady_field'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_var(this,dir)
         implicit none
         type(var),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%SS,dir//'SS'//fortran_PS)
         call export_structured(this%MFP,dir//'MFP'//fortran_PS)
         call export_structured(this%TMP,dir//'TMP'//fortran_PS)
         call export_structured(this%ISP,dir//'ISP'//fortran_PS)
         call export_structured(this%unsteady_lines,&
         dir//'unsteady_lines'//fortran_PS)
         call export_structured(this%unsteady_planes,&
         dir//'unsteady_planes'//fortran_PS)
         call export_structured(this%unsteady_field,&
         dir//'unsteady_field'//fortran_PS)
       end subroutine

       subroutine export_structured_D_var(this,dir)
         implicit none
         type(var),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%SS,dir//'SS'//fortran_PS)
         call export_structured(this%MFP,dir//'MFP'//fortran_PS)
         call export_structured(this%TMP,dir//'TMP'//fortran_PS)
         call export_structured(this%ISP,dir//'ISP'//fortran_PS)
         call export_structured(this%unsteady_lines,&
         dir//'unsteady_lines'//fortran_PS)
         call export_structured(this%unsteady_planes,&
         dir//'unsteady_planes'//fortran_PS)
         call export_structured(this%unsteady_field,&
         dir//'unsteady_field'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_var(this,dir)
         implicit none
         type(var),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%SS,dir//'SS'//fortran_PS)
         call import_structured(this%MFP,dir//'MFP'//fortran_PS)
         call import_structured(this%TMP,dir//'TMP'//fortran_PS)
         call import_structured(this%ISP,dir//'ISP'//fortran_PS)
         call import_structured(this%unsteady_lines,&
         dir//'unsteady_lines'//fortran_PS)
         call import_structured(this%unsteady_planes,&
         dir//'unsteady_planes'//fortran_PS)
         call import_structured(this%unsteady_field,&
         dir//'unsteady_field'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_var(this)
         implicit none
         type(var),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module GF_Fourier_number_mod
        use grid_field_mod
        use grid_mod
        use current_precision_mod
        implicit none
        private
        public :: Fourier_number
        interface Fourier_number; module procedure Fourier_number_GF; end interface

        contains

        function Fourier_number_GF(alpha,g,dt) result(Fourier)
          ! Computes: Fo =  max(alpha*dt/dh^2)
          implicit none
          real(cp),intent(in) :: alpha,dt
          type(grid),intent(in) :: g
          real(cp),dimension(3) :: temp
          integer :: i,j,k
          real(cp) :: Fourier
          Fourier = 0.0_cp
          do k=1,g%c(3)%sc; do j=1,g%c(2)%sc; do i=1,g%c(1)%sc
            temp(1) = alpha / g%c(1)%dhn%f(i)**2.0_cp
            temp(2) = alpha / g%c(2)%dhn%f(j)**2.0_cp
            temp(3) = alpha / g%c(3)%dhn%f(k)**2.0_cp
            Fourier = maxval((/Fourier,dt*maxval(temp)/))
          enddo; enddo; enddo
        end function

      end module
      module GF_Robin_BC_coeff_mod
        use grid_field_mod
        use grid_mod
        use face_edge_corner_indexing_mod
        use current_precision_mod
        implicit none
        private
        public :: Robin_BC_coeff
        interface Robin_BC_coeff; module procedure Robin_BC_coeff_GF; end interface

        contains

        function Robin_BC_coeff_GF(c_w,g) result(coeff)
          ! Computes:
          !
          !                           | 2*c_w - dh*nhat |
          ! Robin_BC_coeff =  maxval( ------------------- )
          !                           | 2*c_w + dh*nhat |
          !
          ! Which has a singularity at 2*c_w = - dh*nhat
          ! This is entirely possible if nhat = -1 and dh = 2*c_w
          ! Robin BCs will fail here and a different mesh size must be used!
          implicit none
          real(cp),dimension(6),intent(in) :: c_w
          type(grid),intent(in) :: g
          real(cp),dimension(6) :: coeff
          real(cp) :: nhat,dh
          integer :: i,dir
          dh = 1.0_cp ! suppress warning
          do i=1,6
            nhat = nhat_given_face(i)
            dir = dir_given_face(i)
            if (min_face(i)) dh = g%c(dir)%dhn%f(1)
            if (max_face(i)) dh = g%c(dir)%dhn_e
            coeff(i) = (2.0_cp*c_w(i)/dh*nhat-1.0_cp)/(2.0_cp*c_w(i)/dh*nhat+1.0_cp)
          enddo
        end function

      end module
      module GF_plane_sum_mod
        ! Compiler flags: (_PARALLELIZE_GF_PLANE_SUM_)
        use current_precision_mod
        use grid_field_mod
        use grid_mod
        implicit none

        private
        public :: plane_sum_x
        public :: plane_sum_y
        public :: plane_sum_z
        interface plane_sum_x;    module procedure plane_sum_x_GF;            end interface
        interface plane_sum_y;    module procedure plane_sum_y_GF;            end interface
        interface plane_sum_z;    module procedure plane_sum_z_GF;            end interface

        interface plane_sum_x;    module procedure plane_sum_x_no_weights_GF; end interface
        interface plane_sum_y;    module procedure plane_sum_y_no_weights_GF; end interface
        interface plane_sum_z;    module procedure plane_sum_z_no_weights_GF; end interface

        contains

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        function plane_sum_x_GF(U,g,p,nhat) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          type(grid),intent(in) :: g
          integer,intent(in) :: p
          real(cp),intent(in) :: nhat
          real(cp) :: F
          integer :: j,k
#ifdef _PARALLELIZE_GF_PLANE_SUM_
          real(cp) :: temp
          temp = 0.0_cp
          !$OMP PARALLEL DO SHARED(g), REDUCTION(+:temp)
          do k=1,U%s(3); do j=1,U%s(2)
            temp = temp + U%f(p,j,k)*g%c(3)%dhn%f(k)*g%c(2)%dhn%f(j)*nhat
          enddo; enddo
          !$OMP END PARALLEL DO
          F = temp
#else
          F = 0.0_cp
          do k=1,U%s(3); do j=1,U%s(2)
            F = F + U%f(p,j,k)*g%c(3)%dhn%f(k)*g%c(2)%dhn%f(j)*nhat
          enddo; enddo
#endif
        end function

        function plane_sum_x_no_weights_GF(U,p,nhat) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          integer,intent(in) :: p
          real(cp),intent(in) :: nhat
          real(cp) :: F
          integer :: j,k
#ifdef _PARALLELIZE_GF_PLANE_SUM_
          real(cp) :: temp
          temp = 0.0_cp
          !$OMP PARALLEL DO REDUCTION(+:temp)
          do k=1,U%s(3); do j=1,U%s(2)
            temp = temp + U%f(p,j,k)*nhat
          enddo; enddo
          !$OMP END PARALLEL DO
          F = temp
#else
          F = 0.0_cp
          do k=1,U%s(3); do j=1,U%s(2)
            F = F + U%f(p,j,k)*nhat
          enddo; enddo
#endif
        end function

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        function plane_sum_y_GF(U,g,p,nhat) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          type(grid),intent(in) :: g
          integer,intent(in) :: p
          real(cp),intent(in) :: nhat
          real(cp) :: F
          integer :: i,k
#ifdef _PARALLELIZE_GF_PLANE_SUM_
          real(cp) :: temp
          temp = 0.0_cp
          !$OMP PARALLEL DO SHARED(g), REDUCTION(+:temp)
          do k=1,U%s(3); do i=1,U%s(1)
            temp = temp + U%f(i,p,k)*g%c(3)%dhn%f(k)*g%c(1)%dhn%f(i)*nhat
          enddo; enddo
          !$OMP END PARALLEL DO
          F = temp
#else
          F = 0.0_cp
          do k=1,U%s(3); do i=1,U%s(1)
            F = F + U%f(i,p,k)*g%c(3)%dhn%f(k)*g%c(1)%dhn%f(i)*nhat
          enddo; enddo
#endif
        end function

        function plane_sum_y_no_weights_GF(U,p,nhat) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          integer,intent(in) :: p
          real(cp),intent(in) :: nhat
          real(cp) :: F
          integer :: i,k
#ifdef _PARALLELIZE_GF_PLANE_SUM_
          real(cp) :: temp
          temp = 0.0_cp
          !$OMP PARALLEL DO REDUCTION(+:temp)
          do k=1,U%s(3); do i=1,U%s(1)
            temp = temp + U%f(i,p,k)*nhat
          enddo; enddo
          !$OMP END PARALLEL DO
          F = temp
#else
          F = 0.0_cp
          do k=1,U%s(3); do i=1,U%s(1)
            F = F + U%f(i,p,k)*nhat
          enddo; enddo
#endif
        end function

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        function plane_sum_z_GF(U,g,p,nhat) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          type(grid),intent(in) :: g
          integer,intent(in) :: p
          real(cp),intent(in) :: nhat
          real(cp) :: F
          integer :: i,j
#ifdef _PARALLELIZE_GF_PLANE_SUM_
          real(cp) :: temp
          temp = 0.0_cp
          !$OMP PARALLEL DO SHARED(g), REDUCTION(+:temp)
          do j=1,U%s(2); do i=1,U%s(1)
            temp = temp + U%f(i,j,p)*g%c(2)%dhn%f(j)*g%c(1)%dhn%f(i)*nhat
          enddo; enddo
          !$OMP END PARALLEL DO
          F = temp
#else
          F = 0.0_cp
          do j=1,U%s(2); do i=1,U%s(1)
            F = F + U%f(i,j,p)*g%c(2)%dhn%f(j)*g%c(1)%dhn%f(i)*nhat
          enddo; enddo
#endif
        end function

        function plane_sum_z_no_weights_GF(U,p,nhat) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          integer,intent(in) :: p
          real(cp),intent(in) :: nhat
          real(cp) :: F
          integer :: i,j
#ifdef _PARALLELIZE_GF_PLANE_SUM_
          real(cp) :: temp
          temp = 0.0_cp
          !$OMP PARALLEL DO REDUCTION(+:temp)
          do j=1,U%s(2); do i=1,U%s(1)
            temp = temp + U%f(i,j,p)*nhat
          enddo; enddo
          !$OMP END PARALLEL DO
          F = temp
#else
          F = 0.0_cp
          do j=1,U%s(2); do i=1,U%s(1)
            F = F + U%f(i,j,p)*nhat
          enddo; enddo
#endif
        end function

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module block_mod
       use grid_field_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use grid_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: block
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_block;              end interface
       interface delete;                 module procedure delete_block;                 end interface
       interface display;                module procedure display_block;                end interface
       interface display_short;          module procedure display_short_block;          end interface
       interface display;                module procedure display_wrap_block;           end interface
       interface print;                  module procedure print_block;                  end interface
       interface print_short;            module procedure print_short_block;            end interface
       interface export;                 module procedure export_block;                 end interface
       interface export_primitives;      module procedure export_primitives_block;      end interface
       interface import;                 module procedure import_block;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_block;end interface
       interface export_structured;      module procedure export_structured_D_block;    end interface
       interface import_structured;      module procedure import_structured_D_block;    end interface
       interface import_primitives;      module procedure import_primitives_block;      end interface
       interface export;                 module procedure export_wrap_block;            end interface
       interface import;                 module procedure import_wrap_block;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_block;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_block;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_block;      end interface

       type block
         type(grid) :: g
         type(grid),dimension(:),allocatable :: f
         type(grid),dimension(:),allocatable :: fb
         type(grid_field),dimension(:),allocatable :: vol
         integer,dimension(6) :: apply_BC_order = 0
       end type

       contains

       subroutine init_copy_block(this,that)
         implicit none
         type(block),intent(inout) :: this
         type(block),intent(in) :: that
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         call delete(this)
         call init(this%g,that%g)
         if (allocated(that%f)) then
           s_f = size(that%f)
           if (s_f.gt.0) then
             allocate(this%f(s_f))
             do i_f=1,s_f
               call init(this%f(i_f),that%f(i_f))
             enddo
           endif
         endif
         if (allocated(that%fb)) then
           s_fb = size(that%fb)
           if (s_fb.gt.0) then
             allocate(this%fb(s_fb))
             do i_fb=1,s_fb
               call init(this%fb(i_fb),that%fb(i_fb))
             enddo
           endif
         endif
         if (allocated(that%vol)) then
           s_vol = size(that%vol)
           if (s_vol.gt.0) then
             allocate(this%vol(s_vol))
             do i_vol=1,s_vol
               call init(this%vol(i_vol),that%vol(i_vol))
             enddo
           endif
         endif
         this%apply_BC_order = that%apply_BC_order
       end subroutine

       subroutine delete_block(this)
         implicit none
         type(block),intent(inout) :: this
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         call delete(this%g)
         if (allocated(this%f)) then
           s_f = size(this%f)
           do i_f=1,s_f
             call delete(this%f(i_f))
           enddo
           deallocate(this%f)
         endif
         if (allocated(this%fb)) then
           s_fb = size(this%fb)
           do i_fb=1,s_fb
             call delete(this%fb(i_fb))
           enddo
           deallocate(this%fb)
         endif
         if (allocated(this%vol)) then
           s_vol = size(this%vol)
           do i_vol=1,s_vol
             call delete(this%vol(i_vol))
           enddo
           deallocate(this%vol)
         endif
         this%apply_BC_order = 0
       end subroutine

       subroutine display_block(this,un)
         implicit none
         type(block),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         call display(this%g,un)
         if (allocated(this%f)) then
           s_f = size(this%f)
           do i_f=1,s_f
             call display(this%f(i_f),un)
           enddo
         endif
         if (allocated(this%fb)) then
           s_fb = size(this%fb)
           do i_fb=1,s_fb
             call display(this%fb(i_fb),un)
           enddo
         endif
         if (allocated(this%vol)) then
           s_vol = size(this%vol)
           do i_vol=1,s_vol
             call display(this%vol(i_vol),un)
           enddo
         endif
         write(un,*) 'apply_BC_order = ',this%apply_BC_order
       end subroutine

       subroutine display_short_block(this,un)
         implicit none
         type(block),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         call display(this%g,un)
         if (allocated(this%f)) then
           s_f = size(this%f)
           do i_f=1,s_f
             call display(this%f(i_f),un)
           enddo
         endif
         if (allocated(this%fb)) then
           s_fb = size(this%fb)
           do i_fb=1,s_fb
             call display(this%fb(i_fb),un)
           enddo
         endif
         if (allocated(this%vol)) then
           s_vol = size(this%vol)
           do i_vol=1,s_vol
             call display(this%vol(i_vol),un)
           enddo
         endif
         write(un,*) 'apply_BC_order = ',this%apply_BC_order
       end subroutine

       subroutine display_wrap_block(this,dir,name)
         implicit none
         type(block),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_block(this)
         implicit none
         type(block),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_block(this)
         implicit none
         type(block),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_block(this,un)
         implicit none
         type(block),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         call export_primitives(this,un)
         call export(this%g,un)
         if (allocated(this%f)) then
           s_f = size(this%f)
           write(un,*) s_f
           if (s_f.gt.0) then
             do i_f=1,s_f
               call export(this%f(i_f),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
         if (allocated(this%fb)) then
           s_fb = size(this%fb)
           write(un,*) s_fb
           if (s_fb.gt.0) then
             do i_fb=1,s_fb
               call export(this%fb(i_fb),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
         if (allocated(this%vol)) then
           s_vol = size(this%vol)
           write(un,*) s_vol
           if (s_vol.gt.0) then
             do i_vol=1,s_vol
               call export(this%vol(i_vol),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
       end subroutine

       subroutine import_block(this,un)
         implicit none
         type(block),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         call delete(this)
         call import_primitives(this,un)
         call import(this%g,un)
         read(un,*) s_f
         if (s_f.gt.0) then
           allocate(this%f(s_f))
           do i_f=1,s_f
             call import(this%f(i_f),un)
           enddo
         endif
         read(un,*) s_fb
         if (s_fb.gt.0) then
           allocate(this%fb(s_fb))
           do i_fb=1,s_fb
             call import(this%fb(i_fb),un)
           enddo
         endif
         read(un,*) s_vol
         if (s_vol.gt.0) then
           allocate(this%vol(s_vol))
           do i_vol=1,s_vol
             call import(this%vol(i_vol),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_block(this,un)
         implicit none
         type(block),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'apply_BC_order  = ';write(un,*) this%apply_BC_order
       end subroutine

       subroutine import_primitives_block(this,un)
         implicit none
         type(block),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%apply_BC_order
       end subroutine

       subroutine export_wrap_block(this,dir,name)
         implicit none
         type(block),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_block(this,dir,name)
         implicit none
         type(block),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_block(this,dir)
         implicit none
         type(block),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         call suppress_warnings(this)
         call set_IO_dir(this%g,dir//'g'//fortran_PS)
         if (allocated(this%f)) then
           s_f = size(this%f)
           do i_f=1,s_f
             call set_IO_dir(this%f(i_f),&
             dir//'f_'//int2str(i_f)//fortran_PS)
           enddo
         endif
         if (allocated(this%fb)) then
           s_fb = size(this%fb)
           do i_fb=1,s_fb
             call set_IO_dir(this%fb(i_fb),&
             dir//'fb_'//int2str(i_fb)//fortran_PS)
           enddo
         endif
         if (allocated(this%vol)) then
           s_vol = size(this%vol)
           do i_vol=1,s_vol
             call set_IO_dir(this%vol(i_vol),&
             dir//'vol_'//int2str(i_vol)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine make_IO_dir_block(this,dir)
         implicit none
         type(block),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%g,dir//'g'//fortran_PS)
         if (allocated(this%f)) then
           s_f = size(this%f)
           do i_f=1,s_f
             call make_IO_dir(this%f(i_f),&
             dir//'f_'//int2str(i_f)//fortran_PS)
           enddo
         endif
         if (allocated(this%fb)) then
           s_fb = size(this%fb)
           do i_fb=1,s_fb
             call make_IO_dir(this%fb(i_fb),&
             dir//'fb_'//int2str(i_fb)//fortran_PS)
           enddo
         endif
         if (allocated(this%vol)) then
           s_vol = size(this%vol)
           do i_vol=1,s_vol
             call make_IO_dir(this%vol(i_vol),&
             dir//'vol_'//int2str(i_vol)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine export_folder_structure_block(this,dir)
         implicit none
         type(block),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         integer :: un
         call export_structured(this%g,dir//'g'//fortran_PS)
         if (allocated(this%f)) then
           s_f = size(this%f)
           write(un,*) s_f
           do i_f=1,s_f
             call export_structured(this%f(i_f),&
             dir//'f_'//int2str(i_f)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         if (allocated(this%fb)) then
           s_fb = size(this%fb)
           write(un,*) s_fb
           do i_fb=1,s_fb
             call export_structured(this%fb(i_fb),&
             dir//'fb_'//int2str(i_fb)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         if (allocated(this%vol)) then
           s_vol = size(this%vol)
           write(un,*) s_vol
           do i_vol=1,s_vol
             call export_structured(this%vol(i_vol),&
             dir//'vol_'//int2str(i_vol)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
       end subroutine

       subroutine export_structured_D_block(this,dir)
         implicit none
         type(block),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%g,dir//'g'//fortran_PS)
         if (allocated(this%f)) then
           s_f = size(this%f)
           write(un,*) s_f
           do i_f=1,s_f
             call export_structured(this%f(i_f),&
             dir//'f_'//int2str(i_f)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         if (allocated(this%fb)) then
           s_fb = size(this%fb)
           write(un,*) s_fb
           do i_fb=1,s_fb
             call export_structured(this%fb(i_fb),&
             dir//'fb_'//int2str(i_fb)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         if (allocated(this%vol)) then
           s_vol = size(this%vol)
           write(un,*) s_vol
           do i_vol=1,s_vol
             call export_structured(this%vol(i_vol),&
             dir//'vol_'//int2str(i_vol)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_block(this,dir)
         implicit none
         type(block),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_f
         integer :: i_fb
         integer :: i_vol
         integer :: s_f
         integer :: s_fb
         integer :: s_vol
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%g,dir//'g'//fortran_PS)
         read(un,*) s_f
         if (s_f.gt.0) then
           if (.not.allocated(this%f)) then
             allocate(this%f(s_f))
           endif
           do i_f=1,s_f
             call import_structured(this%f(i_f),&
             dir//'f_'//int2str(i_f)//fortran_PS)
           enddo
         endif
         read(un,*) s_fb
         if (s_fb.gt.0) then
           if (.not.allocated(this%fb)) then
             allocate(this%fb(s_fb))
           endif
           do i_fb=1,s_fb
             call import_structured(this%fb(i_fb),&
             dir//'fb_'//int2str(i_fb)//fortran_PS)
           enddo
         endif
         read(un,*) s_vol
         if (s_vol.gt.0) then
           if (.not.allocated(this%vol)) then
             allocate(this%vol(s_vol))
           endif
           do i_vol=1,s_vol
             call import_structured(this%vol(i_vol),&
             dir//'vol_'//int2str(i_vol)//fortran_PS)
           enddo
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_block(this)
         implicit none
         type(block),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module coordinates_extend_mod
      ! Pre-processor directives: (_DEBUG_COORDINATES_)
      use coordinates_mod
      use current_precision_mod
      use array_mod
      use array_extend_mod
      use sparse_mod
      use derivative_stencils_mod
      use interpolation_stencils_mod
      use IO_tools_mod
      implicit none

      private
      public :: coordinates
      public :: init

      ! For stitching multi-domains, only
      ! after coordinates has been defined
      public :: stitch_stencils

      ! For multi-grid
      public :: restrict
      public :: prolongate

      public :: pop,snip
      public :: mirror_about_hmin
      public :: mirror_about_hmax

      ! For getting surface / edge corner
      public :: get_GI
      public :: get_boundary
      public :: add_ghost_nodes
      public :: prepend_ghost
      public :: append_ghost

#ifdef _DEBUG_COORDINATES_
      public :: checkCoordinates
#endif

      interface init;              module procedure init_c;                 end interface
      interface init;              module procedure init_array_c;           end interface

      interface restrict;          module procedure restrict_c;             end interface
      interface restrict;          module procedure restrict_reset_c;       end interface
      interface prolongate;        module procedure prolongate_c;           end interface
      interface prolongate;        module procedure prolongate_reset_c;     end interface

      interface mirror_about_hmin; module procedure mirror_about_hmin_c;    end interface
      interface mirror_about_hmax; module procedure mirror_about_hmax_c;    end interface

      interface stitch_stencils;   module procedure stitch_stencils_c;      end interface
      interface init_stencils;     module procedure init_stencils_c;        end interface ! Private

      interface pop;               module procedure pop_c;                  end interface
      interface snip;              module procedure snip_c;                 end interface

      interface get_GI;            module procedure get_GI_c;               end interface
      interface get_boundary;      module procedure get_boundary_c;         end interface

      interface init_props;        module procedure init_props_c;           end interface
      interface add_ghost_nodes;   module procedure add_ghost_nodes_c;      end interface
      interface prepend_ghost;     module procedure prepend_ghost_c;        end interface
      interface append_ghost;      module procedure append_ghost_c;         end interface

      contains

      ! **********************************************************
      ! ********************* ESSENTIALS *************************
      ! **********************************************************

      subroutine init_array_c(c,hn)
        implicit none
        type(coordinates),intent(inout) :: c
        type(array),intent(in) :: hn
        call init(c,hn%f,hn%N)
      end subroutine

      subroutine init_c(c,hn,sn)
        ! Here is a picture how coordinates are initialized for different cases:
        !
        !
        ! ----------------------------- 1) 1 or more interior cells  + 2 ghost (typical):
        !
        !         hn(1)     hn(2)     hn(3)     hn(4)
        !          |-----------------------------|
        !          |    .    |    .    |    .    |
        !          |-----------------------------|
        !          |   hc(1) |   hc(2) |   hc(3) |
        !        amin       hmin      hmax      amax
        !
        ! ----------------------------- 2) 0 interior cells + 2 ghost:
        ! * This case does need special initialization because it is a special case of 1).
        !
        !              hn(1)     hn(2)     hn(3)
        !               |-------------------|
        !               |    .    |    .    |
        !               |-------------------|
        !               |   hc(1) |   hc(2) |
        !             amin    hmin,hmax      amax
        !
        ! ----------------------------- 3) 0 interior cells + 1 ghost:
        !
        !                 hn(1)        hn(2)
        !                  |-------------|
        !                  |      .      |
        !                  |-------------|
        !                  |     hc(1)   |
        !              hmin,amin     hmax,amax
        !
        ! ----------------------------- 4) 0 interior cells + 0 ghost (infinitely thin plane):
        !
        !                    hn(1),hc(1)
        !                         |
        !                         .
        !                         |
        !                         |
        !                hmin,amin,hmax,amax
        !
        ! -----------------------------
        implicit none
        type(coordinates),intent(inout) :: c
        integer,intent(in) :: sn
        real(cp),dimension(sn),intent(in) :: hn
        integer :: i
        call delete(c)
        if (.not.(size(hn).gt.0)) stop 'Error: hn not allocated in init_c in coordinates.f90'
        if (.not.(size(hn).eq.sn)) stop 'Error: sn.ne.size(hn) in init_c in coordinates.f90'

        ! Typical init
        c%sn = size(hn)
        if (c%sn.gt.2) then
          ! Node grid
          call init(c%hn,c%sn)
          call init(c%dhn,c%sn-1)
          c%hn%f = hn
          c%dhn%f = (/(hn(i+1)-hn(i),i=1,c%sn-1)/)
          ! Cell center grid
          c%sc = c%sn-1
          call init(c%hc,c%sc)
          call init(c%dhc,c%sc-1)
          c%hc%f = (/ ((hn(i+1)+hn(i))/2.0_cp,i=1,c%sn-1) /)
          c%dhc%f = (/(c%hc%f(i+1)-c%hc%f(i),i=1,c%sc-1)/)
        elseif (c%sn.eq.2) then
          ! Node grid
          call init(c%hn,c%sn)
          call init(c%dhn,c%sn-1)
          c%hn%f = hn
          c%dhn%f = (/(hn(i+1)-hn(i),i=1,c%sn-1)/)
          ! Cell center grid
          c%sc = c%sn-1
          call init(c%hc,c%sc)
          call init(c%dhc,1)
          c%hc%f = (/ ((hn(i+1)+hn(i))/2.0_cp,i=1,c%sn-1) /)
          c%dhc%f = 0.0_cp
        elseif (c%sn.eq.1) then
          ! Node grid
          call init(c%hn,c%sn)
          call init(c%dhn,1)
          c%hn%f = hn
          c%dhn%f = 0.0_cp
          ! Cell center grid
          c%sc = 1
          call init(c%hc,c%sc)
          call init(c%dhc,1)
          c%hc%f = c%hn%f
          c%dhc%f = 0.0_cp
        endif
        ! Additional information
        call init_props(c)
        call init_stencils(c)
        c%stencils_modified = .false.
        c%defined = .true.
      end subroutine

      subroutine init_props_c(c)
        implicit none
        type(coordinates),intent(inout) :: c
         ! Additional information
         c%dhMin = minval(c%dhn%f)
         c%dhMax = maxval(c%dhn%f)
         c%amin = c%hn%f(1)
         c%amax = c%hn%f(c%sn)
         c%hn_e = c%hn%f(c%sn)
         c%hc_e = c%hc%f(c%sc)
         if (c%sn.gt.2) then ! Typical init
           c%hmin = c%hn%f(2)
           c%hmax = c%hn%f(c%sn-1) ! To account for ghost node
           c%maxRange = c%hmax-c%hmin
           c%N = size(c%hc%f)-2
           c%dhc_e = c%dhc%f(c%sc-1)
           c%dhn_e = c%dhn%f(c%sn-1)
         elseif (c%sn.eq.2) then
           c%hmin = c%hn%f(1)
           c%hmax = c%hn%f(2)
           c%maxRange = c%hmax-c%hmin
           c%N = 0
           c%dhc_e = c%dhc%f(1)
           c%dhn_e = c%dhn%f(1)
         elseif (c%sn.eq.1) then
           c%hmin = c%hn%f(1)
           c%hmax = c%hn%f(1)
           c%maxRange = 0.0_cp
           c%N = 0
           c%dhc_e = c%dhc%f(1)
           c%dhn_e = c%dhn%f(1)
         endif
         c%i_midplane = c%sc/2+1
      end subroutine

      ! *****************************************************************
      ! ************************ STITCH STENCILS ************************
      ! *****************************************************************

      subroutine stitch_stencils_c(c,hmin,hmax)
        implicit none
        type(coordinates),intent(inout) :: c
        logical,intent(in) :: hmin,hmax
        if (.not.c%defined) then
          stop 'Error: coordinates not defined in stitch_stencils_c in coordinates.f90'
        endif
        if (.not.c%stencils_defined) then
          stop 'Error: coordinate stencils not defined in stitch_stencils_c in coordinates.f90'
        endif
        c%stencils_modified(1) = hmin
        c%stencils_modified(2) = hmax
        call stitch_colCC_1(c,hmin,hmax)
        call stitch_colCC_2(c,hmin,hmax)
        call stitch_colN_1(c,hmin,hmax)
        call stitch_colN_2(c,hmin,hmax)
      end subroutine

      subroutine stitch_colCC_2(c,hmin,hmax)
        implicit none
        type(coordinates),intent(inout) :: c
        logical,intent(in) :: hmin,hmax
        real(cp),dimension(:),allocatable :: dh
        integer :: i,s
        if (c%sc.gt.2) then
          s = c%sc; allocate(dh(s-1)); dh = c%dhc%f
          if (hmin) then; i = 2
            c%colCC(2)%L%f(1) =  2.0_cp/(dh(i-1)*(dh(i-1)+dh(i)))
            c%colCC(2)%D%f(1) = -2.0_cp/(dh(i-1)*dh(i))
            c%colCC(2)%U%f(1) =  2.0_cp/(dh( i )*(dh(i-1)+dh(i)))
          endif
          if (hmax) then; i = s-1
            c%colCC(2)%L%f(s-2) =  2.0_cp/(dh(i-1)*(dh(i-1)+dh(i)))
            c%colCC(2)%D%f(s-2) = -2.0_cp/(dh(i-1)*dh(i))
            c%colCC(2)%U%f(s-2) =  2.0_cp/(dh( i )*(dh(i-1)+dh(i)))
          endif
          deallocate(dh)
        else
          write(*,*) 'Error: cannot stitch domains with single point'
          stop 'program stopped in coordinates.f90'
        endif
      end subroutine

      subroutine stitch_colCC_1(c,hmin,hmax)
        implicit none
        type(coordinates),intent(inout) :: c
        real(cp),dimension(:),allocatable :: dh
        logical,intent(in) :: hmin,hmax
        integer :: i,s
        if (c%sc.gt.2) then
          s = c%sc; allocate(dh(s-1)); dh = c%dhc%f
          if (hmin) then; i = 2
            c%colCC(1)%L%f(1) = (-dh(i)/(dh(i-1)*(dh(i-1)+dh(i))))
            c%colCC(1)%D%f(1) = ((-dh(i-1)+dh(i))/(dh(i-1)*dh(i)))
            c%colCC(1)%U%f(1) = (dh(i-1)/(dh(i)*(dh(i-1)+dh(i))))
          endif
          if (hmax) then; i = s-1
            c%colCC(1)%L%f(s-2) = (-dh(i)/(dh(i-1)*(dh(i-1)+dh(i))))
            c%colCC(1)%D%f(s-2) = ((-dh(i-1)+dh(i))/(dh(i-1)*dh(i)))
            c%colCC(1)%U%f(s-2) = (dh(i-1)/(dh(i)*(dh(i-1)+dh(i))))
          endif
          deallocate(dh)
        else
          write(*,*) 'Error: cannot stitch domains with single point'
          stop 'program stopped in coordinates.f90'
        endif
      end subroutine

      subroutine stitch_colN_2(c,hmin,hmax)
        implicit none
        type(coordinates),intent(inout) :: c
        real(cp),dimension(:),allocatable :: dh
        logical,intent(in) :: hmin,hmax
        integer :: i,s
        if (c%sn.gt.2) then
          s = c%sn; allocate(dh(s-1)); dh = c%dhn%f
          if (hmin) then; i = 2
            c%colN(2)%L%f(1) =  2.0_cp/(dh(i-1)*(dh(i-1)+dh(i)))
            c%colN(2)%D%f(1) = -2.0_cp/(dh(i-1)*dh(i))
            c%colN(2)%U%f(1) =  2.0_cp/(dh( i )*(dh(i-1)+dh(i)))
          endif
          if (hmax) then; i = s-1
            c%colN(2)%L%f(s-2) =  2.0_cp/(dh(i-1)*(dh(i-1)+dh(i)))
            c%colN(2)%D%f(s-2) = -2.0_cp/(dh(i-1)*dh(i))
            c%colN(2)%U%f(s-2) =  2.0_cp/(dh( i )*(dh(i-1)+dh(i)))
          endif
          deallocate(dh)
        else
          write(*,*) 'Error: cannot stitch domains with single point'
          stop 'program stopped in coordinates.f90'
        endif
      end subroutine

      subroutine stitch_colN_1(c,hmin,hmax)
        implicit none
        type(coordinates),intent(inout) :: c
        logical,intent(in) :: hmin,hmax
        real(cp),dimension(:),allocatable :: dh
        integer :: i,s
        if (c%sn.gt.2) then
          s = c%sn; allocate(dh(s-1)); dh = c%dhn%f
          if (hmin) then; i = 2
            c%colN(1)%L%f(1) = -(dh(i)/(dh(i-1)*(dh(i-1)+dh(i))))
            c%colN(1)%D%f(1) =  ((-dh(i-1)+dh(i))/(dh(i-1)*dh(i)))
            c%colN(1)%U%f(1) =  (dh(i-1)/(dh( i )*(dh(i-1)+dh(i))))
          endif
          if (hmax) then; i = s-1
            c%colN(1)%L%f(s-2) = -(dh(i)/(dh(i-1)*(dh(i-1)+dh(i))))
            c%colN(1)%D%f(s-2) =  ((-dh(i-1)+dh(i))/(dh(i-1)*dh(i)))
            c%colN(1)%U%f(s-2) =  (dh(i-1)/(dh( i )*(dh(i-1)+dh(i))))
          endif
          deallocate(dh)
        else
          write(*,*) 'Error: cannot stitch domains with single point'
          stop 'program stopped in coordinates.f90'
        endif
      end subroutine

      ! *****************************************************************
      ! ***************** RESTRICTION (FOR MULTIGRID) *******************
      ! *****************************************************************

      subroutine restrict_c(r,c)
        ! Restriction for bad cases should only be allowed ~1 time
        ! Multiple restrictions of this type can make the cells
        ! blow up in size and overlap.
        ! Consider making a flag to only allow 1 time or
        ! use warnings to the user about the grid
        implicit none
        type(coordinates),intent(inout) :: r
        type(coordinates),intent(in) :: c
        integer :: i
        call init(r,c)
        if (c%sc.gt.3) then
          if (mod(c%sc,2).eq.0) then
            call init(r,(/(c%hn%f(2*i),i=1,c%sc/2)/),c%sc/2)
            call add_ghost_nodes(r)
            else; stop 'Error: coordinates must be even in restrictCoordinates in coordinates.f90'
          endif
        else; call init(r,c) ! return c
        endif
      end subroutine

      subroutine restrict_reset_c(c)
        implicit none
        type(coordinates),intent(inout) :: c
        type(coordinates) :: temp
        call restrict(temp,c)
        call init(c,temp)
        call delete(temp)
      end subroutine

      ! *****************************************************************
      ! ****************** PROLONGATE (FOR MULTIGRID) *******************
      ! *****************************************************************

      subroutine prolongate_c(p,c)
        implicit none
        type(coordinates),intent(inout) :: p
        type(coordinates),intent(in) :: c
        type(array),dimension(3) :: a
        integer :: i
        call init(p,c)
            if (c%sn.eq.1) then ! Can't prolongate without interior!
        elseif (c%sn.eq.2) then
        elseif (c%sn.eq.3) then
        elseif (c%sn.gt.3) then ! typical case, check to see if should be (c%sn.gt.4)
          call init(a(1),c%hn%f(2:c%sn-1),c%sn-2)
          call init(a(2),c%hc%f(2:c%sc-1),c%sc-2)
          call init(a(3),a(1)%N+a(2)%N)
          ! call init(a(3),2*(a(1)%N-1)-1)
          do i=1,a(1)%N; a(3)%f(2*i-1) = a(1)%f(i); enddo
          do i=1,a(2)%N; a(3)%f(2*i)   = a(2)%f(i); enddo
          call init(p,a(3)%f,a(3)%N)
          call add_ghost_nodes(p)
          do i=1,3; call delete(a(i)); enddo
        endif
      end subroutine

      subroutine prolongate_reset_c(c)
        implicit none
        type(coordinates),intent(inout) :: c
        type(coordinates) :: temp
        call prolongate(temp,c)
        call init(c,temp)
        call delete(temp)
      end subroutine

      ! *****************************************************************
      ! ******************** MIRROR (FOR SYMMETRY) **********************
      ! *****************************************************************

      subroutine mirror_about_hmin_c(c)
        implicit none
        type(coordinates),intent(inout) :: c
        type(array) :: a,m
        if (c%sn.eq.1) then ! Can't mirror without interior!
        elseif (c%sn.eq.2) then
        elseif (c%sn.eq.3) then
        elseif (c%sn.gt.3) then ! typical case
          call init(m,c%hn%f(2:c%sn),c%sn-1)
          call multiply(m,-1.0_cp)
          call add(m,2.0_cp*c%hn%f(2))
          call reverse(m)
          call init(a,(/m%f,c%hn%f(3:c%sn)/),2*c%sn-1)
          call init(c,a%f,a%N)
          call delete(a)
          call delete(m)
        endif
      end subroutine

      subroutine mirror_about_hmax_c(c)
        implicit none
        type(coordinates),intent(inout) :: c
        type(array) :: a,m
        if (c%sn.eq.1) then ! Can't mirror without interior!
        elseif (c%sn.eq.2) then
        elseif (c%sn.eq.3) then
        elseif (c%sn.gt.3) then ! typical case
          call init(m,c%hn%f(1:c%sn-1),c%sn-1)
          call multiply(m,-1.0_cp)
          call add(m,2.0_cp*c%hn%f(c%sn-1))
          call reverse(m)
          call init(a,(/c%hn%f(1:c%sn-2),m%f/),2*c%sn-3)
          call init(c,a%f,a%N)
          call delete(a)
          call delete(m)
        endif
      end subroutine

      ! *****************************************************************
      ! ********************* POP / SNIP ROUTINES ***********************
      ! *****************************************************************

      subroutine snip_c(c) ! Removes the first index from the coordinates
        implicit none
        type(coordinates),intent(inout) :: c
        type(coordinates) :: temp
        if (c%sn.eq.1) stop 'Error: no nodes to snip in snip_c in coordinates.f90'
        call init(temp,c%hn%f(2:c%sn-1),c%sn-1)
        call init(c,temp%hn%f,temp%sn)
        call delete(temp)
      end subroutine

      subroutine pop_c(c) ! Removes the last index from the coordinates
        implicit none
        type(coordinates),intent(inout) :: c
        type(coordinates) :: temp
        if (c%sn.eq.1) stop 'Error: no nodes to snip in pop_c in coordinates.f90'
        call init(temp,c%hn%f(1:c%sn-1),c%sn-1)
        call init(c,temp%hn%f,temp%sn)
        call delete(temp)
      end subroutine

      ! *****************************************************************
      ! ************* GET GHOST / BOUNDARY / FIRST INTERIOR *************
      ! *****************************************************************

      subroutine get_GI_c(c,dir)
        implicit none
        type(coordinates),intent(inout) :: c
        integer,intent(in) :: dir
        integer :: i,s
        if ((dir.ne.1).and.(dir.ne.-1)) stop 'Error: dir must = 1,-1 in get_GI_c in coordinates.f90'
        s = c%sn
        if (s.gt.3) then ! 3 or more nodes, remove all but boundary surface
        if (dir.eq.-1) then; do i=1,s-3; call pop(c);  enddo; endif
        if (dir.eq. 1) then; do i=1,s-3; call snip(c); enddo; endif
        elseif ((s.eq.3).or.(s.eq.2).or.(s.eq.1)) then
        else; stop 'Error: bad case in get_GI_c in coordinates.f90'
        endif
      end subroutine

      subroutine get_boundary_c(c,dir)
        implicit none
        type(coordinates),intent(inout) :: c
        integer,intent(in) :: dir
        integer :: i,s
        if ((dir.ne.1).and.(dir.ne.-1)) stop 'Error: dir must = 1,-1 in get_boundary_c in coordinates.f90'
        s = c%sn
        if (s.gt.2) then ! 3 or more nodes, remove all but boundary surface
        if (dir.eq.-1) then; do i=1,s-2; call pop(c);  enddo; call snip(c); endif
        if (dir.eq. 1) then; do i=1,s-2; call snip(c); enddo; call pop(c);  endif
        elseif ((s.eq.2).or.(s.eq.1)) then ! single cell, cannot choose which node to remove
        else; stop 'Error: bad case in get_boundary_c in coordinates.f90'
        endif
      end subroutine

      ! *****************************************************************
      ! ************************** AUXILIARY ****************************
      ! *****************************************************************

      subroutine init_stencils_c(c)
        implicit none
        type(coordinates),intent(inout) :: c
        ! Interpolation stencils
        call init(c%theta,interpolation_stencil(c%hc%f,c%hn%f,c%sc,c%sn))
        ! Derivative stencils
        call init(c%stagCC2N,staggered_CC2N(c%dhc%f,c%sc))
        call init(c%stagN2CC,staggered_N2CC(c%dhn%f,c%sn))
        call init(c%colCC_centered(1),collocated_CC_1_centered(c%dhc%f,c%sc))
        call init(c%colCC_centered(2),collocated_CC_2_centered(c%dhc%f,c%sc))
        call init(c%colCC(1),collocated_CC_1(c%dhc%f,c%sc))
        call init(c%colCC(2),collocated_CC_2(c%dhc%f,c%sc))
        call init(c%colN(1),collocated_Node_1(c%dhn%f,c%sn))
        call init(c%colN(2),collocated_Node_2(c%dhn%f,c%sn))

        ! call check(c%stagCC2N)
        ! call check(c%stagN2CC)
        ! call check(c%colCC)
        ! call check(c%colN)
        ! stop 'Done'
        c%stencils_defined = .true.
      end subroutine

      subroutine add_ghost_nodes_c(c)
        implicit none
        type(coordinates),intent(inout) :: c
        if (c%sn.gt.1) then
          call init(c,(/c%hn%f(1)-c%dhn%f(1),c%hn%f,c%hn%f(c%sn)+c%dhn_e/),c%sn+2)
        else
          write(*,*) 'Error: Trying to add ghost point to a single point'
          stop 'program stopped in coordinates.f90'
        endif
      end subroutine

      subroutine prepend_ghost_c(c)
        implicit none
        type(coordinates),intent(inout) :: c
        if (c%sn.gt.1) then
        call init(c,(/c%hn%f(1)-c%dhn%f(1),c%hn%f/),c%sn+1)
        else
          write(*,*) 'Error: Trying to prepend ghost point to a single point'
          stop 'program stopped in coordinates.f90'
        endif
      end subroutine

      subroutine append_ghost_c(c)
        implicit none
        type(coordinates),intent(inout) :: c
        if (c%sn.gt.1) then
        call init(c,(/c%hn%f,c%hn%f(c%sn)+c%dhn_e/),c%sn+1)
        else
          write(*,*) 'Error: Trying to append ghost point to a single point'
          stop 'program stopped in coordinates.f90'
        endif
      end subroutine

#ifdef _DEBUG_COORDINATES_

      subroutine checkCoordinates(c)
        implicit none
        type(coordinates),intent(in) :: c
        write(*,*) 'Starting to check coordinates'
        call check(c%colCC(1))
        call check(c%colCC(2))
        call check(c%colCC_centered(1))
        call check(c%colCC_centered(2))
        call check(c%colN(1))
        call check(c%colN(2))
        call check(c%stagCC2N)
        call check(c%stagN2CC)
        write(*,*) 'step 0'; call insist_consecutive_c(c)
        write(*,*) 'step 1'; call check_stencilSymmetry(c,c%stagCC2N,'stagCC2N')
        write(*,*) 'step 2'; call check_stencilSymmetry(c,c%stagN2CC,'stagN2CC')
        write(*,*) 'step 3'; call check_stencilSymmetry(c,c%colCC(1),'colCC(1)')
        write(*,*) 'step 4'; call check_stencilSymmetry(c,c%colCC(2),'colCC(2)')
        write(*,*) 'step 5'; call check_stencilSymmetry(c,c%colCC_centered(1),'colCC_centered(1)')
        write(*,*) 'step 6'; call check_stencilSymmetry(c,c%colCC_centered(2),'colCC_centered(2)')
        write(*,*) 'step 7'; call check_stencilSymmetry(c,c%colN(1),'colN(1)')
        write(*,*) 'step 8'; call check_stencilSymmetry(c,c%colN(2),'colN(2)')
        write(*,*) 'Done checking coordinates'
        ! stop 'Done'
      end subroutine

      subroutine insist_consecutive_c(c)
        implicit none
        type(coordinates),intent(in) :: c
        integer :: i
        real(cp) :: tol
        if (c%sn.gt.1) then
          ! Check if consectutive
          do i=1,c%sn-1
            if (c%hn%f(i+1)-c%hn%f(i).lt.c%dhMin/2.0_cp) then
               write(*,*) 'i,dh',i,c%hn%f(i+1)-c%hn%f(i)
               write(*,*) 'hn = ',c%hn
               stop 'Error: coordinates are not consecutive.'
            endif
          enddo
          ! Check if cell centeres are in cell center
          tol = c%dhMin*1.0_cp**(-10.0_cp)
          do i=1,c%sn-1
            if (abs((c%hc%f(i)-c%hn%f(i))-(c%hn%f(i+1)-c%hc%f(i))).gt.tol) then
               write(*,*) 'Cell centers are not centered'
               write(*,*) 'i = ',i
               write(*,*) 'hn = ',c%hn%f
               write(*,*) 'hc = ',c%hc%f
               stop 'Error: cell centeres are not in cell centers.'
            endif
          enddo
        else
          write(*,*) 'Warning: cannot check consecutive coordinates for a single point'
          stop 'program stopped in coordinates.f90'
        endif
      end subroutine

      subroutine check_stencilSymmetry(c,T,name)
        implicit none
        type(coordinates),intent(in) :: c
        type(triDiag),intent(in) :: T
        character(len=*),intent(in) :: name
        integer :: i
        real(cp) :: tol,temp
        tol = c%dhMin*1.0_cp**(-15.0_cp)
        ! Check L
        ! do i=1,T%sL
        !   if (allocated(T%L)) then
        !    temp = abs(T%L(i)) - abs(T%L(T%s-i+1))
        !    ! write(*,*) 'temp(L(',i,')) = ',temp
        !    if (abs(temp).gt.tol) then
        !      write(*,*) 'Error: coordinate stencils are not symmetric at location ',i
        !      write(*,*) 'for L on stencil '//name
        !      write(*,*) 'T%L = ',T%L
        !      write(*,*) 'error = ',abs(temp)
        !      stop 'Done'
        !    endif
        !   endif
        ! enddo
        ! Check LU
        ! if (allocated(T%L).and.(allocated(T%U))) then
        !   if (T%sL.ne.T%sU) stop 'Error: T%sL must = T%sU in check_stencilSymmetry in coordinates.f90'
        !   do i=1,T%sL
        !      temp = abs(T%L(i)) - abs(T%U(T%s-i+1))
        !      if (abs(temp).gt.tol) then
        !        write(*,*) 'Error: coordinate stencils are not symmetric at location ',i
        !        write(*,*) 'for LU on stencil '//name
        !        write(*,*) 'T%L = ',T%L
        !        write(*,*) 'T%U = ',T%U
        !        write(*,*) 'error = ',abs(temp)
        !        stop 'Done'
        !      endif
        !   enddo
        ! endif
        ! Check D
        do i=1,T%sD
          if (allocated(T%D)) then
          temp = abs(T%D(i)) - abs(T%D(T%s-i+1))
          ! write(*,*) 'temp(D(',i,')) = ',temp
          if (abs(temp).gt.tol) then
            write(*,*) 'Error: coordinate stencils are not symmetric at location ',i
            write(*,*) 'for D on stencil '//name
            write(*,*) 'T%D = ',T%D
            write(*,*) 'error = ',abs(temp)
            stop 'Done'
          endif
          endif
        enddo
        ! Check U
        ! do i=1,T%sU
        !   if (allocated(T%U)) then
        !   temp = abs(T%U(i)) - abs(T%U(T%s-i+1))
        !   ! write(*,*) 'temp(U(',i,')) = ',temp
        !   if (abs(temp).gt.tol) then
        !     write(*,*) 'Error: coordinate stencils are not symmetric at location ',i
        !     write(*,*) 'for U on stencil '//name
        !     write(*,*) 'T%U = ',T%U
        !      write(*,*) 'error = ',abs(temp)
        !     stop 'Done'
        !   endif
        !   endif
        ! enddo
      end subroutine

#endif
      end module
       module export_frequency_extend_mod
       use export_frequency_mod
       use current_precision_mod
       use string_mod
       use IO_tools_mod
       use time_marching_params_mod
       use export_frequency_params_mod
       use export_frequency_params_extend_mod
       implicit none

       private
       public :: update
       interface update;  module procedure update_EF;         end interface

       contains

       subroutine update_EF(EF,TMP,substep)
         implicit none
         type(export_frequency),intent(inout) :: EF
         type(time_marching_params),intent(in) :: TMP
         logical,intent(in) :: substep
         call update(EF%info,TMP,substep)
         call update(EF%unsteady_0D,TMP,substep)
         call update(EF%unsteady_1D,TMP,substep)
         call update(EF%unsteady_2D,TMP,substep)
         call update(EF%unsteady_3D,TMP,substep)
         call update(EF%final_solution,TMP,substep)
         call update(EF%restart_files,TMP,substep)
       end subroutine

       end module
      module ops_fft_mod
      ! Returns the Fast Fourier Transform of the scalar field, f, wrt direction
      ! dir (1,2,3) which corresponds to (x,y,z).
      !
      ! Flags: (fopenmp,_DEBUG_FFT_)
      !
      ! Implementation:
      ! call fft(omega,f,dir,pad)
      !
      ! INPUT:
      !     f    = f(x,y,z)
      !     dir  = direction along which to take the FT (1,2,3)
      !     pad  = (1,0) = (exclude,include) boundary calc along FT direction
      !            |0000000|     |-------|
      !            |-------|  ,  |-------| Look at fft for implementation details
      !            |0000000|     |-------|
      !
      ! INDEXING: The index range of the incoming scalar field is assumed to begin at one.
      !
      ! CharlieKawczynski@gmail.com
      ! 7/12/2015
      !
      ! Good references:
      !
      ! https://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/

      use current_precision_mod
      use constants_mod
      use grid_mod
      implicit none

      private
      public :: fft,fft1D
      interface fft;      module procedure applyFFT3D;    end interface
#ifdef _FFT_RADIX2_
      interface fft1D;    module procedure fft1D_Radix2;      end interface
#else
      interface fft1D;    module procedure fft1D_full;    end interface
#endif

      contains

#ifdef _FFT_RADIX2_
      recursive subroutine fft1D_Radix2(x) ! In place Cooley-Tukey FFT
        ! Computes
        !
        !                  N
        !    X(k) =       sum  x(n)*exp(-j*2*PI*(k-1)*(n-1)/N), 1 <= k <= N.
        !                 n=1
        !
        ! Notes: Only valid for when the number of cells is 2^N, where N>1
        !
        complex(cp), dimension(:), intent(inout)  :: x
        complex(cp)                               :: t
        integer                                   :: N
        integer                                   :: i
        complex(cp), dimension(:), allocatable    :: even, odd
        N=size(x)
        if(N .le. 1) return
        allocate(odd((N+1)/2))
        allocate(even(N/2))
        ! divide
        odd =x(1:N:2)
        even=x(2:N:2)
        ! conquer
        call fft1D(odd)
        call fft1D(even)
        ! combine
        do i=1,N/2
           t=exp(cmplx(0.0_cp,-2.0_cp*PI*real(i-1,cp)/real(N,cp),kind=cp))*even(i)
           x(i)     = odd(i) + t
           x(i+N/2) = odd(i) - t
        end do
        deallocate(odd)
        deallocate(even)
      end subroutine
#else
      subroutine fft1D_full(x) ! Full Discrete Fourier Transform
        ! Computes
        !
        !                  N
        !    X(k) =       sum  x(n)*exp(-j*2*PI*(k-1)*(n-1)/N), 1 <= k <= N.
        !                 n=1
        !
        ! Notes: This routine computes the full FT (very slow), allowing for an
        !        arbitrary number of cells. If the number of cells
        !        is 2^N, where N>1, then use the Cooley-Tukey FFT below.
        !
        !
        complex(cp), dimension(:), intent(inout)  :: x
        complex(cp), dimension(:), allocatable    :: temp
        complex(cp)                               :: S,j ! sum, sqrt(-1)
        integer                                   :: N,i,k
        N=size(x)
        allocate(temp(N))
        j = cmplx(0.0_cp,1.0_cp,cp)
        S = cmplx(0.0_cp,0.0_cp,cp)
        temp = cmplx(0.0_cp,0.0_cp,cp)
        do i = 1,N
          do k = 1,N
            S = S + x(k)*exp(-2.0_cp*PI*j*real(k-1,cp)*real(i-1,cp)/real(N,cp))
          enddo
          temp(i) = S
          S = cmplx(0.0_cp,0.0_cp,cp)
        enddo
        x = temp
        deallocate(temp)
      end subroutine
#endif

      subroutine applyFFT3D(omega,f,dir,pad)
        implicit none
        complex(cp),dimension(:,:,:),intent(inout) :: omega
        real(cp),dimension(:,:,:),intent(in) :: f
        integer,intent(in) :: dir,pad
        integer,dimension(3) :: s
        integer :: i,j,k

        s = shape(f)

        !$OMP PARALLEL DO
        do k=1,s(3); do j=1,s(2); do i=1,s(1)
        omega(i,j,k) = f(i,j,k)
        enddo; enddo; enddo
        !$OMP END PARALLEL DO

#ifdef _DEBUG_FFT_
        call checkDimensions(s,shape(omega),dir)
#endif

        select case (dir)
        case (1)
          !$OMP PARALLEL DO
          do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad
            call fft1D(omega(:,j,k))
          enddo; enddo
          !$OMP END PARALLEL DO
        case (2)
          !$OMP PARALLEL DO
          do k=1+pad,s(3)-pad; do i=1+pad,s(1)-pad
            call fft1D(omega(i,:,k))
          enddo; enddo
          !$OMP END PARALLEL DO
        case (3)
          !$OMP PARALLEL DO
          do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
            call fft1D(omega(i,j,:))
          enddo; enddo
          !$OMP END PARALLEL DO
        case default
        stop 'Error: dir must = 1,2,3 in applyFFT3D in fft.f90.'
        end select
      end subroutine

      ! ******************* OPERATOR TYPES ****************************

#ifdef _DEBUG_FFT_
      subroutine checkDimensions(s1,s2,dir)
        ! This routine makes sure that the shapes s1 and s2
        ! are correct
        implicit none
        integer,dimension(3),intent(in) :: s1,s2
        integer,intent(in) :: dir
        select case (dir)
        case (1); if (s1(2).ne.s2(2)) stop 'Error: Shape mismatch 1 in fft'
                  if (s1(3).ne.s2(3)) stop 'Error: Shape mismatch 2 in fft'
        case (2); if (s1(1).ne.s2(1)) stop 'Error: Shape mismatch 3 in fft'
                  if (s1(3).ne.s2(3)) stop 'Error: Shape mismatch 4 in fft'
        case (3); if (s1(1).ne.s2(1)) stop 'Error: Shape mismatch 5 in fft'
                  if (s1(2).ne.s2(2)) stop 'Error: Shape mismatch 6 in fft'
        case default
        stop 'Error: dir must = 1,2,3 in fft.f90'
        end select
        if (s1(dir).eq.s2(dir)) then         ! Ok (collocated)
        else; stop 'Error: shape mismatch 7 in fft.f90'
        endif
      end subroutine
#endif

      end module
       module profile_funcs_mod
       use current_precision_mod
       use grid_mod
       use coordinates_mod
       use constants_mod
       implicit none

       private
       ! None of these have been tested yet..
       public :: rotatingCylinder   ! Done
       public :: init_FD_DuctFlow   ! Done
       public :: parabolic1D        ! Done
       public :: shercliff_profile  ! Done
       public :: hunt_profile       ! Done
       public :: isolatedEddy2D     ! Need to change to func
       public :: singleEddy2D       ! Need to change to func
       public :: cylinder2D         ! Need to change to func
       public :: SH_profile

       contains

       function rotatingCylinder(cx,cy,sx,sy,r0,omega0,component) result(f)
         ! Computes velocities fx,fy due to rigid body motion
         ! with coordinates cx,cy. The radius of rotation, r0,
         ! and angular velocity, omega0, are inputs.
         ! NOTE: omega0 may be zero to allow for reverse rotation.
         ! component = (1,2) = (x,y)
         implicit none
         integer,intent(in) :: sx,sy
         real(cp),dimension(sx,sy) :: f
         type(coordinates),intent(in) :: cx,cy
         real(cp),intent(in) :: r0,omega0
         integer,intent(in) :: component
         real(cp) :: x0,y0,r,theta
         integer :: i,j
         real(cp),dimension(:),allocatable :: x,y
         real(cp),dimension(2) :: hmin,hmax
         allocate(x(sx)); allocate(y(sy))
             if (sx.eq.cx%sn) then; x = cx%hn%f
         elseif (sx.eq.cx%sc) then; x = cx%hc%f
           else; stop 'Error: bad size in rotatingCylinder in profile_funcs.f90'
         endif
             if (sy.eq.cy%sn) then; y = cy%hn%f
         elseif (sy.eq.cy%sc) then; y = cy%hc%f
           else; stop 'Error: bad size in rotatingCylinder in profile_funcs.f90'
         endif

         hmin = (/cx%hmin,cy%hmin/)
         hmax = (/cx%hmax,cy%hmax/)
         x0 = (hmax(1) + hmin(1))/2.0_cp
         y0 = (hmax(2) + hmin(2))/2.0_cp
         do i=1,sx; do j=1,sy
           r = sqrt((x(i)-x0)**2.0_cp + (y(j)-y0)**2.0_cp)
           if (r.lt.r0) then
             theta = atan2(y(j),x(i))
             select case (component)
             case (1); f(i,j) = -omega0*r*sin(theta)
             case (2); f(i,j) =  omega0*r*cos(theta)
             end select
           endif
         enddo; enddo
         deallocate(x); deallocate(y)
       end function

       function shercliff_profile(cx,cy,sx,sy,Ha,mu,dpdz) result(w)
         ! Computes the Shercliff profile, w(x,y) for Hartmann number,Ha
         ! Reference:
         !      "Planas, R., Badia, S. & Codina, R. Approximation of
         !      the inductionless MHD problem using a stabilized finite
         !      element method. J. Comput. Phys. 230, 2977–2996 (2011)."
         implicit none
         integer,intent(in) :: sx,sy
         real(cp),dimension(sx,sy) :: w
         type(coordinates),intent(in) :: cx,cy
         real(cp),intent(in) :: Ha,mu,dpdz
         real(cp) :: r1k,r2k,V2,V3,coeff,N,alpha_k,d_B,L,term,a,b
         integer :: i,j,k,iter
         real(cp),dimension(:),allocatable :: x,y

         allocate(x(sx)); allocate(y(sy))
             if (sx.eq.cx%sn) then; x = cx%hn%f
         elseif (sx.eq.cx%sc) then; x = cx%hc%f
           else; stop 'Error: bad size in shercliff_profile in profile_funcs.f90'
         endif
             if (sy.eq.cy%sn) then; y = cy%hn%f
         elseif (sy.eq.cy%sc) then; y = cy%hc%f
           else; stop 'Error: bad size in shercliff_profile in profile_funcs.f90'
         endif

         a = (cx%hmax - cx%hmin)/2.0_cp
         b = (cy%hmax - cy%hmin)/2.0_cp
         L = b/a

         d_B = 0.0_cp
         iter = 1000
         do k=0,iter
           do i=1,sx; do j=1,sy
             alpha_k = (k+0.5_cp)*PI/L
             N = (Ha**2.0_cp + 4.0_cp*alpha_k**2.0_cp)**(0.5_cp)
             r1k = 0.5_cp*(Ha + N)
             r2k = 0.5_cp*(-Ha + N)
             V2 = shercliff_coeff(r1k,r2k,y(j)/a,d_B,N)
             V3 = shercliff_coeff(r2k,r1k,y(j)/a,d_B,N)

             coeff = 2.0_cp*(-1.0_cp)**k*cos(alpha_k*x(i)/a)/(L*alpha_k**3.0_cp)
             term = coeff*(1.0_cp - V2 - V3)
             w(i,j) = w(i,j) + term
           enddo; enddo
         enddo
         w = w/mu*(-dpdz)*a**2.0_cp
         deallocate(x); deallocate(y)
       end function

       function shercliff_coeff(r1k,r2k,eta,d_B,N) result(V)
         ! Computes the coefficient (V2,V3) in the Shercliff profile
         ! expressions given in reference:
         !
         !      "Planas, R., Badia, S. & Codina, R. Approximation of
         !      the inductionless MHD problem using a stabilized finite
         !      element method. J. Comput. Phys. 230, 2977–2996 (2011)."
         implicit none
         real(cp),intent(in) :: r1k,r2k,eta,d_B,N
         real(cp) :: A,B,C,D,V
         A = d_B*r2k+(1.0_cp-exp(-2.0_cp*r2k))/(1.0_cp+exp(-2.0_cp*r2k))
         B = (exp(-r1k*(1.0_cp-eta))+exp(-r1k*(1.0_cp+eta)))/2.0_cp
         C = (1.0_cp+exp(-2.0_cp*r1k))/2.0_cp*d_B*N
         D = (1.0_cp-exp(-2.0_cp*(r1k+r2k)))/(1.0_cp+exp(-2.0_cp*r2k))
         V = A*B/(C+D)
       end function

       function hunt_coeff(r1k,r2k,eta,N) result(V)
         ! Computes the coefficient (V2,V3) in the Hunt profile
         ! expressions given in reference:
         !
         !      "Planas, R., Badia, S. & Codina, R. Approximation of
         !      the inductionless MHD problem using a stabilized finite
         !      element method. J. Comput. Phys. 230, 2977–2996 (2011)."
         implicit none
         real(cp),intent(in) :: r1k,r2k,eta,N
         real(cp) :: A,B,C,V
         A = r2k/N
         B = exp(-r1k*(1.0_cp-eta))+exp(-r1k*(1.0_cp+eta))
         C = 1.0_cp+exp(-2.0_cp*r1k)
         V = A*B/C
       end function

       function hunt_profile(cx,cy,sx,sy,Ha,mu,dpdz) result(w)
         ! Computes the Hunt profile, w(x,y) for Hartmann number,Ha
         ! Reference:
         !      "Planas, R., Badia, S. & Codina, R. Approximation of
         !      the inductionless MHD problem using a stabilized finite
         !      element method. J. Comput. Phys. 230, 2977–2996 (2011)."
         implicit none
         integer,intent(in) :: sx,sy
         real(cp),dimension(sx,sy) :: w
         type(coordinates),intent(in) :: cx,cy
         real(cp),intent(in) :: Ha,mu,dpdz
         real(cp) :: r1k,r2k,V2,V3,coeff,N,alpha_k,L,term,a,b
         integer :: i,j,k,iter
         real(cp),dimension(:),allocatable :: x,y

         allocate(x(sx)); allocate(y(sy))
             if (sx.eq.cx%sn) then; x = cx%hn%f
         elseif (sx.eq.cx%sc) then; x = cx%hc%f
           else; stop 'Error: bad size in hunt_profile in profile_funcs.f90'
         endif
             if (sy.eq.cy%sn) then; y = cy%hn%f
         elseif (sy.eq.cy%sc) then; y = cy%hc%f
           else; stop 'Error: bad size in hunt_profile in profile_funcs.f90'
         endif

         a = (cx%hmax - cx%hmin)/2.0_cp
         b = (cy%hmax - cy%hmin)/2.0_cp
         L = b/a

         iter = 1000
         do k=0,iter
           do i=1,sx; do j=1,sy
             alpha_k = (k+0.5_cp)*PI/L
             N = (Ha**2.0_cp + 4.0_cp*alpha_k**2.0_cp)**(0.5_cp)
             r1k = 0.5_cp*(Ha + N)
             r2k = 0.5_cp*(-Ha + N)
             V2 = hunt_coeff(r1k,r2k,y(j)/a,N)
             V3 = hunt_coeff(r2k,r1k,y(j)/a,N)

             coeff = 2.0_cp*(-1.0_cp)**k*cos(alpha_k*x(i)/a)/(L*alpha_k**3.0_cp)
             term = coeff*(1.0_cp - V2 - V3)
             w(i,j) = w(i,j) + term
           enddo; enddo
         enddo
         w = w/mu*(-dpdz)*a**2.0_cp
         deallocate(x); deallocate(y)
       end function

       function SH_coeff(r1k,r2k,eta,d_B,N) result(V)
         ! Computes the coefficient (V2,V3) in the Shercliff profile
         ! expressions given in reference:
         !
         !      "Planas, R., Badia, S. & Codina, R. Approximation of
         !      the inductionless MHD problem using a stabilized finite
         !      element method. J. Comput. Phys. 230, 2977–2996 (2011)."
         implicit none
         real(cp),intent(in) :: r1k,r2k,eta,d_B,N
         real(cp) :: A,B,C,D,V
         A = d_B*r2k+(1.0_cp-exp(-2.0_cp*r2k))/(1.0_cp+exp(-2.0_cp*r2k))
         B = (exp(-r1k*(1.0_cp-eta))+exp(-r1k*(1.0_cp+eta)))/2.0_cp
         C = (1.0_cp+exp(-2.0_cp*r1k))/2.0_cp*d_B*N
         D = (1.0_cp-exp(-2.0_cp*(r1k+r2k)))/(1.0_cp+exp(-2.0_cp*r2k))
         V = A*B/(C+D)
       end function

       function SH_profile(cx,cy,sx,sy,d_B,Ha,mu,dpdz) result(w)
         ! Computes the Hunt profile, w(x,y) for Hartmann number,Ha
         ! Reference:
         !      "Planas, R., Badia, S. & Codina, R. Approximation of
         !      the inductionless MHD problem using a stabilized finite
         !      element method. J. Comput. Phys. 230, 2977–2996 (2011)."
         !
         !
         ! Hunt flow configuration
         !
         !         conducting
         !   B⁰   |----------|
         !   ^    |          |
         !   |    |          | - non-conducting
         !   |    |          |
         !        |----------|
         !         conducting
         !
         implicit none
         integer,intent(in) :: sx,sy
         real(cp),dimension(sx,sy) :: w
         type(coordinates),intent(in) :: cx,cy
         real(cp),intent(in) :: Ha,mu,dpdz,d_B
         real(cp) :: r1k,r2k,V2,V3,coeff,N,alpha_k,L,term,a,b
         integer :: i,j,k,iter
         real(cp),dimension(:),allocatable :: x,y,xi,eta

         allocate(x(sx)); allocate(y(sy)); allocate(xi(sx)); allocate(eta(sy))
             if (sx.eq.cx%sn) then; x = cx%hn%f
         elseif (sx.eq.cx%sc) then; x = cx%hc%f
           else; stop 'Error: bad size in hunt_profile in profile_funcs.f90'
         endif
             if (sy.eq.cy%sn) then; y = cy%hn%f
         elseif (sy.eq.cy%sc) then; y = cy%hc%f
           else; stop 'Error: bad size in hunt_profile in profile_funcs.f90'
         endif

         a = (cx%hmax - cx%hmin)/2.0_cp
         b = (cy%hmax - cy%hmin)/2.0_cp
         L = b/a
         xi = x/a
         eta = y/a

         iter = 1000
         w = 0.0_cp
         do k=0,iter
           do i=1,sx; do j=1,sy
             alpha_k = (k+0.5_cp)*PI/L
             N = (Ha**2.0_cp + 4.0_cp*alpha_k**2.0_cp)**(0.5_cp)
             r1k = 0.5_cp*(Ha + N)
             r2k = 0.5_cp*(-Ha + N)
             V2 = SH_coeff(r1k,r2k,eta(j),d_B,N)
             V3 = SH_coeff(r2k,r1k,eta(j),d_B,N)

             coeff = 2.0_cp*(-1.0_cp)**k*cos(alpha_k*xi(i))/(L*alpha_k**3.0_cp)
             term = coeff*(1.0_cp - V2 - V3)
             w(i,j) = w(i,j) + term
           enddo; enddo
         enddo
         w = w/mu*(-dpdz)*a**2.0_cp
         deallocate(x,y,xi,eta)
       end function

       function init_FD_DuctFlow(cx,cy,sx,sy) result(w)
         implicit none
         integer,intent(in) :: sx,sy
         real(cp),dimension(sx,sy) :: w
         type(coordinates),intent(in) :: cx,cy
         real(cp),dimension(:),allocatable :: hx,hy
         real(cp) :: alpha,height,width,F,A,A1,A2,A3
         real(cp),dimension(2) :: hmin,hmax
         integer :: i,j,n,m,nMax,mMax
         hmin = (/cx%hmin,cy%hmin/)
         hmax = (/cx%hmax,cy%hmax/)
         allocate(hx(sx)); width  = (hmax(1) - hmin(1))/2.0_cp
         allocate(hy(sy)); height = (hmax(2) - hmin(2))/2.0_cp

             if (sx.eq.cx%sn) then; hx = cx%hn%f
         elseif (sx.eq.cx%sc) then; hx = cx%hc%f
           else; stop 'Error: bad size in init_FD_DuctFlow in profile_funcs.f90'
         endif
             if (sy.eq.cy%sn) then; hy = cy%hn%f
         elseif (sy.eq.cy%sc) then; hy = cy%hc%f
           else; stop 'Error: bad size in init_FD_DuctFlow in profile_funcs.f90'
         endif
         ! Iterations in infinite series:
         nMax = 100; mMax = 100
         F = 1.0_cp ! This is dynamic viscosity or proportional to it or something...
         alpha = width/height
         do i=1,sx
           do j=1,sy
             do m=1,mMax
               do n=1,nMax
               A1 = 16.0_cp*F*alpha**2.0_cp*height**2.0_cp/&
               ((real(m,cp)*PI)**2.0_cp+(alpha*real(n,cp)*PI)**2.0_cp)
               A2 = 1.0_cp/(real(m,cp)*PI)*1.0_cp/(real(n,cp)*PI)
               A3 = (1.0_cp-cos(real(m,cp)*PI))*(1.0_cp-cos(real(n,cp)*PI))
               A = A1*A2*A3
               w(i,j) = w(i,j) + A*sin(real(m,cp)*PI*(hx(i)-hmin(1))/(2.0_cp*width))*&
                                             sin(real(n,cp)*PI*(hy(j)-hmin(2))/(2.0_cp*height))
               enddo
             enddo
           enddo
         enddo
         deallocate(hx,hy)
       end function

       function parabolic1D(c,s) result(u)
         implicit none
         type(coordinates),intent(in) :: c
         integer,intent(in) :: s
         real(cp),dimension(s) :: u
         real(cp),dimension(:),allocatable :: h
         integer :: i
         real(cp) :: Re
         Re = 200.0_cp
         allocate(h(s))
             if (s.eq.c%sn) then; h = c%hn%f
         elseif (s.eq.c%sc) then; h = c%hc%f
         else; stop 'Error: bad size in parabolic1D in profile_funcs.f90'
         endif
         do i=1,s
           u(i) = 0.5_cp*Re*(1.0_cp - h(i)**2.0_cp)
         enddo
         deallocate(h)
       end function

       function isolatedEddy2D(cx,cy,sx,sy,component) result(f)
         ! Computes velocities fx,fy from reference:
         !      "Weiss, N. O. The Expulsion of Magnetic Flux
         !      by Eddies. Proc. R. Soc. A Math. Phys. Eng.
         !      Sci. 293, 310–328 (1966).""
         !
         ! Computes
         !           U = curl(psi)
         ! Where
         !           psi = (-1/(2 pi)) cos(2 pi x) cos(2 pi y)
         !           u = dpsi/dy
         !           v =-dpsi/dx
         !           w = 0
         ! Computes
         !       u = dpsi/dy =   cos(2 pi x) sin(2 pi y)
         !       v =-dpsi/dx = - sin(2 pi x) cos(2 pi y)
         !
         ! Component = (1,2) = (x,y)
         implicit none
         integer,intent(in) :: sx,sy
         real(cp),dimension(sx,sy) :: f
         type(coordinates),intent(in) :: cx,cy
         integer,intent(in) :: component
         integer :: i,j
         real(cp) :: wavenum
         real(cp),dimension(:),allocatable :: x,y
         if (sx.lt.1) stop 'Error: sx < 1 in isolatedEddy2D in profile_funcs.f90'
         if (sy.lt.1) stop 'Error: sy < 1 in isolatedEddy2D in profile_funcs.f90'
         allocate(x(sx)); allocate(y(sy))
             if (sx.eq.cx%sn) then; x = cx%hn%f
         elseif (sx.eq.cx%sc) then; x = cx%hc%f
           else; stop 'Error: bad size in isolatedEddy2D in profile_funcs.f90'
         endif
             if (sy.eq.cy%sn) then; y = cy%hn%f
         elseif (sy.eq.cy%sc) then; y = cy%hc%f
           else; stop 'Error: bad size in isolatedEddy2D in profile_funcs.f90'
         endif

         wavenum = 2.0_cp
         select case (component)
         case (1); do j=1,sy;do i=1,sx
                     f(i,j) =   cos(wavenum*PI*x(i)) * &
                                sin(wavenum*PI*y(j))
                   enddo;enddo
         case (2); do j=1,sy;do i=1,sx
                     f(i,j) = - sin(wavenum*PI*x(i)) * &
                                cos(wavenum*PI*y(j))
                   enddo;enddo
         case default; stop 'Error: bad component input in isolatedEddy2D in profile_funcs.f90'
         end select
         deallocate(x,y)
       end function

       ! subroutine isolatedEddy2D(u,v,g)
       !   ! From
       !   !      Weiss, N. O. The Expulsion of Magnetic Flux
       !   !      by Eddies. Proc. R. Soc. A Math. Phys. Eng.
       !   !      Sci. 293, 310–328 (1966).
       !   !
       !   ! Computes
       !   !           U = curl(psi)
       !   ! Where
       !   !           psi = (-1/(2 pi)) cos(2 pi x) cos(2 pi y)
       !   !           u = dpsi/dy
       !   !           v =-dpsi/dx
       !   !           w = 0
       !   ! Computes
       !   !       u = dpsi/dy =   cos(2 pi x) sin(2 pi y)
       !   !       v =-dpsi/dx = - sin(2 pi x) cos(2 pi y)
       !   implicit none
       !   real(cp),dimension(:,:),intent(inout) :: u,v
       !   type(grid),intent(in) :: g
       !   integer :: i,j
       !   integer,dimension(2) :: sx,sy
       !   real(cp) :: wavenum
       !   wavenum = 2.0_cp
       !   sx = shape(u); sy = shape(v)
       !   do j=1,sx(2);do i=1,sx(1)
       !        u(i,j) =   cos(wavenum*PI*g%c(1)%hn%f(i)) * &
       !                   sin(wavenum*PI*g%c(2)%hc%f(j))
       !   enddo;enddo
       !   do j=1,sy(2);do i=1,sy(1)
       !        v(i,j) = - sin(wavenum*PI*g%c(1)%hc%f(i)) * &
       !                   cos(wavenum*PI*g%c(2)%hn%f(j))
       !   enddo;enddo
       ! end subroutine

       subroutine singleEddy2D(u,v,g)
         ! From
         !      Weiss, N. O. The Expulsion of Magnetic Flux
         !      by Eddies. Proc. R. Soc. A Math. Phys. Eng.
         !      Sci. 293, 310–328 (1966).
         !
         ! Computes
         !           U = curl(psi)
         ! Where
         !           psi = (-1/pi) (1-4 y^2)^4 cos(pi x)
         !           u = dpsi/dy = (-1/pi) cos(pi x) 4 (1-4 y^2)^3(-8y)
         !                       = (32y/pi) cos(pi x) (1-4 y^2)^3
         !           v =-dpsi/dx = (1-4 y^2)^4 sin(pi x)
         !           w = 0
         ! Computes
         !       u = dpsi/dy =   (32y/pi) cos(pi x) (1-4 y^2)^3
         !       v =-dpsi/dx = - (1-4 y^2)^4 sin(pi x)
         implicit none
         real(cp),dimension(:,:),intent(inout) :: u,v
         type(grid),intent(in) :: g
         integer :: i,j
         integer,dimension(2) :: sx,sy
         real(cp) :: one,two,three,four
         one = 1.0_cp; two = 2.0_cp
         three = 3.0_cp; four = 4.0_cp
         sx = shape(u); sy = shape(v)
         do j=1,sx(2);do i=1,sx(1)
          u(i,j) = (32.0_cp*g%c(2)%hc%f(j)/PI)*((one-four*g%c(2)%hc%f(j)**two)**three) * &
          cos(PI*g%c(1)%hn%f(i))
         enddo;enddo
         do j=1,sy(2);do i=1,sy(1)
          v(i,j) = - ((one-four*g%c(2)%hn%f(j)**two)**four)*sin(PI*g%c(1)%hc%f(i))
         enddo;enddo
       end subroutine

       subroutine cylinder2D(u,v,g)
         ! From
         !      Moffatt
         !
         ! Computes
         !           U(r) = omega0*r
         ! for
         !           0 < r < r0
         !
         implicit none
         real(cp),dimension(:,:),intent(inout) :: u,v
         type(grid),intent(in) :: g
         integer :: i,j
         integer,dimension(2) :: sx,sy
         real(cp),dimension(3) :: hc
         real(cp) :: omega0,r0,two,r,theta
         two = 2.0_cp
         omega0 = 1.0_cp; r0 = 1.0_cp
         u = 0.0_cp; v = 0.0_cp

         sx = shape(u); sy = shape(v)
         hc = (/((g%c(i)%hmax+g%c(i)%hmin)/2.0_cp,i=1,3)/)

         do j=1,sx(2);do i=1,sx(1)
          r = sqrt((g%c(1)%hn%f(i)-hc(1))**two + (g%c(2)%hc%f(j)-hc(2))**two)
          theta = atan2(g%c(2)%hc%f(j),g%c(1)%hn%f(i))
          if (r.lt.r0) u(i,j) =-omega0*r*sin(theta)
         enddo;enddo
         do j=1,sy(2);do i=1,sy(1)
          r = sqrt((g%c(1)%hc%f(i)-hc(1))**two + (g%c(2)%hn%f(j)-hc(2))**two)
          theta = atan2(g%c(2)%hn%f(j),g%c(1)%hc%f(i))
          if (r.lt.r0) v(i,j) = omega0*r*cos(theta)
         enddo;enddo
       end subroutine

       ! subroutine vortex2D(U,g,s,dir,vsign,directory)
       !   implicit none
       !   type(VF),intent(inout) :: U
       !   type(grid),intent(in) :: g
       !   integer,dimension(3),intent(in) :: s
       !   integer,intent(in) :: dir,vsign
       !   character(len=*),intent(in) :: directory
       !   integer :: Nx,Ny,Nz
       !   integer :: i,j,k
       !   ! Vortex variables
       !   real(cp) :: omega0,r,alpha,r0
       !   type(scalarField) :: omega,psi
       !   type(BCs) :: psi_bcs
       !   type(solverSettings) :: ss_psi
       !   type(VF) :: tempVF,temp
       !   type(norms) :: norm
       !   type(mySOR) :: SOR
       !   real(cp) :: two,one
       !   integer,dimension(2) :: d
       !   two = 2.0_cp; one = 1.0_cp
       !   d = orthogonalDirections(dir)
       !   call setAllZero(psi_bcs,s,5)
       !   call checkBCs(psi_bcs)
       !   call writeAllBoundaries(psi_bcs,directory//'parameters/','psi')
       !   omega0 = 1000.0
       !   alpha = 10000.0
       !   call init(omega,s)
       !   do k = 1,s(3)
       !     do j = 1,s(2)
       !       do i = 1,s(1)
       !         r0 = sqrt( (g%c(d(1))%hmax-g%c(d(1))%hmin)**two + &
       !                    (g%c(d(2))%hmax-g%c(d(2))%hmin)**two )
       !         r = sqrt( g%c(d(1))%hc%f(i)**two + &
       !                   g%c(d(2))%hc%f(j)**two )/r0
       !         omega(i,j,k) = omega0*(one - r**two)*exp(-alpha*r**two)
       !       enddo
       !     enddo
       !   enddo
       !   call init(psi,s)
       !   call init(ss_psi)
       !   call setMaxIterations(ss_psi,100)
       !   call poisson(SOR,psi%phi,omega%phi,psi_bcs,g,ss_psi,norm,.true.)
       !   call writeToFile(g,omega,directory//'Ufield/','omega')
       !   call writeToFile(g,psi,directory//'Ufield/','psi')
       !   call delete(omega)
       !   call allocateX(tempVF,g%c(1)%sc,g%c(2)%sn,g%c(3)%sn)
       !   call allocateY(tempVF,g%c(1)%sn,g%c(2)%sc,g%c(3)%sn)
       !   call allocateZ(tempVF,g%c(1)%sn,g%c(2)%sn,g%c(3)%sc)
       !   call curl(U,tempVF,g)
       !   call delete(psi)
       !   call delete(tempVF)
       ! end subroutine


       ! subroutine initVortex(u,v,w,g,vdir,vsign,dir)
       !   implicit none
       !   real(cp),dimension(:,:,:),intent(inout) :: u,v,w
       !   type(grid),intent(in) :: g
       !   integer,intent(in) :: vdir,vsign
       !   character(len=*),intent(in) :: dir
       !   integer :: Nx,Ny,Nz
       !   real(cp) :: x_0,x_N
       !   real(cp) :: y_0,y_N
       !   real(cp) :: z_0,z_N
       !   integer :: i,j,k
       !   real(cp),dimension(:),allocatable :: xn,yn,zn
       !   real(cp),dimension(:),allocatable :: xc,yc,zc
       !   ! Vortex variables
       !   real(cp) :: omega0,r,alpha,r0
       !   real(cp),dimension(:,:,:),allocatable :: omega,psi
       !   type(BCs) :: psi_bcs
       !   type(solverSettings) :: ss_psi
       !   real(cp),dimension(:,:,:),allocatable :: tempx,tempy,tempz,temp
       !   type(myError) :: err
       !   real(cp),dimension(3) :: hmin,hmax
       !   type(mySOR) :: SOR
       !   hmin = (/g%c(1)%hmin,g%c(2)%hmin,g%c(3)%hmin/)
       !   hmax = (/g%c(1)%hmax,g%c(2)%hmax,g%c(3)%hmax/)
       !   x_0 = g%c(1)%hmin; y_0 = g%c(2)%hmin; z_0 = g%c(3)%hmin
       !   x_N = g%c(1)%hmax; y_N = g%c(2)%hmax; z_N = g%c(3)%hmax
       !   allocate(xc(g%c(1)%sc),yc(g%c(2)%sc),zc(g%c(3)%sc))
       !   allocate(xn(g%c(1)%sn),yn(g%c(2)%sn),zn(g%c(3)%sn))
       !   xc = g%c(1)%hc%f; yc = g%c(2)%hc%f; zc = g%c(3)%hc%f
       !   xn = g%c(1)%hn%f; yn = g%c(2)%hn%f; zn = g%c(3)%hn%f
       !   call setAllZero(psi_bcs,Nx+2,Ny+2,Nz+2,5)
       !   call checkBCs(psi_bcs)
       !   call writeAllBoundaries(psi_bcs,dir//'parameters/','psi')
       !   omega0 = 1000.0
       !   alpha = 10000.0
       !   allocate(omega(Nx+2,Ny+2,Nz+2))
       !   do i=1,Nx+2
       !     do j = 1,Ny+2
       !       do k = 1,Nz+2
       !          r0 = sqrt( (x_N-x_0)**2.0 + (y_N-y_0)**2.0 + (z_N-z_0)**2.0 )
       !          r = sqrt( xc(i)**2.0 + yc(j)**2.0 + zc(k)**2.0 )/r0
       !          omega(i,j,k) = omega0*(1.0 - r**2.0)*exp(-alpha*r**2.0)
       !       enddo
       !     enddo
       !   enddo
       !   allocate(psi(Nx+2,Ny+2,Nz+2))
       !   call init(ss_psi)
       !   call setMaxIterations(ss_psi,100)
       !   omega = -omega
       !   call myPoisson(SOR,psi,omega,psi_bcs,g,ss_psi,err,1,.true.)
       !   call writeToFile(xc,yc,zc,omega,dir//'Ufield/','omega')
       !   call writeToFile(xc,yc,zc,psi,dir//'Ufield/','psi')
       !   deallocate(omega)
       !   allocate(tempx(Nx+2,Ny+2,Nz+2))
       !   allocate(tempy(Nx+2,Ny+2,Nz+2))
       !   allocate(tempz(Nx+2,Ny+2,Nz+2))
       !   allocate( temp(Nx+2,Ny+2,Nz+2))
       !   call myCC2FaceGrad(tempx,tempy,tempz,psi,g)
       !   call myFace2CellCenter(temp,tempy(:,1:Ny+1,:),g,2)
       !   call myCellCenter2Face(u,temp,g,1)
       !   call myFace2CellCenter(temp,tempx(1:Nx+1,:,:),g,1)
       !   call myCellCenter2Face(v,temp,g,2)
       !   v = -v
       !   deallocate(psi)
       !   w = 0.0_cp
       !   deallocate(tempx,tempy,tempz,temp)
       !   deallocate(xn,yn,zn)
       !   deallocate(xc,yc,zc)
       ! end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module single_procedure_mod
       use apply_face_BC_op_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: single_procedure
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_single_procedure;              end interface
       interface delete;                 module procedure delete_single_procedure;                 end interface
       interface display;                module procedure display_single_procedure;                end interface
       interface display_short;          module procedure display_short_single_procedure;          end interface
       interface display;                module procedure display_wrap_single_procedure;           end interface
       interface print;                  module procedure print_single_procedure;                  end interface
       interface print_short;            module procedure print_short_single_procedure;            end interface
       interface export;                 module procedure export_single_procedure;                 end interface
       interface export_primitives;      module procedure export_primitives_single_procedure;      end interface
       interface import;                 module procedure import_single_procedure;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_single_procedure;end interface
       interface export_structured;      module procedure export_structured_D_single_procedure;    end interface
       interface import_structured;      module procedure import_structured_D_single_procedure;    end interface
       interface import_primitives;      module procedure import_primitives_single_procedure;      end interface
       interface export;                 module procedure export_wrap_single_procedure;            end interface
       interface import;                 module procedure import_wrap_single_procedure;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_single_procedure;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_single_procedure;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_single_procedure;      end interface

       type single_procedure
         procedure(apply_face_BC_op),pointer,nopass :: P
         logical :: defined = .false.
         integer :: ID = 0
       end type

       contains

       subroutine init_copy_single_procedure(this,that)
         implicit none
         type(single_procedure),intent(inout) :: this
         type(single_procedure),intent(in) :: that
         call delete(this)
         this%P => that%P
         this%defined = that%defined
         this%ID = that%ID
       end subroutine

       subroutine delete_single_procedure(this)
         implicit none
         type(single_procedure),intent(inout) :: this
         nullify(this%P)
         this%defined = .false.
         this%ID = 0
       end subroutine

       subroutine display_single_procedure(this,un)
         implicit none
         type(single_procedure),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined = ',this%defined
         write(un,*) 'ID      = ',this%ID
       end subroutine

       subroutine display_short_single_procedure(this,un)
         implicit none
         type(single_procedure),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined = ',this%defined
         write(un,*) 'ID      = ',this%ID
       end subroutine

       subroutine display_wrap_single_procedure(this,dir,name)
         implicit none
         type(single_procedure),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_single_procedure(this)
         implicit none
         type(single_procedure),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_single_procedure(this)
         implicit none
         type(single_procedure),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_single_procedure(this,un)
         implicit none
         type(single_procedure),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
       end subroutine

       subroutine import_single_procedure(this,un)
         implicit none
         type(single_procedure),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
       end subroutine

       subroutine export_primitives_single_procedure(this,un)
         implicit none
         type(single_procedure),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined  = ';write(un,*) this%defined
         write(un,*) 'ID       = ';write(un,*) this%ID
       end subroutine

       subroutine import_primitives_single_procedure(this,un)
         implicit none
         type(single_procedure),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%defined
         read(un,*); read(un,*) this%ID
       end subroutine

       subroutine export_wrap_single_procedure(this,dir,name)
         implicit none
         type(single_procedure),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_single_procedure(this,dir,name)
         implicit none
         type(single_procedure),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_single_procedure(this,dir)
         implicit none
         type(single_procedure),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         if (.false.) then
           write(*,*) dir
         endif
       end subroutine

       subroutine make_IO_dir_single_procedure(this,dir)
         implicit none
         type(single_procedure),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
       end subroutine

       subroutine export_folder_structure_single_procedure(this,dir)
         implicit none
         type(single_procedure),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
       end subroutine

       subroutine export_structured_D_single_procedure(this,dir)
         implicit none
         type(single_procedure),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         close(un)
       end subroutine

       subroutine import_structured_D_single_procedure(this,dir)
         implicit none
         type(single_procedure),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         close(un)
       end subroutine

       subroutine suppress_warnings_single_procedure(this)
         implicit none
         type(single_procedure),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module sub_domain_extend_mod
       use sub_domain_mod
       use current_precision_mod
       use overlap_mod
       use overlap_extend_mod
       use grid_mod
       use data_location_extend_mod
       use face_edge_corner_indexing_mod
       use coordinates_mod

       implicit none

       private
       public :: init,display,print ! Essentials

       ! public::init               ! call init(SD,g_R1,g_R2,tol,p)
       public :: define_C           ! call define_C(OL_inout,g1,g2,dir,p)
       public :: define_N           ! call define_N(OL_inout,g1,g2,dir,p)
       public :: p_from_boundary_C  ! call p_from_boundary_C(OL_out,OL_in,g1,g2,dir,p)
       public :: p_from_boundary_N  ! call p_from_boundary_N(OL_out,OL_in,g1,g2,dir,p)
       public :: get_dh_boundary    ! call get_dh_boundary(g1,g2,dir)
       public :: init_mixed

       interface init;            module procedure init_sub_domain;              end interface
       interface display;         module procedure display_sub_domain;           end interface
       interface print;           module procedure print_sub_domain;             end interface

       interface init_mixed;      module procedure init_mixed_sub_domain;        end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_sub_domain(SD,g_R1,g_R2,g_R1_id,g_R2_id,tol,p)
         implicit none
         type(sub_domain),intent(inout) :: SD
         type(grid),intent(in) :: g_R1,g_R2
         integer,intent(in) :: g_R1_id,g_R2_id,p
         real(cp),intent(in) :: tol
         integer :: i
         logical,dimension(3) :: L
         call delete(SD)
         do i=1,3; L(i) = is_overlap(g_R1%c(i),g_R2%c(i),tol); enddo
         SD%defined = all(L)
         if (SD%defined) then
           do i=1,3; call define_C(SD%C(i),g_R1,g_R2,i,tol,p); enddo
           do i=1,3; call define_N(SD%N(i),g_R1,g_R2,i,tol,p); enddo
           SD%g_R1_id = g_R1_id
           SD%g_R2_id = g_R2_id
         endif
       end subroutine

       subroutine display_sub_domain(SD,name,u)
         implicit none
         type(sub_domain),intent(in) :: SD
         character(len=*),intent(in) :: name
         integer,intent(in) :: u
         write(u,*) ' ---------- sub_domain ---------- '//name
         write(u,*) 'defined,g_R1_id,g_R2_id = ',SD%defined,SD%g_R1_id,SD%g_R2_id
         write(u,*) ''
         write(u,*) 'C:'
         call display(SD%C,u)
         write(u,*) 'N:'
         call display(SD%N,u)
         write(u,*) 'M:'
         call display(SD%M,u)
         write(u,*) ' -------------------------------- '
       end subroutine

       subroutine print_sub_domain(SD,name)
         implicit none
         type(sub_domain),intent(in) :: SD
         character(len=*),intent(in) :: name
         call display(SD,name,6)
       end subroutine

       ! **********************************************************
       ! **********************************************************
       ! **********************************************************

       subroutine define_C(OL_inout,g1,g2,dir,tol,p)
         implicit none
         type(overlap),intent(inout) :: OL_inout
         type(grid),intent(in) :: g1,g2
         integer,intent(in) :: dir,p
         real(cp),intent(in) :: tol
         call init(OL_inout,get_C_overlap((/g1%c(dir),g2%c(dir)/),tol,p))
       end subroutine

       subroutine define_N(OL_inout,g1,g2,dir,tol,p)
         implicit none
         type(overlap),intent(inout) :: OL_inout
         type(grid),intent(in) :: g1,g2
         integer,intent(in) :: dir,p
         real(cp),intent(in) :: tol
         call init(OL_inout,get_N_overlap((/g1%c(dir),g2%c(dir)/),tol,p))
       end subroutine

       subroutine p_from_boundary_C(OL_out,OL_in,g1,g2,dir,tol,p)
         implicit none
         type(overlap),intent(inout) :: OL_out
         type(overlap),intent(in) :: OL_in
         type(grid),intent(in) :: g1,g2
         integer,intent(in) :: dir,p
         real(cp),intent(in) :: tol
         call init(OL_out,get_p_from_boundary_C(OL_in,(/g1%c(dir),g2%c(dir)/),tol,p))
       end subroutine

       subroutine p_from_boundary_N(OL_out,OL_in,g1,g2,dir,tol,p)
         implicit none
         type(overlap),intent(inout) :: OL_out
         type(overlap),intent(in) :: OL_in
         type(grid),intent(in) :: g1,g2
         integer,intent(in) :: dir,p
         real(cp),intent(in) :: tol
         call init(OL_out,get_p_from_boundary_N(OL_in,(/g1%c(dir),g2%c(dir)/),tol,p))
       end subroutine

       ! *********************************************************************
       ! *************************** BOUNDARY dh *****************************
       ! *********************************************************************

       function get_dh_boundary(g,dir) result(dh)
         implicit none
         type(grid),dimension(2),intent(in) :: g
         integer,intent(in) :: dir
         real(cp) :: dh
             if (g(1)%c(dir)%sn.eq.3) then; dh = g(1)%c(dir)%dhn%f(1)
         elseif (g(2)%c(dir)%sn.eq.3) then; dh = g(2)%c(dir)%dhn%f(1)
         else; dh = 0.0_cp
         endif
       end function

       subroutine init_mixed_sub_domain(M,C,N,DL)
         implicit none
         type(overlap),dimension(3),intent(inout) :: M
         type(data_location),intent(in) :: DL
         type(overlap),dimension(3),intent(in) :: C,N
         integer :: i
         if (is_Face(DL)) then
          do i=1,3; call init(M(i),C(i)); enddo
          call init(M(get_Face(DL)),N(get_Face(DL)))
         elseif (is_Edge(DL)) then
          do i=1,3; call init(M(i),N(i)); enddo
          call init(M(get_Edge(DL)),C(get_Edge(DL)))
         elseif (is_CC(DL)) then
          do i=1,3; call init(M(i),C(i)); enddo
         elseif (is_Node(DL)) then
          do i=1,3; call init(M(i),N(i)); enddo
         else; stop 'Error: no type found in init_props_physical_overlap in physical_overlap.f90'
         endif
       end subroutine

       end module
       module time_statistics_params_extend_mod
       use time_statistics_params_mod
       use current_precision_mod
       use stats_period_mod
       use stats_period_extend_mod
       use time_marching_params_mod

       implicit none
       private

       public :: time_statistics_params
       public :: init
       public :: update

       interface init;    module procedure init_TSP;      end interface
       interface update;  module procedure update_TSP;    end interface

       contains

       subroutine init_TSP(TSP,collect,t_start,t_stop)
         implicit none
         type(time_statistics_params),intent(inout) :: TSP
         logical,intent(in) :: collect
         real(cp),intent(in) :: t_start,t_stop
         call delete(TSP)
         TSP%collect = collect
         call init(TSP%O1_stats,t_start,t_stop)
         call init(TSP%O2_stats,t_stop,t_stop+TSP%O1_stats%period)
       end subroutine

       subroutine update_TSP(TSP,TMP)
         implicit none
         type(time_statistics_params),intent(inout) :: TSP
         type(time_marching_params),intent(in) :: TMP
         call update(TSP%O1_stats,TMP)
         call update(TSP%O2_stats,TMP)
       end subroutine

       end module
       module var_extend_mod
       use var_mod
       implicit none

       private
       public :: init_IC_BC
       public :: print_info

       interface init_IC_BC;  module procedure init_IC_BC_V;  end interface
       interface print_info;  module procedure print_info_V;  end interface
       interface display_info;module procedure display_info_V;end interface

       contains

       subroutine init_IC_BC_V(V,IC,BC)
         implicit none
         type(var),intent(inout) :: V
         integer,intent(in) :: IC,BC
         V%IC = IC
         V%BC = BC
       end subroutine

       subroutine display_info_V(V,un)
         implicit none
         type(var),intent(in) :: V
         integer,intent(in) :: un
         write(un,*) 'solve_method = ',V%SS%solve_method
         write(un,*) 'alpha        = ',V%MFP%alpha
         write(un,*) 'dt           = ',V%TMP%TS%dt
         write(un,*) 't            = ',V%TMP%t
         write(un,*) 'tol_rel      = ',V%ISP%EC%tol_rel
         write(un,*) 'tol_abs      = ',V%ISP%EC%tol_abs
         write(un,*) 'iter_max     = ',V%ISP%EC%iter_max
       end subroutine

       subroutine print_info_V(V)
         implicit none
         type(var),intent(in) :: V
         call display_info(V,6)
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module var_set_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use var_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: var_set
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_var_set;              end interface
       interface delete;                 module procedure delete_var_set;                 end interface
       interface display;                module procedure display_var_set;                end interface
       interface display_short;          module procedure display_short_var_set;          end interface
       interface display;                module procedure display_wrap_var_set;           end interface
       interface print;                  module procedure print_var_set;                  end interface
       interface print_short;            module procedure print_short_var_set;            end interface
       interface export;                 module procedure export_var_set;                 end interface
       interface export_primitives;      module procedure export_primitives_var_set;      end interface
       interface import;                 module procedure import_var_set;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_var_set;end interface
       interface export_structured;      module procedure export_structured_D_var_set;    end interface
       interface import_structured;      module procedure import_structured_D_var_set;    end interface
       interface import_primitives;      module procedure import_primitives_var_set;      end interface
       interface export;                 module procedure export_wrap_var_set;            end interface
       interface import;                 module procedure import_wrap_var_set;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_var_set;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_var_set;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_var_set;      end interface

       type var_set
         type(var) :: T
         type(var) :: U
         type(var) :: p
         type(var) :: B
         type(var) :: jCrossB
         type(var) :: stresses
         type(var) :: B0
         type(var) :: phi
         type(var) :: rho
       end type

       contains

       subroutine init_copy_var_set(this,that)
         implicit none
         type(var_set),intent(inout) :: this
         type(var_set),intent(in) :: that
         call delete(this)
         call init(this%T,that%T)
         call init(this%U,that%U)
         call init(this%p,that%p)
         call init(this%B,that%B)
         call init(this%jCrossB,that%jCrossB)
         call init(this%stresses,that%stresses)
         call init(this%B0,that%B0)
         call init(this%phi,that%phi)
         call init(this%rho,that%rho)
       end subroutine

       subroutine delete_var_set(this)
         implicit none
         type(var_set),intent(inout) :: this
         call delete(this%T)
         call delete(this%U)
         call delete(this%p)
         call delete(this%B)
         call delete(this%jCrossB)
         call delete(this%stresses)
         call delete(this%B0)
         call delete(this%phi)
         call delete(this%rho)
       end subroutine

       subroutine display_var_set(this,un)
         implicit none
         type(var_set),intent(in) :: this
         integer,intent(in) :: un
         call display(this%T,un)
         call display(this%U,un)
         call display(this%p,un)
         call display(this%B,un)
         call display(this%jCrossB,un)
         call display(this%stresses,un)
         call display(this%B0,un)
         call display(this%phi,un)
         call display(this%rho,un)
       end subroutine

       subroutine display_short_var_set(this,un)
         implicit none
         type(var_set),intent(in) :: this
         integer,intent(in) :: un
         call display(this%T,un)
         call display(this%U,un)
         call display(this%p,un)
         call display(this%B,un)
         call display(this%jCrossB,un)
         call display(this%stresses,un)
         call display(this%B0,un)
         call display(this%phi,un)
         call display(this%rho,un)
       end subroutine

       subroutine display_wrap_var_set(this,dir,name)
         implicit none
         type(var_set),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_var_set(this)
         implicit none
         type(var_set),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_var_set(this)
         implicit none
         type(var_set),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_var_set(this,un)
         implicit none
         type(var_set),intent(in) :: this
         integer,intent(in) :: un
         call export(this%T,un)
         call export(this%U,un)
         call export(this%p,un)
         call export(this%B,un)
         call export(this%jCrossB,un)
         call export(this%stresses,un)
         call export(this%B0,un)
         call export(this%phi,un)
         call export(this%rho,un)
       end subroutine

       subroutine import_var_set(this,un)
         implicit none
         type(var_set),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%T,un)
         call import(this%U,un)
         call import(this%p,un)
         call import(this%B,un)
         call import(this%jCrossB,un)
         call import(this%stresses,un)
         call import(this%B0,un)
         call import(this%phi,un)
         call import(this%rho,un)
       end subroutine

       subroutine export_primitives_var_set(this,un)
         implicit none
         type(var_set),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_var_set(this,un)
         implicit none
         type(var_set),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_var_set(this,dir,name)
         implicit none
         type(var_set),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_var_set(this,dir,name)
         implicit none
         type(var_set),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_var_set(this,dir)
         implicit none
         type(var_set),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%T,dir//'T'//fortran_PS)
         call set_IO_dir(this%U,dir//'U'//fortran_PS)
         call set_IO_dir(this%p,dir//'p'//fortran_PS)
         call set_IO_dir(this%B,dir//'B'//fortran_PS)
         call set_IO_dir(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call set_IO_dir(this%stresses,dir//'stresses'//fortran_PS)
         call set_IO_dir(this%B0,dir//'B0'//fortran_PS)
         call set_IO_dir(this%phi,dir//'phi'//fortran_PS)
         call set_IO_dir(this%rho,dir//'rho'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_var_set(this,dir)
         implicit none
         type(var_set),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%T,dir//'T'//fortran_PS)
         call make_IO_dir(this%U,dir//'U'//fortran_PS)
         call make_IO_dir(this%p,dir//'p'//fortran_PS)
         call make_IO_dir(this%B,dir//'B'//fortran_PS)
         call make_IO_dir(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call make_IO_dir(this%stresses,dir//'stresses'//fortran_PS)
         call make_IO_dir(this%B0,dir//'B0'//fortran_PS)
         call make_IO_dir(this%phi,dir//'phi'//fortran_PS)
         call make_IO_dir(this%rho,dir//'rho'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_var_set(this,dir)
         implicit none
         type(var_set),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%T,dir//'T'//fortran_PS)
         call export_structured(this%U,dir//'U'//fortran_PS)
         call export_structured(this%p,dir//'p'//fortran_PS)
         call export_structured(this%B,dir//'B'//fortran_PS)
         call export_structured(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call export_structured(this%stresses,dir//'stresses'//fortran_PS)
         call export_structured(this%B0,dir//'B0'//fortran_PS)
         call export_structured(this%phi,dir//'phi'//fortran_PS)
         call export_structured(this%rho,dir//'rho'//fortran_PS)
       end subroutine

       subroutine export_structured_D_var_set(this,dir)
         implicit none
         type(var_set),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%T,dir//'T'//fortran_PS)
         call export_structured(this%U,dir//'U'//fortran_PS)
         call export_structured(this%p,dir//'p'//fortran_PS)
         call export_structured(this%B,dir//'B'//fortran_PS)
         call export_structured(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call export_structured(this%stresses,dir//'stresses'//fortran_PS)
         call export_structured(this%B0,dir//'B0'//fortran_PS)
         call export_structured(this%phi,dir//'phi'//fortran_PS)
         call export_structured(this%rho,dir//'rho'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_var_set(this,dir)
         implicit none
         type(var_set),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%T,dir//'T'//fortran_PS)
         call import_structured(this%U,dir//'U'//fortran_PS)
         call import_structured(this%p,dir//'p'//fortran_PS)
         call import_structured(this%B,dir//'B'//fortran_PS)
         call import_structured(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call import_structured(this%stresses,dir//'stresses'//fortran_PS)
         call import_structured(this%B0,dir//'B0'//fortran_PS)
         call import_structured(this%phi,dir//'phi'//fortran_PS)
         call import_structured(this%rho,dir//'rho'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_var_set(this)
         implicit none
         type(var_set),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module GF_plane_mean_mod
        use current_precision_mod
        use grid_field_mod
        use GF_plane_sum_mod
        use grid_mod
        implicit none

        private
        public :: plane_mean_x
        public :: plane_mean_y
        public :: plane_mean_z
        interface plane_mean_x;    module procedure plane_mean_x_GF;            end interface
        interface plane_mean_y;    module procedure plane_mean_y_GF;            end interface
        interface plane_mean_z;    module procedure plane_mean_z_GF;            end interface
        interface plane_mean_x;    module procedure plane_mean_x_no_weights_GF; end interface
        interface plane_mean_y;    module procedure plane_mean_y_no_weights_GF; end interface
        interface plane_mean_z;    module procedure plane_mean_z_no_weights_GF; end interface

        contains

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        function plane_mean_x_GF(U,g,p) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          type(grid),intent(in) :: g
          integer,intent(in) :: p
          real(cp) :: F
          F = plane_sum_x(U,g,p,1.0_cp)/g%c(1)%maxRange
        end function

        function plane_mean_x_no_weights_GF(U,p) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          integer,intent(in) :: p
          real(cp) :: F
          F = plane_sum_x(U,p,1.0_cp)/real(U%s(1),cp)
        end function

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        function plane_mean_y_GF(U,g,p) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          type(grid),intent(in) :: g
          integer,intent(in) :: p
          real(cp) :: F
          F = plane_sum_y(U,g,p,1.0_cp)/g%c(2)%maxRange
        end function

        function plane_mean_y_no_weights_GF(U,p) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          integer,intent(in) :: p
          real(cp) :: F
          F = plane_sum_y(U,p,1.0_cp)/real(U%s(2),cp)
        end function

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        function plane_mean_z_GF(U,g,p) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          type(grid),intent(in) :: g
          integer,intent(in) :: p
          real(cp) :: F
          F = plane_sum_z(U,g,p,1.0_cp)/g%c(3)%maxRange
        end function

        function plane_mean_z_no_weights_GF(U,p) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          integer,intent(in) :: p
          real(cp) :: F
          F = plane_sum_z(U,p,1.0_cp)/real(U%s(3),cp)
        end function

      end module
       module face_SD_extend_mod
       use face_SD_mod
       use current_precision_mod
       use index_2D_mod
       use overlap_mod
       use overlap_extend_mod
       use grid_mod
       use datatype_conversion_mod
       use sub_domain_mod
       use sub_domain_extend_mod
       use face_edge_corner_indexing_mod
       use data_location_extend_mod
       use coordinates_mod

       implicit none

       private
       public :: face_SD
       public :: init,display,print ! Essentials

       public :: init_mixed
       public :: init_Robin_coeff

       interface init;             module procedure init_face_SD;        end interface
       interface display;          module procedure display_face_SD;     end interface
       interface print;            module procedure print_face_SD;       end interface

       interface init_mixed;       module procedure init_mixed_face_SD;  end interface
       interface init_Robin_coeff; module procedure init_Robin_coeff_SD; end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_face_SD(FSD,g,g_b)
         implicit none
         type(face_SD),intent(inout) :: FSD
         type(grid),intent(in) :: g
         type(grid),dimension(6),intent(in) :: g_b
         type(sub_domain) :: temp
         real(cp) :: tol
         integer :: i,dir,i_opp
         logical :: many_cell
         tol = 10.0_cp**(-12.0_cp)
         call delete(FSD)
         do i=1,6
           dir = dir_given_face(i)
           call init(temp,g_b(i),g,i,0,tol,0)
           call init(FSD%G(i),temp)
           call init(FSD%B(i),temp)
           call init(FSD%I(i),temp)
           call init(FSD%I_OPP(i),temp)
           call init(FSD%G_periodic_N(i),temp)
           call init(FSD%I_OPP_periodic_N(i),temp)
           call p_from_boundary_C(FSD%G(i)%C(dir),temp%C(dir),g,g_b(i),dir,tol,1)
           call p_from_boundary_C(FSD%I(i)%C(dir),temp%C(dir),g,g_b(i),dir,tol,2)

           call p_from_boundary_N(FSD%G(i)%N(dir),temp%N(dir),g,g_b(i),dir,tol,1)
           call p_from_boundary_N(FSD%B(i)%N(dir),temp%N(dir),g,g_b(i),dir,tol,2)
           call p_from_boundary_N(FSD%I(i)%N(dir),temp%N(dir),g,g_b(i),dir,tol,3)
           FSD%dh(i) = get_dh_boundary((/g,g_b(i)/),dir)
           FSD%nhat(i) = nhat_given_face(i)
           FSD%i_2D(i)%i = adj_dir_given_face(i)
         enddo

         do i=1,6
           i_opp = opp_face_given_face(i)
           call init(FSD%I_OPP(i_opp),FSD%I(i))
         enddo
         do i=1,6
           call init(FSD%I_OPP_periodic_N(i),FSD%I_OPP(i))
           call init(FSD%G_periodic_N(i),FSD%G(i))
         enddo

         ! For Periodic BCs, node points must be truncated by 1,
         ! to solve the system correctly. If there's a single
         ! interior cell (not multicell), however, then periodic
         ! BCs should be symmetric and simply enforce no changes
         ! along the single interior cell.
         do i=1,6
           i_opp = opp_face_given_face(i)
           dir = dir_given_face(i)
           many_cell = g%c(dir)%sn.gt.4
           if (max_face(i).and.many_cell) call init(FSD%G_periodic_N(i),FSD%B(i))
           if (max_face(i).and.many_cell) call init(FSD%I_OPP_periodic_N(i),FSD%B(i_opp))
         enddo
         call delete(temp)
       end subroutine

       subroutine display_face_SD(FSD,name,u)
         implicit none
         type(face_SD),intent(in) :: FSD
         character(len=*),intent(in) :: name
         integer,intent(in) :: u
         integer :: i
         write(u,*) ' ************************* face_SD ************************* '//name
         do i=1,6; call display(FSD%G(i),'G face '//int2str(i),u); enddo
         do i=1,6; call display(FSD%B(i),'B face '//int2str(i),u); enddo
         do i=1,6; call display(FSD%I(i),'I face '//int2str(i),u); enddo
         do i=1,6; call display(FSD%G_periodic_N(i),'G_periodic_N face '//int2str(i),u); enddo
         do i=1,6; call display(FSD%I_OPP(i),'I_OPP face '//int2str(i),u); enddo
         do i=1,6; call display(FSD%I_OPP_periodic_N(i),'I_OPP_periodic_N face '//int2str(i),u); enddo
         write(u,*) 'dh = ',FSD%dh
         write(u,*) 'nhat = ',FSD%nhat
         write(u,*) 'Robin_coeff = ',FSD%Robin_coeff
         write(u,*) 'c_w = ',FSD%c_w
         do i=1,6; write(u,*) 'i_2D = '; write(u,*) FSD%i_2D(i)%i; enddo
         write(u,*) ' *********************************************************** '
       end subroutine

       subroutine print_face_SD(FSD,name)
         implicit none
         type(face_SD),intent(in) :: FSD
         character(len=*),intent(in) :: name
         call display(FSD,name,6)
       end subroutine

       subroutine init_mixed_face_SD(FSD,DL)
         implicit none
         type(face_SD),intent(inout) :: FSD
         type(data_location),intent(in) :: DL
         integer :: i
         do i=1,6; call init_mixed(FSD%G(i)%M,FSD%G(i)%C,FSD%G(i)%N,DL); enddo
         do i=1,6; call init_mixed(FSD%B(i)%M,FSD%B(i)%C,FSD%B(i)%N,DL); enddo
         do i=1,6; call init_mixed(FSD%I(i)%M,FSD%I(i)%C,FSD%I(i)%N,DL); enddo
         do i=1,6; call init_mixed(FSD%I_OPP(i)%M,FSD%I_OPP(i)%C,FSD%I_OPP(i)%N,DL); enddo
         do i=1,6; call init_mixed(FSD%G_periodic_N(i)%M,&
          FSD%G_periodic_N(i)%C,FSD%G_periodic_N(i)%N,DL); enddo

         do i=1,6; call init_mixed(FSD%I_OPP_periodic_N(i)%M,&
          FSD%I_OPP_periodic_N(i)%C,FSD%I_OPP_periodic_N(i)%N,DL); enddo
       end subroutine

       subroutine init_Robin_coeff_SD(FSD,c_w,Robin_coeff)
         implicit none
         type(face_SD),intent(inout) :: FSD
         real(cp),dimension(6),intent(in) :: c_w,Robin_coeff
         FSD%c_w = c_w
         FSD%Robin_coeff = Robin_coeff
       end subroutine

       end module
       module grid_connect_mod
       use current_precision_mod
       use array_mod
       use array_extend_mod
       use coordinates_mod
       use coordinates_extend_mod
       use grid_mod
       use mesh_quality_params_mod
       use coordinate_distribution_funcs_mod
       use coordinate_distribution_funcs_iterate_mod
       use coordinate_stretch_param_match_mod
       implicit none

       private

       public :: con_prep_uniform      ! con_prep_uniform(g,g_in,N,dir)
       public :: con_prep_Roberts_L    ! con_prep_Roberts_L(g,g_in,L,N,dir)
       public :: con_prep_Roberts_R    ! con_prep_Roberts_R(g,g_in,L,N,dir)
       public :: con_prep_Roberts_B    ! con_prep_Roberts_B(g,g_in,L,N,dir)
       ! public :: con_prep_cluster      ! Not yet implemented

       public :: con_app_uniform       ! con_app_uniform(g,g_in,N,dir)
       public :: con_app_Roberts_L     ! con_app_Roberts_L(g,g_in,L,N,dir)
       public :: con_app_Roberts_R     ! con_app_Roberts_R(g,g_in,L,N,dir)
       public :: con_app_Roberts_B     ! con_app_Roberts_B(g,g_in,L,N,dir)
       ! public :: con_app_cluster       ! Not yet implemented

       contains

       subroutine process(g,a,dir)
         implicit none
         type(grid),intent(inout) :: g
         type(array),intent(inout) :: a
         integer,intent(in) :: dir
         call init(g%c(dir),a)
         call add_ghost_nodes(g%c(dir))
         call delete(a)
       end subroutine

       ! ******************************************************************** Prepend

       subroutine con_prep_uniform(g,g_in,N,dir)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         integer,intent(in) :: N,dir
         type(array) :: a
         real(cp) :: dh
         call check_N(N,'con_prep_uniform')
         call init(g,g_in)
         dh = g%c(dir)%dhn%f(1)
         call init(a,uniformLeft(g_in%c(dir)%hmin,dh,N))
         call process(g,a,dir)
       end subroutine

       subroutine con_prep_Roberts_L(g,g_in,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         type(mesh_quality_params),intent(in) :: MQP
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         real(cp) :: beta,hmin
         type(array) :: a
         integer :: i,N_final
         call check_N(N,'con_prep_Roberts_L')
         call init(g,g_in)
         N_final = N
         hmin = g_in%c(dir)%hmin
         do i=1,MQP%N_iter
           beta = beta_dh_small(hmin - L,hmin,N_final,g_in%c(dir)%dhn%f(1))
           call init(a,robertsLeft(hmin-L,hmin,N_final,beta))
           N_final = a%N
           if (needs_more_points(a,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process(g,a,dir)
       end subroutine

       subroutine con_prep_Roberts_R(g,g_in,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         type(mesh_quality_params),intent(in) :: MQP
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         real(cp) :: beta,hmin
         type(array) :: a
         integer :: i,N_final
         call check_N(N,'con_prep_Roberts_R')
         call init(g,g_in)
         N_final = N
         hmin = g_in%c(dir)%hmin
         do i=1,MQP%N_iter
           beta = beta_dh_small(hmin - L,hmin,N_final,g_in%c(dir)%dhn%f(1))
           call init(a,robertsRight(hmin-L,hmin,N_final,beta))
           N_final = a%N
           if (needs_more_points(a,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process(g,a,dir)
       end subroutine

       subroutine con_prep_Roberts_B(g,g_in,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         type(mesh_quality_params),intent(in) :: MQP
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         real(cp) :: beta,hmin
         type(array) :: a
         integer :: i,N_final
         call check_N(N,'con_prep_Roberts_B')
         call init(g,g_in)
         N_final = N
         hmin = g_in%c(dir)%hmin
         do i=1,MQP%N_iter
           beta = beta_dh_both(hmin - L,hmin,N_final,g_in%c(dir)%dhn%f(1))
           call init(a,robertsBoth(hmin-L,hmin,N_final,beta))
           N_final = a%N
           if (needs_more_points(a,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process(g,a,dir)
       end subroutine

       ! ******************************************************************** Append

       subroutine con_app_uniform(g,g_in,N,dir)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         integer,intent(in) :: N,dir
         type(array) :: a
         real(cp) :: dh
         call check_N(N,'con_app_uniform')
         call init(g,g_in)
         dh = g%c(dir)%dhn_e
         call init(a,uniformRight(g_in%c(dir)%hmax,dh,N))
         call process(g,a,dir)
       end subroutine

       subroutine con_app_Roberts_L(g,g_in,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         type(mesh_quality_params),intent(in) :: MQP
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         real(cp) :: beta,hmax
         type(array) :: a
         integer :: i,N_final
         call check_N(N,'con_app_Roberts_L')
         call init(g,g_in)
         N_final = N
         hmax = g_in%c(dir)%hmax
         do i=1,MQP%N_iter
           beta = beta_dh_small(hmax,hmax + L,N_final,g_in%c(dir)%dhn_e)
           call init(a,robertsLeft(hmax,hmax + L,N_final,beta))
           N_final = a%N
           if (needs_more_points(a,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process(g,a,dir)
       end subroutine

       subroutine con_app_Roberts_R(g,g_in,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         type(mesh_quality_params),intent(in) :: MQP
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         real(cp) :: beta,hmax
         type(array) :: a
         integer :: i,N_final
         call check_N(N,'con_app_Roberts_R')
         call init(g,g_in)
         N_final = N
         hmax = g_in%c(dir)%hmax
         do i=1,MQP%N_iter
           beta = beta_dh_small(hmax,hmax + L,N_final,g_in%c(dir)%dhn%f(1))
           call init(a,robertsRight(hmax,hmax + L,N_final,beta))
           N_final = a%N
           if (needs_more_points(a,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process(g,a,dir)
       end subroutine

       subroutine con_app_Roberts_B(g,g_in,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         type(mesh_quality_params),intent(in) :: MQP
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         real(cp) :: beta,hmax
         type(array) :: a
         integer :: i,N_final
         call check_N(N,'con_app_Roberts_B')
         call init(g,g_in)
         N_final = N
         hmax = g_in%c(dir)%hmax
         do i=1,MQP%N_iter
           beta = beta_dh_both(hmax,hmax + L,N_final,g_in%c(dir)%dhn_e)
           call init(a,robertsBoth(hmax,hmax + L,N_final,beta))
           N_final = a%N
           if (needs_more_points(a,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process(g,a,dir)
       end subroutine

       subroutine check_N(N,caller)
         implicit none
         character(len=*),intent(in) :: caller
         integer,intent(in) :: N
         if (.not.(N.gt.0)) then
           write(*,*) 'Error: N is not > 0 in ',caller,' in extend_grid.f90'
           stop 'Done'
         endif
       end subroutine

       end module
       module grid_extend_mod
       use grid_mod
      ! Pre-processor directives: (_DEBUG_COORDINATES_)
       use current_precision_mod
       use array_mod
       use data_location_extend_mod
       use face_edge_corner_indexing_mod
       use IO_tools_mod
       use coordinates_mod
       use coordinates_extend_mod
       implicit none

       private
       public :: grid
       public :: init ! Essentials

       public :: restrict_x,restrict_xy ! specifically for MG

       public :: restrict
       public :: prolongate

       public :: initProps
       public :: snip,pop

       public :: mirror_about_hmin
       public :: mirror_about_hmax

       public :: get_shape

       public :: get_coordinates_h
       public :: get_coordinates_dh
       public :: get_coordinates_dual_h
       public :: get_coordinates_dual_dh

       public :: get_face_GI
       public :: get_face_GI_grid
       public :: get_edge_GI
       public :: get_corner_GI
       public :: get_face_b
       public :: get_edge_b
       public :: get_corner_b

#ifdef _DEBUG_COORDINATES_
       public :: checkGrid
#endif

       interface init;                     module procedure initGrid1;                  end interface
       interface init;                     module procedure initGrid2;                  end interface

       interface initProps;                module procedure initProps_grid;             end interface

       interface restrict;                 module procedure restrictGrid1;              end interface
       interface restrict;                 module procedure restrictGrid3;              end interface
       interface restrict_x;               module procedure restrictGrid_x;             end interface
       interface restrict_xy;              module procedure restrictGrid_xy;            end interface

       interface restrict;                 module procedure restrict_dir_g;             end interface
       interface restrict;                 module procedure restrict_all_g;             end interface
       interface restrict;                 module procedure restrict_dir2_g;            end interface
       interface prolongate;               module procedure prolongate_dir_g;           end interface
       interface prolongate;               module procedure prolongate_all_g;           end interface

       interface snip;                     module procedure snip_grid;                  end interface
       interface pop;                      module procedure pop_grid;                   end interface

       interface mirror_about_hmin;        module procedure mirror_about_hmin_g;        end interface
       interface mirror_about_hmax;        module procedure mirror_about_hmax_g;        end interface

       interface get_shape;                module procedure get_shape_g;                end interface

       interface get_face_GI;              module procedure get_face_GI_grid;           end interface
       interface get_edge_GI;              module procedure get_edge_GI_grid;           end interface
       interface get_corner_GI;            module procedure get_corner_GI_grid;         end interface

       interface get_face_b;               module procedure get_face_grid_b;            end interface
       interface get_face_b;               module procedure get_face_grid_b_IO;         end interface
       interface get_edge_b;               module procedure get_edge_grid_b;            end interface
       interface get_corner_b;             module procedure get_corner_grid_b;          end interface

       interface get_coordinates_h;        module procedure get_coordinates_h_g;        end interface
       interface get_coordinates_dh;       module procedure get_coordinates_dh_g;       end interface
       interface get_coordinates_dual_h;   module procedure get_coordinates_dual_h_g;   end interface
       interface get_coordinates_dual_dh;  module procedure get_coordinates_dual_dh_g;  end interface


       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine initGrid1(g,h,dir)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),dimension(:),intent(in) :: h
         integer,intent(in) :: dir
         integer :: i
         call init(g%c(dir),h,size(h))
         if (all((/(allocated(g%c(i)%hn%f),i=1,3)/))) then
           call initProps(g)
#ifdef _DEBUG_COORDINATES_
           call checkGrid(g)
#endif
         endif
       end subroutine

       subroutine initGrid2(g,h1,h2,h3)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),dimension(:),intent(in) :: h1,h2,h3
         call init(g%c(1),h1,size(h1))
         call init(g%c(2),h2,size(h2))
         call init(g%c(3),h3,size(h3))
         call initProps(g)
       end subroutine

       ! **********************************************************
       ! **********************************************************
       ! **********************************************************

       subroutine initProps_grid(g)
         implicit none
         type(grid),intent(inout) :: g
         integer :: i
         g%volume = g%c(1)%maxRange*g%c(2)%maxRange*g%c(3)%maxRange
         g%defined = all((/(g%c(i)%defined,i=1,3)/))
       end subroutine

       ! ------------------- restrict (for multigrid) --------------

       subroutine restrictGrid1(r,g,dir)
         type(grid),intent(inout) :: r
         type(grid),intent(in) :: g
         integer,intent(in) :: dir
         call restrict(r%c(dir),g%c(dir))
       end subroutine

       subroutine restrictGrid3(r,g)
         type(grid),intent(inout) :: r
         type(grid),intent(in) :: g
         integer :: i
         do i = 1,3; call restrict(r%c(i),g%c(i)) ;enddo
       end subroutine

       subroutine restrictGrid_x(r,g)
         type(grid),intent(inout) :: r
         type(grid),intent(in) :: g
         call restrict(r%c(1),g%c(1))
       end subroutine

       subroutine restrictGrid_xy(r,g)
         type(grid),intent(inout) :: r
         type(grid),intent(in) :: g
         call restrict(r%c(1),g%c(1))
         call restrict(r%c(2),g%c(2))
       end subroutine

       ! ***********************************************************
       ! ******************* RESTRICT / PROLONGATE *****************
       ! ***********************************************************

       subroutine restrict_all_g(g)
         type(grid),intent(inout) :: g
         call restrict(g%c(1))
         call restrict(g%c(2))
         call restrict(g%c(3))
       end subroutine

       subroutine restrict_dir_g(g,dir)
         type(grid),intent(inout) :: g
         integer,intent(in) :: dir
         call restrict(g%c(dir))
       end subroutine

       subroutine restrict_dir2_g(g,dir)
         type(grid),intent(inout) :: g
         integer,dimension(2),intent(in) :: dir
         call restrict(g%c(dir(1)))
         call restrict(g%c(dir(2)))
       end subroutine

       subroutine prolongate_all_g(g)
         type(grid),intent(inout) :: g
         call prolongate(g%c(1))
         call prolongate(g%c(2))
         call prolongate(g%c(3))
       end subroutine

       subroutine prolongate_dir_g(g,dir)
         type(grid),intent(inout) :: g
         integer,intent(in) :: dir
         call prolongate(g%c(dir))
       end subroutine

       ! ***********************************************************
       ! ***********************************************************
       ! ***********************************************************

       subroutine pop_grid(g,dir) ! Removes the last index from the grid
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: dir
         call pop(g%c(dir))
       end subroutine

       subroutine mirror_about_hmin_g(g,dir)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: dir
         call mirror_about_hmin(g%c(dir))
       end subroutine

       subroutine mirror_about_hmax_g(g,dir)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: dir
         call mirror_about_hmax(g%c(dir))
       end subroutine

       function get_shape_g(g,DL) result(s)
         implicit none
         type(grid),intent(in) :: g
         type(data_location),intent(in) :: DL
         integer,dimension(3) :: s
         integer :: i
         do i=1,3
             if ( N_along(DL,i)) then; s(i) = g%c(i)%sn
         elseif (CC_along(DL,i)) then; s(i) = g%c(i)%sc
         !     if ( N_along(DL,i)) then; s(i) = g%c(i)%h(1)%N
         ! elseif (CC_along(DL,i)) then; s(i) = g%c(i)%h(2)%N
         else; stop 'Error: bad DL in get_shape_g in grid.f90'
         endif
         enddo
       end function

       subroutine snip_grid(g,dir) ! Removes the first index from the grid
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: dir
         call snip(g%c(dir))
       end subroutine

       ! ---------------------------------------------- check grid

#ifdef _DEBUG_COORDINATES_
       subroutine checkGrid(g)
         implicit none
         type(grid),intent(in) :: g
         integer :: i
         do i=1,3; call checkCoordinates(g%c(i)); enddo
       end subroutine
#endif

       ! *********************************************************************
       ! *********************************************************************
       ! ******************** GET SURFACE / EDGE / CORNER ********************
       ! *********************************************************************
       ! *********************************************************************

       subroutine get_face_GI_grid(g,g_in,face)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         integer,intent(in) :: face
         call init(g,g_in)
         if (min_face(face)) call get_GI(g%c(dir_given_face(face)),-1)
         if (max_face(face)) call get_GI(g%c(dir_given_face(face)), 1)
       end subroutine

       subroutine get_edge_GI_grid(g,g_in,edge)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         integer,intent(in) :: edge
         type(grid) :: temp
         integer,dimension(2) :: f
         f = adj_faces_given_edge(edge)
         call get_face_GI(temp,g_in,f(1))
         call get_face_GI(g,temp,f(2))
       end subroutine

       subroutine get_corner_GI_grid(g,g_in,corner)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         integer,intent(in) :: corner
         type(grid) :: A,B
         integer,dimension(3) :: f
         f = adj_faces_given_corner(corner)
         call get_face_GI(A,g_in,f(1))
         call get_face_GI(B,A,f(2))
         call get_face_GI(g,B,f(3))
       end subroutine

       subroutine get_face_grid_b(g,g_in,face)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         integer,intent(in) :: face
         call init(g,g_in)
         if (min_face(face)) call get_boundary(g%c(dir_given_face(face)),-1)
         if (max_face(face)) call get_boundary(g%c(dir_given_face(face)), 1)
       end subroutine
       subroutine get_face_grid_b_IO(g,face)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: face
         if (min_face(face)) call get_boundary(g%c(dir_given_face(face)),-1)
         if (max_face(face)) call get_boundary(g%c(dir_given_face(face)), 1)
       end subroutine
       subroutine get_edge_grid_b(g,g_in,edge)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         integer,intent(in) :: edge
         type(grid) :: temp
         integer,dimension(2) :: f
         f = adj_faces_given_edge(edge)
         call get_face_b(temp,g_in,f(1))
         call get_face_b(g,temp,f(2))
       end subroutine
       subroutine get_corner_grid_b(g,g_in,corner)
         implicit none
         type(grid),intent(inout) :: g
         type(grid),intent(in) :: g_in
         integer,intent(in) :: corner
         type(grid) :: A,B
         integer,dimension(3) :: f
         f = adj_faces_given_corner(corner)
         call get_face_b(A,g_in,f(1))
         call get_face_b(B,A,f(2))
         call get_face_b(g,B,f(3))
       end subroutine

      subroutine get_coordinates_h_g(h,g,DL)
        implicit none
        type(array),dimension(3),intent(inout) :: h
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer :: i
        do i=1,3
            if ( N_along(DL,i)) then; call init(h(i),g%c(i)%hn)
        elseif (CC_along(DL,i)) then; call init(h(i),g%c(i)%hc)
        else; stop 'Error: bad DL in get_coordinates_h_g in grid.f90'
        endif
        enddo
      end subroutine

      subroutine get_coordinates_dh_g(h,g,DL)
        implicit none
        type(array),dimension(3),intent(inout) :: h
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer :: i
        do i=1,3
            if ( N_along(DL,i)) then; call init(h(i),g%c(i)%dhn)
        elseif (CC_along(DL,i)) then; call init(h(i),g%c(i)%dhc)
        else; stop 'Error: bad DL in get_coordinates_dh_g in grid.f90'
        endif
        enddo
      end subroutine

      subroutine get_coordinates_dual_h_g(h,g,DL)
        implicit none
        type(array),dimension(3),intent(inout) :: h
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer :: i
        do i=1,3
            if ( N_along(DL,i)) then; call init(h(i),g%c(i)%hc)
        elseif (CC_along(DL,i)) then; call init(h(i),g%c(i)%hn)
        else; stop 'Error: bad DL in get_coordinates_dual_h_g in grid.f90'
        endif
        enddo
      end subroutine

      subroutine get_coordinates_dual_dh_g(h,g,DL)
        implicit none
        type(array),dimension(3),intent(inout) :: h
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer :: i
        do i=1,3
            if ( N_along(DL,i)) then; call init(h(i),g%c(i)%dhc)
        elseif (CC_along(DL,i)) then; call init(h(i),g%c(i)%dhn)
        else; stop 'Error: bad DL in get_coordinates_dual_dh_g in grid.f90'
        endif
        enddo
      end subroutine

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module mesh_mod
       use block_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use mesh_props_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: mesh
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_mesh;              end interface
       interface delete;                 module procedure delete_mesh;                 end interface
       interface display;                module procedure display_mesh;                end interface
       interface display_short;          module procedure display_short_mesh;          end interface
       interface display;                module procedure display_wrap_mesh;           end interface
       interface print;                  module procedure print_mesh;                  end interface
       interface print_short;            module procedure print_short_mesh;            end interface
       interface export;                 module procedure export_mesh;                 end interface
       interface export_primitives;      module procedure export_primitives_mesh;      end interface
       interface import;                 module procedure import_mesh;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_mesh;end interface
       interface export_structured;      module procedure export_structured_D_mesh;    end interface
       interface import_structured;      module procedure import_structured_D_mesh;    end interface
       interface import_primitives;      module procedure import_primitives_mesh;      end interface
       interface export;                 module procedure export_wrap_mesh;            end interface
       interface import;                 module procedure import_wrap_mesh;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_mesh;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_mesh;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_mesh;      end interface

       type mesh
         type(block),dimension(:),allocatable :: B
         type(mesh_props) :: MP
         logical :: defined = .false.
         integer :: s = 0
       end type

       contains

       subroutine init_copy_mesh(this,that)
         implicit none
         type(mesh),intent(inout) :: this
         type(mesh),intent(in) :: that
         integer :: i_B
         integer :: s_B
         call delete(this)
         if (allocated(that%B)) then
           s_B = size(that%B)
           if (s_B.gt.0) then
             allocate(this%B(s_B))
             do i_B=1,s_B
               call init(this%B(i_B),that%B(i_B))
             enddo
           endif
         endif
         call init(this%MP,that%MP)
         this%defined = that%defined
         this%s = that%s
       end subroutine

       subroutine delete_mesh(this)
         implicit none
         type(mesh),intent(inout) :: this
         integer :: i_B
         integer :: s_B
         if (allocated(this%B)) then
           s_B = size(this%B)
           do i_B=1,s_B
             call delete(this%B(i_B))
           enddo
           deallocate(this%B)
         endif
         call delete(this%MP)
         this%defined = .false.
         this%s = 0
       end subroutine

       subroutine display_mesh(this,un)
         implicit none
         type(mesh),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_B
         integer :: s_B
         if (allocated(this%B)) then
           s_B = size(this%B)
           do i_B=1,s_B
             call display(this%B(i_B),un)
           enddo
         endif
         call display(this%MP,un)
         write(un,*) 'defined = ',this%defined
         write(un,*) 's       = ',this%s
       end subroutine

       subroutine display_short_mesh(this,un)
         implicit none
         type(mesh),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_B
         integer :: s_B
         if (allocated(this%B)) then
           s_B = size(this%B)
           do i_B=1,s_B
             call display(this%B(i_B),un)
           enddo
         endif
         call display(this%MP,un)
         write(un,*) 'defined = ',this%defined
         write(un,*) 's       = ',this%s
       end subroutine

       subroutine display_wrap_mesh(this,dir,name)
         implicit none
         type(mesh),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_mesh(this)
         implicit none
         type(mesh),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_mesh(this)
         implicit none
         type(mesh),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_mesh(this,un)
         implicit none
         type(mesh),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_B
         integer :: s_B
         call export_primitives(this,un)
         if (allocated(this%B)) then
           s_B = size(this%B)
           write(un,*) s_B
           if (s_B.gt.0) then
             do i_B=1,s_B
               call export(this%B(i_B),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
         call export(this%MP,un)
       end subroutine

       subroutine import_mesh(this,un)
         implicit none
         type(mesh),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_B
         integer :: s_B
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_B
         if (s_B.gt.0) then
           allocate(this%B(s_B))
           do i_B=1,s_B
             call import(this%B(i_B),un)
           enddo
         endif
         call import(this%MP,un)
       end subroutine

       subroutine export_primitives_mesh(this,un)
         implicit none
         type(mesh),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'defined  = ';write(un,*) this%defined
         write(un,*) 's        = ';write(un,*) this%s
       end subroutine

       subroutine import_primitives_mesh(this,un)
         implicit none
         type(mesh),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%defined
         read(un,*); read(un,*) this%s
       end subroutine

       subroutine export_wrap_mesh(this,dir,name)
         implicit none
         type(mesh),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_mesh(this,dir,name)
         implicit none
         type(mesh),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_mesh(this,dir)
         implicit none
         type(mesh),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_B
         integer :: s_B
         call suppress_warnings(this)
         if (allocated(this%B)) then
           s_B = size(this%B)
           do i_B=1,s_B
             call set_IO_dir(this%B(i_B),&
             dir//'B_'//int2str(i_B)//fortran_PS)
           enddo
         endif
         call set_IO_dir(this%MP,dir//'MP'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_mesh(this,dir)
         implicit none
         type(mesh),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_B
         integer :: s_B
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         if (allocated(this%B)) then
           s_B = size(this%B)
           do i_B=1,s_B
             call make_IO_dir(this%B(i_B),&
             dir//'B_'//int2str(i_B)//fortran_PS)
           enddo
         endif
         call make_IO_dir(this%MP,dir//'MP'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_mesh(this,dir)
         implicit none
         type(mesh),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_B
         integer :: s_B
         integer :: un
         if (allocated(this%B)) then
           s_B = size(this%B)
           write(un,*) s_B
           do i_B=1,s_B
             call export_structured(this%B(i_B),&
             dir//'B_'//int2str(i_B)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         call export_structured(this%MP,dir//'MP'//fortran_PS)
       end subroutine

       subroutine export_structured_D_mesh(this,dir)
         implicit none
         type(mesh),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_B
         integer :: s_B
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         if (allocated(this%B)) then
           s_B = size(this%B)
           write(un,*) s_B
           do i_B=1,s_B
             call export_structured(this%B(i_B),&
             dir//'B_'//int2str(i_B)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         call export_structured(this%MP,dir//'MP'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_mesh(this,dir)
         implicit none
         type(mesh),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_B
         integer :: s_B
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         read(un,*) s_B
         if (s_B.gt.0) then
           if (.not.allocated(this%B)) then
             allocate(this%B(s_B))
           endif
           do i_B=1,s_B
             call import_structured(this%B(i_B),&
             dir//'B_'//int2str(i_B)//fortran_PS)
           enddo
         endif
         call import_structured(this%MP,dir//'MP'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_mesh(this)
         implicit none
         type(mesh),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module ops_dct_mod
      ! Returns the Discrete Cosine Transform of the scalar field, f, wrt direction
      ! dir (1,2,3) which corresponds to (x,y,z).
      !
      ! Flags: (fopenmp,_DEBUG_DCT_)
      !
      ! Implementation:
      ! call apply(omega,f,g,dir,pad)
      !
      ! INPUT:
      !     f            = f(x,y,z)
      !     g            = grid (g%c(1,2,3)%dhn, g%c(1,2,3)%dhc)
      !     dir          = direction along which to take the fourier transform (1,2,3)
      !     pad          = (1,0) = (exclude,include) boundary calc along fourier transform direction
      !                    |0000000|     |-------|
      !                    |-------|  ,  |-------| Look at dct for implementation details
      !                    |0000000|     |-------|
      !
      ! INDEXING: The index range of the incoming scalar field is assumed to begin at one.
      !
      ! CharlieKawczynski@gmail.com
      ! 7/12/2015

      use current_precision_mod
      use grid_mod
      use ops_fft_mod
      use constants_mod
      implicit none

      private
      public :: dct,dct1D
      interface dct;    module procedure applyDCT3D;    end interface

      contains

      subroutine dct1D(x)
        ! DCT    Discrete cosine transform of type II
        !
        !        Y = dct(X) returns the discrete cosine transform of X,
        !        based on the staggered-grid definition
        !                    N
        !            Y(k) = sum X(j) cos (pi*(k-1)*(j-1/2)/N)
        !                   j=1
        !        The vector Y is the same size as X and contains the
        !        discrete cosine transform coefficients.
        !
        real(cp),    dimension(:), intent(inout)  :: x
        complex(cp), dimension(:), allocatable    :: xx,e
        integer                                   :: N,k
        complex(cp)                               :: j
        N = size(x)
        allocate(xx(2*N))
        allocate(e(N))
        xx = 0.0_cp
        e = 0.0_cp
        j = cmplx(0.0_cp,1.0_cp,cp)
        xx(1:N) = cmplx(x,0.0_cp,cp)
        do k=1,N
          xx(N+k) = cmplx(x(N-k+1),0.0_cp,cp)
        enddo
        call fft1D(xx)
        do k=1,N
          e(k) = 0.5_cp*exp(-j*0.5_cp*PI*real(k-1,cp)/real(N,cp))
        enddo
        do k=1,N
          x(k) = real(xx(k)*e(k),cp)
        enddo
        deallocate(xx)
        deallocate(e)
      end subroutine

      subroutine applyDCT3D(f,dir,pad)
        implicit none
        real(cp),dimension(:,:,:),intent(inout) :: f
        integer,intent(in) :: dir,pad
        integer,dimension(3) :: s
        integer :: i,j,k

        s = shape(f)

#ifdef _DEBUG_DCT_
        call checkDimensions(s,shape(f),dir)
#endif

        select case (dir)
        case (1)
          !$OMP PARALLEL DO
          do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad
            call dct1D(f(:,j,k))
          enddo; enddo
          !$OMP END PARALLEL DO
        case (2)
          !$OMP PARALLEL DO
          do k=1+pad,s(3)-pad; do i=1+pad,s(1)-pad
            call dct1D(f(i,:,k))
          enddo; enddo
          !$OMP END PARALLEL DO
        case (3)
          !$OMP PARALLEL DO
          do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
            call dct1D(f(i,j,:))
          enddo; enddo
          !$OMP END PARALLEL DO
        case default
        stop 'Error: dir must = 1,2,3 in delGen in del.f90.'
        end select
      end subroutine

      ! ******************* OPERATOR TYPES ****************************

#ifdef _DEBUG_DCT_
      subroutine checkDimensions(s1,s2,dir)
        ! This routine makes sure that the shapes s1 and s2
        ! are equal for orthogonal directions to dir, which
        ! must be the case for all derivatives in del.
        implicit none
        integer,dimension(3),intent(in) :: s1,s2
        integer,intent(in) :: dir
        select case (dir)
        case (1); if (s1(2).ne.s2(2)) stop 'Error: Shape mismatch 1 in del'
                  if (s1(3).ne.s2(3)) stop 'Error: Shape mismatch 2 in del'
        case (2); if (s1(1).ne.s2(1)) stop 'Error: Shape mismatch 3 in del'
                  if (s1(3).ne.s2(3)) stop 'Error: Shape mismatch 4 in del'
        case (3); if (s1(1).ne.s2(1)) stop 'Error: Shape mismatch 5 in del'
                  if (s1(2).ne.s2(2)) stop 'Error: Shape mismatch 6 in del'
        case default
        stop 'Error: dir must = 1,2,3 in del.f90'
        end select
        if (s1(dir).eq.s2(dir)) then         ! Ok (collocated)
        else; stop 'Error: shape mismatch 7 in del.f90'
        endif
      end subroutine
#endif

      end module
      module ops_idct_mod
      ! Returns the inverse Discrete Cosine Transform of the scalar field, f, wrt direction
      ! dir (1,2,3) which corresponds to (x,y,z).
      !
      ! Flags: (fopenmp,_DEBUG_iDCT_)
      !
      ! Implementation:
      ! call apply(omega,f,g,dir,pad)
      !
      ! INPUT:
      !     f            = f(x,y,z)
      !     g            = grid (g%c(1,2,3)%dhn, g%c(1,2,3)%dhc)
      !     dir          = direction along which to take the fourier transform (1,2,3)
      !     pad          = (1,0) = (exclude,include) boundary calc along fourier transform direction
      !                    |0000000|     |-------|
      !                    |-------|  ,  |-------| Look at idct for implementation details
      !                    |0000000|     |-------|
      !
      ! INDEXING: The index range of the incoming scalar field is assumed to begin at one.
      !
      ! CharlieKawczynski@gmail.com
      ! 7/12/2015

      use current_precision_mod
      use grid_mod
      use ops_fft_mod
      use constants_mod
      implicit none

      private
      public :: idct,idct1D

      interface idct;    module procedure applyiDCT3D;    end interface

      contains

      subroutine idct1D(x)
        ! iDCT    Inverse Discrete cosine transform of type II
        !
        !        Y = idct(X) returns the discrete cosine transform of X,
        !        based on the staggered-grid definition
        !                    N
        !            Y(k) = sum X(j) cos (pi*(k-1)*(j-1/2)/N)
        !                   j=1
        !        The vector Y is the same size as X and contains the
        !        discrete cosine transform coefficients.
        !
        real(cp),    dimension(:), intent(inout)  :: x
        complex(cp), dimension(:), allocatable  :: xx,xx2,e
        complex(cp)                               :: j
        integer                                   :: N
        integer                                   :: k
        N = size(x)
        allocate(xx(2*N))
        allocate(xx2(2*N))
        allocate(e(N))
        j = cmplx(0.0_cp,1.0_cp,cp)

        xx = 0.0_cp; xx2 = xx
        e = 0.0_cp

        xx(1:N) = cmplx(x,0.0_cp,cp)
        do k=1,N
          e(k) = 0.5_cp*exp(-j*0.5_cp*PI*real(k-1,cp)/real(N,cp))
        enddo
        xx(1:N) = xx(1:N)*e
        xx2(1:N) = xx(1:N)

        do k=2,N
          xx2(N+k) = conjg(xx(N-k+2))
        enddo

        call fft1D(xx2)
        x = 2.0_cp/real(N,cp)*real(xx2(1:N),cp)

        deallocate(xx)
        deallocate(xx2)
        deallocate(e)
      end subroutine

      subroutine applyiDCT3D(f,dir,pad)
        implicit none
        real(cp),dimension(:,:,:),intent(inout) :: f
        integer,intent(in) :: dir,pad
        integer,dimension(3) :: s
        integer :: i,j,k

        s = shape(f)

#ifdef _DEBUG_iDCT_
        call checkDimensions(s,shape(f),dir)
#endif

        select case (dir)
        case (1)
          !$OMP PARALLEL DO
          do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad
            call idct1D(f(:,j,k))
          enddo; enddo
          !$OMP END PARALLEL DO
        case (2)
          !$OMP PARALLEL DO
          do k=1+pad,s(3)-pad; do i=1+pad,s(1)-pad
            call idct1D(f(i,:,k))
          enddo; enddo
          !$OMP END PARALLEL DO
        case (3)
          !$OMP PARALLEL DO
          do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
            call idct1D(f(i,j,:))
          enddo; enddo
          !$OMP END PARALLEL DO
        case default
        stop 'Error: dir must = 1,2,3 in delGen in del.f90.'
        end select
      end subroutine

      ! ******************* OPERATOR TYPES ****************************

#ifdef _DEBUG_iDCT_
      subroutine checkDimensions(s1,s2,dir)
        ! This routine makes sure that the shapes s1 and s2
        ! are equal for orthogonal directions to dir, which
        ! must be the case for all derivatives in del.
        implicit none
        integer,dimension(3),intent(in) :: s1,s2
        integer,intent(in) :: dir
        select case (dir)
        case (1); if (s1(2).ne.s2(2)) stop 'Error: Shape mismatch 1 in del'
                  if (s1(3).ne.s2(3)) stop 'Error: Shape mismatch 2 in del'
        case (2); if (s1(1).ne.s2(1)) stop 'Error: Shape mismatch 3 in del'
                  if (s1(3).ne.s2(3)) stop 'Error: Shape mismatch 4 in del'
        case (3); if (s1(1).ne.s2(1)) stop 'Error: Shape mismatch 5 in del'
                  if (s1(2).ne.s2(2)) stop 'Error: Shape mismatch 6 in del'
        case default
        stop 'Error: dir must = 1,2,3 in del.f90'
        end select
        if (s1(dir).eq.s2(dir)) then         ! Ok (collocated)
        else; stop 'Error: shape mismatch 7 in del.f90'
        endif
      end subroutine
#endif

      end module
       module physical_sub_domain_extend_mod
       use physical_sub_domain_mod
       use current_precision_mod
       use overlap_mod
       use overlap_extend_mod
       use grid_mod
       use face_edge_corner_indexing_mod
       use sub_domain_mod
       use sub_domain_extend_mod
       use data_location_extend_mod
       use coordinates_mod

       implicit none

       private
       public :: init,display,print

       public :: init_mixed

       public :: pick_extrema_bot
       public :: pick_extrema_top

       interface init;             module procedure init_PSD;              end interface
       interface display;          module procedure display_PSD;           end interface
       interface print;            module procedure print_PSD;             end interface

       interface init_mixed;       module procedure init_mixed_PSD;        end interface

       interface pick_extrema_bot; module procedure pick_extrema_bot_PSD;  end interface
       interface pick_extrema_top; module procedure pick_extrema_top_PSD;  end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_PSD(PS,g_R1,g_R2,g_R1_id,g_R2_id)
         implicit none
         type(physical_sub_domain),intent(inout) :: PS
         type(grid),intent(in) :: g_R1,g_R2
         integer,intent(in) :: g_R1_id,g_R2_id
         real(cp) :: tol
         tol = 10.0_cp**(-12.0_cp)
         call init(PS%total,g_R1,g_R2,g_R1_id,g_R2_id,tol,0)
         call init(PS%physical,g_R1,g_R2,g_R1_id,g_R2_id,tol,1)
         ! PS%defined = PS%total%defined.and.PS%physical%defined
         PS%defined = PS%physical%defined
       end subroutine

       subroutine display_PSD(PS,name,u)
         implicit none
         type(physical_sub_domain),intent(in) :: PS
         character(len=*),intent(in) :: name
         integer,intent(in) :: u
         write(u,*) ' ********** physical_sub_domain ************ '//name
         write(u,*) 'defined = ',PS%defined
         call display(PS%total,name,u)
         call display(PS%physical,name,u)
         write(u,*) ' ********************************* '
       end subroutine

       subroutine print_PSD(PS,name)
         implicit none
         type(physical_sub_domain),intent(in) :: PS
         character(len=*),intent(in) :: name
         call display(PS,name,6)
       end subroutine

       ! **********************************************************************
       ! **********************************************************************
       ! **********************************************************************

       subroutine init_mixed_PSD(PS,DL)
         implicit none
         type(physical_sub_domain),intent(inout) :: PS
         type(data_location),intent(in) :: DL
         call init_mixed(PS%total%M,PS%total%C,PS%total%N,DL)
         call init_mixed(PS%physical%M,PS%physical%C,PS%physical%N,DL)
       end subroutine

       subroutine pick_extrema_bot_PSD(PS,dir)
         implicit none
         type(physical_sub_domain),intent(inout) :: PS
         integer,intent(in) :: dir
         call pick_extrema_bot(PS%physical%C(dir),PS%total%C(dir))
         call pick_extrema_bot(PS%physical%N(dir),PS%total%N(dir))
         call pick_extrema_bot(PS%physical%M(dir),PS%total%M(dir))
       end subroutine

       subroutine pick_extrema_top_PSD(PS,dir)
         implicit none
         type(physical_sub_domain),intent(inout) :: PS
         integer,intent(in) :: dir
         call pick_extrema_top(PS%physical%C(dir),PS%total%C(dir))
         call pick_extrema_top(PS%physical%N(dir),PS%total%N(dir))
         call pick_extrema_top(PS%physical%M(dir),PS%total%M(dir))
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module procedure_array_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use single_procedure_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: procedure_array
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_procedure_array;              end interface
       interface delete;                 module procedure delete_procedure_array;                 end interface
       interface display;                module procedure display_procedure_array;                end interface
       interface display_short;          module procedure display_short_procedure_array;          end interface
       interface display;                module procedure display_wrap_procedure_array;           end interface
       interface print;                  module procedure print_procedure_array;                  end interface
       interface print_short;            module procedure print_short_procedure_array;            end interface
       interface export;                 module procedure export_procedure_array;                 end interface
       interface export_primitives;      module procedure export_primitives_procedure_array;      end interface
       interface import;                 module procedure import_procedure_array;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_procedure_array;end interface
       interface export_structured;      module procedure export_structured_D_procedure_array;    end interface
       interface import_structured;      module procedure import_structured_D_procedure_array;    end interface
       interface import_primitives;      module procedure import_primitives_procedure_array;      end interface
       interface export;                 module procedure export_wrap_procedure_array;            end interface
       interface import;                 module procedure import_wrap_procedure_array;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_procedure_array;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_procedure_array;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_procedure_array;      end interface

       type procedure_array
         integer :: N = 0
         type(single_procedure),dimension(:),allocatable :: SP
         logical :: defined = .false.
       end type

       contains

       subroutine init_copy_procedure_array(this,that)
         implicit none
         type(procedure_array),intent(inout) :: this
         type(procedure_array),intent(in) :: that
         integer :: i_SP
         integer :: s_SP
         call delete(this)
         this%N = that%N
         if (allocated(that%SP)) then
           s_SP = size(that%SP)
           if (s_SP.gt.0) then
             allocate(this%SP(s_SP))
             do i_SP=1,s_SP
               call init(this%SP(i_SP),that%SP(i_SP))
             enddo
           endif
         endif
         this%defined = that%defined
       end subroutine

       subroutine delete_procedure_array(this)
         implicit none
         type(procedure_array),intent(inout) :: this
         integer :: i_SP
         integer :: s_SP
         this%N = 0
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           do i_SP=1,s_SP
             call delete(this%SP(i_SP))
           enddo
           deallocate(this%SP)
         endif
         this%defined = .false.
       end subroutine

       subroutine display_procedure_array(this,un)
         implicit none
         type(procedure_array),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_SP
         integer :: s_SP
         write(un,*) 'N       = ',this%N
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           do i_SP=1,s_SP
             call display(this%SP(i_SP),un)
           enddo
         endif
         write(un,*) 'defined = ',this%defined
       end subroutine

       subroutine display_short_procedure_array(this,un)
         implicit none
         type(procedure_array),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_SP
         integer :: s_SP
         write(un,*) 'N       = ',this%N
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           do i_SP=1,s_SP
             call display(this%SP(i_SP),un)
           enddo
         endif
         write(un,*) 'defined = ',this%defined
       end subroutine

       subroutine display_wrap_procedure_array(this,dir,name)
         implicit none
         type(procedure_array),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_procedure_array(this)
         implicit none
         type(procedure_array),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_procedure_array(this)
         implicit none
         type(procedure_array),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_procedure_array(this,un)
         implicit none
         type(procedure_array),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_SP
         integer :: s_SP
         call export_primitives(this,un)
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           write(un,*) s_SP
           if (s_SP.gt.0) then
             do i_SP=1,s_SP
               call export(this%SP(i_SP),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
       end subroutine

       subroutine import_procedure_array(this,un)
         implicit none
         type(procedure_array),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_SP
         integer :: s_SP
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_SP
         if (s_SP.gt.0) then
           allocate(this%SP(s_SP))
           do i_SP=1,s_SP
             call import(this%SP(i_SP),un)
           enddo
         endif
       end subroutine

       subroutine export_primitives_procedure_array(this,un)
         implicit none
         type(procedure_array),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'N        = ';write(un,*) this%N
         write(un,*) 'defined  = ';write(un,*) this%defined
       end subroutine

       subroutine import_primitives_procedure_array(this,un)
         implicit none
         type(procedure_array),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%N
         read(un,*); read(un,*) this%defined
       end subroutine

       subroutine export_wrap_procedure_array(this,dir,name)
         implicit none
         type(procedure_array),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_procedure_array(this,dir,name)
         implicit none
         type(procedure_array),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_procedure_array(this,dir)
         implicit none
         type(procedure_array),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SP
         integer :: s_SP
         call suppress_warnings(this)
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           do i_SP=1,s_SP
             call set_IO_dir(this%SP(i_SP),&
             dir//'SP_'//int2str(i_SP)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine make_IO_dir_procedure_array(this,dir)
         implicit none
         type(procedure_array),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SP
         integer :: s_SP
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           do i_SP=1,s_SP
             call make_IO_dir(this%SP(i_SP),&
             dir//'SP_'//int2str(i_SP)//fortran_PS)
           enddo
         endif
       end subroutine

       subroutine export_folder_structure_procedure_array(this,dir)
         implicit none
         type(procedure_array),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SP
         integer :: s_SP
         integer :: un
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           write(un,*) s_SP
           do i_SP=1,s_SP
             call export_structured(this%SP(i_SP),&
             dir//'SP_'//int2str(i_SP)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
       end subroutine

       subroutine export_structured_D_procedure_array(this,dir)
         implicit none
         type(procedure_array),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SP
         integer :: s_SP
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         if (allocated(this%SP)) then
           s_SP = size(this%SP)
           write(un,*) s_SP
           do i_SP=1,s_SP
             call export_structured(this%SP(i_SP),&
             dir//'SP_'//int2str(i_SP)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_procedure_array(this,dir)
         implicit none
         type(procedure_array),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_SP
         integer :: s_SP
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         read(un,*) s_SP
         if (s_SP.gt.0) then
           if (.not.allocated(this%SP)) then
             allocate(this%SP(s_SP))
           endif
           do i_SP=1,s_SP
             call import_structured(this%SP(i_SP),&
             dir//'SP_'//int2str(i_SP)//fortran_PS)
           enddo
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_procedure_array(this)
         implicit none
         type(procedure_array),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module sim_params_mod
       use probe_set_mom_mod
       use datatype_conversion_mod
       use dimensionless_params_mod
       use export_logicals_mod
       use probe_set_nrg_mod
       use mirror_props_mod
       use energy_terms_mod
       use geometry_props_mod
       use induction_terms_mod
       use time_marching_params_mod
       use dir_manip_mod
       use momentum_terms_mod
       use var_set_mod
       use time_statistics_params_mod
       use export_frequency_mod
       use probe_set_ind_mod
       use sim_config_params_mod
       use mesh_params_mod
       use mesh_quality_params_mod
       use flow_control_logicals_mod
       use IO_tools_mod
       use string_mod
       implicit none

       private
       public :: sim_params
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_sim_params;              end interface
       interface delete;                 module procedure delete_sim_params;                 end interface
       interface display;                module procedure display_sim_params;                end interface
       interface display_short;          module procedure display_short_sim_params;          end interface
       interface display;                module procedure display_wrap_sim_params;           end interface
       interface print;                  module procedure print_sim_params;                  end interface
       interface print_short;            module procedure print_short_sim_params;            end interface
       interface export;                 module procedure export_sim_params;                 end interface
       interface export_primitives;      module procedure export_primitives_sim_params;      end interface
       interface import;                 module procedure import_sim_params;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_sim_params;end interface
       interface export_structured;      module procedure export_structured_D_sim_params;    end interface
       interface import_structured;      module procedure import_structured_D_sim_params;    end interface
       interface import_primitives;      module procedure import_primitives_sim_params;      end interface
       interface export;                 module procedure export_wrap_sim_params;            end interface
       interface import;                 module procedure import_wrap_sim_params;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_sim_params;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_sim_params;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_sim_params;      end interface

       type sim_params
         type(probe_set_mom) :: PS_mom
         type(probe_set_ind) :: PS_ind
         type(probe_set_nrg) :: PS_nrg
         type(var_set) :: VS
         type(mesh_params) :: MP_mom
         type(mesh_quality_params) :: MQP
         type(mesh_params) :: MP_ind
         type(mesh_params) :: MP_sigma
         type(dimensionless_params) :: DP
         type(export_logicals) :: EL
         type(export_frequency) :: EF
         type(energy_terms) :: ET
         type(momentum_terms) :: MT
         type(induction_terms) :: IT
         type(geometry_props) :: GP
         type(mirror_props) :: MP
         type(time_marching_params) :: coupled
         type(flow_control_logicals) :: FCL
         type(time_statistics_params) :: TSP
         type(sim_config_params) :: SCP
       end type

       contains

       subroutine init_copy_sim_params(this,that)
         implicit none
         type(sim_params),intent(inout) :: this
         type(sim_params),intent(in) :: that
         call delete(this)
         call init(this%PS_mom,that%PS_mom)
         call init(this%PS_ind,that%PS_ind)
         call init(this%PS_nrg,that%PS_nrg)
         call init(this%VS,that%VS)
         call init(this%MP_mom,that%MP_mom)
         call init(this%MQP,that%MQP)
         call init(this%MP_ind,that%MP_ind)
         call init(this%MP_sigma,that%MP_sigma)
         call init(this%DP,that%DP)
         call init(this%EL,that%EL)
         call init(this%EF,that%EF)
         call init(this%ET,that%ET)
         call init(this%MT,that%MT)
         call init(this%IT,that%IT)
         call init(this%GP,that%GP)
         call init(this%MP,that%MP)
         call init(this%coupled,that%coupled)
         call init(this%FCL,that%FCL)
         call init(this%TSP,that%TSP)
         call init(this%SCP,that%SCP)
       end subroutine

       subroutine delete_sim_params(this)
         implicit none
         type(sim_params),intent(inout) :: this
         call delete(this%PS_mom)
         call delete(this%PS_ind)
         call delete(this%PS_nrg)
         call delete(this%VS)
         call delete(this%MP_mom)
         call delete(this%MQP)
         call delete(this%MP_ind)
         call delete(this%MP_sigma)
         call delete(this%DP)
         call delete(this%EL)
         call delete(this%EF)
         call delete(this%ET)
         call delete(this%MT)
         call delete(this%IT)
         call delete(this%GP)
         call delete(this%MP)
         call delete(this%coupled)
         call delete(this%FCL)
         call delete(this%TSP)
         call delete(this%SCP)
       end subroutine

       subroutine display_sim_params(this,un)
         implicit none
         type(sim_params),intent(in) :: this
         integer,intent(in) :: un
         call display(this%PS_mom,un)
         call display(this%PS_ind,un)
         call display(this%PS_nrg,un)
         call display(this%VS,un)
         call display(this%MP_mom,un)
         call display(this%MQP,un)
         call display(this%MP_ind,un)
         call display(this%MP_sigma,un)
         call display(this%DP,un)
         call display(this%EL,un)
         call display(this%EF,un)
         call display(this%ET,un)
         call display(this%MT,un)
         call display(this%IT,un)
         call display(this%GP,un)
         call display(this%MP,un)
         call display(this%coupled,un)
         call display(this%FCL,un)
         call display(this%TSP,un)
         call display(this%SCP,un)
       end subroutine

       subroutine display_short_sim_params(this,un)
         implicit none
         type(sim_params),intent(in) :: this
         integer,intent(in) :: un
         call display(this%PS_mom,un)
         call display(this%PS_ind,un)
         call display(this%PS_nrg,un)
         call display(this%VS,un)
         call display(this%MP_mom,un)
         call display(this%MQP,un)
         call display(this%MP_ind,un)
         call display(this%MP_sigma,un)
         call display(this%DP,un)
         call display(this%EL,un)
         call display(this%EF,un)
         call display(this%ET,un)
         call display(this%MT,un)
         call display(this%IT,un)
         call display(this%GP,un)
         call display(this%MP,un)
         call display(this%coupled,un)
         call display(this%FCL,un)
         call display(this%TSP,un)
         call display(this%SCP,un)
       end subroutine

       subroutine display_wrap_sim_params(this,dir,name)
         implicit none
         type(sim_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_sim_params(this)
         implicit none
         type(sim_params),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_sim_params(this)
         implicit none
         type(sim_params),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_sim_params(this,un)
         implicit none
         type(sim_params),intent(in) :: this
         integer,intent(in) :: un
         call export(this%PS_mom,un)
         call export(this%PS_ind,un)
         call export(this%PS_nrg,un)
         call export(this%VS,un)
         call export(this%MP_mom,un)
         call export(this%MQP,un)
         call export(this%MP_ind,un)
         call export(this%MP_sigma,un)
         call export(this%DP,un)
         call export(this%EL,un)
         call export(this%EF,un)
         call export(this%ET,un)
         call export(this%MT,un)
         call export(this%IT,un)
         call export(this%GP,un)
         call export(this%MP,un)
         call export(this%coupled,un)
         call export(this%FCL,un)
         call export(this%TSP,un)
         call export(this%SCP,un)
       end subroutine

       subroutine import_sim_params(this,un)
         implicit none
         type(sim_params),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%PS_mom,un)
         call import(this%PS_ind,un)
         call import(this%PS_nrg,un)
         call import(this%VS,un)
         call import(this%MP_mom,un)
         call import(this%MQP,un)
         call import(this%MP_ind,un)
         call import(this%MP_sigma,un)
         call import(this%DP,un)
         call import(this%EL,un)
         call import(this%EF,un)
         call import(this%ET,un)
         call import(this%MT,un)
         call import(this%IT,un)
         call import(this%GP,un)
         call import(this%MP,un)
         call import(this%coupled,un)
         call import(this%FCL,un)
         call import(this%TSP,un)
         call import(this%SCP,un)
       end subroutine

       subroutine export_primitives_sim_params(this,un)
         implicit none
         type(sim_params),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_sim_params(this,un)
         implicit none
         type(sim_params),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_sim_params(this,dir,name)
         implicit none
         type(sim_params),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_sim_params(this,dir,name)
         implicit none
         type(sim_params),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_sim_params(this,dir)
         implicit none
         type(sim_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%PS_mom,dir//'PS_mom'//fortran_PS)
         call set_IO_dir(this%PS_ind,dir//'PS_ind'//fortran_PS)
         call set_IO_dir(this%PS_nrg,dir//'PS_nrg'//fortran_PS)
         call set_IO_dir(this%VS,dir//'VS'//fortran_PS)
         call set_IO_dir(this%MP_mom,dir//'MP_mom'//fortran_PS)
         call set_IO_dir(this%MQP,dir//'MQP'//fortran_PS)
         call set_IO_dir(this%MP_ind,dir//'MP_ind'//fortran_PS)
         call set_IO_dir(this%MP_sigma,dir//'MP_sigma'//fortran_PS)
         call set_IO_dir(this%DP,dir//'DP'//fortran_PS)
         call set_IO_dir(this%EL,dir//'EL'//fortran_PS)
         call set_IO_dir(this%EF,dir//'EF'//fortran_PS)
         call set_IO_dir(this%ET,dir//'ET'//fortran_PS)
         call set_IO_dir(this%MT,dir//'MT'//fortran_PS)
         call set_IO_dir(this%IT,dir//'IT'//fortran_PS)
         call set_IO_dir(this%GP,dir//'GP'//fortran_PS)
         call set_IO_dir(this%MP,dir//'MP'//fortran_PS)
         call set_IO_dir(this%coupled,dir//'coupled'//fortran_PS)
         call set_IO_dir(this%FCL,dir//'FCL'//fortran_PS)
         call set_IO_dir(this%TSP,dir//'TSP'//fortran_PS)
         call set_IO_dir(this%SCP,dir//'SCP'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_sim_params(this,dir)
         implicit none
         type(sim_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%PS_mom,dir//'PS_mom'//fortran_PS)
         call make_IO_dir(this%PS_ind,dir//'PS_ind'//fortran_PS)
         call make_IO_dir(this%PS_nrg,dir//'PS_nrg'//fortran_PS)
         call make_IO_dir(this%VS,dir//'VS'//fortran_PS)
         call make_IO_dir(this%MP_mom,dir//'MP_mom'//fortran_PS)
         call make_IO_dir(this%MQP,dir//'MQP'//fortran_PS)
         call make_IO_dir(this%MP_ind,dir//'MP_ind'//fortran_PS)
         call make_IO_dir(this%MP_sigma,dir//'MP_sigma'//fortran_PS)
         call make_IO_dir(this%DP,dir//'DP'//fortran_PS)
         call make_IO_dir(this%EL,dir//'EL'//fortran_PS)
         call make_IO_dir(this%EF,dir//'EF'//fortran_PS)
         call make_IO_dir(this%ET,dir//'ET'//fortran_PS)
         call make_IO_dir(this%MT,dir//'MT'//fortran_PS)
         call make_IO_dir(this%IT,dir//'IT'//fortran_PS)
         call make_IO_dir(this%GP,dir//'GP'//fortran_PS)
         call make_IO_dir(this%MP,dir//'MP'//fortran_PS)
         call make_IO_dir(this%coupled,dir//'coupled'//fortran_PS)
         call make_IO_dir(this%FCL,dir//'FCL'//fortran_PS)
         call make_IO_dir(this%TSP,dir//'TSP'//fortran_PS)
         call make_IO_dir(this%SCP,dir//'SCP'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_sim_params(this,dir)
         implicit none
         type(sim_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%PS_mom,dir//'PS_mom'//fortran_PS)
         call export_structured(this%PS_ind,dir//'PS_ind'//fortran_PS)
         call export_structured(this%PS_nrg,dir//'PS_nrg'//fortran_PS)
         call export_structured(this%VS,dir//'VS'//fortran_PS)
         call export_structured(this%MP_mom,dir//'MP_mom'//fortran_PS)
         call export_structured(this%MQP,dir//'MQP'//fortran_PS)
         call export_structured(this%MP_ind,dir//'MP_ind'//fortran_PS)
         call export_structured(this%MP_sigma,dir//'MP_sigma'//fortran_PS)
         call export_structured(this%DP,dir//'DP'//fortran_PS)
         call export_structured(this%EL,dir//'EL'//fortran_PS)
         call export_structured(this%EF,dir//'EF'//fortran_PS)
         call export_structured(this%ET,dir//'ET'//fortran_PS)
         call export_structured(this%MT,dir//'MT'//fortran_PS)
         call export_structured(this%IT,dir//'IT'//fortran_PS)
         call export_structured(this%GP,dir//'GP'//fortran_PS)
         call export_structured(this%MP,dir//'MP'//fortran_PS)
         call export_structured(this%coupled,dir//'coupled'//fortran_PS)
         call export_structured(this%FCL,dir//'FCL'//fortran_PS)
         call export_structured(this%TSP,dir//'TSP'//fortran_PS)
         call export_structured(this%SCP,dir//'SCP'//fortran_PS)
       end subroutine

       subroutine export_structured_D_sim_params(this,dir)
         implicit none
         type(sim_params),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%PS_mom,dir//'PS_mom'//fortran_PS)
         call export_structured(this%PS_ind,dir//'PS_ind'//fortran_PS)
         call export_structured(this%PS_nrg,dir//'PS_nrg'//fortran_PS)
         call export_structured(this%VS,dir//'VS'//fortran_PS)
         call export_structured(this%MP_mom,dir//'MP_mom'//fortran_PS)
         call export_structured(this%MQP,dir//'MQP'//fortran_PS)
         call export_structured(this%MP_ind,dir//'MP_ind'//fortran_PS)
         call export_structured(this%MP_sigma,dir//'MP_sigma'//fortran_PS)
         call export_structured(this%DP,dir//'DP'//fortran_PS)
         call export_structured(this%EL,dir//'EL'//fortran_PS)
         call export_structured(this%EF,dir//'EF'//fortran_PS)
         call export_structured(this%ET,dir//'ET'//fortran_PS)
         call export_structured(this%MT,dir//'MT'//fortran_PS)
         call export_structured(this%IT,dir//'IT'//fortran_PS)
         call export_structured(this%GP,dir//'GP'//fortran_PS)
         call export_structured(this%MP,dir//'MP'//fortran_PS)
         call export_structured(this%coupled,dir//'coupled'//fortran_PS)
         call export_structured(this%FCL,dir//'FCL'//fortran_PS)
         call export_structured(this%TSP,dir//'TSP'//fortran_PS)
         call export_structured(this%SCP,dir//'SCP'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_sim_params(this,dir)
         implicit none
         type(sim_params),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%PS_mom,dir//'PS_mom'//fortran_PS)
         call import_structured(this%PS_ind,dir//'PS_ind'//fortran_PS)
         call import_structured(this%PS_nrg,dir//'PS_nrg'//fortran_PS)
         call import_structured(this%VS,dir//'VS'//fortran_PS)
         call import_structured(this%MP_mom,dir//'MP_mom'//fortran_PS)
         call import_structured(this%MQP,dir//'MQP'//fortran_PS)
         call import_structured(this%MP_ind,dir//'MP_ind'//fortran_PS)
         call import_structured(this%MP_sigma,dir//'MP_sigma'//fortran_PS)
         call import_structured(this%DP,dir//'DP'//fortran_PS)
         call import_structured(this%EL,dir//'EL'//fortran_PS)
         call import_structured(this%EF,dir//'EF'//fortran_PS)
         call import_structured(this%ET,dir//'ET'//fortran_PS)
         call import_structured(this%MT,dir//'MT'//fortran_PS)
         call import_structured(this%IT,dir//'IT'//fortran_PS)
         call import_structured(this%GP,dir//'GP'//fortran_PS)
         call import_structured(this%MP,dir//'MP'//fortran_PS)
         call import_structured(this%coupled,dir//'coupled'//fortran_PS)
         call import_structured(this%FCL,dir//'FCL'//fortran_PS)
         call import_structured(this%TSP,dir//'TSP'//fortran_PS)
         call import_structured(this%SCP,dir//'SCP'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_sim_params(this)
         implicit none
         type(sim_params),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module var_set_extend_mod
       use var_set_mod
       use var_mod
       use var_extend_mod
       use iter_solver_params_mod
       use iter_solver_params_extend_mod
       use time_marching_params_mod
       use time_marching_params_extend_mod
       use string_mod
       use path_extend_mod
       use dir_tree_mod
       use current_precision_mod
       implicit none

       private
       public :: print_info
       public :: couple_time_step

       public :: assign_beta
       public :: assign_coeff_implicit
       public :: assign_coeff_explicit

       public :: sanity_check

       public :: import_TMP_dt
       public :: import_exit_criteria

       interface print_info;            module procedure print_info_VS;            end interface

       interface couple_time_step;      module procedure couple_time_step_VS;      end interface
       interface assign_beta;           module procedure assign_beta_VS;           end interface
       interface assign_coeff_implicit; module procedure assign_coeff_implicit_VS; end interface
       interface assign_coeff_explicit; module procedure assign_coeff_explicit_VS; end interface

       interface sanity_check;          module procedure sanity_check_VS;          end interface

       interface import_exit_criteria;  module procedure import_exit_criteria_VS;  end interface
       interface import_TMP_dt;         module procedure import_TMP_dt_VS;         end interface

       contains

       subroutine couple_time_step_VS(VS,coupled)
         implicit none
         type(var_set),intent(inout) :: VS
         type(time_marching_params),intent(in) :: coupled
         call couple_time_step(VS%T%TMP  ,coupled)
         call couple_time_step(VS%U%TMP  ,coupled)
         call couple_time_step(VS%P%TMP  ,coupled)
         call couple_time_step(VS%B%TMP  ,coupled)
         call couple_time_step(VS%B0%TMP ,coupled)
         call couple_time_step(VS%phi%TMP,coupled)
         call couple_time_step(VS%rho%TMP,coupled)
       end subroutine

       subroutine assign_beta_VS(VS)
         implicit none
         type(var_set),intent(inout) :: VS
         VS%B%MFP%beta   = 1.0_cp - VS%B%MFP%alpha ! weight of explicit treatment
         VS%U%MFP%beta   = 1.0_cp - VS%U%MFP%alpha ! weight of explicit treatment
         VS%T%MFP%beta   = 1.0_cp - VS%T%MFP%alpha ! weight of explicit treatment
         VS%phi%MFP%beta = 0.0_cp                  ! Poisson, coefficient unused
         VS%p%MFP%beta   = 0.0_cp                  ! Poisson, coefficient unused
         VS%rho%MFP%beta = 0.0_cp                  ! Poisson, coefficient unused
       end subroutine

       subroutine assign_coeff_explicit_VS(VS)
         implicit none
         type(var_set),intent(inout) :: VS
         VS%B%MFP%coeff_explicit   = VS%B%MFP%coeff_natural*VS%B%MFP%beta ! RHS diffusion coefficient
         VS%U%MFP%coeff_explicit   = VS%U%MFP%coeff_natural*VS%U%MFP%beta ! RHS diffusion coefficient
         VS%T%MFP%coeff_explicit   = VS%T%MFP%coeff_natural*VS%T%MFP%beta ! RHS diffusion coefficient
         VS%phi%MFP%coeff_explicit = 0.0_cp ! Poisson, coefficient unused
         VS%p%MFP%coeff_explicit   = 0.0_cp ! Poisson, coefficient unused
         VS%rho%MFP%coeff_explicit = 0.0_cp ! Poisson, coefficient unused
       end subroutine

       subroutine assign_coeff_implicit_VS(VS)
         implicit none
         type(var_set),intent(inout) :: VS
         VS%B%MFP%coeff_implicit   = -VS%B%MFP%coeff_natural*VS%B%MFP%alpha ! LHS diffusion coefficient
         VS%U%MFP%coeff_implicit   = -VS%U%MFP%coeff_natural*VS%U%MFP%alpha ! LHS diffusion coefficient
         VS%T%MFP%coeff_implicit   = -VS%T%MFP%coeff_natural*VS%T%MFP%alpha ! LHS diffusion coefficient
         VS%phi%MFP%coeff_implicit = 0.0_cp ! Poisson, coefficient unused
         VS%p%MFP%coeff_implicit   = 0.0_cp ! Poisson, coefficient unused
         VS%rho%MFP%coeff_implicit = 0.0_cp ! Poisson, coefficient unused
       end subroutine

       subroutine sanity_check_VS(VS)
         implicit none
         type(var_set),intent(in) :: VS
         if (VS%T%SS%solve  .and.(.not.VS%T%SS%initialize))   stop 'Error: solve but not init? T in var_set.f90'
         if (VS%U%SS%solve  .and.(.not.VS%U%SS%initialize))   stop 'Error: solve but not init? U in var_set.f90'
         if (VS%P%SS%solve  .and.(.not.VS%P%SS%initialize))   stop 'Error: solve but not init? P in var_set.f90'
         if (VS%B%SS%solve  .and.(.not.VS%B%SS%initialize))   stop 'Error: solve but not init? B in var_set.f90'
         if (VS%B0%SS%solve .and.(.not.VS%B0%SS%initialize))  stop 'Error: solve but not init? B0 in var_set.f90'
         if (VS%phi%SS%solve.and.(.not.VS%phi%SS%initialize)) stop 'Error: solve but not init? phi in var_set.f90'
         if (VS%rho%SS%solve.and.(.not.VS%rho%SS%initialize)) stop 'Error: solve but not init? rho in var_set.f90'
         if (window(VS%T%MFP%alpha,0.0_cp,1.0_cp)) stop 'Error: 0<alpha(T)<1 not true in var_set.f90'
         if (window(VS%U%MFP%alpha,0.0_cp,1.0_cp)) stop 'Error: 0<alpha(U)<1 not true in var_set.f90'
         if (window(VS%B%MFP%alpha,0.0_cp,1.0_cp)) stop 'Error: 0<alpha(B)<1 not true in var_set.f90'
       end subroutine

       function window(alpha,min_val,max_val) result(L)
         implicit none
         real(cp),intent(in) :: alpha,min_val,max_val
         logical :: L
         L = (alpha.lt.min_val).or.(alpha.gt.max_val)
       end function

       subroutine import_TMP_dt_VS(VS)
         implicit none
         type(var_set),intent(inout) :: VS
         if (VS%T%SS%initialize)   call import_structured(VS%T%TMP%TS)
         if (VS%U%SS%initialize)   call import_structured(VS%U%TMP%TS)
         if (VS%P%SS%initialize)   call import_structured(VS%P%TMP%TS)
         if (VS%B%SS%initialize)   call import_structured(VS%B%TMP%TS)
         if (VS%B0%SS%initialize)  call import_structured(VS%B0%TMP%TS)
         if (VS%phi%SS%initialize) call import_structured(VS%phi%TMP%TS)
         if (VS%rho%SS%initialize) call import_structured(VS%rho%TMP%TS)
       end subroutine

       subroutine import_exit_criteria_VS(VS)
         implicit none
         type(var_set),intent(inout) :: VS
         if(VS%T%SS%initialize) call import_structured(VS%T%ISP%EC)
         if(VS%U%SS%initialize) call import_structured(VS%U%ISP%EC)
         if(VS%P%SS%initialize) call import_structured(VS%P%ISP%EC)
         if(VS%B%SS%initialize) call import_structured(VS%B%ISP%EC)
         if(VS%B0%SS%initialize) call import_structured(VS%B0%ISP%EC)
         if(VS%phi%SS%initialize) call import_structured(VS%phi%ISP%EC)
         if(VS%rho%SS%initialize) call import_structured(VS%rho%ISP%EC)
       end subroutine

       subroutine print_info_VS(VS)
         implicit none
         type(var_set),intent(in) :: VS
         if (VS%T%SS%initialize)   call print_info(VS%T)
         if (VS%U%SS%initialize)   call print_info(VS%U)
         if (VS%P%SS%initialize)   call print_info(VS%P)
         if (VS%B%SS%initialize)   call print_info(VS%B)
         if (VS%B0%SS%initialize)  call print_info(VS%B0)
         if (VS%phi%SS%initialize) call print_info(VS%phi)
         if (VS%rho%SS%initialize) call print_info(VS%rho)
       end subroutine

       end module
      module GF_export_mod
      use data_location_extend_mod
      use string_mod
      use grid_field_mod
      use grid_mod
      use grid_extend_mod
      use array_mod
      use array_extend_mod
      use datatype_conversion_mod
      use current_precision_mod
      use face_edge_corner_indexing_mod
      use exp_Tecplot_Zone_mod
      implicit none

      logical :: export_mid_plane = .false.
      logical :: export_mid_line  = .false.
      private
      public :: exp_3D_3C_GF,exp_3D_2C_GF,exp_3D_1C_GF,exp_3D_0C_GF ! 3D Fields
      public :: exp_2D_3C_GF,exp_2D_2C_GF,exp_2D_1C_GF,exp_2D_0C_GF ! 2D Fields
      public :: exp_1D_3C_GF,exp_1D_2C_GF,exp_1D_1C_GF,exp_1D_0C_GF ! 1D Fields

      contains

      ! ***********************************************************************
      ! ****************************** 3D FIELDS ******************************
      ! ***********************************************************************

      subroutine exp_3D_3C_GF(g,DL,t,pad,un,u,v,w)
        implicit none
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer,intent(in) :: un,pad,t
        type(grid_field),intent(in) :: u,v,w
        type(array),dimension(3) :: h
        integer,dimension(3) :: s
        integer :: i,j,k
        s = get_shape(g,DL)
        call exp_Zone_3I(un,s-2*pad,t)
        call get_coordinates_h(h,g,DL)
        do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
          write(un,*) h(1)%f(i),&
                      h(2)%f(j),&
                      h(3)%f(k),&
                      u%f(i,j,k),v%f(i,j,k),w%f(i,j,k)
        enddo; enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine exp_3D_2C_GF(g,DL,t,pad,un,u,v)
        implicit none
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer,intent(in) :: un,pad,t
        type(grid_field),intent(in) :: u,v
        type(array),dimension(3) :: h
        integer,dimension(3) :: s
        integer :: i,j,k
        s = get_shape(g,DL)
        call exp_Zone_3I(un,s-2*pad,t)
        call get_coordinates_h(h,g,DL)
        do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
          write(un,*) h(1)%f(i),&
                      h(2)%f(j),&
                      h(3)%f(k),&
                      u%f(i,j,k),v%f(i,j,k)
        enddo; enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine exp_3D_1C_GF(g,DL,t,pad,un,u)
        implicit none
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer,intent(in) :: un,pad,t
        type(grid_field),intent(in) :: u
        type(array),dimension(3) :: h
        integer,dimension(3) :: s
        integer :: i,j,k
        s = get_shape(g,DL)
        call exp_Zone_3I(un,s-2*pad,t)
        call get_coordinates_h(h,g,DL)
        do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
          write(un,*) h(1)%f(i),&
                      h(2)%f(j),&
                      h(3)%f(k),&
                      u%f(i,j,k)
        enddo; enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine exp_3D_0C_GF(g,DL,t,pad,un,u)
        implicit none
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer,intent(in) :: un,pad,t
        real(cp),intent(in) :: u
        type(array),dimension(3) :: h
        integer,dimension(3) :: s
        integer :: i,j,k
        s = get_shape(g,DL)
        call exp_Zone_3I(un,s-2*pad,t)
        call get_coordinates_h(h,g,DL)
        do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
          write(un,*) h(1)%f(i),&
                      h(2)%f(j),&
                      h(3)%f(k),&
                      u
        enddo; enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      ! ***********************************************************************
      ! ****************************** 2D FIELDS ******************************
      ! ***********************************************************************

      subroutine exp_2D_3C_GF(g,DL,t,pad,un,u,v,w,dir,plane)
        implicit none
        integer,intent(in) :: un,pad,dir,plane,t
        type(grid_field),intent(in) :: u,v,w
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,j,i_p,j_p,k_p,p
        integer,dimension(3) :: s,e
        integer,dimension(2) :: d,s_2D
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        s_2D = adj_shape_given_dir(s,dir)
        call exp_Zone_2I(un,s_2D-2*pad,t)
        call get_coordinates_h(h,g,DL)
        p = get_p_plane_used(g,dir,plane)
        call write_tec_comment_plane(un,h,dir,p)
        do j=1+pad,s(d(2))-pad; do i=1+pad,s(d(1))-pad
          i_p = e(1)*p + i*(1-e(1))
          j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
          k_p = e(3)*p + j*(1-e(3))
          write(un,*) h(d(1))%f(i),&
                      h(d(2))%f(j),&
                      u%f(i_p,j_p,k_p),&
                      v%f(i_p,j_p,k_p),&
                      w%f(i_p,j_p,k_p)
        enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine exp_2D_2C_GF(g,DL,t,pad,un,u,v,dir,plane)
        implicit none
        integer,intent(in) :: un,pad,dir,plane,t
        type(grid_field),intent(in) :: u,v
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,j,i_p,j_p,k_p,p
        integer,dimension(3) :: s,e
        integer,dimension(2) :: d,s_2D
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        s_2D = adj_shape_given_dir(s,dir)
        call exp_Zone_2I(un,s_2D-2*pad,t)
        call get_coordinates_h(h,g,DL)
        p = get_p_plane_used(g,dir,plane)
        call write_tec_comment_plane(un,h,dir,p)
        do j=1+pad,s(d(2))-pad; do i=1+pad,s(d(1))-pad
          i_p = e(1)*p + i*(1-e(1))
          j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
          k_p = e(3)*p + j*(1-e(3))
          write(un,*) h(d(1))%f(i),&
                      h(d(2))%f(j),&
                      u%f(i_p,j_p,k_p),&
                      v%f(i_p,j_p,k_p)
        enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine exp_2D_1C_GF(g,DL,t,pad,un,u,dir,plane)
        implicit none
        integer,intent(in) :: un,pad,dir,plane,t
        type(grid_field),intent(in) :: u
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,j,i_p,j_p,k_p,p
        integer,dimension(3) :: s,e
        integer,dimension(2) :: d,s_2D
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        s_2D = adj_shape_given_dir(s,dir)
        call exp_Zone_2I(un,s_2D-2*pad,t)
        call get_coordinates_h(h,g,DL)
        p = get_p_plane_used(g,dir,plane)
        call write_tec_comment_plane(un,h,dir,p)
        do j=1+pad,s(d(2))-pad; do i=1+pad,s(d(1))-pad
          i_p = e(1)*p + i*(1-e(1))
          j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
          k_p = e(3)*p + j*(1-e(3))
          write(un,*) h(d(1))%f(i),&
                      h(d(2))%f(j),&
                      u%f(i_p,j_p,k_p)
        enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine exp_2D_0C_GF(g,DL,t,pad,un,u,dir,plane)
        implicit none
        integer,intent(in) :: un,pad,dir,plane,t
        real(cp),intent(in) :: u
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,j,i_p,j_p,k_p,p
        integer,dimension(3) :: s,e
        integer,dimension(2) :: d,s_2D
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        s_2D = adj_shape_given_dir(s,dir)
        call exp_Zone_2I(un,s_2D-2*pad,t)
        call get_coordinates_h(h,g,DL)
        p = get_p_plane_used(g,dir,plane)
        call write_tec_comment_plane(un,h,dir,p)
        do j=1+pad,s(d(2))-pad; do i=1+pad,s(d(1))-pad
          i_p = e(1)*p + i*(1-e(1))
          j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
          k_p = e(3)*p + j*(1-e(3))
          write(un,*) h(d(1))%f(i),&
                      h(d(2))%f(j),&
                      u
        enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      ! ***********************************************************************
      ! ****************************** 1D FIELDS ******************************
      ! ***********************************************************************

      subroutine exp_1D_3C_GF(g,DL,t,pad,un,u,v,w,dir,line)
        implicit none
        integer,intent(in) :: un,pad,dir,t
        integer,dimension(2),intent(in) :: line
        type(grid_field),intent(in) :: u,v,w
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,i_L,j_L,k_L
        integer,dimension(3) :: s,e,i_line,i_line_used
        integer,dimension(2) :: d
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        i_line(d(1)) = line(1)
        i_line(d(2)) = line(2)
        i_line(dir)  = 0 ! multiplied by zero anyway
        call exp_Zone_1I(un,s(dir)-2*pad,t)
        call get_coordinates_h(h,g,DL)
        i_line_used = get_i_line_used(g,dir,i_line)
        call write_tec_comment_line(un,h,dir,i_line_used,d)
        do i=1+pad,s(dir)-pad
          i_L = i*e(1)+(1-e(1))*i_line_used(1)
          j_L = i*e(2)+(1-e(2))*i_line_used(2)
          k_L = i*e(3)+(1-e(3))*i_line_used(3)
          write(un,*) h(dir)%f(i),&
                      u%f(i_L,j_L,k_L),&
                      v%f(i_L,j_L,k_L),&
                      w%f(i_L,j_L,k_L)
        enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine exp_1D_2C_GF(g,DL,t,pad,un,u,v,dir,line)
        implicit none
        integer,intent(in) :: un,pad,dir,t
        integer,dimension(2),intent(in) :: line
        type(grid_field),intent(in) :: u,v
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,i_L,j_L,k_L
        integer,dimension(3) :: s,e,i_line,i_line_used
        integer,dimension(2) :: d
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        i_line(d(1)) = line(1)
        i_line(d(2)) = line(2)
        i_line(dir)  = 0 ! multiplied by zero anyway
        call exp_Zone_1I(un,s(dir)-2*pad,t)
        call get_coordinates_h(h,g,DL)
        i_line_used = get_i_line_used(g,dir,i_line)
        call write_tec_comment_line(un,h,dir,i_line_used,d)
        do i=1+pad,s(dir)-pad
          i_L = i*e(1)+(1-e(1))*i_line_used(1)
          j_L = i*e(2)+(1-e(2))*i_line_used(2)
          k_L = i*e(3)+(1-e(3))*i_line_used(3)
          write(un,*) h(dir)%f(i),&
                      u%f(i_L,j_L,k_L),&
                      v%f(i_L,j_L,k_L)
        enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine exp_1D_1C_GF(g,DL,t,pad,un,u,dir,line)
        implicit none
        integer,intent(in) :: un,pad,dir,t
        integer,dimension(2),intent(in) :: line
        type(grid_field),intent(in) :: u
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,i_L,j_L,k_L
        integer,dimension(3) :: s,e,i_line,i_line_used
        integer,dimension(2) :: d
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        i_line(d(1)) = line(1)
        i_line(d(2)) = line(2)
        i_line(dir)  = 0 ! multiplied by zero anyway
        call exp_Zone_1I(un,s(dir)-2*pad,t)
        call get_coordinates_h(h,g,DL)
        i_line_used = get_i_line_used(g,dir,i_line)
        call write_tec_comment_line(un,h,dir,i_line_used,d)
        do i=1+pad,s(dir)-pad
          i_L = i*e(1)+(1-e(1))*i_line_used(1)
          j_L = i*e(2)+(1-e(2))*i_line_used(2)
          k_L = i*e(3)+(1-e(3))*i_line_used(3)
          write(un,*) h(dir)%f(i),&
                      u%f(i_L,j_L,k_L)
        enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine exp_1D_0C_GF(g,DL,t,pad,un,u,dir,line)
        implicit none
        integer,intent(in) :: un,pad,dir,t
        integer,dimension(2),intent(in) :: line
        real(cp),intent(in) :: u
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,i_L,j_L,k_L
        integer,dimension(3) :: s,e,i_line,i_line_used
        integer,dimension(2) :: d
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        i_line(d(1)) = line(1)
        i_line(d(2)) = line(2)
        i_line(dir)  = 0 ! multiplied by zero anyway
        call exp_Zone_1I(un,s(dir)-2*pad,t)
        call get_coordinates_h(h,g,DL)
        i_line_used = get_i_line_used(g,dir,i_line)
        call write_tec_comment_line(un,h,dir,i_line_used,d)
        do i=1+pad,s(dir)-pad
          i_L = i*e(1)+(1-e(1))*i_line_used(1)
          j_L = i*e(2)+(1-e(2))*i_line_used(2)
          k_L = i*e(3)+(1-e(3))*i_line_used(3)
          write(un,*) h(dir)%f(i),&
                      u
        enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      function get_i_line_used(g,dir,i_line) result(i_line_used)
        implicit none
        integer,intent(in) :: dir
        type(grid),intent(in) :: g
        integer,dimension(3),intent(in) :: i_line
        integer,dimension(3) :: i_line_used
        integer,dimension(2) :: d
        d = adj_dir_given_dir(dir)
        if (export_mid_line) then; i_line_used(d(1)) = g%c(d(1))%i_midplane
                                   i_line_used(d(2)) = g%c(d(2))%i_midplane
        else;                      i_line_used = i_line
        endif
      end function

      function get_p_plane_used(g,dir,plane) result(p_plane_used)
        implicit none
        type(grid),intent(in) :: g
        integer,intent(in) :: dir
        integer,intent(in) :: plane
        integer :: p_plane_used
        if (export_mid_plane) then; p_plane_used = g%c(dir)%i_midplane
        else;                       p_plane_used = plane
        endif
      end function

      subroutine write_tec_comment_line(un,h,dir,i_line_used,d)
        implicit none
        integer,intent(in) :: un,dir
        type(array),dimension(3),intent(in) :: h
        integer,dimension(3),intent(in) :: i_line_used
        integer,dimension(2),intent(in) :: d
        integer :: i
        type(string),dimension(5) :: comment
        type(string),dimension(2) :: loc
        character :: c_dir1,c_dir2
        c_dir1 = xyz_given_dir(d(1))
        c_dir2 = xyz_given_dir(d(2))
        call init(loc(1),cp2str(h(d(1))%f(i_line_used(d(1)))))
        call init(loc(2),cp2str(h(d(2))%f(i_line_used(d(2)))))
        call init(comment(1),'# Line direction = '//int2str(dir))
        call init(comment(2),'# Line index('//c_dir1//')  = '//int2str(i_line_used(d(1))))
        call init(comment(3),'# Line index('//c_dir2//')  = '//int2str(i_line_used(d(2))))
        call init(comment(4),'# Line location('//c_dir1//')  = '//str(loc(1)))
        call init(comment(5),'# Line location('//c_dir2//')  = '//str(loc(2)))
        do i=1,5; call write_formatted(comment(i),un); enddo
        do i=1,5; call delete(comment(i)); enddo
        do i=1,2; call delete(loc(i)); enddo
      end subroutine

      subroutine write_tec_comment_plane(un,h,dir,p_plane_used)
        implicit none
        integer,intent(in) :: un,dir
        type(array),dimension(3),intent(in) :: h
        integer,intent(in) :: p_plane_used
        integer :: i
        type(string),dimension(3) :: comment
        type(string) :: loc
        character :: c_dir
        c_dir = xyz_given_dir(dir)
        call init(loc,cp2str(h(dir)%f(p_plane_used)))
        call init(comment(1),'# Plane direction = '//int2str(dir))
        call init(comment(2),'# Plane index('//c_dir//')  = '//int2str(p_plane_used))
        call init(comment(3),'# Plane location('//c_dir//')  = '//str(loc))
        do i=1,3; call write_formatted(comment(i),un); enddo
        do i=1,3; call delete(comment(i)); enddo
        call delete(loc)
      end subroutine

      end module
      module GF_import_mod
      use data_location_extend_mod
      use grid_field_mod
      use grid_mod
      use grid_extend_mod
      use array_mod
      use array_extend_mod
      use current_precision_mod
      use face_edge_corner_indexing_mod
      use exp_Tecplot_Zone_mod
      implicit none

      private

      public :: imp_3D_3C_GF,imp_3D_2C_GF,imp_3D_1C_GF,imp_3D_0C_GF ! 3D Fields
      public :: imp_2D_3C_GF,imp_2D_2C_GF,imp_2D_1C_GF,imp_2D_0C_GF ! 2D Fields
      public :: imp_1D_3C_GF,imp_1D_2C_GF,imp_1D_1C_GF,imp_1D_0C_GF ! 1D Fields

      contains

      ! ***********************************************************************
      ! ****************************** 3D FIELDS ******************************
      ! ***********************************************************************

      subroutine imp_3D_3C_GF(g,DL,pad,un,u,v,w)
        implicit none
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer,intent(in) :: un,pad
        type(grid_field),intent(inout) :: u,v,w
        type(array),dimension(3) :: h
        integer,dimension(3) :: s
        integer :: i,j,k
        s = get_shape(g,DL)
        ! call exp_Zone_3I(un,s-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
           read(un,*) h(1)%f(i),&
                      h(2)%f(j),&
                      h(3)%f(k),&
                      u%f(i,j,k),v%f(i,j,k),w%f(i,j,k)
        enddo; enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine imp_3D_2C_GF(g,DL,pad,un,u,v)
        implicit none
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer,intent(in) :: un,pad
        type(grid_field),intent(inout) :: u,v
        type(array),dimension(3) :: h
        integer,dimension(3) :: s
        integer :: i,j,k
        s = get_shape(g,DL)
        ! call exp_Zone_3I(un,s-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
           read(un,*) h(1)%f(i),&
                      h(2)%f(j),&
                      h(3)%f(k),&
                      u%f(i,j,k),v%f(i,j,k)
        enddo; enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine imp_3D_1C_GF(g,DL,pad,un,u)
        implicit none
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer,intent(in) :: un,pad
        type(grid_field),intent(inout) :: u
        type(array),dimension(3) :: h
        integer,dimension(3) :: s
        integer :: i,j,k
        s = get_shape(g,DL)
        ! call exp_Zone_3I(un,s-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
           read(un,*) h(1)%f(i),&
                      h(2)%f(j),&
                      h(3)%f(k),&
                      u%f(i,j,k)
        enddo; enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine imp_3D_0C_GF(g,DL,pad,un,u)
        implicit none
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer,intent(in) :: un,pad
        real(cp),intent(inout) :: u
        type(array),dimension(3) :: h
        integer,dimension(3) :: s
        integer :: i,j,k
        s = get_shape(g,DL)
        ! call exp_Zone_3I(un,s-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do k=1+pad,s(3)-pad; do j=1+pad,s(2)-pad; do i=1+pad,s(1)-pad
           read(un,*) h(1)%f(i),&
                      h(2)%f(j),&
                      h(3)%f(k),&
                      u
        enddo; enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      ! ***********************************************************************
      ! ****************************** 2D FIELDS ******************************
      ! ***********************************************************************

      subroutine imp_2D_3C_GF(g,DL,pad,un,u,v,w,dir,plane)
        implicit none
        integer,intent(in) :: un,pad,dir,plane
        type(grid_field),intent(inout) :: u,v,w
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,j,i_p,j_p,k_p
        integer,dimension(3) :: s,e
        integer,dimension(2) :: d,s_2D
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        s_2D = adj_shape_given_dir(s,dir)
        ! call exp_Zone_2I(un,s_2D-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do j=1+pad,s(d(2))-pad; do i=1+pad,s(d(1))-pad
          i_p = e(1)*plane + i*(1-e(1))
          j_p = e(2)*plane + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
          k_p = e(3)*plane + j*(1-e(3))
           read(un,*) h(d(1))%f(i),&
                      h(d(2))%f(j),&
                      u%f(i_p,j_p,k_p),&
                      v%f(i_p,j_p,k_p),&
                      w%f(i_p,j_p,k_p)
        enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine imp_2D_2C_GF(g,DL,pad,un,u,v,dir,plane)
        implicit none
        integer,intent(in) :: un,pad,dir,plane
        type(grid_field),intent(inout) :: u,v
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,j,i_p,j_p,k_p
        integer,dimension(3) :: s,e
        integer,dimension(2) :: d,s_2D
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        s_2D = adj_shape_given_dir(s,dir)
        ! call exp_Zone_2I(un,s_2D-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do j=1+pad,s(d(2))-pad; do i=1+pad,s(d(1))-pad
          i_p = e(1)*plane + i*(1-e(1))
          j_p = e(2)*plane + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
          k_p = e(3)*plane + j*(1-e(3))
           read(un,*) h(d(1))%f(i),&
                      h(d(2))%f(j),&
                      u%f(i_p,j_p,k_p),&
                      v%f(i_p,j_p,k_p)
        enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine imp_2D_1C_GF(g,DL,pad,un,u,dir,plane)
        implicit none
        integer,intent(in) :: un,pad,dir,plane
        type(grid_field),intent(inout) :: u
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,j,i_p,j_p,k_p
        integer,dimension(3) :: s,e
        integer,dimension(2) :: d,s_2D
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        s_2D = adj_shape_given_dir(s,dir)
        ! call exp_Zone_2I(un,s_2D-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do j=1+pad,s(d(2))-pad; do i=1+pad,s(d(1))-pad
          i_p = e(1)*plane + i*(1-e(1))
          j_p = e(2)*plane + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
          k_p = e(3)*plane + j*(1-e(3))
           read(un,*) h(d(1))%f(i),&
                      h(d(2))%f(j),&
                      u%f(i_p,j_p,k_p)
        enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine imp_2D_0C_GF(g,DL,pad,un,u,dir,plane)
        implicit none
        integer,intent(in) :: un,pad,dir,plane
        real(cp),intent(inout) :: u
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,j,i_p,j_p,k_p
        integer,dimension(3) :: s,e
        integer,dimension(2) :: d,s_2D
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        s_2D = adj_shape_given_dir(s,dir)
        ! call exp_Zone_2I(un,s_2D-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do j=1+pad,s(d(2))-pad; do i=1+pad,s(d(1))-pad
          i_p = e(1)*plane + i*(1-e(1))
          j_p = e(2)*plane + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
          k_p = e(3)*plane + j*(1-e(3))
           read(un,*) h(d(1))%f(i),&
                      h(d(2))%f(j),&
                      u
        enddo; enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      ! ***********************************************************************
      ! ****************************** 1D FIELDS ******************************
      ! ***********************************************************************

      subroutine imp_1D_3C_GF(g,DL,pad,un,u,v,w,dir,line)
        implicit none
        integer,intent(in) :: un,pad,dir
        integer,dimension(2),intent(in) :: line
        type(grid_field),intent(inout) :: u,v,w
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,i_L,j_L,k_L
        integer,dimension(3) :: s,e,i_line
        integer,dimension(2) :: d
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        i_line(d(1)) = line(d(1))
        i_line(d(2)) = line(d(2))
        i_line(dir)  = 0 ! multiplied by zero anyway
        ! call exp_Zone_1I(un,s(dir)-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do i=1+pad,s(dir)-pad
          i_L = i*e(1)+(1-e(1))*i_line(1)
          j_L = i*e(2)+(1-e(2))*i_line(2)
          k_L = i*e(3)+(1-e(3))*i_line(3)
           read(un,*) h(dir)%f(i),&
                      u%f(i_L,j_L,k_L),&
                      v%f(i_L,j_L,k_L),&
                      w%f(i_L,j_L,k_L)
        enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine imp_1D_2C_GF(g,DL,pad,un,u,v,dir,line)
        implicit none
        integer,intent(in) :: un,pad,dir
        integer,dimension(2),intent(in) :: line
        type(grid_field),intent(inout) :: u,v
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,i_L,j_L,k_L
        integer,dimension(3) :: s,e,i_line
        integer,dimension(2) :: d
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        i_line(d(1)) = line(d(1))
        i_line(d(2)) = line(d(2))
        i_line(dir)  = 0 ! multiplied by zero anyway
        ! call exp_Zone_1I(un,s(dir)-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do i=1+pad,s(dir)-pad
          i_L = i*e(1)+(1-e(1))*i_line(1)
          j_L = i*e(2)+(1-e(2))*i_line(2)
          k_L = i*e(3)+(1-e(3))*i_line(3)
           read(un,*) h(dir)%f(i),&
                      u%f(i_L,j_L,k_L),&
                      v%f(i_L,j_L,k_L)
        enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine imp_1D_1C_GF(g,DL,pad,un,u,dir,line)
        implicit none
        integer,intent(in) :: un,pad,dir
        integer,dimension(2),intent(in) :: line
        type(grid_field),intent(inout) :: u
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,i_L,j_L,k_L
        integer,dimension(3) :: s,e,i_line
        integer,dimension(2) :: d
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        i_line(d(1)) = line(d(1))
        i_line(d(2)) = line(d(2))
        i_line(dir)  = 0 ! multiplied by zero anyway
        ! call exp_Zone_1I(un,s(dir)-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do i=1+pad,s(dir)-pad
          i_L = i*e(1)+(1-e(1))*i_line(1)
          j_L = i*e(2)+(1-e(2))*i_line(2)
          k_L = i*e(3)+(1-e(3))*i_line(3)
           read(un,*) h(dir)%f(i),&
                      u%f(i_L,j_L,k_L)
        enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      subroutine imp_1D_0C_GF(g,DL,pad,un,u,dir,line)
        implicit none
        integer,intent(in) :: un,pad,dir
        integer,dimension(2),intent(in) :: line
        real(cp),intent(inout) :: u
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        type(array),dimension(3) :: h
        integer :: i,i_L,j_L,k_L
        integer,dimension(3) :: s,e,i_line
        integer,dimension(2) :: d
        s = get_shape(g,DL)
        d = adj_dir_given_dir(dir)
        e = eye_given_dir(dir)
        i_line(d(1)) = line(d(1))
        i_line(d(2)) = line(d(2))
        i_line(dir)  = 0 ! multiplied by zero anyway
        ! call exp_Zone_1I(un,s(dir)-2*pad,t)
        read(un,*)
        call get_coordinates_h(h,g,DL)
        do i=1+pad,s(dir)-pad
          i_L = i*e(1)+(1-e(1))*i_line(1)
          j_L = i*e(2)+(1-e(2))*i_line(2)
          k_L = i*e(3)+(1-e(3))*i_line(3)
           read(un,*) h(dir)%f(i),&
                      u
        enddo
        do i=1,3; call delete(h(i)); enddo
      end subroutine

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module boundary_conditions_mod
       use boundary_mod
       use datatype_conversion_mod
       use face_SD_mod
       use procedure_array_mod
       use IO_tools_mod
       use string_mod
       use data_location_mod
       use BC_logicals_mod
       use dir_manip_mod
       implicit none

       private
       public :: boundary_conditions
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_boundary_conditions;              end interface
       interface delete;                 module procedure delete_boundary_conditions;                 end interface
       interface display;                module procedure display_boundary_conditions;                end interface
       interface display_short;          module procedure display_short_boundary_conditions;          end interface
       interface display;                module procedure display_wrap_boundary_conditions;           end interface
       interface print;                  module procedure print_boundary_conditions;                  end interface
       interface print_short;            module procedure print_short_boundary_conditions;            end interface
       interface export;                 module procedure export_boundary_conditions;                 end interface
       interface export_primitives;      module procedure export_primitives_boundary_conditions;      end interface
       interface import;                 module procedure import_boundary_conditions;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_boundary_conditions;end interface
       interface export_structured;      module procedure export_structured_D_boundary_conditions;    end interface
       interface import_structured;      module procedure import_structured_D_boundary_conditions;    end interface
       interface import_primitives;      module procedure import_primitives_boundary_conditions;      end interface
       interface export;                 module procedure export_wrap_boundary_conditions;            end interface
       interface import;                 module procedure import_wrap_boundary_conditions;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_boundary_conditions;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_boundary_conditions;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_boundary_conditions;      end interface

       type boundary_conditions
         type(BC_logicals) :: BCL
         integer,dimension(6) :: apply_BC_order = 0
         type(data_location) :: DL
         type(boundary) :: face
         type(procedure_array) :: PA_face_BCs
         type(procedure_array) :: PA_face_implicit_BCs
         type(face_SD) :: f_BCs
       end type

       contains

       subroutine init_copy_boundary_conditions(this,that)
         implicit none
         type(boundary_conditions),intent(inout) :: this
         type(boundary_conditions),intent(in) :: that
         call delete(this)
         call init(this%BCL,that%BCL)
         this%apply_BC_order = that%apply_BC_order
         call init(this%DL,that%DL)
         call init(this%face,that%face)
         call init(this%PA_face_BCs,that%PA_face_BCs)
         call init(this%PA_face_implicit_BCs,that%PA_face_implicit_BCs)
         call init(this%f_BCs,that%f_BCs)
       end subroutine

       subroutine delete_boundary_conditions(this)
         implicit none
         type(boundary_conditions),intent(inout) :: this
         call delete(this%BCL)
         this%apply_BC_order = 0
         call delete(this%DL)
         call delete(this%face)
         call delete(this%PA_face_BCs)
         call delete(this%PA_face_implicit_BCs)
         call delete(this%f_BCs)
       end subroutine

       subroutine display_boundary_conditions(this,un)
         implicit none
         type(boundary_conditions),intent(in) :: this
         integer,intent(in) :: un
         call display(this%BCL,un)
         write(un,*) 'apply_BC_order       = ',this%apply_BC_order
         call display(this%DL,un)
         call display(this%face,un)
         call display(this%PA_face_BCs,un)
         call display(this%PA_face_implicit_BCs,un)
         call display(this%f_BCs,un)
       end subroutine

       subroutine display_short_boundary_conditions(this,un)
         implicit none
         type(boundary_conditions),intent(in) :: this
         integer,intent(in) :: un
         call display(this%BCL,un)
         write(un,*) 'apply_BC_order       = ',this%apply_BC_order
         call display(this%DL,un)
         call display(this%face,un)
         call display(this%PA_face_BCs,un)
         call display(this%PA_face_implicit_BCs,un)
         call display(this%f_BCs,un)
       end subroutine

       subroutine display_wrap_boundary_conditions(this,dir,name)
         implicit none
         type(boundary_conditions),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_boundary_conditions(this)
         implicit none
         type(boundary_conditions),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_boundary_conditions(this)
         implicit none
         type(boundary_conditions),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_boundary_conditions(this,un)
         implicit none
         type(boundary_conditions),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%BCL,un)
         call export(this%DL,un)
         call export(this%face,un)
         call export(this%PA_face_BCs,un)
         call export(this%PA_face_implicit_BCs,un)
         call export(this%f_BCs,un)
       end subroutine

       subroutine import_boundary_conditions(this,un)
         implicit none
         type(boundary_conditions),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%BCL,un)
         call import(this%DL,un)
         call import(this%face,un)
         call import(this%PA_face_BCs,un)
         call import(this%PA_face_implicit_BCs,un)
         call import(this%f_BCs,un)
       end subroutine

       subroutine export_primitives_boundary_conditions(this,un)
         implicit none
         type(boundary_conditions),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'apply_BC_order        = ';write(un,*) this%apply_BC_order
       end subroutine

       subroutine import_primitives_boundary_conditions(this,un)
         implicit none
         type(boundary_conditions),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%apply_BC_order
       end subroutine

       subroutine export_wrap_boundary_conditions(this,dir,name)
         implicit none
         type(boundary_conditions),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_boundary_conditions(this,dir,name)
         implicit none
         type(boundary_conditions),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_boundary_conditions(this,dir)
         implicit none
         type(boundary_conditions),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%BCL,dir//'BCL'//fortran_PS)
         if (this%BCL%defined) then
           call set_IO_dir(this%DL,dir//'DL'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call set_IO_dir(this%face,dir//'face'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call set_IO_dir(this%PA_face_BCs,dir//'PA_face_BCs'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call set_IO_dir(this%PA_face_implicit_BCs,&
           dir//'PA_face_implicit_BCs'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call set_IO_dir(this%f_BCs,dir//'f_BCs'//fortran_PS)
         endif
       end subroutine

       subroutine make_IO_dir_boundary_conditions(this,dir)
         implicit none
         type(boundary_conditions),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%BCL,dir//'BCL'//fortran_PS)
         if (this%BCL%defined) then
           call make_IO_dir(this%DL,dir//'DL'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call make_IO_dir(this%face,dir//'face'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call make_IO_dir(this%PA_face_BCs,dir//'PA_face_BCs'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call make_IO_dir(this%PA_face_implicit_BCs,&
           dir//'PA_face_implicit_BCs'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call make_IO_dir(this%f_BCs,dir//'f_BCs'//fortran_PS)
         endif
       end subroutine

       subroutine export_folder_structure_boundary_conditions(this,dir)
         implicit none
         type(boundary_conditions),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%BCL,dir//'BCL'//fortran_PS)
         if (this%BCL%defined) then
           call export_structured(this%DL,dir//'DL'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call export_structured(this%face,dir//'face'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call export_structured(this%PA_face_BCs,&
           dir//'PA_face_BCs'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call export_structured(this%PA_face_implicit_BCs,&
           dir//'PA_face_implicit_BCs'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call export_structured(this%f_BCs,dir//'f_BCs'//fortran_PS)
         endif
       end subroutine

       subroutine export_structured_D_boundary_conditions(this,dir)
         implicit none
         type(boundary_conditions),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%BCL,dir//'BCL'//fortran_PS)
         if (this%BCL%defined) then
           call export_structured(this%DL,dir//'DL'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call export_structured(this%face,dir//'face'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call export_structured(this%PA_face_BCs,&
           dir//'PA_face_BCs'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call export_structured(this%PA_face_implicit_BCs,&
           dir//'PA_face_implicit_BCs'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call export_structured(this%f_BCs,dir//'f_BCs'//fortran_PS)
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_boundary_conditions(this,dir)
         implicit none
         type(boundary_conditions),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%BCL,dir//'BCL'//fortran_PS)
         if (this%BCL%defined) then
           call import_structured(this%DL,dir//'DL'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call import_structured(this%face,dir//'face'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call import_structured(this%PA_face_BCs,&
           dir//'PA_face_BCs'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call import_structured(this%PA_face_implicit_BCs,&
           dir//'PA_face_implicit_BCs'//fortran_PS)
         endif
         if (this%BCL%defined) then
           call import_structured(this%f_BCs,dir//'f_BCs'//fortran_PS)
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_boundary_conditions(this)
         implicit none
         type(boundary_conditions),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module config_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use kill_switch_mod
       use stop_clock_mod
       use dir_tree_mod
       use string_mod
       use export_now_mod
       use sim_params_mod
       use export_safe_mod
       use dir_manip_mod
       implicit none

       private
       public :: config
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_config;              end interface
       interface delete;                 module procedure delete_config;                 end interface
       interface display;                module procedure display_config;                end interface
       interface display_short;          module procedure display_short_config;          end interface
       interface display;                module procedure display_wrap_config;           end interface
       interface print;                  module procedure print_config;                  end interface
       interface print_short;            module procedure print_short_config;            end interface
       interface export;                 module procedure export_config;                 end interface
       interface export_primitives;      module procedure export_primitives_config;      end interface
       interface import;                 module procedure import_config;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_config;end interface
       interface export_structured;      module procedure export_structured_D_config;    end interface
       interface import_structured;      module procedure import_structured_D_config;    end interface
       interface import_primitives;      module procedure import_primitives_config;      end interface
       interface export;                 module procedure export_wrap_config;            end interface
       interface import;                 module procedure import_wrap_config;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_config;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_config;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_config;      end interface
       interface export;                 module procedure export_DN_config;              end interface
       interface import;                 module procedure import_DN_config;              end interface
       interface export_structured;      module procedure export_structured_DN_config;   end interface
       interface import_structured;      module procedure import_structured_DN_config;   end interface

       type config
         type(dir_tree) :: DT
         type(sim_params) :: SP
         type(string) :: dir_target
         type(stop_clock) :: sc
         type(export_now) :: EN
         type(export_safe) :: ES
         type(kill_switch) :: KS
         type(string) :: dir
         type(string) :: name
       end type

       contains

       subroutine init_copy_config(this,that)
         implicit none
         type(config),intent(inout) :: this
         type(config),intent(in) :: that
         call delete(this)
         call init(this%DT,that%DT)
         call init(this%SP,that%SP)
         call init(this%dir_target,that%dir_target)
         call init(this%sc,that%sc)
         call init(this%EN,that%EN)
         call init(this%ES,that%ES)
         call init(this%KS,that%KS)
         call init(this%dir,that%dir)
         call init(this%name,that%name)
       end subroutine

       subroutine delete_config(this)
         implicit none
         type(config),intent(inout) :: this
         call delete(this%DT)
         call delete(this%SP)
         call delete(this%dir_target)
         call delete(this%sc)
         call delete(this%EN)
         call delete(this%ES)
         call delete(this%KS)
         call delete(this%dir)
         call delete(this%name)
       end subroutine

       subroutine display_config(this,un)
         implicit none
         type(config),intent(in) :: this
         integer,intent(in) :: un
         call display(this%DT,un)
         call display(this%SP,un)
         call display(this%dir_target,un)
         call display(this%sc,un)
         call display(this%EN,un)
         call display(this%ES,un)
         call display(this%KS,un)
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_short_config(this,un)
         implicit none
         type(config),intent(in) :: this
         integer,intent(in) :: un
         call display(this%DT,un)
         call display(this%SP,un)
         call display(this%dir_target,un)
         call display(this%sc,un)
         call display(this%EN,un)
         call display(this%ES,un)
         call display(this%KS,un)
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_wrap_config(this,dir,name)
         implicit none
         type(config),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_config(this)
         implicit none
         type(config),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_config(this)
         implicit none
         type(config),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_config(this,un)
         implicit none
         type(config),intent(in) :: this
         integer,intent(in) :: un
         call export(this%DT,un)
         call export(this%SP,un)
         call export(this%dir_target,un)
         call export(this%sc,un)
         call export(this%EN,un)
         call export(this%ES,un)
         call export(this%KS,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_config(this,un)
         implicit none
         type(config),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%DT,un)
         call import(this%SP,un)
         call import(this%dir_target,un)
         call import(this%sc,un)
         call import(this%EN,un)
         call import(this%ES,un)
         call import(this%KS,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_config(this,un)
         implicit none
         type(config),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_config(this,un)
         implicit none
         type(config),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_config(this,dir,name)
         implicit none
         type(config),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_config(this,dir,name)
         implicit none
         type(config),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_config(this)
         implicit none
         type(config),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_config(this)
         implicit none
         type(config),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_config(this)
         implicit none
         type(config),intent(in) :: this
         integer :: un
         integer :: un_indicate
         un_indicate = new_and_open(str(this%dir),&
         'delete_primitives_to_bypass_restart')
         close(un_indicate)
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%DT,str(this%dir)//'DT'//fortran_PS)
         call export_structured(this%SP,str(this%dir)//'SP'//fortran_PS)
         call export_structured(this%dir_target,&
         str(this%dir)//'dir_target'//fortran_PS)
         call export_structured(this%sc,str(this%dir)//'sc'//fortran_PS)
         call export_structured(this%EN,str(this%dir)//'EN'//fortran_PS)
         call export_structured(this%ES,str(this%dir)//'ES'//fortran_PS)
         call export_structured(this%KS,str(this%dir)//'KS'//fortran_PS)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_config(this)
         implicit none
         type(config),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%DT,str(this%dir)//'DT'//fortran_PS)
         call import_structured(this%SP,str(this%dir)//'SP'//fortran_PS)
         call import_structured(this%dir_target,&
         str(this%dir)//'dir_target'//fortran_PS)
         call import_structured(this%sc,str(this%dir)//'sc'//fortran_PS)
         call import_structured(this%EN,str(this%dir)//'EN'//fortran_PS)
         call import_structured(this%ES,str(this%dir)//'ES'//fortran_PS)
         call import_structured(this%KS,str(this%dir)//'KS'//fortran_PS)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_config(this,dir)
         implicit none
         type(config),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%DT,dir//'DT'//fortran_PS)
         call set_IO_dir(this%SP,dir//'SP'//fortran_PS)
         call set_IO_dir(this%dir_target,dir//'dir_target'//fortran_PS)
         call set_IO_dir(this%sc,dir//'sc'//fortran_PS)
         call set_IO_dir(this%EN,dir//'EN'//fortran_PS)
         call set_IO_dir(this%ES,dir//'ES'//fortran_PS)
         call set_IO_dir(this%KS,dir//'KS'//fortran_PS)
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_config(this,dir)
         implicit none
         type(config),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%DT,dir//'DT'//fortran_PS)
         call make_IO_dir(this%SP,dir//'SP'//fortran_PS)
         call make_IO_dir(this%dir_target,dir//'dir_target'//fortran_PS)
         call make_IO_dir(this%sc,dir//'sc'//fortran_PS)
         call make_IO_dir(this%EN,dir//'EN'//fortran_PS)
         call make_IO_dir(this%ES,dir//'ES'//fortran_PS)
         call make_IO_dir(this%KS,dir//'KS'//fortran_PS)
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_config(this,dir)
         implicit none
         type(config),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         integer :: un_indicate
         un_indicate = new_and_open(dir,&
         'delete_primitives_to_bypass_restart')
         close(un_indicate)
         call export_structured(this%DT,dir//'DT'//fortran_PS)
         call export_structured(this%SP,dir//'SP'//fortran_PS)
         call export_structured(this%dir_target,&
         dir//'dir_target'//fortran_PS)
         call export_structured(this%sc,dir//'sc'//fortran_PS)
         call export_structured(this%EN,dir//'EN'//fortran_PS)
         call export_structured(this%ES,dir//'ES'//fortran_PS)
         call export_structured(this%KS,dir//'KS'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_config(this,dir)
         implicit none
         type(config),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         integer :: un_indicate
         un_indicate = new_and_open(dir,&
         'delete_primitives_to_bypass_restart')
         close(un_indicate)
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%DT,dir//'DT'//fortran_PS)
         call export_structured(this%SP,dir//'SP'//fortran_PS)
         call export_structured(this%dir_target,&
         dir//'dir_target'//fortran_PS)
         call export_structured(this%sc,dir//'sc'//fortran_PS)
         call export_structured(this%EN,dir//'EN'//fortran_PS)
         call export_structured(this%ES,dir//'ES'//fortran_PS)
         call export_structured(this%KS,dir//'KS'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_config(this,dir)
         implicit none
         type(config),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%DT,dir//'DT'//fortran_PS)
         call import_structured(this%SP,dir//'SP'//fortran_PS)
         call import_structured(this%dir_target,&
         dir//'dir_target'//fortran_PS)
         call import_structured(this%sc,dir//'sc'//fortran_PS)
         call import_structured(this%EN,dir//'EN'//fortran_PS)
         call import_structured(this%ES,dir//'ES'//fortran_PS)
         call import_structured(this%KS,dir//'KS'//fortran_PS)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_config(this)
         implicit none
         type(config),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module grid_continue_mod
       use current_precision_mod
       use array_mod
       use array_extend_mod
       use coordinates_mod
       use coordinates_extend_mod
       use grid_mod
       use grid_extend_mod
       use mesh_quality_params_mod
       use coordinate_distribution_funcs_mod
       use coordinate_distribution_funcs_iterate_mod
       use coordinate_stretch_param_match_mod
       implicit none

       private

       public :: ext_uniform_IO
       public :: ext_Roberts_near_IO
       public :: ext_Roberts_far_IO
       public :: ext_Roberts_B_IO

       public :: ext_prep_uniform_IO      ! ext_prep_uniform(g,N,dir)
       public :: ext_prep_Roberts_L_IO    ! ext_prep_Roberts_L(g,L,N,dir)
       public :: ext_prep_Roberts_R_IO    ! ext_prep_Roberts_R(g,L,N,dir)
       public :: ext_prep_Roberts_B_IO    ! ext_prep_Roberts_B(g,L,N,dir)
       ! public :: ext_prep_cluster      ! Not yet implemented

       public :: ext_app_uniform_IO       ! ext_app_uniform(g,N,dir)
       public :: ext_app_Roberts_L_IO     ! ext_app_Roberts_L(g,L,N,dir)
       public :: ext_app_Roberts_R_IO     ! ext_app_Roberts_R(g,L,N,dir)
       public :: ext_app_Roberts_B_IO     ! ext_app_Roberts_B(g,L,N,dir)
       ! public :: ext_app_cluster       ! Not yet implemented

       public :: ext_app_Roberts_C2F_IO     ! ext_app_Roberts_B(g,L,N,dir)
       public :: ext_prep_Roberts_C2F_IO

       contains

       ! ******************************************************************** Prepend + Append

       subroutine ext_uniform_IO(g,N,dir)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: N,dir
         call ext_prep_uniform_IO(g,N,dir)
         call ext_app_uniform_IO (g,N,dir)
       end subroutine

       subroutine ext_Roberts_near_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         call ext_prep_Roberts_R_IO(g,L,N,dir,MQP)
         call ext_app_Roberts_L_IO (g,L,N,dir,MQP)
       end subroutine

       subroutine ext_Roberts_far_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         call ext_prep_Roberts_L_IO(g,L,N,dir,MQP)
         call ext_app_Roberts_R_IO (g,L,N,dir,MQP)
       end subroutine

       subroutine ext_Roberts_B_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         call ext_prep_Roberts_B_IO(g,L,N,dir,MQP)
         call ext_app_Roberts_B_IO (g,L,N,dir,MQP)
       end subroutine

       ! ******************************************************************** Prepend

       subroutine process_prepend(g,a,b,dir)
         implicit none
         type(grid),intent(inout) :: g
         type(array),intent(inout) :: a,b
         integer,intent(in) :: dir
         call snip(a); call snip(a)
         call prepend(a,b)
         call init(g%c(dir),a)
         call prepend_ghost(g%c(dir))
         call initProps(g)
         call delete(a); call delete(b)
       end subroutine

       subroutine ext_prep_uniform_IO(g,N,dir)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: N,dir
         type(array) :: a,b
         real(cp) :: hmin,dh
         call check_N(N,'ext_prep_uniform_IO')
         call init(a,g%c(dir)%hn)
         hmin = g%c(dir)%hmin; dh = g%c(dir)%dhn%f(1)
         call init(b,uniformLeft(hmin,dh,N))
         call process_prepend(g,a,b,dir)
       end subroutine

       subroutine ext_prep_Roberts_L_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         real(cp) :: beta,hmin,dh
         type(array) :: a,b
         integer :: i,N_final
         call check_N(N,'ext_prep_Roberts_L_IO')
         call init(a,g%c(dir)%hn)
         hmin = g%c(dir)%hmin; dh = g%c(dir)%dhn%f(1)
         N_final = N
         do i=1,MQP%N_iter
           beta = beta_dh_small(hmin - L,hmin,N_final,dh)
           call init(b,robertsLeft(hmin-L,hmin,N_final,beta))
           N_final = b%N
           if (needs_more_points(b,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process_prepend(g,a,b,dir)
       end subroutine

       subroutine ext_prep_Roberts_R_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         real(cp) :: beta,hmin,dh
         type(array) :: a,b
         integer :: i,N_final
         call check_N(N,'ext_prep_Roberts_R_IO')
         call init(a,g%c(dir)%hn)
         hmin = g%c(dir)%hmin; dh = g%c(dir)%dhn%f(1)
         N_final = N
         do i=1,MQP%N_iter
           beta = beta_dh_small(hmin - L,hmin,N_final,dh)
           call init(b,robertsRight(hmin-L,hmin,N_final,beta))
           N_final = b%N
           if (needs_more_points(b,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process_prepend(g,a,b,dir)
       end subroutine

       subroutine ext_prep_Roberts_B_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         real(cp) :: beta,hmin,dh
         type(array) :: a,b
         integer :: i,N_final
         call check_N(N,'ext_prep_Roberts_B_IO')
         call init(a,g%c(dir)%hn)
         hmin = g%c(dir)%hmin; dh = g%c(dir)%dhn%f(1)
         N_final = N
         do i=1,MQP%N_iter
           beta = beta_dh_both(hmin - L,hmin,N_final,dh)
           call init(b,robertsBoth(hmin-L,hmin,N_final,beta))
           N_final = b%N
           if (needs_more_points(b,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process_prepend(g,a,b,dir)
       end subroutine

       subroutine ext_prep_Roberts_C2F_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         real(cp) :: beta,hmin,dh
         type(array) :: a,b
         integer :: i,N_final
         call check_N(N,'ext_prep_Roberts_C2F_IO')
         call init(a,g%c(dir)%hn)
         hmin = g%c(dir)%hmin; dh = g%c(dir)%dhn%f(1)
         N_final = N
         do i=1,MQP%N_iter
           beta = beta_dh_big(hmin - L,hmin,N_final,dh)
           call init(b,robertsLeft(hmin-L,hmin,N_final,beta))
           N_final = b%N
           if (needs_more_points(b,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process_prepend(g,a,b,dir)
       end subroutine

       ! ******************************************************************** Append

       subroutine process_append(g,a,b,dir)
         implicit none
         type(grid),intent(inout) :: g
         type(array),intent(inout) :: a,b
         integer,intent(in) :: dir
         call init(a,g%c(dir)%hn)
         call pop(a); call pop(a)
         call append(a,b)
         call init(g%c(dir),a)
         call append_ghost(g%c(dir))
         call initProps(g)
         call delete(a); call delete(b)
       end subroutine

       subroutine ext_app_uniform_IO(g,N,dir)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: N,dir
         type(array) :: a,b
         real(cp) :: dh
         call check_N(N,'ext_app_uniform_IO')
         call init(a,g%c(dir)%hn)
         dh = g%c(dir)%dhn_e
         call init(b,uniformRight(g%c(dir)%hmax,dh,N))
         call process_append(g,a,b,dir)
       end subroutine

       subroutine ext_app_Roberts_L_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         real(cp) :: beta,hmax,dh
         type(array) :: a,b
         integer :: i,N_final
         call check_N(N,'ext_app_Roberts_L_IO')
         hmax = g%c(dir)%hmax; dh = g%c(dir)%dhn_e
         N_final = N
         do i=1,MQP%N_iter
           beta = beta_dh_small(hmax,hmax + L,N_final,dh)
           call init(b,robertsLeft(hmax,hmax + L,N_final,beta))
           N_final = b%N
           if (needs_more_points(b,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process_append(g,a,b,dir)
       end subroutine

       subroutine ext_app_Roberts_R_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         real(cp) :: beta,hmax,dh
         type(array) :: a,b
         integer :: i,N_final
         call check_N(N,'ext_app_Roberts_R_IO')
         hmax = g%c(dir)%hmax; dh = g%c(dir)%dhn_e
         N_final = N
         do i=1,MQP%N_iter
           beta = beta_dh_small(hmax,hmax + L,N_final,dh)
           call init(b,robertsRight(hmax,hmax + L,N_final,beta))
           N_final = b%N
           if (needs_more_points(b,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process_append(g,a,b,dir)
       end subroutine

       subroutine ext_app_Roberts_B_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         real(cp) :: beta,hmax,dh
         type(array) :: a,b
         integer :: i,N_final
         call check_N(N,'ext_app_Roberts_B_IO')
         hmax = g%c(dir)%hmax; dh = g%c(dir)%dhn_e
         N_final = N
         do i=1,MQP%N_iter
           beta = beta_dh_both(hmax,hmax + L,N_final,dh)
           call init(b,robertsBoth(hmax,hmax + L,N_final,beta))
           N_final = b%N
           if (needs_more_points(b,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process_append(g,a,b,dir)
       end subroutine

       subroutine ext_app_Roberts_C2F_IO(g,L,N,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         real(cp),intent(in) :: L
         integer,intent(in) :: N,dir
         type(mesh_quality_params),intent(in) :: MQP
         real(cp) :: beta,hmax,dh
         type(array) :: a,b
         integer :: i,N_final
         call check_N(N,'ext_app_Roberts_C2F_IO')
         hmax = g%c(dir)%hmax; dh = g%c(dir)%dhn_e
         N_final = N
         do i=1,MQP%N_iter
           beta = beta_dh_big(hmax,hmax + L,N_final,dh)
           call init(b,robertsRight(hmax,hmax + L,N_final,beta))
           N_final = b%N
           if (needs_more_points(b,MQP)) then; N_final=N_final+1; else; exit; endif
         enddo
         call process_append(g,a,b,dir)
       end subroutine

       subroutine check_N(N,caller)
         implicit none
         character(len=*),intent(in) :: caller
         integer,intent(in) :: N
         if (.not.(N.gt.0)) then
           write(*,*) 'Error: N is not > 0 in ',caller,' in extend_grid.f90'
           stop 'Done'
         endif
       end subroutine

       end module
      module grid_field_extend_mod
        use grid_field_mod
        use current_precision_mod
        use grid_mod
        use grid_extend_mod
        use array_mod
        use array_extend_mod
        use face_edge_corner_indexing_mod
        use IO_tools_mod
        use data_location_extend_mod
        implicit none
        private

        public :: grid_field
        public :: init,display,export ! Essentials

        public :: init_CC
        public :: init_Face
        public :: init_Edge
        public :: init_Node

        public :: print_info
        public :: display_info
        public :: print_physical
        public :: insist_shape_match
        public :: insist_shape_staggered
        public :: insist_allocated

        interface init;                     module procedure init_DL_GF;                   end interface
        interface init;                     module procedure init_shape_GF;                end interface
        interface init;                     module procedure init_shape_GF_2;              end interface
        interface display;                  module procedure display_pad_GF;               end interface

        interface export;                   module procedure export_wrapper_GF_DL;         end interface
        interface export;                   module procedure export_wrapper_GF;            end interface

        interface init_CC;                  module procedure init_GF_CC;                   end interface
        interface init_Face;                module procedure init_GF_Face;                 end interface
        interface init_Edge;                module procedure init_GF_Edge;                 end interface
        interface init_Node;                module procedure init_GF_Node;                 end interface

        interface print_physical;           module procedure print_physical_GF;            end interface
        interface print_info;               module procedure print_info_GF;                end interface
        interface display_info;             module procedure display_info_GF;              end interface
        interface insist_shape_match;       module procedure insist_shape_match_GF;        end interface
        interface insist_shape_match;       module procedure insist_shape_match_plane_GF;  end interface
        interface insist_shape_staggered;   module procedure insist_shape_staggered_dir_GF;end interface
        interface insist_allocated;         module procedure insist_allocated_GF;          end interface

       contains

        ! **********************************************************
        ! ********************* ESSENTIALS *************************
        ! **********************************************************

        subroutine init_DL_GF(a,g,DL)
          implicit none
          type(grid_field),intent(inout) :: a
          type(data_location),intent(in) :: DL
          type(grid),intent(in) :: g
          if (is_CC(DL)) then; call init_CC(a,g)
          elseif (is_Node(DL)) then; call init_Node(a,g)
          elseif (is_Face(DL)) then; call init_Face(a,g,get_face(DL))
          elseif (is_Edge(DL)) then; call init_Edge(a,g,get_edge(DL))
          else; stop 'Erorr: bad input to init_DL_GF in GF_base.f90'
          endif
        end subroutine

        subroutine init_shape_GF(a,Nx,Ny,Nz)
          implicit none
          type(grid_field),intent(inout) :: a
          integer,intent(in) :: Nx,Ny,Nz
          if (allocated(a%f)) deallocate(a%f)
          allocate(a%f(Nx,Ny,Nz))
          a%s = shape(a%f)
          a%s_1D = a%s(1)*a%s(2)*a%s(3)
        end subroutine

        subroutine init_shape_GF_2(a,s)
          implicit none
          type(grid_field),intent(inout) :: a
          integer,dimension(3),intent(in) :: s
          if (allocated(a%f)) deallocate(a%f)
          allocate(a%f(s(1),s(2),s(3)))
          a%s = shape(a%f)
          a%s_1D = a%s(1)*a%s(2)*a%s(3)
        end subroutine

        subroutine init_GF_CC(a,g)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid),intent(in) :: g
          call init_shape_GF(a,g%c(1)%sc,g%c(2)%sc,g%c(3)%sc)
        end subroutine

        subroutine init_GF_Face(a,g,dir)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid),intent(in) :: g
          integer,intent(in) :: dir
          select case (dir)
          case (1); call init_shape_GF(a,g%c(1)%sn,g%c(2)%sc,g%c(3)%sc)
          case (2); call init_shape_GF(a,g%c(1)%sc,g%c(2)%sn,g%c(3)%sc)
          case (3); call init_shape_GF(a,g%c(1)%sc,g%c(2)%sc,g%c(3)%sn)
          case default; stop 'Error: dir must = 1,2,3 in init_GF_Face in GF.f90'
          end select
        end subroutine

        subroutine init_GF_Edge(a,g,dir)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid),intent(in) :: g
          integer,intent(in) :: dir
          select case (dir)
          case (1); call init_shape_GF(a,g%c(1)%sc,g%c(2)%sn,g%c(3)%sn)
          case (2); call init_shape_GF(a,g%c(1)%sn,g%c(2)%sc,g%c(3)%sn)
          case (3); call init_shape_GF(a,g%c(1)%sn,g%c(2)%sn,g%c(3)%sc)
          case default; stop 'Error: dir must = 1,2,3 in init_GF_Face in GF.f90'
          end select
        end subroutine

        subroutine init_GF_Node(a,g)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid),intent(in) :: g
          call init_shape_GF(a,g%c(1)%sn,g%c(2)%sn,g%c(3)%sn)
        end subroutine

        subroutine display_pad_GF(a,p,un)
          implicit none
          type(grid_field),intent(in) :: a
          integer,intent(in) :: un,p
          integer :: i,j,k
          if (allocated(a%f)) then
            write(*,*) 'shape(f) = ',a%s
            do k=1+p,a%s(3)-p; do j=1+p,a%s(2)-p; do i=1+p,a%s(1)-p
              write(un,*) 'f(',i,',',j,',',k,') = ',a%f(i,j,k)
            enddo; enddo; enddo
          endif
        end subroutine

        subroutine print_physical_GF(a)
          implicit none
          type(grid_field),intent(in) :: a
          call display(a,1,6)
        end subroutine

        subroutine display_info_GF(a,un)
          implicit none
          type(grid_field),intent(in) :: a
          integer,intent(in) :: un
          write(un,*) 'shape(f) = ',a%s
          ! write(un,*) 'size(f) = ',a%s_1D
        end subroutine

        subroutine print_info_GF(a)
          implicit none
          type(grid_field),intent(in) :: a
          call display_info(a,6)
        end subroutine

        ! *******************************************************************************

        subroutine export_wrapper_GF(a,hx,hy,hz,un,name)
          implicit none
          type(grid_field),intent(in) :: a
          real(cp),dimension(:),intent(in) :: hx,hy,hz
          integer,intent(in) :: un
          character(len=*),intent(in) :: name
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_allocated_GF(a,'export_wrapper_GF')
#endif
          write(un,*) 'TITLE = "3D Field"'
          write(un,*) 'VARIABLES = "x","y","z","',name,'"'
          write(un,*) 'ZONE,I=',a%s(1),',J=',a%s(2),',K=',a%s(3)
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          write(un,*) hx(i),hy(j),hz(k),a%f(i,j,k)
          enddo; enddo; enddo
        end subroutine

        subroutine export_wrapper_GF_DL(a,g,dir,name,DL)
          implicit none
          type(grid_field),intent(in) :: a
          type(grid),intent(in) :: g
          character(len=*),intent(in) :: dir,name
          type(data_location),intent(in) :: DL
          type(array),dimension(3) :: h
          integer :: un,i
          un = new_and_open(dir,name)
          call get_coordinates_h(h,g,DL)
          call export(a,h(1)%f,h(2)%f,h(3)%f,un,name)
          call close_and_message(un,dir,name)
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine insist_shape_match_GF(A,B,caller)
          implicit none
          type(grid_field),intent(in) :: A,B
          character(len=*),intent(in) :: caller
          logical,dimension(3) :: L
          L(1) = A%s(1).ne.B%s(1)
          L(2) = A%s(2).ne.B%s(2)
          L(3) = A%s(3).ne.B%s(3)
          if (any(L)) then
            write(*,*) 'Error: shape mismatch in insist_shape_match_GF in ',caller,' in GF_base.f90'
            write(*,*) 'A%s = ',A%s
            write(*,*) 'B%s = ',B%s
            write(*,*) 'shape(A%f) = ',shape(A%f)
            write(*,*) 'shape(B%f) = ',shape(B%f)
            stop 'Done'
          endif
        end subroutine

        subroutine insist_shape_match_plane_GF(A,B,dir,caller)
          implicit none
          type(grid_field),intent(in) :: A,B
          integer,intent(in) :: dir
          character(len=*),intent(in) :: caller
          logical,dimension(2) :: L
          integer,dimension(2) :: adj
          adj = adj_dir_given_dir(dir)
          L(1) = A%s(adj(1)).ne.B%s(adj(1))
          L(2) = A%s(adj(2)).ne.B%s(adj(2))
          if (any(L)) then
            write(*,*) 'Error: shape mismatch in insist_shape_match_plane_GF'
            write(*,*) 'in ',caller,' in GF_base.f90'
            write(*,*) 'A%s(adj(1)) = ',A%s(adj(1))
            write(*,*) 'A%s(adj(2)) = ',A%s(adj(2))
            write(*,*) 'B%s(adj(1)) = ',B%s(adj(1))
            write(*,*) 'B%s(adj(2)) = ',B%s(adj(2))
            stop 'Done'
          endif
        end subroutine

        subroutine insist_shape_staggered_dir_GF(C,N,dir,caller)
          implicit none
          type(grid_field),intent(in) :: C,N
          integer,intent(in) :: dir
          character(len=*),intent(in) :: caller
          if (.not.(C%s(dir).eq.N%s(dir)-1)) then
            write(*,*) 'Error: staggered shape mismatch in insist_shape_staggered_dir_GF'
            write(*,*) 'in ',caller,' in GF_base.f90'
            write(*,*) 'C%s(dir) = ',C%s(dir)
            write(*,*) 'N%s(dir) = ',N%s(dir)
            stop 'Done'
          endif
        end subroutine

        subroutine insist_allocated_GF(A,caller)
          implicit none
          type(grid_field),intent(in) :: A
          character(len=*),intent(in) :: caller
          if (.not.allocated(A%f)) then
            write(*,*) 'Error: GF not allocated in ',caller,' in GF_base.f90'
            stop 'Done'
          endif
        end subroutine

      end module
       module grid_init_mod
       use current_precision_mod
       use grid_mod
       use grid_extend_mod
       use array_mod
       use array_extend_mod
       use coordinates_mod
       use coordinates_extend_mod
       use mesh_quality_params_mod
       use coordinate_distribution_funcs_mod
       use coordinate_distribution_funcs_iterate_mod
       use coordinate_stretch_param_match_mod
       implicit none

       private

       public :: grid_uniform
       public :: grid_Roberts_L,grid_Roberts_R,grid_Roberts_B
       public :: grid_cluster

       contains

       subroutine process(g,dir)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: dir
         call add_ghost_nodes(g%c(dir))
         call initProps(g)
       end subroutine

       subroutine grid_uniform(g,hmin,hmax,N,dir)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: N,dir
         real(cp),intent(in) :: hmin,hmax
         call init(g%c(dir),uniform_iterate(hmin,hmax,N))
         call process(g,dir)
       end subroutine

       subroutine grid_Roberts_L(g,hmin,hmax,N,beta,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: N,dir
         real(cp),intent(in) :: hmin,hmax,beta
         type(mesh_quality_params),intent(in) :: MQP
         call init(g%c(dir),robertsLeft_iterate(hmin,hmax,N,beta,MQP))
         call process(g,dir)
       end subroutine

       subroutine grid_Roberts_R(g,hmin,hmax,N,beta,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: N,dir
         real(cp),intent(in) :: hmin,hmax,beta
         type(mesh_quality_params),intent(in) :: MQP
         call init(g%c(dir),robertsRight_iterate(hmin,hmax,N,beta,MQP))
         call process(g,dir)
       end subroutine

       subroutine grid_Roberts_B(g,hmin,hmax,N,beta,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: N,dir
         real(cp),intent(in) :: hmin,hmax,beta
         type(mesh_quality_params),intent(in) :: MQP
         call init(g%c(dir),robertsBoth_iterate(hmin,hmax,N,beta,MQP))
         call process(g,dir)
       end subroutine

       subroutine grid_cluster(g,hmin,hmax,N,yc,tau,dir,MQP)
         implicit none
         type(grid),intent(inout) :: g
         integer,intent(in) :: N,dir
         real(cp),intent(in) :: hmin,hmax,yc,tau
         type(mesh_quality_params),intent(in) :: MQP
         call init(g%c(dir),cluster_iterate(hmin,hmax,N,yc,tau,MQP))
         call process(g,dir)
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module mesh_block_mod
       use string_mod
       use block_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use mesh_mod
       use dir_manip_mod
       implicit none

       private
       public :: mesh_block
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_mesh_block;              end interface
       interface delete;                 module procedure delete_mesh_block;                 end interface
       interface display;                module procedure display_mesh_block;                end interface
       interface display_short;          module procedure display_short_mesh_block;          end interface
       interface display;                module procedure display_wrap_mesh_block;           end interface
       interface print;                  module procedure print_mesh_block;                  end interface
       interface print_short;            module procedure print_short_mesh_block;            end interface
       interface export;                 module procedure export_mesh_block;                 end interface
       interface export_primitives;      module procedure export_primitives_mesh_block;      end interface
       interface import;                 module procedure import_mesh_block;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_mesh_block;end interface
       interface export_structured;      module procedure export_structured_D_mesh_block;    end interface
       interface import_structured;      module procedure import_structured_D_mesh_block;    end interface
       interface import_primitives;      module procedure import_primitives_mesh_block;      end interface
       interface export;                 module procedure export_wrap_mesh_block;            end interface
       interface import;                 module procedure import_wrap_mesh_block;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_mesh_block;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_mesh_block;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_mesh_block;      end interface

       type mesh_block
         type(mesh) :: m
         type(block) :: B
       end type

       contains

       subroutine init_copy_mesh_block(this,that)
         implicit none
         type(mesh_block),intent(inout) :: this
         type(mesh_block),intent(in) :: that
         call delete(this)
         call init(this%m,that%m)
         call init(this%B,that%B)
       end subroutine

       subroutine delete_mesh_block(this)
         implicit none
         type(mesh_block),intent(inout) :: this
         call delete(this%m)
         call delete(this%B)
       end subroutine

       subroutine display_mesh_block(this,un)
         implicit none
         type(mesh_block),intent(in) :: this
         integer,intent(in) :: un
         call display(this%m,un)
         call display(this%B,un)
       end subroutine

       subroutine display_short_mesh_block(this,un)
         implicit none
         type(mesh_block),intent(in) :: this
         integer,intent(in) :: un
         call display(this%m,un)
         call display(this%B,un)
       end subroutine

       subroutine display_wrap_mesh_block(this,dir,name)
         implicit none
         type(mesh_block),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_mesh_block(this)
         implicit none
         type(mesh_block),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_mesh_block(this)
         implicit none
         type(mesh_block),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_mesh_block(this,un)
         implicit none
         type(mesh_block),intent(in) :: this
         integer,intent(in) :: un
         call export(this%m,un)
         call export(this%B,un)
       end subroutine

       subroutine import_mesh_block(this,un)
         implicit none
         type(mesh_block),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%m,un)
         call import(this%B,un)
       end subroutine

       subroutine export_primitives_mesh_block(this,un)
         implicit none
         type(mesh_block),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_mesh_block(this,un)
         implicit none
         type(mesh_block),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_mesh_block(this,dir,name)
         implicit none
         type(mesh_block),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_mesh_block(this,dir,name)
         implicit none
         type(mesh_block),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_mesh_block(this,dir)
         implicit none
         type(mesh_block),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%B,dir//'B'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_mesh_block(this,dir)
         implicit none
         type(mesh_block),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%B,dir//'B'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_mesh_block(this,dir)
         implicit none
         type(mesh_block),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%B,dir//'B'//fortran_PS)
       end subroutine

       subroutine export_structured_D_mesh_block(this,dir)
         implicit none
         type(mesh_block),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%B,dir//'B'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_mesh_block(this,dir)
         implicit none
         type(mesh_block),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%B,dir//'B'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_mesh_block(this)
         implicit none
         type(mesh_block),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module mesh_domain_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use physical_domain_mod
       use mesh_mod
       use dir_manip_mod
       implicit none

       private
       public :: mesh_domain
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_mesh_domain;              end interface
       interface delete;                 module procedure delete_mesh_domain;                 end interface
       interface display;                module procedure display_mesh_domain;                end interface
       interface display_short;          module procedure display_short_mesh_domain;          end interface
       interface display;                module procedure display_wrap_mesh_domain;           end interface
       interface print;                  module procedure print_mesh_domain;                  end interface
       interface print_short;            module procedure print_short_mesh_domain;            end interface
       interface export;                 module procedure export_mesh_domain;                 end interface
       interface export_primitives;      module procedure export_primitives_mesh_domain;      end interface
       interface import;                 module procedure import_mesh_domain;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_mesh_domain;end interface
       interface export_structured;      module procedure export_structured_D_mesh_domain;    end interface
       interface import_structured;      module procedure import_structured_D_mesh_domain;    end interface
       interface import_primitives;      module procedure import_primitives_mesh_domain;      end interface
       interface export;                 module procedure export_wrap_mesh_domain;            end interface
       interface import;                 module procedure import_wrap_mesh_domain;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_mesh_domain;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_mesh_domain;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_mesh_domain;      end interface

       type mesh_domain
         type(physical_domain) :: D
         type(mesh) :: m_R1
         type(mesh) :: m_R2
       end type

       contains

       subroutine init_copy_mesh_domain(this,that)
         implicit none
         type(mesh_domain),intent(inout) :: this
         type(mesh_domain),intent(in) :: that
         call delete(this)
         call init(this%D,that%D)
         call init(this%m_R1,that%m_R1)
         call init(this%m_R2,that%m_R2)
       end subroutine

       subroutine delete_mesh_domain(this)
         implicit none
         type(mesh_domain),intent(inout) :: this
         call delete(this%D)
         call delete(this%m_R1)
         call delete(this%m_R2)
       end subroutine

       subroutine display_mesh_domain(this,un)
         implicit none
         type(mesh_domain),intent(in) :: this
         integer,intent(in) :: un
         call display(this%D,un)
         call display(this%m_R1,un)
         call display(this%m_R2,un)
       end subroutine

       subroutine display_short_mesh_domain(this,un)
         implicit none
         type(mesh_domain),intent(in) :: this
         integer,intent(in) :: un
         call display(this%D,un)
         call display(this%m_R1,un)
         call display(this%m_R2,un)
       end subroutine

       subroutine display_wrap_mesh_domain(this,dir,name)
         implicit none
         type(mesh_domain),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_mesh_domain(this)
         implicit none
         type(mesh_domain),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_mesh_domain(this)
         implicit none
         type(mesh_domain),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_mesh_domain(this,un)
         implicit none
         type(mesh_domain),intent(in) :: this
         integer,intent(in) :: un
         call export(this%D,un)
         call export(this%m_R1,un)
         call export(this%m_R2,un)
       end subroutine

       subroutine import_mesh_domain(this,un)
         implicit none
         type(mesh_domain),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%D,un)
         call import(this%m_R1,un)
         call import(this%m_R2,un)
       end subroutine

       subroutine export_primitives_mesh_domain(this,un)
         implicit none
         type(mesh_domain),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_mesh_domain(this,un)
         implicit none
         type(mesh_domain),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_mesh_domain(this,dir,name)
         implicit none
         type(mesh_domain),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_mesh_domain(this,dir,name)
         implicit none
         type(mesh_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_mesh_domain(this,dir)
         implicit none
         type(mesh_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%D,dir//'D'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_mesh_domain(this,dir)
         implicit none
         type(mesh_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%D,dir//'D'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_mesh_domain(this,dir)
         implicit none
         type(mesh_domain),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%D,dir//'D'//fortran_PS)
       end subroutine

       subroutine export_structured_D_mesh_domain(this,dir)
         implicit none
         type(mesh_domain),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%D,dir//'D'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_mesh_domain(this,dir)
         implicit none
         type(mesh_domain),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%D,dir//'D'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_mesh_domain(this)
         implicit none
         type(mesh_domain),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module probe_extend_mod
       use probe_mod
       ! Implementation:
       !       type(probe) :: p
       !       call init(p,tec_dir,tec_name,restart)
       !       do i=1,1000
       !         call export(p,n,t,d)      ! sets data to be exported
       !       enddo
       use current_precision_mod
       use string_mod
       use array_mod
       use IO_tools_mod
       use sim_params_mod
       use time_marching_params_mod
       use is_nan_mod

       implicit none
       private
       public :: init,delete,export,import
       public :: get_data

       interface init;     module procedure init_probe;               end interface
       interface delete;   module procedure delete_probe_many;        end interface
       interface export;   module procedure export_probe_wrapper_dim; end interface
       interface import;   module procedure import_probe_wrapper_dim; end interface

       interface export;   module procedure export_probe_data;        end interface

       interface get_data; module procedure get_data_probe;           end interface

       contains

       subroutine init_probe(p,tec_dir,tec_name,restart,simple,TMP)
         implicit none
         type(probe),intent(inout) :: p
         character(len=*),intent(in) :: tec_dir,tec_name
         logical,intent(in) :: restart,simple
         type(time_marching_params),intent(in) :: TMP
         if (restart) then
           call init_probe_restart(p,TMP)
         else
           call init_probe_fresh(p,tec_dir,tec_name,simple)
         endif
       end subroutine

       subroutine init_probe_fresh(p,tec_dir,tec_name,simple)
         implicit none
         type(probe),intent(inout) :: p
         character(len=*),intent(in) :: tec_dir,tec_name
         logical,intent(in) :: simple
         type(string) :: s
         call init(p%tec_dir,tec_dir)
         call init(p%tec_name,tec_name)
         p%simple = simple
         p%restart = .false.
         p%un = new_and_open(tec_dir,tec_name)
         write(p%un,*) 'TITLE = "'//tec_name//' probe"'
         call init(s,'VARIABLES = t')
         call append(s,','//tec_name)
         p%cols = 2
         if (.not.p%simple) then
           p%cols = p%cols+1;call append(s,',d('//tec_name//')/dt')
           p%cols = p%cols+1;call append(s,',|d('//tec_name//')/dt|')
           p%cols = p%cols+1;call append(s,',|d('//tec_name//')/dt|/max(d)_used')
           p%cols = p%cols+1;call append(s,',max(d)')
         endif
         write(p%un,*) str(s)
         call delete(s)
         write(p%un,*) 'ZONE DATAPACKING = POINT'
         flush(p%un)
         p%n_step = 0
         p%d_amax = 0.0_cp
       end subroutine

       subroutine init_probe_restart(p,TMP)
         implicit none
         type(probe),intent(inout) :: p
         type(time_marching_params),intent(in) :: TMP
         integer(li) :: i_last
         p%restart = .true.
         call truncate_data_in_open_file(p,TMP,i_last)
         p%un = open_to_append(str(p%tec_dir),str(p%tec_name))
         call export(p) ! So that restart is passed to next sim.
       end subroutine

       subroutine delete_probe_many(p)
         implicit none
         type(probe),dimension(:),intent(inout) :: p
         integer :: i
         if (size(p).gt.0) then
           do i=1,size(p); call delete(p(i)); enddo
         endif
       end subroutine

       subroutine export_probe_wrapper_dim(p,tec_dir,tec_name)
         implicit none
         type(probe),dimension(:),intent(in) :: p
         character(len=*),intent(in) :: tec_dir,tec_name
         integer :: i
         if (size(p).gt.0) then
           do i=1,size(p); call export(p(i),tec_dir,tec_name); enddo
         endif
       end subroutine

       subroutine import_probe_wrapper_dim(p,tec_dir,tec_name)
         implicit none
         type(probe),dimension(:),intent(inout) :: p
         character(len=*),intent(in) :: tec_dir,tec_name
         integer :: i
         if (size(p).gt.0) then
         do i=1,size(p); call import(p(i),tec_dir,tec_name); enddo
         endif
       end subroutine

       subroutine update_probe_data(p,TMP,d)
         implicit none
         type(probe),intent(inout) :: p
         type(time_marching_params),intent(in) :: TMP
         real(cp),intent(in) :: d
         ! Breaks if double exported data (TMP%t = p%t)
         p%d_data_dt = (d - p%d)/(TMP%t - p%t)
         if (TMP%n_step.eq.0) p%d_data_dt = 0.0_cp
         if (p%t.lt.10.0_cp**(-10.0_cp)) p%d_data_dt = 0.0_cp
         p%abs_d_data_dt = abs(p%d_data_dt)
         p%t = TMP%t
         p%d = d
         p%d_amax = maxval((/p%d_amax,p%d,abs(d)/))
         p%abs_d_data_dt_by_dmax = p%abs_d_data_dt/p%d_amax
         if (p%d_amax.lt.10.0_cp**(-10.0_cp)) p%abs_d_data_dt_by_dmax = p%abs_d_data_dt
         if (p%n_step.eq.TMP%n_step.and.(TMP%n_step.gt.0)) then
          write(*,*) 'Error: cannot export probe '//str(p%tec_name)//' consecutively.'
          write(*,*) 'TMP%n_step = ',TMP%n_step
          write(*,*) 'p%n_step = ',p%n_step
          stop 'Done'
         endif
         p%n_step = TMP%n_step
       end subroutine

       subroutine export_probe_data(p,TMP,d)
         implicit none
         type(probe),intent(inout) :: p
         type(time_marching_params),intent(in) :: TMP
         real(cp),intent(in) :: d
         call update_probe_data(p,TMP,d)
         call check_nans_probe(p)
         if (.not.p%simple) then
         write(p%un,*) p%t,p%d,p%d_data_dt,p%abs_d_data_dt,p%abs_d_data_dt_by_dmax,p%d_amax
         else; write(p%un,*) p%t,p%d
         endif
         flush(p%un)
       end subroutine

       subroutine check_nans_probe(p)
         implicit none
         type(probe),intent(in) :: p
         if (is_nan(p%d)) then
           write(*,*) 'Error: NaN in data in probe: ',str(p%tec_name)
           write(*,*) 'data = ',p%d
           stop 'Divergence error. Sorry!'
         endif
       end subroutine

       function get_data_probe(p) result(d)
         implicit none
         type(probe),intent(in) :: p
         real(cp) :: d
         d = p%d
       end function

       subroutine truncate_data_in_open_file(p,TMP,i_last)
         implicit none
         type(probe),intent(in) :: p
         type(time_marching_params),intent(in) :: TMP
         integer(li),intent(inout) :: i_last
         real(cp),dimension(:),allocatable :: d
         integer(li) :: i,i_first_to_delete,n_lines_in_file
         integer :: un,stat
         n_lines_in_file = get_n_lines_of_file(str(p%tec_dir),str(p%tec_name))
         i_last = n_lines_in_file
         if (n_lines_in_file.gt.3) then
           un = open_to_read(str(p%tec_dir),str(p%tec_name))
           read(un,*); read(un,*); read(un,*)
           allocate(d(p%cols))
           i_first_to_delete = 1
           do i=1,n_lines_in_file-3
             read(un,*,iostat=stat) d
             if (TMP%t.gt.d(1)) then
               i_first_to_delete = i
             endif
             if (stat .lt. 0) then
               exit
             endif
           enddo
           close(un)
           un = open_to_read_write(str(p%tec_dir),str(p%tec_name))
           read(un,*); read(un,*); read(un,*)
           if (i_first_to_delete.ne.TMP%n_step) then
             do i=1,i_first_to_delete; read(un,*); enddo
             do i=i_first_to_delete+1,n_lines_in_file-3; write(un,*) ''; enddo
           endif
           deallocate(d)
           close(un)
           i_last = int(i_first_to_delete)+3
         endif
       end subroutine

       end module
     module sim_params_aux_mod
     use current_precision_mod
     use constants_mod
     use IO_tools_mod
     use dir_tree_mod
     use var_mod
     use var_set_extend_mod
     use string_mod
     use path_extend_mod
     use segment_mod
     use dimensionless_params_extend_mod
     use time_marching_params_mod
     use time_marching_params_extend_mod
     use mesh_params_mod
     use mesh_quality_params_mod
     use export_planes_mod
     use export_lines_mod
     use sim_params_mod
     implicit none

     private
     public :: sanity_check
     public :: display_compiler_info
     public :: set_restart
     public :: post_process
     public :: get_apply_BC_order
     public :: get_FFT_dir

     interface sanity_check;          module procedure sanity_check_SP;                  end interface
     interface display_compiler_info; module procedure display_compiler_info_SP;         end interface
     interface display_compiler_info; module procedure display_compiler_info_wrapper_SP; end interface
     interface set_restart;           module procedure set_restart_SP;                   end interface
     interface post_process;          module procedure post_process_SP;                  end interface

     contains

     function get_apply_BC_order(periodic_dir) result(apply_BC_order)
       implicit none
       integer,dimension(3),intent(in) :: periodic_dir
       integer,dimension(6) :: apply_BC_order
       apply_BC_order = (/5,6,1,2,3,4/) ! Chosen for lid-driven cavity case, lid at y_max
       if (sum(periodic_dir).eq.1) then
             if (periodic_dir(1).eq.1) then
             apply_BC_order = (/5,6,3,4,1,2/)
         elseif (periodic_dir(2).eq.1) then
             apply_BC_order = (/5,6,1,2,3,4/)
         elseif (periodic_dir(3).eq.1) then
             apply_BC_order = (/1,2,3,4,5,6/)
         else; stop 'Error: bad periodic_dir in get_apply_BC_order in sim_params_aux.f90'
         endif
       elseif (sum(periodic_dir).eq.2) then
             if ((periodic_dir(2).eq.1).and.(periodic_dir(3).eq.1)) then
             apply_BC_order = (/1,2,5,6,3,4/)
         elseif ((periodic_dir(1).eq.1).and.(periodic_dir(3).eq.1)) then
             apply_BC_order = (/3,4,5,6,1,2/)
         elseif ((periodic_dir(1).eq.1).and.(periodic_dir(2).eq.1)) then
             apply_BC_order = (/1,2,3,4,5,6/)
         else; stop 'Error: bad periodic_dir in get_apply_BC_order in sim_params_aux.f90'
         endif
       endif
     end function

     function get_FFT_dir(periodic_dir) result(FFT_dir)
       implicit none
       integer,dimension(3),intent(in) :: periodic_dir
       integer :: FFT_dir
       FFT_dir = 1
       if (sum(periodic_dir).eq.1) then
             if (periodic_dir(1).eq.1) then; FFT_dir = 1
         elseif (periodic_dir(2).eq.1) then; FFT_dir = 2
         elseif (periodic_dir(3).eq.1) then; FFT_dir = 3
         else; stop 'Error: bad periodic_dir in get_FFT_dir in sim_params_aux.f90'
         endif
       elseif (sum(periodic_dir).eq.2) then
             if ((periodic_dir(2).eq.1).and.(periodic_dir(3).eq.1)) then; FFT_dir = 1
         elseif ((periodic_dir(1).eq.1).and.(periodic_dir(3).eq.1)) then; FFT_dir = 2
         elseif ((periodic_dir(1).eq.1).and.(periodic_dir(2).eq.1)) then; FFT_dir = 3
         else; stop 'Error: bad periodic_dir in get_FFT_dir in sim_params_aux.f90'
         endif
       endif
     end function

     subroutine post_process_SP(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       call sanity_check(SP)
       if (SP%SCP%couple_time_steps) call couple_time_step(SP%VS,SP%coupled)
       if (SP%MP%mirror) SP%DP%KE_scale = SP%DP%KE_scale*2.0_cp
       if (SP%MP%mirror) SP%DP%ME_scale = SP%DP%ME_scale*2.0_cp
       if (SP%MP%mirror) SP%DP%JE_scale = SP%DP%JE_scale*2.0_cp
     end subroutine

     subroutine set_restart_SP(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       SP%FCL%restart_meshes = .true.
       SP%VS%T%SS%restart    = .true.
       SP%VS%U%SS%restart    = .true.
       SP%VS%P%SS%restart    = .true.
       SP%VS%B%SS%restart    = .true.
       SP%VS%B0%SS%restart   = .true.
       SP%VS%phi%SS%restart  = .true.
       SP%VS%rho%SS%restart  = .true.
     end subroutine

     subroutine sanity_check_SP(SP)
       implicit none
       type(sim_params),intent(in) :: SP
       call sanity_check(SP%VS)
       call check_time_statistics_window(SP)
     end subroutine

     function alpha_in_window(alpha,min_val,max_val) result(L)
       implicit none
       real(cp),intent(in) :: alpha,min_val,max_val
       logical :: L
       L = (alpha.gt.min_val).and.(alpha.lt.max_val)
     end function

     subroutine check_time_statistics_window(SP)
       implicit none
       type(sim_params),intent(in) :: SP
       logical,dimension(4) :: L_temp
       if (SP%TSP%collect) then
         L_temp(1) = alpha_in_window(SP%TSP%O1_stats%t_start,SP%DP%t_start,SP%DP%t_final)
         L_temp(2) = alpha_in_window(SP%TSP%O1_stats%t_stop ,SP%DP%t_start,SP%DP%t_final)
         L_temp(3) = alpha_in_window(SP%TSP%O2_stats%t_start,SP%DP%t_start,SP%DP%t_final)
         L_temp(4) = alpha_in_window(SP%TSP%O2_stats%t_stop ,SP%DP%t_start,SP%DP%t_final)
         if (.not.all(L_temp)) then
           write(*,*) ''
           write(*,*) 'Error: time-statistics window extends beyond'
           write(*,*) 'the simulation time. Ending execution.'
           write(*,*) 'SP%DP%t_start           = ',SP%DP%t_start
           write(*,*) 'SP%DP%t_final           = ',SP%DP%t_final
           write(*,*) 'SP%TSP%O1_stats%t_start = ',SP%TSP%O1_stats%t_start
           write(*,*) 'SP%TSP%O1_stats%t_stop  = ',SP%TSP%O1_stats%t_stop
           write(*,*) 'SP%TSP%O2_stats%t_start = ',SP%TSP%O2_stats%t_start
           write(*,*) 'SP%TSP%O2_stats%t_stop  = ',SP%TSP%O2_stats%t_stop
           stop 'Done in check_time_statistics_window in sim_params_aux.f90'
         endif
       endif
     end subroutine

     subroutine display_compiler_info_SP(un)
       implicit none
       integer,intent(in) :: un
       ! call get_environment_variable(name[, value, length, status, trim_name)
       write(un,*) ' ----------------- COMPILER FLAG INFO -------------- '
#ifdef _PARALLELIZE_GF_
       write(un,*) '_PARALLELIZE_GF_ = .true.'
#else
       write(un,*) '_PARALLELIZE_GF_ = .false.'
#endif
#ifdef _PARALLELIZE_BF_PLANE_
       write(un,*) '_PARALLELIZE_BF_PLANE_ = .true.'
#else
       write(un,*) '_PARALLELIZE_BF_PLANE_ = .false.'
#endif
#ifdef PARALLELIZE_2D_OPS
       write(un,*) 'PARALLELIZE_2D_OPS = .true.'
#else
       write(un,*) 'PARALLELIZE_2D_OPS = .false.'
#endif
#ifdef PARALLELIZE_1D_OPS
       write(un,*) 'PARALLELIZE_1D_OPS = .true.'
#else
       write(un,*) 'PARALLELIZE_1D_OPS = .false.'
#endif
     end subroutine

       subroutine display_compiler_info_wrapper_SP(dir,name)
         implicit none
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display_compiler_info(un)
         close(un)
       end subroutine

     end module
      module GF_add_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none
        private
        public :: add

        interface add;     module procedure add_GF_GF;        end interface
        interface add;     module procedure add_GF_GF_GF;     end interface
        interface add;     module procedure add_GF_GF_GF_GF;  end interface
        interface add;     module procedure add_GF_R;         end interface
        interface add;     module procedure add_GF_S;         end interface
        interface add;     module procedure add_S_GF;         end interface
        interface add;     module procedure add_GF_GF9;       end interface

      contains

        subroutine add_GF_GF(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'add_GF_GF (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = a%f(i,j,k) + b%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'add_GF_GF (2)')
#endif
          a%f = a%f + b%f
#endif
        end subroutine

        subroutine add_GF_GF_GF(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b,c
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'add_GF_GF_GF (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = b%f(i,j,k) + c%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'add_GF_GF_GF (2)')
#endif
          a%f = b%f + c%f
#endif
        end subroutine

        subroutine add_GF_GF_GF_GF(a,b,c,d)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b,c,d
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'add_GF_GF_GF_GF (1)')
          call insist_shape_match(a,c,'add_GF_GF_GF_GF (2)')
          call insist_shape_match(a,d,'add_GF_GF_GF_GF (3)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = b%f(i,j,k) + c%f(i,j,k) + d%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'add_GF_GF_GF_GF (4)')
          call insist_shape_match(a,c,'add_GF_GF_GF_GF (5)')
          call insist_shape_match(a,d,'add_GF_GF_GF_GF (6)')
#endif
          a%f = b%f + c%f + d%f
#endif
        end subroutine

        subroutine add_GF_R(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),dimension(:,:,:),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = a%f(i,j,k) + b(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          a%f = a%f + b
#endif
        end subroutine

        subroutine add_GF_S(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = a%f(i,j,k) + b
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          a%f = a%f + b
#endif
        end subroutine

        subroutine add_S_GF(g2,a)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: g2
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = a%f(i,j,k) + g2
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          a%f = a%f + g2
#endif
        end subroutine

        subroutine add_GF_GF9(A,B1,B2,B3,B4,B5,B6,B7,B8,B9)
          implicit none
          type(grid_field),intent(inout) :: A
          type(grid_field),intent(in) :: B1,B2,B3,B4,B5,B6,B7,B8,B9
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(A,B1,'add_GF_GF9 (1)')
          call insist_shape_match(A,B2,'add_GF_GF9 (2)')
          call insist_shape_match(A,B3,'add_GF_GF9 (3)')
          call insist_shape_match(A,B4,'add_GF_GF9 (4)')
          call insist_shape_match(A,B5,'add_GF_GF9 (5)')
          call insist_shape_match(A,B6,'add_GF_GF9 (6)')
          call insist_shape_match(A,B7,'add_GF_GF9 (7)')
          call insist_shape_match(A,B8,'add_GF_GF9 (8)')
          call insist_shape_match(A,B9,'add_GF_GF9 (9)')
#endif
          !$OMP PARALLEL DO
          do k=1,A%s(3); do j=1,A%s(2); do i=1,A%s(1)
          A%f(i,j,k) = B1%f(i,j,k)+B2%f(i,j,k)+B3%f(i,j,k)+&
                       B4%f(i,j,k)+B5%f(i,j,k)+B6%f(i,j,k)+&
                       B7%f(i,j,k)+B8%f(i,j,k)+B9%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(A,B1,'add_GF_GF9 (10)')
          call insist_shape_match(A,B2,'add_GF_GF9 (11)')
          call insist_shape_match(A,B3,'add_GF_GF9 (12)')
          call insist_shape_match(A,B4,'add_GF_GF9 (13)')
          call insist_shape_match(A,B5,'add_GF_GF9 (14)')
          call insist_shape_match(A,B6,'add_GF_GF9 (15)')
          call insist_shape_match(A,B7,'add_GF_GF9 (16)')
          call insist_shape_match(A,B8,'add_GF_GF9 (17)')
          call insist_shape_match(A,B9,'add_GF_GF9 (18)')
#endif
          A%f = B1%f+B2%f+B3%f+&
                B4%f+B5%f+B6%f+&
                B7%f+B8%f+B9%f
#endif
        end subroutine

      end module
      module GF_add_plane_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none

        private
        public :: add_plane
        interface add_plane;      module procedure add_plane_GF_S;     end interface
        interface add_plane;      module procedure add_plane_GF_GF;    end interface

        public :: add_plane_x
        public :: add_plane_y
        public :: add_plane_z
        interface add_plane_x;    module procedure add_plane_x_GF_S;   end interface
        interface add_plane_x;    module procedure add_plane_x_GF_GF;  end interface
        interface add_plane_y;    module procedure add_plane_y_GF_S;   end interface
        interface add_plane_y;    module procedure add_plane_y_GF_GF;  end interface
        interface add_plane_z;    module procedure add_plane_z_GF_S;   end interface
        interface add_plane_z;    module procedure add_plane_z_GF_GF;  end interface

        public :: add_2_planes_x
        public :: add_2_planes_y
        public :: add_2_planes_z
        interface add_2_planes_x; module procedure add_2_planes_x_S;   end interface
        interface add_2_planes_y; module procedure add_2_planes_y_S;   end interface
        interface add_2_planes_z; module procedure add_2_planes_z_S;   end interface

        contains

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine add_plane_GF_S(a,b,p,dir)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p,dir
          select case(dir)
          case (1); call add_plane_x(a,b,p)
          case (2); call add_plane_y(a,b,p)
          case (3); call add_plane_z(a,b,p)
          case default
          write(*,*) 'Error: dir must = 1:3 in add_plane_GF_S in GF_add_plane.f90'
          write(*,*) 'dir = ',dir
          stop 'Done'
          end select
        end subroutine

        subroutine add_plane_GF_GF(a,b,p_a,p_b,dir)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b,dir
          select case(dir)
          case (1); call add_plane_x(a,b,p_a,p_b)
          case (2); call add_plane_y(a,b,p_a,p_b)
          case (3); call add_plane_z(a,b,p_a,p_b)
          case default
          write(*,*) 'Error: dir must = 1:3 in add_plane_GF_GF in GF_add_plane.f90'
          write(*,*) 'dir = ',dir
          stop 'Done'
          end select
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine add_plane_x_GF_S(a,b,p)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p
          integer :: j,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do j=1,a%s(2)
          a%f(p,j,k) = a%f(p,j,k) + b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine add_plane_x_GF_GF(a,b,p_a,p_b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer :: j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,1,'add_plane_x_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do j=1,a%s(2)
          a%f(p_a,j,k) = a%f(p_a,j,k) + b%f(p_b,j,k)
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine add_2_planes_x_S(a,b,p_1,p_2)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p_1,p_2
          integer :: j,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do j=1,a%s(2)
          a%f(p_1,j,k) = a%f(p_1,j,k) + b
          a%f(p_2,j,k) = a%f(p_2,j,k) + b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine add_plane_y_GF_S(a,b,p)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p
          integer :: i,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do i=1,a%s(1)
          a%f(i,p,k) = a%f(i,p,k) + b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine add_plane_y_GF_GF(a,b,p_a,p_b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer :: i,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,2,'add_plane_y_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do i=1,a%s(1)
          a%f(i,p_a,k) = a%f(i,p_a,k) + b%f(i,p_b,k)
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine add_2_planes_y_S(a,b,p_1,p_2)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p_1,p_2
          integer :: i,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do i=1,a%s(1)
          a%f(i,p_1,k) = a%f(i,p_1,k) + b
          a%f(i,p_2,k) = a%f(i,p_2,k) + b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine add_plane_z_GF_S(a,b,p)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p
          integer :: i,j
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,p) = a%f(i,j,p) + b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine add_plane_z_GF_GF(a,b,p_a,p_b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer :: i,j
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,3,'add_plane_z_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,p_a) = a%f(i,j,p_a) + b%f(i,j,p_b)
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine add_2_planes_z_S(a,b,p_1,p_2)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p_1,p_2
          integer :: i,j
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,p_1) = a%f(i,j,p_1) + b
          a%f(i,j,p_2) = a%f(i,j,p_2) + b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

      end module
      module GF_add_product_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none
        private
        public :: add_product
        interface add_product;  module procedure add_product_GF_GF_S;    end interface
        interface add_product;  module procedure add_product_GF_GF_GF;   end interface

        contains

        subroutine add_product_GF_GF_S(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          real(cp),intent(in) :: c
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'add_product_GF_GF_S (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = a%f(i,j,k) + b%f(i,j,k)*c
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'add_product_GF_GF_S (2)')
#endif
          a%f = a%f + b%f*c
#endif
        end subroutine

        subroutine add_product_GF_GF_GF(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b,c
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'add_product_GF_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = a%f(i,j,k) + b%f(i,j,k)*c%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1) ! No intrinsic matrix-matrix mult.
          a%f(i,j,k) = a%f(i,j,k) + b%f(i,j,k)*c%f(i,j,k)
          enddo; enddo; enddo
#endif
        end subroutine

      end module
      module GF_assign_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none
        private
        public :: assign,assign_negative

        interface assign;                   module procedure assign_GF_S;            end interface
        interface assign;                   module procedure assign_GF_GF;           end interface
        interface assign;                   module procedure assign_GF_R;            end interface
        interface assign_negative;          module procedure assign_negative_GF_GF;  end interface

        contains

        subroutine assign_GF_GF(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'assign_GF_GF (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = b%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'assign_GF_GF (2)')
#endif
          a%f = b%f
#endif
        end subroutine

        subroutine assign_GF_R(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),dimension(:,:,:),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = b(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          a%f = b
#endif
        end subroutine

        subroutine assign_GF_S(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = b
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          a%f = b
#endif
        end subroutine

        subroutine assign_negative_GF_GF(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'assign_negative_GF_GF (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = -b%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'assign_negative_GF_GF (2)')
#endif
          a%f = -b%f
#endif
        end subroutine

      end module
      module GF_assign_plane_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none

        private
        public :: assign_plane
        interface assign_plane;      module procedure assign_plane_GF_S;     end interface
        interface assign_plane;      module procedure assign_plane_GF_GF;    end interface

        public :: assign_plane_x
        public :: assign_plane_y
        public :: assign_plane_z
        interface assign_plane_x;    module procedure assign_plane_x_GF_S;   end interface
        interface assign_plane_x;    module procedure assign_plane_x_GF_GF;  end interface
        interface assign_plane_y;    module procedure assign_plane_y_GF_S;   end interface
        interface assign_plane_y;    module procedure assign_plane_y_GF_GF;  end interface
        interface assign_plane_z;    module procedure assign_plane_z_GF_S;   end interface
        interface assign_plane_z;    module procedure assign_plane_z_GF_GF;  end interface

        public :: assign_2_planes_x
        public :: assign_2_planes_y
        public :: assign_2_planes_z
        interface assign_2_planes_x; module procedure assign_2_planes_x_S;   end interface
        interface assign_2_planes_y; module procedure assign_2_planes_y_S;   end interface
        interface assign_2_planes_z; module procedure assign_2_planes_z_S;   end interface

        contains

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine assign_plane_GF_S(a,b,p,dir)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p,dir
          select case(dir)
          case (1); call assign_plane_x(a,b,p)
          case (2); call assign_plane_y(a,b,p)
          case (3); call assign_plane_z(a,b,p)
          case default
          write(*,*) 'Error: dir must = 1:3 in assign_plane_GF_S in GF_assign_plane.f90'
          write(*,*) 'dir = ',dir
          stop 'Done'
          end select
        end subroutine

        subroutine assign_plane_GF_GF(a,b,p_a,p_b,dir)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b,dir
          select case(dir)
          case (1); call assign_plane_x(a,b,p_a,p_b)
          case (2); call assign_plane_y(a,b,p_a,p_b)
          case (3); call assign_plane_z(a,b,p_a,p_b)
          case default
          write(*,*) 'Error: dir must = 1:3 in assign_plane_GF_GF in GF_assign_plane.f90'
          write(*,*) 'dir = ',dir
          stop 'Done'
          end select
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine assign_plane_x_GF_S(a,b,p)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p
          integer :: j,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do j=1,a%s(2)
          a%f(p,j,k) = b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine assign_plane_x_GF_GF(a,b,p_a,p_b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer :: j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,1,'assign_plane_x_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do j=1,a%s(2)
          a%f(p_a,j,k) = b%f(p_b,j,k)
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine assign_2_planes_x_S(a,b,p_1,p_2)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p_1,p_2
          integer :: j,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do j=1,a%s(2)
          a%f(p_1,j,k) = b
          a%f(p_2,j,k) = b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine assign_plane_y_GF_S(a,b,p)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p
          integer :: i,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do i=1,a%s(1)
          a%f(i,p,k) = b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine assign_plane_y_GF_GF(a,b,p_a,p_b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer :: i,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,2,'assign_plane_y_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do i=1,a%s(1)
          a%f(i,p_a,k) = b%f(i,p_b,k)
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine assign_2_planes_y_S(a,b,p_1,p_2)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p_1,p_2
          integer :: i,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do i=1,a%s(1)
          a%f(i,p_1,k) = b
          a%f(i,p_2,k) = b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine assign_plane_z_GF_S(a,b,p)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p
          integer :: i,j
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,p) = b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine assign_plane_z_GF_GF(a,b,p_a,p_b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer :: i,j
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,3,'assign_plane_z_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,p_a) = b%f(i,j,p_b)
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine assign_2_planes_z_S(a,b,p_1,p_2)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p_1,p_2
          integer :: i,j
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,p_1) = b
          a%f(i,j,p_2) = b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

      end module
      module GF_assign_plane_ave_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none

        private
        public :: assign_plane_ave
        interface assign_plane_ave;   module procedure assign_plane_ave_GF; end interface

        public :: assign_plane_ave_x
        public :: assign_plane_ave_y
        public :: assign_plane_ave_z
        interface assign_plane_ave_x;  module procedure assign_plane_ave_x_GF; end interface
        interface assign_plane_ave_y;  module procedure assign_plane_ave_y_GF; end interface
        interface assign_plane_ave_z;  module procedure assign_plane_ave_z_GF; end interface

        contains

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine assign_plane_ave_GF(a,b,p_a,p_b1,p_b2,dir)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b1,p_b2,dir
          select case(dir)
          case (1); call assign_plane_ave_x(a,b,p_a,p_b1,p_b2)
          case (2); call assign_plane_ave_y(a,b,p_a,p_b1,p_b2)
          case (3); call assign_plane_ave_z(a,b,p_a,p_b1,p_b2)
          case default
          write(*,*) 'Error: dir must = 1:3 in assign_plane_GF_GF in GF_assign_plane.f90'
          write(*,*) 'dir = ',dir
          stop 'Done'
          end select
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine assign_plane_ave_x_GF(a,b,p_a,p_b1,p_b2)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b1,p_b2
          integer :: j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,1,'assign_plane_x_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do j=1,a%s(2)
          a%f(p_a,j,k) = 0.5_cp*(b%f(p_b1,j,k)+b%f(p_b2,j,k))
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine assign_plane_ave_y_GF(a,b,p_a,p_b1,p_b2)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b1,p_b2
          integer :: i,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,2,'assign_plane_y_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do i=1,a%s(1)
          a%f(i,p_a,k) = 0.5_cp*(b%f(i,p_b1,k)+b%f(i,p_b2,k))
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine assign_plane_ave_z_GF(a,b,p_a,p_b1,p_b2)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b1,p_b2
          integer :: i,j
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,3,'assign_plane_z_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,p_a) = 0.5_cp*(b%f(i,j,p_b1)+b%f(i,j,p_b2))
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

      end module
      module GF_divide_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none
        private

        public :: divide
        interface divide;                   module procedure divide_GF_GF;           end interface
        interface divide;                   module procedure divide_GF_GF_GF;        end interface
        interface divide;                   module procedure divide_GF_S_GF;         end interface
        interface divide;                   module procedure divide_GF_S;            end interface
        interface divide;                   module procedure divide_S_GF;            end interface

      contains

        subroutine divide_GF_GF(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'divide_GF_GF (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = a%f(i,j,k) / b%f(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'divide_GF_GF (2)')
#endif
          a%f = a%f / b%f
#endif
        end subroutine

        subroutine divide_GF_GF_GF(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b,c
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'divide_GF_GF_GF (1)')
          call insist_shape_match(a,c,'divide_GF_GF_GF (2)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = b%f(i,j,k) / c%f(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'divide_GF_GF_GF (3)')
          call insist_shape_match(a,c,'divide_GF_GF_GF (4)')
#endif
          a%f = b%f / c%f
#endif
        end subroutine

        subroutine divide_GF_S_GF(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: c
          real(cp),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,c,'divide_GF_S_GF (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = b / c%f(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,c,'divide_GF_S_GF (2)')
#endif
          a%f = b / c%f
#endif
        end subroutine

        subroutine divide_GF_S(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = a%f(i,j,k) / b
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
          a%f = a%f / b
#endif
        end subroutine

        subroutine divide_S_GF(g2,a)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: g2
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = g2 / a%f(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
          a%f = g2 / a%f
#endif
        end subroutine

      end module
       module GF_extrap_mod
       ! Compiler flags: (_DEBUG_EXTRAP_)
       use current_precision_mod
       use grid_field_mod
       use grid_field_extend_mod
       use face_edge_corner_indexing_mod
       use grid_mod
       implicit none

       private
       public :: extrap
       interface extrap;     module procedure extrap_staggered_GF;   end interface
       interface extrap;     module procedure extrap_self_GF;        end interface

       contains

       subroutine extrap_staggered_GF(N,C,dir)
         ! Formulae are simple because the first 2 cells have equal sizes.
         !         N  C  N  C  N  C  N  C  N
         !         |--o--|--o--|--o--|--o--|    --> dir
         !         *                       *
         !
         ! f_ghost + f_boundary
         ! --------------------  = C    -->  f_ghost = 2g - f_boundary
         !          2
         implicit none
         type(grid_field),intent(inout) :: N
         type(grid_field),intent(in) :: C
         integer,intent(in) :: dir
#ifdef _DEBUG_EXTRAP_
         call insist_shape_match(C,N,dir,'extrap_staggered_GF')
         call insist_shape_staggered(C,N,dir,'extrap_staggered_GF')
#endif
         ! Backward extrapolation
         select case (dir)
         case (1); N%f(1,:,:) = 2.0_cp*C%f(1,:,:) - N%f(2,:,:)
         case (2); N%f(:,1,:) = 2.0_cp*C%f(:,1,:) - N%f(:,2,:)
         case (3); N%f(:,:,1) = 2.0_cp*C%f(:,:,1) - N%f(:,:,2)
         end select
         ! Forward extrapolation
         select case (dir)
         case (1); N%f(N%s(1),:,:) = 2.0_cp*C%f(C%s(1),:,:) - N%f(N%s(1)-1,:,:)
         case (2); N%f(:,N%s(2),:) = 2.0_cp*C%f(:,C%s(2),:) - N%f(:,N%s(2)-1,:)
         case (3); N%f(:,:,N%s(3)) = 2.0_cp*C%f(:,:,C%s(3)) - N%f(:,:,N%s(3)-1)
         end select
       end subroutine

       subroutine extrap_self_GF(N,dir)
         ! Formulae are simple because the first 2 cells have equal sizes.
         implicit none
         type(grid_field),intent(inout) :: N
         integer,intent(in) :: dir
         ! Backward extrapolation
         select case (dir)
         case (1); N%f(1,:,:) = 2.0_cp*N%f(2,:,:) - N%f(3,:,:)
         case (2); N%f(:,1,:) = 2.0_cp*N%f(:,2,:) - N%f(:,3,:)
         case (3); N%f(:,:,1) = 2.0_cp*N%f(:,:,2) - N%f(:,:,3)
         end select
         ! Forward extrapolation
         select case (dir)
         case (1); N%f(N%s(1),:,:) = 2.0_cp*N%f(N%s(1)-1,:,:) - N%f(N%s(1)-2,:,:)
         case (2); N%f(:,N%s(2),:) = 2.0_cp*N%f(:,N%s(2)-1,:) - N%f(:,N%s(2)-2,:)
         case (3); N%f(:,:,N%s(3)) = 2.0_cp*N%f(:,:,N%s(3)-1) - N%f(:,:,N%s(3)-2)
         end select
       end subroutine

       end module
      module GF_magnitude_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none
        private
        public :: magnitude

        interface magnitude;     module procedure magnitude_GF_GF_GF_GF;  end interface

      contains

        subroutine magnitude_GF_GF_GF_GF(a,b,c,d)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b,c,d
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'magnitude_GF_GF_GF_GF (1)')
          call insist_shape_match(a,c,'magnitude_GF_GF_GF_GF (2)')
          call insist_shape_match(a,d,'magnitude_GF_GF_GF_GF (3)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = sqrt(b%f(i,j,k)**2.0_cp + c%f(i,j,k)**2.0_cp + d%f(i,j,k)**2.0_cp)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'magnitude_GF_GF_GF_GF (4)')
          call insist_shape_match(a,c,'magnitude_GF_GF_GF_GF (5)')
          call insist_shape_match(a,d,'magnitude_GF_GF_GF_GF (6)')
#endif
          a%f = sqrt(b%f**2.0_cp + c%f**2.0_cp + d%f**2.0_cp)
#endif
        end subroutine

      end module
      module GF_multiply_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none
        private
        public :: multiply

        interface multiply;                 module procedure multiply_GF_GF;         end interface
        interface multiply;                 module procedure multiply_GF_GF_GF;      end interface
        interface multiply;                 module procedure multiply_GF_GF_S;       end interface
        interface multiply;                 module procedure multiply_GF_S;          end interface
        interface multiply;                 module procedure multiply_S_GF;          end interface

      contains

        subroutine multiply_GF_GF(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'multiply_GF_GF (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = a%f(i,j,k) * b%f(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'multiply_GF_GF (2)')
#endif
          a%f = a%f * b%f
#endif
        end subroutine

        subroutine multiply_GF_GF_GF(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b,c
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'multiply_GF_GF_GF (1)')
          call insist_shape_match(a,c,'multiply_GF_GF_GF (2)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = b%f(i,j,k) * c%f(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'multiply_GF_GF_GF (3)')
          call insist_shape_match(a,c,'multiply_GF_GF_GF (4)')
#endif
          a%f = b%f * c%f
#endif
        end subroutine

        subroutine multiply_GF_GF_S(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          real(cp),intent(in) :: c
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'multiply_GF_GF_S (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = b%f(i,j,k) * c
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'multiply_GF_GF_S (2)')
#endif
          a%f = b%f * c
#endif
        end subroutine

        subroutine multiply_GF_S(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = a%f(i,j,k) * b
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
          a%f = a%f * b
#endif
        end subroutine

        subroutine multiply_S_GF(g2,a)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: g2
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = a%f(i,j,k) * g2
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
          a%f = a%f * g2
#endif
        end subroutine

      end module
      module GF_multiply_plane_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none

        private
        public :: multiply_plane
        interface multiply_plane;      module procedure multiply_plane_GF_S;            end interface
        interface multiply_plane;      module procedure multiply_plane_GF_GF;           end interface
        interface multiply_plane;      module procedure multiply_plane_GF_GF_shift;     end interface

        public :: multiply_plane_x
        public :: multiply_plane_y
        public :: multiply_plane_z
        interface multiply_plane_x;    module procedure multiply_plane_x_GF_S;          end interface
        interface multiply_plane_x;    module procedure multiply_plane_x_GF_GF;         end interface
        interface multiply_plane_x;    module procedure multiply_plane_x_GF_GF_shift;   end interface
        interface multiply_plane_y;    module procedure multiply_plane_y_GF_S;          end interface
        interface multiply_plane_y;    module procedure multiply_plane_y_GF_GF;         end interface
        interface multiply_plane_y;    module procedure multiply_plane_y_GF_GF_shift;   end interface
        interface multiply_plane_z;    module procedure multiply_plane_z_GF_S;          end interface
        interface multiply_plane_z;    module procedure multiply_plane_z_GF_GF;         end interface
        interface multiply_plane_z;    module procedure multiply_plane_z_GF_GF_shift;   end interface

        contains

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine multiply_plane_GF_S(a,b,p,dir)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p,dir
          select case(dir)
          case (1); call multiply_plane_x(a,b,p)
          case (2); call multiply_plane_y(a,b,p)
          case (3); call multiply_plane_z(a,b,p)
          case default
          write(*,*) 'Error: dir must = 1:3 in multiply_plane_GF_S in GF_multiply_plane.f90'
          write(*,*) 'dir = ',dir
          stop 'Done'
          end select
        end subroutine

        subroutine multiply_plane_GF_GF(a,b,p_a,p_b,dir)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b,dir
          select case(dir)
          case (1); call multiply_plane_x(a,b,p_a,p_b)
          case (2); call multiply_plane_y(a,b,p_a,p_b)
          case (3); call multiply_plane_z(a,b,p_a,p_b)
          case default
          write(*,*) 'Error: dir must = 1:3 in multiply_plane_GF_GF in GF_multiply_plane.f90'
          write(*,*) 'dir = ',dir
          stop 'Done'
          end select
        end subroutine

        subroutine multiply_plane_GF_GF_shift(a,b,p_a,p_b,dir,s)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b,dir
          integer,dimension(3),intent(in) :: s
          select case(dir)
          case (1); call multiply_plane_x(a,b,p_a,p_b,s)
          case (2); call multiply_plane_y(a,b,p_a,p_b,s)
          case (3); call multiply_plane_z(a,b,p_a,p_b,s)
          case default
          write(*,*) 'Error: dir must = 1:3 in multiply_plane_GF_GF_shift in GF_multiply_plane.f90'
          write(*,*) 'dir = ',dir
          stop 'Done'
          end select
        end subroutine


        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine multiply_plane_x_GF_S(a,b,p)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p
          integer :: j,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do j=1,a%s(2)
          a%f(p,j,k) = a%f(p,j,k)*b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine multiply_plane_x_GF_GF(a,b,p_a,p_b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer :: j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,1,'multiply_plane_x_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do j=1,a%s(2)
          a%f(p_a,j,k) = a%f(p_a,j,k)*b%f(p_b,j,k)
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine multiply_plane_x_GF_GF_shift(a,b,p_a,p_b,s)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer,dimension(3),intent(in) :: s
          integer :: j,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3)-s(3); do j=1,a%s(2)-s(2)
          a%f(p_a,j,k) = a%f(p_a,j,k)*b%f(p_b,j+s(2),k+s(3))
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine multiply_plane_y_GF_S(a,b,p)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p
          integer :: i,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do i=1,a%s(1)
          a%f(i,p,k) = a%f(i,p,k)*b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine multiply_plane_y_GF_GF(a,b,p_a,p_b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer :: i,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,2,'multiply_plane_y_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3); do i=1,a%s(1)
          a%f(i,p_a,k) = a%f(i,p_a,k)*b%f(i,p_b,k)
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine multiply_plane_y_GF_GF_shift(a,b,p_a,p_b,s)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer,dimension(3),intent(in) :: s
          integer :: i,k
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do k=1,a%s(3)-s(3); do i=1,a%s(1)-s(1)
          a%f(i,p_a,k) = a%f(i,p_a,k)*b%f(i+s(1),p_b,k+s(3))
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        subroutine multiply_plane_z_GF_S(a,b,p)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
          integer,intent(in) :: p
          integer :: i,j
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,p) = a%f(i,j,p)*b
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine multiply_plane_z_GF_GF(a,b,p_a,p_b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer :: i,j
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,3,'multiply_plane_z_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,p_a) = a%f(i,j,p_a)*b%f(i,j,p_b)
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine
        subroutine multiply_plane_z_GF_GF_shift(a,b,p_a,p_b,s)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
          integer,intent(in) :: p_a,p_b
          integer,dimension(3),intent(in) :: s
          integer :: i,j
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP PARALLEL DO

#endif
          do j=1,a%s(2)-s(2); do i=1,a%s(1)-s(1)
          a%f(i,j,p_a) = a%f(i,j,p_a)*b%f(i+s(1),j+s(2),p_b)
          enddo; enddo
#ifdef _PARALLELIZE_GF_PLANE_
          !$OMP END PARALLEL DO

#endif
        end subroutine

      end module
       module GF_norms_weights_mod
       use current_precision_mod
       use grid_field_mod
       use grid_field_extend_mod
       use grid_mod
       implicit none

       private
       public :: compute_Ln_norm

       ! Interfaces:
       ! Ln(e,u,n,mesh) = L(n) = ∫∫∫ u(i,j,k)ⁿ dx dy dz   ! Only for CC data
       ! Ln(e,u,n,vol)  = L(n) = ∫∫∫ u(i,j,k)ⁿ dx dy dz

       interface compute_Ln_norm;    module procedure Ln_weights_1_GF;  end interface
       interface compute_Ln_norm;    module procedure Ln_weights_3_GF;  end interface
       interface compute_Ln_norm;    module procedure Ln_weights_9_GF;  end interface

       contains

       subroutine Ln_weights_1_GF(e,u,n,vol)
         implicit none
         real(cp),intent(inout) :: e
         type(grid_field),intent(in) :: u,vol
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: i,j,k
#ifdef _DEBUG_GF_NORMS_
         call insist_shape_match(u,vol,'Ln_weights_1_GF')
#endif
         temp = 0.0_cp
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP PARALLEL DO REDUCTION(+:temp)

#endif
         do k=1,u%s(3); do j=1,u%s(2); do i=1,u%s(1)
           temp = temp + (U%f(i,j,k)**n)*vol%f(i,j,k)
         enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP END PARALLEL DO

#endif
         e = temp
       end subroutine

       subroutine Ln_weights_3_GF(e,u_x,u_y,u_z,n,vol)
         implicit none
         real(cp),intent(inout) :: e
         type(grid_field),intent(in) :: u_x,u_y,u_z,vol
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: i,j,k
#ifdef _DEBUG_GF_NORMS_
         call insist_shape_match(u_x,u_y,'Ln_weights_3_GF (1)')
         call insist_shape_match(u_x,u_z,'Ln_weights_3_GF (2)')
#endif
         temp = 0.0_cp
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP PARALLEL DO REDUCTION(+:temp)

#endif
         do k=1,u_x%s(3); do j=1,u_x%s(2); do i=1,u_x%s(1)
           temp = temp + (u_x%f(i,j,k)**n+&
                          u_y%f(i,j,k)**n+&
                          u_z%f(i,j,k)**n)*vol%f(i,j,k)
         enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP END PARALLEL DO

#endif
         e = temp
       end subroutine

       subroutine Ln_weights_9_GF(e,u_xx,u_xy,u_xz,u_yx,u_yy,u_yz,u_zx,u_zy,u_zz,n,vol)
         implicit none
         real(cp),intent(inout) :: e
         type(grid_field),intent(in) :: u_xx,u_xy,u_xz,u_yx,u_yy,u_yz,u_zx,u_zy,u_zz,vol
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: i,j,k
#ifdef _DEBUG_GF_NORMS_
         call insist_shape_match(u_xx,u_xy,'Ln_weights_9_GF (1)')
         call insist_shape_match(u_xx,u_xz,'Ln_weights_9_GF (2)')
         call insist_shape_match(u_xx,u_yx,'Ln_weights_9_GF (3)')
         call insist_shape_match(u_xx,u_yy,'Ln_weights_9_GF (4)')
         call insist_shape_match(u_xx,u_yz,'Ln_weights_9_GF (5)')
         call insist_shape_match(u_xx,u_zx,'Ln_weights_9_GF (6)')
         call insist_shape_match(u_xx,u_zy,'Ln_weights_9_GF (7)')
         call insist_shape_match(u_xx,u_zz,'Ln_weights_9_GF (8)')
#endif
         temp = 0.0_cp
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP PARALLEL DO REDUCTION(+:temp)

#endif
         do k=1,u_xx%s(3); do j=1,u_xx%s(2); do i=1,u_xx%s(1)
           temp = temp + (u_xx%f(i,j,k)**n+&
                          u_xy%f(i,j,k)**n+&
                          u_xz%f(i,j,k)**n+&
                          u_yx%f(i,j,k)**n+&
                          u_yy%f(i,j,k)**n+&
                          u_yz%f(i,j,k)**n+&
                          u_zx%f(i,j,k)**n+&
                          u_zy%f(i,j,k)**n+&
                          u_zz%f(i,j,k)**n)*vol%f(i,j,k)
         enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP END PARALLEL DO

#endif
         e = temp
       end subroutine

       end module
       module GF_norms_weights_light_mod
       use current_precision_mod
       use grid_field_extend_mod
       use grid_extend_mod
       use data_location_extend_mod
       use array_mod
       implicit none

       private
       public :: compute_Ln_norm

       ! Interfaces:
       ! Ln(e,u,n,mesh) = L(n) = ∫∫∫ u(i,j,k)ⁿ dx dy dz   ! Only for CC data
       ! Ln(e,u,n,vol)  = L(n) = ∫∫∫ u(i,j,k)ⁿ dx dy dz

       interface compute_Ln_norm;    module procedure Ln_weights_1_GF;  end interface
       interface compute_Ln_norm;    module procedure Ln_weights_3_GF;  end interface
       interface compute_Ln_norm;    module procedure Ln_weights_9_GF;  end interface

       contains

       subroutine Ln_weights_1_GF(val,u,n,g,DL)
         implicit none
         real(cp),intent(inout) :: val
         type(grid_field),intent(in) :: u
         type(data_location),intent(in) :: DL
         type(grid),intent(in) :: g
         real(cp),intent(in) :: n
         type(array),dimension(3) :: dh
         integer,dimension(3) :: e
         real(cp) :: temp
         integer :: i,j,k
         call get_coordinates_dual_dh(dh,g,DL)
         e = N_eye(DL)
         temp = 0.0_cp
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP PARALLEL DO REDUCTION(+:temp)

#endif
         do k=1+e(3),u%s(3)-e(3); do j=1+e(2),u%s(2)-e(2); do i=1+e(1),u%s(1)-e(1)
           temp = temp + (U%f(i,j,k)**n)*(dh(1)%f(i-e(1))*&
                                          dh(2)%f(j-e(2))*&
                                          dh(3)%f(k-e(3)))
         enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP END PARALLEL DO

#endif
         do i=1,3; call delete(dh(i)); enddo
         val = temp
       end subroutine

       subroutine Ln_weights_3_GF(val,u_x,u_y,u_z,n,g,DL)
         implicit none
         real(cp),intent(inout) :: val
         type(grid_field),intent(in) :: u_x,u_y,u_z
         type(data_location),intent(in) :: DL
         type(grid),intent(in) :: g
         real(cp),intent(in) :: n
         type(array),dimension(3) :: dh
         integer,dimension(3) :: e
         real(cp) :: temp
         integer :: i,j,k
#ifdef _DEBUG_GF_NORMS_
         call insist_shape_match(u_x,u_y,'Ln_weights_3_GF (1)')
         call insist_shape_match(u_x,u_z,'Ln_weights_3_GF (2)')
#endif
         call get_coordinates_dual_dh(dh,g,DL)
         e = N_eye(DL)
         temp = 0.0_cp
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP PARALLEL DO REDUCTION(+:temp)

#endif
         do k=1+e(3),u_x%s(3)-e(3); do j=1+e(2),u_x%s(2)-e(2); do i=1+e(1),u_x%s(1)-e(1)
           temp = temp + (u_x%f(i,j,k)**n+&
                          u_y%f(i,j,k)**n+&
                          u_z%f(i,j,k)**n)*(dh(1)%f(i-e(1))*&
                                            dh(2)%f(j-e(2))*&
                                            dh(3)%f(k-e(3)))
         enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP END PARALLEL DO

#endif
         do i=1,3; call delete(dh(i)); enddo
         val = temp
       end subroutine

       subroutine Ln_weights_9_GF(val,u_xx,u_xy,u_xz,u_yx,u_yy,u_yz,u_zx,u_zy,u_zz,n,g,DL)
         implicit none
         real(cp),intent(inout) :: val
         type(grid_field),intent(in) :: u_xx,u_xy,u_xz,u_yx,u_yy,u_yz,u_zx,u_zy,u_zz
         type(data_location),intent(in) :: DL
         type(grid),intent(in) :: g
         real(cp),intent(in) :: n
         type(array),dimension(3) :: dh
         integer,dimension(3) :: e
         real(cp) :: temp
         integer :: i,j,k
#ifdef _DEBUG_GF_NORMS_
         call insist_shape_match(u_xx,u_xy,'Ln_weights_9_GF (1)')
         call insist_shape_match(u_xx,u_xz,'Ln_weights_9_GF (2)')
         call insist_shape_match(u_xx,u_yx,'Ln_weights_9_GF (3)')
         call insist_shape_match(u_xx,u_yy,'Ln_weights_9_GF (4)')
         call insist_shape_match(u_xx,u_yz,'Ln_weights_9_GF (5)')
         call insist_shape_match(u_xx,u_zx,'Ln_weights_9_GF (6)')
         call insist_shape_match(u_xx,u_zy,'Ln_weights_9_GF (7)')
         call insist_shape_match(u_xx,u_zz,'Ln_weights_9_GF (8)')
#endif
         call get_coordinates_dual_dh(dh,g,DL)
         e = N_eye(DL)
         temp = 0.0_cp
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP PARALLEL DO REDUCTION(+:temp)

#endif
         do k=1+e(3),u_xx%s(3)-e(3); do j=1+e(2),u_xx%s(2)-e(2); do i=1+e(1),u_xx%s(1)-e(1)
           temp = temp + (u_xx%f(i,j,k)**n+&
                          u_xy%f(i,j,k)**n+&
                          u_xz%f(i,j,k)**n+&
                          u_yx%f(i,j,k)**n+&
                          u_yy%f(i,j,k)**n+&
                          u_yz%f(i,j,k)**n+&
                          u_zx%f(i,j,k)**n+&
                          u_zy%f(i,j,k)**n+&
                          u_zz%f(i,j,k)**n)*(dh(1)%f(i-e(1))*&
                                             dh(2)%f(j-e(2))*&
                                             dh(3)%f(k-e(3)))
         enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP END PARALLEL DO

#endif
         do i=1,3; call delete(dh(i)); enddo
         val = temp
       end subroutine

       end module
      module GF_product_add_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none
        private
        public :: product_add

        interface product_add;              module procedure product_add_GF_GF_S;    end interface
        interface product_add;              module procedure product_add_GF_GF_GF;   end interface

      contains

        subroutine product_add_GF_GF_S(a,c,b)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: c
          type(grid_field),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'product_add_GF_GF_S (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = a%f(i,j,k)*c + b%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'product_add_GF_GF_S (2)')
#endif
          a%f = a%f*c + b%f
#endif
        end subroutine

        subroutine product_add_GF_GF_GF(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b,c
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'product_add_GF_GF_GF')
#endif
#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = a%f(i,j,k)*c%f(i,j,k) + b%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1) ! No intrinsic matrix-matrix mult.
          a%f(i,j,k) = a%f(i,j,k)*c%f(i,j,k) + b%f(i,j,k)
          enddo; enddo; enddo
#endif
        end subroutine

      end module
      module GF_subtract_mod
        use grid_field_mod
        use grid_field_extend_mod
        use current_precision_mod
        implicit none
        private
        public :: subtract

        interface subtract;                 module procedure subtract_GF_GF;         end interface
        interface subtract;                 module procedure subtract_GF_GF_GF;      end interface
        interface subtract;                 module procedure subtract_GF_R_R;        end interface
        interface subtract;                 module procedure subtract_GF_R;          end interface
        interface subtract;                 module procedure subtract_GF_S;          end interface
        interface subtract;                 module procedure subtract_S_GF;          end interface

      contains

        subroutine subtract_GF_GF(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'subtract_GF_GF (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = a%f(i,j,k) - b%f(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'subtract_GF_GF (2)')
#endif
          a%f = a%f - b%f
#endif
        end subroutine

        subroutine subtract_GF_GF_GF(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a
          type(grid_field),intent(in) :: b,c
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'subtract_GF_GF_GF (1)')
#endif
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = b%f(i,j,k) - c%f(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
#ifdef _DEBUG_GF_
          call insist_shape_match(a,b,'subtract_GF_GF_GF (2)')
#endif
          a%f = b%f - c%f
#endif
        end subroutine

        subroutine subtract_GF_R_R(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),dimension(:,:,:),intent(in) :: b,c
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = b(i,j,k) - c(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
          a%f = b - c
#endif
        end subroutine

        subroutine subtract_GF_S(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = a%f(i,j,k) - b
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
          a%f = a%f - b
#endif
        end subroutine

        subroutine subtract_GF_R(a,b)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),dimension(:,:,:),intent(in) :: b
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = a%f(i,j,k) - b(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
          a%f = a%f - b
#endif
        end subroutine

        subroutine subtract_S_GF(g2,a)
          implicit none
          type(grid_field),intent(inout) :: a
          real(cp),intent(in) :: g2
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3)
            do j=1,a%s(2)
              do i=1,a%s(1)
                a%f(i,j,k) = g2 - a%f(i,j,k)
              enddo
            enddo
          enddo
          !$OMP END PARALLEL DO
#else
          a%f = g2 - a%f
#endif
        end subroutine

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module block_field_mod
       use procedure_array_plane_op_mod
       use grid_field_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use boundary_conditions_mod
       use string_mod
       use data_location_mod
       use dir_manip_mod
       implicit none

       private
       public :: block_field
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,get_necessary_for_restart,suppress_warnings

       interface init;                     module procedure init_copy_block_field;                end interface
       interface delete;                   module procedure delete_block_field;                   end interface
       interface display;                  module procedure display_block_field;                  end interface
       interface display_short;            module procedure display_short_block_field;            end interface
       interface display;                  module procedure display_wrap_block_field;             end interface
       interface print;                    module procedure print_block_field;                    end interface
       interface print_short;              module procedure print_short_block_field;              end interface
       interface export;                   module procedure export_block_field;                   end interface
       interface export_primitives;        module procedure export_primitives_block_field;        end interface
       interface import;                   module procedure import_block_field;                   end interface
       interface export_folder_structure;  module procedure export_folder_structure_block_field;  end interface
       interface export_structured;        module procedure export_structured_D_block_field;      end interface
       interface import_structured;        module procedure import_structured_D_block_field;      end interface
       interface import_primitives;        module procedure import_primitives_block_field;        end interface
       interface export;                   module procedure export_wrap_block_field;              end interface
       interface import;                   module procedure import_wrap_block_field;              end interface
       interface set_IO_dir;               module procedure set_IO_dir_block_field;               end interface
       interface make_IO_dir;              module procedure make_IO_dir_block_field;              end interface
       interface get_necessary_for_restart;module procedure get_necessary_for_restart_block_field;end interface
       interface suppress_warnings;        module procedure suppress_warnings_block_field;        end interface

       type block_field
         logical :: BCs_defined = .false.
         logical :: necessary_for_restart = .false.
         type(boundary_conditions) :: BCs
         type(grid_field) :: GF
         type(data_location) :: DL
         logical,dimension(3) :: many_cell_N_periodic = .false.
         logical,dimension(3) :: many_cell = .false.
         type(procedure_array_plane_op) :: PA_assign_ghost_XPeriodic
         type(procedure_array_plane_op) :: PA_assign_ghost_N_XPeriodic
         type(procedure_array_plane_op) :: PA_assign_wall_Dirichlet
         type(procedure_array_plane_op) :: PA_assign_wall_Periodic_single
         type(procedure_array_plane_op) :: PA_multiply_wall_Neumann
       end type

       contains

       subroutine init_copy_block_field(this,that)
         implicit none
         type(block_field),intent(inout) :: this
         type(block_field),intent(in) :: that
         call delete(this)
         this%BCs_defined = that%BCs_defined
         this%necessary_for_restart = that%necessary_for_restart
         call init(this%BCs,that%BCs)
         call init(this%GF,that%GF)
         call init(this%DL,that%DL)
         this%many_cell_N_periodic = that%many_cell_N_periodic
         this%many_cell = that%many_cell
         call init(this%PA_assign_ghost_XPeriodic,&
         that%PA_assign_ghost_XPeriodic)
         call init(this%PA_assign_ghost_N_XPeriodic,&
         that%PA_assign_ghost_N_XPeriodic)
         call init(this%PA_assign_wall_Dirichlet,&
         that%PA_assign_wall_Dirichlet)
         call init(this%PA_assign_wall_Periodic_single,&
         that%PA_assign_wall_Periodic_single)
         call init(this%PA_multiply_wall_Neumann,&
         that%PA_multiply_wall_Neumann)
       end subroutine

       subroutine delete_block_field(this)
         implicit none
         type(block_field),intent(inout) :: this
         this%BCs_defined = .false.
         this%necessary_for_restart = .false.
         call delete(this%BCs)
         call delete(this%GF)
         call delete(this%DL)
         this%many_cell_N_periodic = .false.
         this%many_cell = .false.
         call delete(this%PA_assign_ghost_XPeriodic)
         call delete(this%PA_assign_ghost_N_XPeriodic)
         call delete(this%PA_assign_wall_Dirichlet)
         call delete(this%PA_assign_wall_Periodic_single)
         call delete(this%PA_multiply_wall_Neumann)
       end subroutine

       subroutine display_block_field(this,un)
         implicit none
         type(block_field),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'BCs_defined                    = ',this%BCs_defined
         write(un,*) 'necessary_for_restart          = ',&
         this%necessary_for_restart
         call display(this%BCs,un)
         call display(this%GF,un)
         call display(this%DL,un)
         write(un,*) 'many_cell_N_periodic           = ',&
         this%many_cell_N_periodic
         write(un,*) 'many_cell                      = ',this%many_cell
         call display(this%PA_assign_ghost_XPeriodic,un)
         call display(this%PA_assign_ghost_N_XPeriodic,un)
         call display(this%PA_assign_wall_Dirichlet,un)
         call display(this%PA_assign_wall_Periodic_single,un)
         call display(this%PA_multiply_wall_Neumann,un)
       end subroutine

       subroutine display_short_block_field(this,un)
         implicit none
         type(block_field),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'BCs_defined                    = ',this%BCs_defined
         write(un,*) 'necessary_for_restart          = ',&
         this%necessary_for_restart
         call display(this%BCs,un)
         call display(this%GF,un)
         call display(this%DL,un)
         write(un,*) 'many_cell_N_periodic           = ',&
         this%many_cell_N_periodic
         write(un,*) 'many_cell                      = ',this%many_cell
         call display(this%PA_assign_ghost_XPeriodic,un)
         call display(this%PA_assign_ghost_N_XPeriodic,un)
         call display(this%PA_assign_wall_Dirichlet,un)
         call display(this%PA_assign_wall_Periodic_single,un)
         call display(this%PA_multiply_wall_Neumann,un)
       end subroutine

       subroutine display_wrap_block_field(this,dir,name)
         implicit none
         type(block_field),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_block_field(this)
         implicit none
         type(block_field),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_block_field(this)
         implicit none
         type(block_field),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_block_field(this,un)
         implicit none
         type(block_field),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%BCs,un)
         call export(this%GF,un)
         call export(this%DL,un)
         call export(this%PA_assign_ghost_XPeriodic,un)
         call export(this%PA_assign_ghost_N_XPeriodic,un)
         call export(this%PA_assign_wall_Dirichlet,un)
         call export(this%PA_assign_wall_Periodic_single,un)
         call export(this%PA_multiply_wall_Neumann,un)
       end subroutine

       subroutine import_block_field(this,un)
         implicit none
         type(block_field),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%BCs,un)
         call import(this%GF,un)
         call import(this%DL,un)
         call import(this%PA_assign_ghost_XPeriodic,un)
         call import(this%PA_assign_ghost_N_XPeriodic,un)
         call import(this%PA_assign_wall_Dirichlet,un)
         call import(this%PA_assign_wall_Periodic_single,un)
         call import(this%PA_multiply_wall_Neumann,un)
       end subroutine

       subroutine export_primitives_block_field(this,un)
         implicit none
         type(block_field),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'BCs_defined                     = ';write(un,*) this%BCs_defined
         write(un,*) 'necessary_for_restart           = ';write(un,*) this%necessary_for_restart
         write(un,*) 'many_cell_N_periodic            = ';write(un,*) this%many_cell_N_periodic
         write(un,*) 'many_cell                       = ';write(un,*) this%many_cell
       end subroutine

       subroutine import_primitives_block_field(this,un)
         implicit none
         type(block_field),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%BCs_defined
         read(un,*); read(un,*) this%necessary_for_restart
         read(un,*); read(un,*) this%many_cell_N_periodic
         read(un,*); read(un,*) this%many_cell
       end subroutine

       subroutine export_wrap_block_field(this,dir,name)
         implicit none
         type(block_field),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_block_field(this,dir,name)
         implicit none
         type(block_field),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       function get_necessary_for_restart_block_field(this) result(L)
         implicit none
         type(block_field),intent(in) :: this
         logical :: L
         L = this%necessary_for_restart
       end function

       subroutine set_IO_dir_block_field(this,dir)
         implicit none
         type(block_field),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%BCs,dir//'BCs'//fortran_PS)
         call set_IO_dir(this%GF,dir//'GF'//fortran_PS)
         call set_IO_dir(this%DL,dir//'DL'//fortran_PS)
         call set_IO_dir(this%PA_assign_ghost_XPeriodic,&
         dir//'PA_assign_ghost_XPeriodic'//fortran_PS)
         call set_IO_dir(this%PA_assign_ghost_N_XPeriodic,&
         dir//'PA_assign_ghost_N_XPeriodic'//fortran_PS)
         call set_IO_dir(this%PA_assign_wall_Dirichlet,&
         dir//'PA_assign_wall_Dirichlet'//fortran_PS)
         call set_IO_dir(this%PA_assign_wall_Periodic_single,&
         dir//'PA_assign_wall_Periodic_single'//fortran_PS)
         call set_IO_dir(this%PA_multiply_wall_Neumann,&
         dir//'PA_multiply_wall_Neumann'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_block_field(this,dir)
         implicit none
         type(block_field),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%BCs,dir//'BCs'//fortran_PS)
         call make_IO_dir(this%GF,dir//'GF'//fortran_PS)
         call make_IO_dir(this%DL,dir//'DL'//fortran_PS)
         call make_IO_dir(this%PA_assign_ghost_XPeriodic,&
         dir//'PA_assign_ghost_XPeriodic'//fortran_PS)
         call make_IO_dir(this%PA_assign_ghost_N_XPeriodic,&
         dir//'PA_assign_ghost_N_XPeriodic'//fortran_PS)
         call make_IO_dir(this%PA_assign_wall_Dirichlet,&
         dir//'PA_assign_wall_Dirichlet'//fortran_PS)
         call make_IO_dir(this%PA_assign_wall_Periodic_single,&
         dir//'PA_assign_wall_Periodic_single'//fortran_PS)
         call make_IO_dir(this%PA_multiply_wall_Neumann,&
         dir//'PA_multiply_wall_Neumann'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_block_field(this,dir)
         implicit none
         type(block_field),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%BCs,dir//'BCs'//fortran_PS)
         if (this%necessary_for_restart) then
           call export_structured(this%GF,dir//'GF'//fortran_PS)
         endif
         call export_structured(this%DL,dir//'DL'//fortran_PS)
         call export_structured(this%PA_assign_ghost_XPeriodic,&
         dir//'PA_assign_ghost_XPeriodic'//fortran_PS)
         call export_structured(this%PA_assign_ghost_N_XPeriodic,&
         dir//'PA_assign_ghost_N_XPeriodic'//fortran_PS)
         call export_structured(this%PA_assign_wall_Dirichlet,&
         dir//'PA_assign_wall_Dirichlet'//fortran_PS)
         call export_structured(this%PA_assign_wall_Periodic_single,&
         dir//'PA_assign_wall_Periodic_single'//fortran_PS)
         call export_structured(this%PA_multiply_wall_Neumann,&
         dir//'PA_multiply_wall_Neumann'//fortran_PS)
       end subroutine

       subroutine export_structured_D_block_field(this,dir)
         implicit none
         type(block_field),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%BCs,dir//'BCs'//fortran_PS)
         if (this%necessary_for_restart) then
           call export_structured(this%GF,dir//'GF'//fortran_PS)
         endif
         call export_structured(this%DL,dir//'DL'//fortran_PS)
         call export_structured(this%PA_assign_ghost_XPeriodic,&
         dir//'PA_assign_ghost_XPeriodic'//fortran_PS)
         call export_structured(this%PA_assign_ghost_N_XPeriodic,&
         dir//'PA_assign_ghost_N_XPeriodic'//fortran_PS)
         call export_structured(this%PA_assign_wall_Dirichlet,&
         dir//'PA_assign_wall_Dirichlet'//fortran_PS)
         call export_structured(this%PA_assign_wall_Periodic_single,&
         dir//'PA_assign_wall_Periodic_single'//fortran_PS)
         call export_structured(this%PA_multiply_wall_Neumann,&
         dir//'PA_multiply_wall_Neumann'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_block_field(this,dir)
         implicit none
         type(block_field),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%BCs,dir//'BCs'//fortran_PS)
         if (this%necessary_for_restart) then
           call import_structured(this%GF,dir//'GF'//fortran_PS)
         endif
         call import_structured(this%DL,dir//'DL'//fortran_PS)
         call import_structured(this%PA_assign_ghost_XPeriodic,&
         dir//'PA_assign_ghost_XPeriodic'//fortran_PS)
         call import_structured(this%PA_assign_ghost_N_XPeriodic,&
         dir//'PA_assign_ghost_N_XPeriodic'//fortran_PS)
         call import_structured(this%PA_assign_wall_Dirichlet,&
         dir//'PA_assign_wall_Dirichlet'//fortran_PS)
         call import_structured(this%PA_assign_wall_Periodic_single,&
         dir//'PA_assign_wall_Periodic_single'//fortran_PS)
         call import_structured(this%PA_multiply_wall_Neumann,&
         dir//'PA_multiply_wall_Neumann'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_block_field(this)
         implicit none
         type(block_field),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
     module mesh_bank_mod
     use current_precision_mod
     use constants_mod
     use string_mod
     use dir_tree_mod
     use path_extend_mod
     use mesh_params_extend_mod
     use segment_extend_mod
     use mesh_quality_params_extend_mod
     use sim_params_mod
     use sim_params_aux_mod
     implicit none

     private
     public :: define_mesh_SP_plasma_disruption
     public :: define_mesh_SP_plasma_disruption_plane
     public :: define_mesh_SP_plasma_disruption_plane_insulating
     public :: define_mesh_SP_plasma_disruption_line
     public :: define_mesh_SP_plasma_disruption_1D_analytic
     public :: small_dataset
     public :: define_mesh_bandaru
     public :: define_mesh_bandaru_FFT
     public :: define_mesh_MHD_Shercliff_plane
     public :: define_mesh_MHD_Shercliff_plane_FFT
     public :: define_mesh_full_BC_w_vacuum_symmetric
     public :: define_mesh_full_BC_n_vacuum_symmetric
     public :: define_mesh_full_BC_w_vacuum_3D
     public :: define_mesh_full_BC_w_vacuum_3D_high_res
     public :: define_mesh_full_BC_n_vacuum_3D
     public :: define_mesh_SP_MHD_LDC_Sergey_uniform
     public :: define_mesh_hydro_LDC_Ghia

     contains

     subroutine define_mesh_SP_plasma_disruption(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_wall,t_fluid,CR,buffer
       integer :: N,N_w
       CR = 10.0_cp ! Cavity Ratio
       t_fluid = 1.0_cp; t_wall = 0.05_cp; buffer = 1.5_cp;
       N = 100; N_w = 14
       ! N = 30; N_w = 4
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_Roberts_B'   ,N*2 ,-t_fluid*CR,t_fluid*CR,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_Roberts_B'   ,N   ,-t_fluid   ,t_fluid   ,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B'   ,N   ,-t_fluid   ,t_fluid   ,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call add_ext(SP%MP_sigma,seg_1d(1,'ext_Roberts_B_IO',N_w*2,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(2,'ext_Roberts_B_IO',N_w  ,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(3,'ext_Roberts_B_IO',N_w  ,t_wall,buffer))
       call init(SP%MP_ind,SP%MP_sigma)
     end subroutine

     subroutine define_mesh_SP_plasma_disruption_plane(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_wall,t_fluid,buffer
       integer :: N,N_w
       t_fluid = 1.0_cp; t_wall = 0.05_cp; buffer = 1.5_cp;
       N = 130; N_w = 14
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_uniform'  ,1 ,-0.5_cp ,0.5_cp ,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_Roberts_B',N ,-t_fluid,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B',N ,-t_fluid,t_fluid,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call add_ext(SP%MP_sigma,seg_1d(2,'ext_Roberts_B_IO',N_w,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(3,'ext_Roberts_B_IO',N_w,t_wall,buffer))
       call init(SP%MP_ind,SP%MP_sigma)
     end subroutine

     subroutine define_mesh_SP_plasma_disruption_plane_insulating(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_wall,t_fluid,buffer
       integer :: N,N_w
       t_fluid = 1.0_cp; t_wall = 0.05_cp; buffer = 1.5_cp;
       N = 150; N_w = 14
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_uniform'  ,1 ,-0.5_cp ,0.5_cp ,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_Roberts_B',N ,-t_fluid,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B',N ,-t_fluid,t_fluid,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call init(SP%MP_ind,SP%MP_sigma)
     end subroutine

     subroutine define_mesh_SP_plasma_disruption_line(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_wall,t_fluid,buffer
       integer :: N,N_w
       t_fluid = 1.0_cp; t_wall = 0.05_cp; buffer = 1.5_cp;
       N = 200; N_w = 14
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_uniform'  ,1 ,-0.5_cp ,0.5_cp ,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_uniform'  ,1 ,-0.5_cp ,0.5_cp ,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B',N ,-t_fluid,t_fluid,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call add_ext(SP%MP_sigma,seg_1d(3,'ext_Roberts_B_IO',N_w,t_wall,buffer))
       call init(SP%MP_ind,SP%MP_sigma)
     end subroutine

     subroutine define_mesh_SP_plasma_disruption_1D_analytic(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_fluid,buffer
       integer :: N
       t_fluid = 1.0_cp; buffer = 1.5_cp;
       N = 100
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_uniform'     ,1 ,-t_fluid,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_uniform'     ,1 ,-t_fluid,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B'   ,N ,-t_fluid,t_fluid,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call init(SP%MP_ind,SP%MP_sigma)
     end subroutine

     subroutine small_dataset(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_fluid,buffer
       integer :: N
       t_fluid = 1.0_cp; buffer = 1.0_cp; N = 5;
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_Roberts_B'   ,N ,-t_fluid,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_Roberts_B'   ,N ,-t_fluid,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B'   ,N ,-t_fluid,t_fluid,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call init(SP%MP_ind,SP%MP_sigma)
     end subroutine

     subroutine define_mesh_bandaru(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: buffer
       integer :: N
       buffer = 1.0_cp; N = 130
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_uniform'  ,N,0.0_cp ,2.0_cp*PI,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B',N,-1.0_cp,1.0_cp,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_uniform'  ,1,-0.5_cp,0.5_cp,buffer))
       call init(SP%MP_ind,SP%MP_mom)
       call init(SP%MP_sigma,SP%MP_ind)
     end subroutine

     subroutine define_mesh_bandaru_FFT(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: buffer
       integer :: N
       buffer = 1.0_cp; N = 128
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_uniform',N,0.0_cp ,2.0_cp*PI,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_uniform',N*2,-1.0_cp,1.0_cp,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_uniform',1,-0.5_cp,0.5_cp,buffer))
       call init(SP%MP_ind,SP%MP_mom)
       call init(SP%MP_sigma,SP%MP_ind)
     end subroutine

     subroutine define_mesh_MHD_Shercliff_plane(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: buffer
       integer :: N
       buffer = 1.0_cp; N = 150
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_uniform'  ,1,-0.5_cp,0.5_cp,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_Roberts_B',N,-1.0_cp,1.0_cp,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B',N,-1.0_cp,1.0_cp,buffer))
       call init(SP%MP_ind,SP%MP_mom)
       call init(SP%MP_sigma,SP%MP_ind)
     end subroutine

     subroutine define_mesh_MHD_Shercliff_plane_FFT(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: buffer
       integer :: N
       buffer = 1.0_cp; N = 128
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_uniform'  ,1,-0.5_cp,0.5_cp,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_uniform'  ,N,-0.5_cp,0.5_cp,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_uniform'  ,N,-0.5_cp,0.5_cp,buffer))
       call init(SP%MP_ind,SP%MP_mom)
       call init(SP%MP_sigma,SP%MP_ind)
     end subroutine

     subroutine define_mesh_full_BC_w_vacuum_symmetric(SP) ! Correctness confirmed 11/27/2017
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_wall,t_fluid,t_vac,buffer
       integer :: N,N_w,N_half
       t_vac = 7.0_cp; t_fluid = 1.0_cp; t_wall = 0.05_cp; buffer = 2.0_cp; N = 80; N_w = 9; N_half = ceiling(N/2.0_cp)
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_Roberts_B'         ,N       ,-t_fluid        ,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_L'         ,N_half  ,-t_fluid        ,0.0_cp ,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_Roberts_R'         ,N_half+5, 0.0_cp         ,t_fluid,buffer))
       call add_ext( SP%MP_mom,seg_1d(2,'ext_prep_Roberts_C2F_IO',N_half  , 0.0_cp+t_fluid ,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call add_ext(SP%MP_sigma,seg_1d(1,'ext_Roberts_B_IO'      ,N_w-1,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(3,'ext_prep_Roberts_B_IO' ,N_w-1,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(2,'ext_prep_Roberts_B_IO' ,N_w-1,t_wall,buffer))
       call init(SP%MP_ind,SP%MP_sigma)
       call add_ext(SP%MP_ind,seg_1d(1,'ext_Roberts_near_IO'      ,  N_w+1,t_vac - t_fluid - t_wall,buffer))
       call add_ext(SP%MP_ind,seg_1d(3,'ext_prep_Roberts_R_IO'    ,  N_w+2,t_vac - t_fluid - t_wall,buffer))
       call add_ext(SP%MP_ind,seg_1d(2,'ext_prep_Roberts_R_IO'    ,  N_w-1,t_vac - t_fluid - t_wall,buffer))
       call add_ext(SP%MP_ind,seg_1d(2,'ext_app_Roberts_L_IO'     ,2*N_w-2,t_vac - t_fluid         ,buffer))
     end subroutine

     subroutine define_mesh_full_BC_n_vacuum_symmetric(SP) ! Correctness confirmed 11/27/2017
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_wall,t_fluid,t_vac,buffer
       integer :: N,N_w,N_half
       t_vac = 7.0_cp; t_fluid = 1.0_cp; t_wall = 0.05_cp; buffer = 2.0_cp; N = 80; N_w = 9; N_half = ceiling(N/2.0_cp)
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_Roberts_B'         ,N       ,-t_fluid        ,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_L'         ,N_half  ,-t_fluid        ,0.0_cp ,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_Roberts_R'         ,N_half+5, 0.0_cp         ,t_fluid,buffer))
       call add_ext( SP%MP_mom,seg_1d(2,'ext_prep_Roberts_C2F_IO',N_half  , 0.0_cp+t_fluid ,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call add_ext(SP%MP_sigma,seg_1d(1,'ext_Roberts_B_IO'      ,N_w-1,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(3,'ext_prep_Roberts_B_IO' ,N_w-1,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(2,'ext_prep_Roberts_B_IO' ,N_w-1,t_wall,buffer))
       call init(SP%MP_ind,SP%MP_sigma)
     end subroutine

     subroutine define_mesh_full_BC_w_vacuum_3D(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_wall,t_fluid,t_vac,buffer
       integer :: N,N_w,N_half
       t_vac = 7.0_cp; t_fluid = 1.0_cp; t_wall = 0.05_cp;
       buffer = 2.0_cp; N = 80; N_w = 9; N_half = ceiling(N/2.0_cp)
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_Roberts_B'         ,N       ,-t_fluid        ,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B'         ,N       ,-t_fluid        ,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_Roberts_R'         ,N_half+5, 0.0_cp         ,t_fluid,buffer))
       call add_ext( SP%MP_mom,seg_1d(2,'ext_prep_Roberts_C2F_IO',N_half  , 0.0_cp+t_fluid ,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call add_ext(SP%MP_sigma,seg_1d(1,'ext_Roberts_B_IO'      ,N_w-1,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(3,'ext_Roberts_B_IO'      ,N_w-1,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(2,'ext_prep_Roberts_B_IO' ,N_w-1,t_wall,buffer))
       call init(SP%MP_ind,SP%MP_sigma)
       call add_ext(SP%MP_ind,seg_1d(1,'ext_Roberts_near_IO'      ,  N_w+1,t_vac - t_fluid - t_wall,buffer))
       call add_ext(SP%MP_ind,seg_1d(3,'ext_Roberts_near_IO'      ,  N_w+1,t_vac - t_fluid - t_wall,buffer))
       call add_ext(SP%MP_ind,seg_1d(2,'ext_prep_Roberts_R_IO'    ,  N_w-1,t_vac - t_fluid - t_wall,buffer))
       call add_ext(SP%MP_ind,seg_1d(2,'ext_app_Roberts_L_IO'     ,2*N_w-2,t_vac - t_fluid         ,buffer))
     end subroutine

     subroutine define_mesh_full_BC_w_vacuum_3D_high_res(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_wall,t_fluid,t_vac,buffer
       integer :: N,N_w,N_half
       t_vac = 7.0_cp; t_fluid = 1.0_cp; t_wall = 0.05_cp;
       buffer = 2.0_cp; N = 100; N_w = 9; N_half = ceiling(N/2.0_cp)
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_Roberts_B'         ,N       ,-t_fluid        ,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B'         ,N       ,-t_fluid        ,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_Roberts_R'         ,N_half+5, 0.0_cp         ,t_fluid,buffer))
       call add_ext( SP%MP_mom,seg_1d(2,'ext_prep_Roberts_C2F_IO',N_half  , 0.0_cp+t_fluid ,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call add_ext(SP%MP_sigma,seg_1d(1,'ext_Roberts_B_IO'      ,N_w-1,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(3,'ext_Roberts_B_IO'      ,N_w-1,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(2,'ext_prep_Roberts_B_IO' ,N_w-1,t_wall,buffer))
       call init(SP%MP_ind,SP%MP_sigma)
       call add_ext(SP%MP_ind,seg_1d(1,'ext_Roberts_near_IO'      ,  N_w+1,t_vac - t_fluid - t_wall,buffer))
       call add_ext(SP%MP_ind,seg_1d(3,'ext_Roberts_near_IO'      ,  N_w+1,t_vac - t_fluid - t_wall,buffer))
       call add_ext(SP%MP_ind,seg_1d(2,'ext_prep_Roberts_R_IO'    ,  N_w-1,t_vac - t_fluid - t_wall,buffer))
       call add_ext(SP%MP_ind,seg_1d(2,'ext_app_Roberts_L_IO'     ,2*N_w-2,t_vac - t_fluid         ,buffer))
     end subroutine

     subroutine define_mesh_full_BC_n_vacuum_3D(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: t_wall,t_fluid,t_vac,buffer
       integer :: N,N_w,N_half
       t_vac = 7.0_cp; t_fluid = 1.0_cp; t_wall = 0.05_cp;
       buffer = 2.0_cp; N = 80; N_w = 9; N_half = ceiling(N/2.0_cp)
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_Roberts_B'         ,N       ,-t_fluid        ,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_Roberts_B'         ,N       ,-t_fluid        ,t_fluid,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_Roberts_R'         ,N_half+5, 0.0_cp         ,t_fluid,buffer))
       call add_ext( SP%MP_mom,seg_1d(2,'ext_prep_Roberts_C2F_IO',N_half  , 0.0_cp+t_fluid ,buffer))
       call init(SP%MP_sigma,SP%MP_mom)
       call add_ext(SP%MP_sigma,seg_1d(1,'ext_Roberts_B_IO'      ,N_w-1,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(3,'ext_Roberts_B_IO'      ,N_w-1,t_wall,buffer))
       call add_ext(SP%MP_sigma,seg_1d(2,'ext_prep_Roberts_B_IO' ,N_w-1,t_wall,buffer))
       call init(SP%MP_ind,SP%MP_sigma)
     end subroutine

     subroutine define_mesh_SP_MHD_LDC_Sergey_uniform(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_uniform',45,-1.0_cp,1.0_cp,1.0_cp))
       call add_base(SP%MP_mom,seg_1d(2,'grid_uniform',45,-1.0_cp,1.0_cp,1.0_cp))
       call add_base(SP%MP_mom,seg_1d(3,'grid_uniform',45,-1.0_cp,1.0_cp,1.0_cp))
       call init(SP%MP_ind,SP%MP_mom)
       call init(SP%MP_sigma,SP%MP_ind)
       call add_ext(SP%MP_ind,seg_1d(1,'ext_uniform_IO',11))
       call add_ext(SP%MP_ind,seg_1d(2,'ext_uniform_IO',11))
       call add_ext(SP%MP_ind,seg_1d(3,'ext_uniform_IO',11))
     end subroutine

     subroutine define_mesh_hydro_LDC_Ghia(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       real(cp) :: buffer
       integer :: N
       buffer = 1.0_cp; N = 64
       call init(SP%MP_mom,SP%MQP)
       call init(SP%MP_sigma,SP%MQP)
       call init(SP%MP_ind,SP%MQP)
       call add_base(SP%MP_mom,seg_1d(1,'grid_uniform',N,-1.0_cp,1.0_cp,buffer))
       call add_base(SP%MP_mom,seg_1d(2,'grid_uniform',N,-1.0_cp,1.0_cp,buffer))
       call add_base(SP%MP_mom,seg_1d(3,'grid_uniform',1,-0.5_cp,0.5_cp,buffer))
       call init(SP%MP_ind,SP%MP_mom)
       call init(SP%MP_sigma,SP%MP_ind)
     end subroutine

     end module
     module sim_params_init_DPs_mod
     use current_precision_mod
     use constants_mod
     use dimensionless_params_extend_mod
     use sim_params_mod
     use sim_params_aux_mod
     implicit none

     private
     public :: sim_params_init_DPs

     contains

     subroutine sim_params_init_DPs(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       call delete(SP%DP)

       SP%DP%dtime                   = 1.0_cp*pow(-3)
       SP%DP%t_start                 = 0.0_cp ! Does not do anything yet...

       SP%DP%t_final                 = 100.0_cp
       ! SP%DP%t_final                 = 3.0_cp*SP%DP%dtime ! for testing

       SP%DP%Re                      = 400.0_cp
       ! SP%DP%N                       = 5.0_cp*pow(0)
       SP%DP%Q                       = 8.0_cp*pow(-1)
       SP%DP%Rem                     = 1.0_cp*pow(1)
       if (.not.SP%SCP%finite_Rem) SP%DP%Rem = 1.0_cp
       ! SP%DP%Ha                      = 5.0_cp*pow(2)
       ! SP%DP%Ha                      = 10.0_cp
       ! SP%DP%Ha                      = 10.0_cp*pow(3)
       ! SP%DP%Ha                      = 15.0_cp*pow(3)
       SP%DP%N                       = 1.0_cp/SP%DP%Q
       SP%DP%c_w(1:6)                = 0.0_cp
       SP%DP%c_w( 5 )                = 1.0_cp
       SP%DP%c_w( 6 )                = 1.0_cp
       SP%DP%Robin_coeff             = 0.0_cp
       SP%DP%Robin_coeff(5:6)        = -1.0_cp/SP%DP%c_w(5:6)
       ! SP%DP%c_w_coeff                = (2.0_cp*SP%DP%c_w/dh_nhat-1.0_cp)/(2.0_cp*SP%DP%c_w/dh_nhat+1.0_cp)
       ! SP%DP%sig_local_over_sig_f    = 1.0_cp*pow(-3)
       SP%DP%sig_local_over_sig_f    = 1.0_cp
       SP%DP%Gr                      = 0.0_cp
       SP%DP%Pr                      = 0.01_cp
       SP%DP%Fr                      = 1.0_cp
       SP%DP%Ec                      = 0.0_cp

       SP%DP%Ha                      = (1.0_cp/SP%DP%Q*SP%DP%Re)**0.5_cp
       SP%DP%Al                      = SP%DP%N/SP%DP%Rem
       SP%DP%Pe                      = SP%DP%Pr*SP%DP%Re
       SP%DP%tau                     = SP%DP%Re/SP%DP%Ha
       SP%DP%L_eta                   = SP%DP%Re**(-0.75_cp)
       SP%DP%U_eta                   = SP%DP%Re**(-0.25_cp)
       SP%DP%t_eta                   = SP%DP%Re**(-0.50_cp)
       SP%DP%KE_scale                = 1.0_cp
       SP%DP%ME_scale                = SP%DP%Al
       SP%DP%JE_scale                = SP%DP%N*2.0_cp ! x2 because (J^2/sigma) not (1/2 J^2/sigma)
     end subroutine

     end module
     module sim_params_init_export_mod
     use current_precision_mod
     use constants_mod
     use string_mod
     use dir_tree_mod
     use time_statistics_params_extend_mod
     use export_frequency_params_extend_mod
     use export_frequency_extend_mod
     use export_field_extend_mod
     use export_planes_extend_mod
     use export_lines_extend_mod
     use sim_params_mod
     use sim_params_aux_mod
     implicit none

     private
     public :: sim_params_init_export

     contains

     subroutine sim_params_init_export(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       logical,parameter :: T = .true.
       logical,parameter :: F = .false.

       ! call init(EFP,export_ever,export_first_step,frequency_base,frequency_exp)
       call init(SP%EF%info          ,T,T,10**2,SP%DP%t_start,SP%DP%t_final,0.01_cp)
       call init(SP%EF%unsteady_0D   ,T,T,10**2,SP%DP%t_start,SP%DP%t_final,0.01_cp)
       call init(SP%EF%unsteady_1D   ,T,T,  0  ,SP%DP%t_start,SP%DP%t_final,0.01_cp)
       call init(SP%EF%unsteady_2D   ,T,T,  0  ,SP%DP%t_start,SP%DP%t_final,0.01_cp)
       call init(SP%EF%unsteady_3D   ,F,F,  0  ,SP%DP%t_start,SP%DP%t_final,0.01_cp)
       call init(SP%EF%restart_files ,F,F,10**2,SP%DP%t_start,SP%DP%t_final,0.01_cp)
       call init(SP%EF%final_solution,F,F,  1  ,SP%DP%t_start,SP%DP%t_final,0.01_cp)

       ! call init(export_field,export_ever)
       call init(SP%VS%T%unsteady_field  ,F)
       call init(SP%VS%U%unsteady_field  ,F)
       call init(SP%VS%P%unsteady_field  ,F)
       call init(SP%VS%B%unsteady_field  ,F)
       call init(SP%VS%B0%unsteady_field ,F)
       call init(SP%VS%phi%unsteady_field,F)
       call init(SP%VS%rho%unsteady_field,F)
       ! call init(export_plane,export_ever,dir,plane)
       call init(SP%VS%T%unsteady_planes  ,F,2,1,'1')
       call init(SP%VS%U%unsteady_planes  ,F,3,2,'1')
       call add (SP%VS%U%unsteady_planes  ,F,3,23,'2')
       call init(SP%VS%P%unsteady_planes  ,F,2,1,'1')
       call init(SP%VS%B%unsteady_planes  ,F,2,1,'1')
       call init(SP%VS%B0%unsteady_planes ,F,2,1,'1')
       call init(SP%VS%phi%unsteady_planes,F,2,1,'1')
       call init(SP%VS%rho%unsteady_planes,F,2,1,'1')
       ! call init(export_line,export_ever,dir,line)
       call init(SP%VS%T%unsteady_lines  ,F,1,(/2,34/),'1')
       call init(SP%VS%U%unsteady_lines  ,F,1,(/2,34/),'1')
       call init(SP%VS%P%unsteady_lines  ,F,1,(/2,34/),'1')
       call init(SP%VS%B%unsteady_lines  ,F,1,(/2,34/),'1')
       call init(SP%VS%B0%unsteady_lines ,F,1,(/2,34/),'1')
       call init(SP%VS%phi%unsteady_lines,F,1,(/2,34/),'1')
       call init(SP%VS%rho%unsteady_lines,F,1,(/2,34/),'1')

       ! Statistics
       ! call init(TSP,collect,t_start,t_stop)
       call init(SP%TSP,F,900.0_cp,1000.0_cp)
     end subroutine

     end module
     module sim_params_init_flow_config_mod
     use current_precision_mod
     use constants_mod
     use string_mod
     use dir_tree_mod
     use var_extend_mod
     use var_set_extend_mod
     use path_extend_mod
     use equation_term_extend_mod
     use export_frequency_params_extend_mod
     use export_frequency_extend_mod
     use time_marching_params_extend_mod
     use sim_params_mod
     use sim_params_aux_mod
     implicit none

     private
     public :: sim_params_init_flow_config

     contains

     subroutine sim_params_init_flow_config(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       logical,parameter :: T = .true.
       logical,parameter :: F = .false.

       SP%GP%periodic_dir            = (/0,0,1/)
       SP%GP%apply_BC_order          = get_apply_BC_order(SP%GP%periodic_dir)
       SP%GP%FFT_dir                 = get_FFT_dir(SP%GP%periodic_dir)

       SP%MT%zero_source_components   = (/F,F,F/)
       SP%MT%zero_source_components_any   = any(SP%MT%zero_source_components)
       SP%IT%zero_source_components   = (/F,F,F/)
       SP%IT%zero_source_components_any   = any(SP%IT%zero_source_components)

       ! call init_IC_BC(var      ,IC   ,BC)
       call init_IC_BC(SP%VS%T    ,0    ,0 )
       call init_IC_BC(SP%VS%U    ,0    ,1 )
       call init_IC_BC(SP%VS%P    ,0    ,0 )
       call init_IC_BC(SP%VS%B    ,0    ,0 )
       call init_IC_BC(SP%VS%B0   ,0    ,0 )
       call init_IC_BC(SP%VS%phi  ,0    ,0 )
       call init_IC_BC(SP%VS%rho  ,0    ,0 )

       ! The following is needed only if curl-curl(B) is used, opposed to J in solver.
       ! if (SP%SCP%finite_Rem) SP%VS%B%MFP%coeff_explicit = SP%VS%B%MFP%coeff_explicit/SP%DP%Rem

       ! IF A TERM IS REPEATED, THE ONLY TERM THAT COUNTS IS THE LAST ONE DEFINED TO BE "TRUE"
       ! Sources to add to momentum equation. NOTE: scale is not set if add=false
       call init(SP%MT%pressure_grad       ,F,-1.0_cp                   )
       call init(SP%MT%diffusion           ,T,SP%VS%U%MFP%coeff_explicit)
       call init(SP%MT%diffusion_linear    ,F,SP%VS%U%MFP%coeff_explicit)
       call init(SP%MT%advection_convection,T,-1.0_cp                   )
       call init(SP%MT%advection_convection,F,-1.0_cp/SP%DP%Rem         )
       call init(SP%MT%advection_divergence,F,-1.0_cp                   )
       call init(SP%MT%advection_divergence,F,-1.0_cp/SP%DP%Rem         ) ! For Rem ne 1 in Bandaru
       call init(SP%MT%advection_base_flow ,F,-1.0_cp                   )
       call init(SP%MT%mean_pressure_grad  ,F,1.0_cp                    )
       call init(SP%MT%JCrossB             ,F,SP%DP%N                   )
       call init(SP%MT%JCrossB             ,F,SP%DP%N*SP%DP%Rem         ) ! For Rem ne 1 in Bandaru (look at J definition in Bandaru)
       call init(SP%MT%Q2D_JCrossB         ,F,-1.0_cp/SP%DP%tau         )
       call init(SP%MT%Buoyancy            ,F,SP%DP%Gr/SP%DP%Re**2.0_cp )
       call init(SP%MT%Gravity             ,F,1.0_cp/SP%DP%Fr**2.0_cp   )

       ! Sources to add to induction equation. NOTE: scale is not set if add=false
       call init(SP%IT%B_applied       ,T, 1.0_cp           ) ! B0 = scale*B0
       call init(SP%IT%current         ,T, 1.0_cp/SP%DP%Rem ) ! J = scale curl(B)
       call init(SP%IT%advection       ,F, 1.0_cp           )
       call init(SP%IT%advection       ,F, 1.0_cp/SP%DP%Rem ) ! For Rem ne 1 in Bandaru
       call init(SP%IT%diffusion       ,F, -SP%VS%B%MFP%beta) ! since LHS and J includes scale
       call init(SP%IT%diffusion_linear,F, -SP%VS%B%MFP%beta) ! since LHS and J includes scale
       call init(SP%IT%unsteady_B0     ,F, -1.0_cp          ) ! since RHS

       ! Sources to add to energy equation. NOTE: scale is not set if add=false
       call init(SP%ET%advection          , F,-1.0_cp           )
       call init(SP%ET%diffusion          , F,1.0_cp/SP%DP%Pe   )
       call init(SP%ET%KE_diffusion       , F,-SP%DP%Ec/SP%DP%Re)
       call init(SP%ET%viscous_dissipation, F, SP%DP%Ec/SP%DP%Re)
       call init(SP%ET%joule_heating      , F,SP%DP%Ec*SP%DP%N  )
       call init(SP%ET%volumetric_heating , F,1.0_cp            )
     end subroutine

     end module
     module sim_params_init_logicals_mod
     use current_precision_mod
     use constants_mod
     use mirror_props_extend_mod
     use sim_params_mod
     use sim_params_aux_mod
     implicit none

     private
     public :: sim_params_init_logicals

     real(cp),parameter :: seconds_per_day = 60.0_cp*60.0_cp*24.0_cp
     real(cp),parameter :: minutes = 60.0_cp

     contains

     subroutine sim_params_init_logicals(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       logical,parameter :: T = .true.
       logical,parameter :: F = .false.

       SP%FCL%stop_after_mesh_export             = F
       SP%FCL%stop_before_solve                  = F
       SP%FCL%skip_solver_loop                   = F
       SP%FCL%post_process                       = F
       SP%FCL%Poisson_test                       = F
       SP%FCL%matrix_visualization               = F
       SP%FCL%Taylor_Green_Vortex_test           = F
       SP%FCL%temporal_convergence_test          = F
       SP%FCL%operator_commute_test              = F
       SP%FCL%compute_export_E_K_Budget          = F
       SP%FCL%compute_export_E_M_budget          = F
       SP%FCL%restart_meshes                     = F

       SP%FCL%simulate_crash                     = F
       SP%FCL%restart_simulated_crash            = F
       SP%FCL%export_numerical_flow_rate         = F
       SP%FCL%export_Shercliff_Hunt_analytic_sol = F
       SP%FCL%export_vorticity_streamfunction    = F
       SP%FCL%export_heavy                       = T
       SP%FCL%export_final_tec                   = T
       SP%FCL%export_final_restart               = T
       SP%FCL%print_every_MHD_step               = F
       SP%FCL%print_mesh_before_solve            = F
       SP%FCL%compute_surface_power              = F

       SP%EL%export_analytic                     = F
       SP%EL%export_meshes                       = T
       SP%EL%export_vort_SF                      = F
       SP%EL%export_mat_props                    = F
       SP%EL%export_ICs                          = F
       SP%EL%export_cell_volume                  = F
       SP%EL%export_planar                       = F
       SP%EL%export_symmetric                    = F
       SP%EL%export_mesh_block                   = F
       SP%EL%export_soln_only                    = F

       SP%SCP%export_safe_period                 = 1.0_cp*seconds_per_day
       ! SP%SCP%export_safe_period                 = 1.0_cp*minutes
       SP%SCP%uniform_gravity_dir                = 1
       SP%SCP%uniform_B0_dir                     = 3
       SP%SCP%mpg_dir                            = 1
       SP%SCP%couple_time_steps                  = T
       SP%SCP%finite_Rem                         = T
       SP%SCP%include_vacuum                     = F
       SP%SCP%embed_B_interior                   = F

       ! call init(MP,mirror,mirror_face)
       call init(SP%MP,F,6) ! Must be defined before KE_scale,ME_scale,JE_scale
       SP%EL%export_symmetric = SP%MP%mirror
     end subroutine

     end module
     module sim_params_init_solver_config_mod
     use current_precision_mod
     use constants_mod
     use string_mod
     use dir_tree_mod
     use var_extend_mod
     use var_set_extend_mod
     use path_extend_mod
     use equation_term_extend_mod
     use solver_settings_extend_mod
     use time_marching_params_extend_mod
     use iter_solver_params_extend_mod
     use sim_params_mod
     use sim_params_aux_mod
     implicit none

     private
     public :: sim_params_init_solver_config

     contains

     subroutine sim_params_init_solver_config(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       logical,parameter :: T = .true.
       logical,parameter :: F = .false.

       ! call init(SS        ,initialize,solve,restart,prescribe_BCs,solve_method)
       call init(SP%VS%T%SS  ,F         ,F    ,F      ,F            ,0)
       call init(SP%VS%U%SS  ,T         ,T    ,F      ,T            ,9)
       call init(SP%VS%P%SS  ,T         ,T    ,F      ,F            ,0)
       call init(SP%VS%B%SS  ,T         ,F    ,F      ,T            ,6)
       call init(SP%VS%B0%SS ,T         ,F    ,F      ,F            ,0)
       call init(SP%VS%phi%SS,T         ,F    ,F      ,F            ,0)
       call init(SP%VS%rho%SS,F         ,F    ,F      ,F            ,0)
       !     solve_method = 1 = Euler_time_no_diff_Euler_sources_no_correction
       !     solve_method = 2 = Euler_time_no_diff_AB2_sources_no_correction
       !     solve_method = 3 = Euler_time_no_diff_Euler_sources
       !     solve_method = 4 = Euler_time_no_diff_AB2_sources
       !     solve_method = 5 = Euler_time_Euler_sources
       !     solve_method = 6 = Euler_time_AB2_sources
       !     solve_method = 7 = O2_BDF_time_AB2_sources
       !     solve_method = 8 = Euler_time_AB2_sources_new

       ! call init(ISP,iter_max,tol_rel,tol_abs,n_skip_check_res,export_convergence)
       call init(SP%VS%T%ISP,  5  ,pow(-6),pow(-13),1,F,SP%FCL%export_heavy)
       call init(SP%VS%U%ISP,  5  ,pow(-6),pow(-13),1,F,SP%FCL%export_heavy)
       call init(SP%VS%P%ISP,  5  ,pow(-6),pow(-13),1,F,SP%FCL%export_heavy)
       call init(SP%VS%B%ISP,  5  ,pow(-6),pow(-13),1,F,SP%FCL%export_heavy)
       call init(SP%VS%B0%ISP, 5  ,pow(-6),pow(-13),1,F,SP%FCL%export_heavy)
       call init(SP%VS%phi%ISP,5  ,pow(-6),pow(-13),1,F,SP%FCL%export_heavy)
       call init(SP%VS%rho%ISP,5  ,pow(-6),pow(-13),1,F,SP%FCL%export_heavy)

       ! call init(TMP,RK_n_stages,RK_active,multistep_iter,n_step_stop,dtime)
       call init(SP%coupled,   1,F,1 ,SP%DP%t_start,SP%DP%t_final,SP%DP%dtime)
       call init(SP%VS%T%TMP,  1,F,1 ,SP%DP%t_start,SP%DP%t_final,SP%DP%dtime)
       call init(SP%VS%U%TMP,  1,F,1 ,SP%DP%t_start,SP%DP%t_final,SP%DP%dtime)
       call init(SP%VS%P%TMP,  1,F,1 ,SP%DP%t_start,SP%DP%t_final,SP%DP%dtime)
       call init(SP%VS%B%TMP,  1,F,1 ,SP%DP%t_start,SP%DP%t_final,SP%DP%dtime)
       call init(SP%VS%B0%TMP, 1,F,1 ,SP%DP%t_start,SP%DP%t_final,SP%DP%dtime)
       call init(SP%VS%phi%TMP,1,F,1 ,SP%DP%t_start,SP%DP%t_final,SP%DP%dtime)
       call init(SP%VS%rho%TMP,1,F,1 ,SP%DP%t_start,SP%DP%t_final,SP%DP%dtime)

       ! Matrix-free parameters:
       ! coeff_natural  = coefficient of terms in non-discretized equation
       ! coeff_explicit = coefficient of explicit terms without time discretization
       ! coeff_implicit = coefficient of implicit terms without time discretization
       ! coeff_implicit_time_split = dt*coeff_implicit/coeff_unsteady (computed in time_marching_methods.f90)

       SP%VS%B%MFP%alpha = 1.0_cp ! weight of implicit treatment (1 = Backward Euler, .5 = Crank Nicholson)
       SP%VS%U%MFP%alpha = 1.0_cp ! weight of implicit treatment (1 = Backward Euler, .5 = Crank Nicholson)
       SP%VS%T%MFP%alpha = 1.0_cp ! weight of implicit treatment (1 = Backward Euler, .5 = Crank Nicholson)
       SP%VS%B%MFP%coeff_natural = -1.0_cp/SP%DP%Rem ! natural diffusion coefficient on RHS
       SP%VS%U%MFP%coeff_natural =  1.0_cp/SP%DP%Re  ! natural diffusion coefficient on RHS
       SP%VS%T%MFP%coeff_natural =  1.0_cp/SP%DP%Pe  ! natural diffusion coefficient on RHS
       call assign_beta(SP%VS)           ! weight of explicit treatment, alpha must be defined first
       call assign_coeff_explicit(SP%VS) ! RHS diffusion coefficient, (beta ,coeff_natural) must be defined first
       call assign_coeff_implicit(SP%VS) ! LHS diffusion coefficient, (alpha,coeff_natural) must be defined first
     end subroutine

     end module
      module GF_amax_diff_mod
        use grid_field_mod
        use grid_field_extend_mod
        use grid_mod
        use GF_assign_plane_mod
        use GF_plane_mean_mod
        use current_precision_mod
        implicit none
        private

        public :: amax_diff
        interface amax_diff;      module procedure amax_diff_GF;       end interface
        interface amax_diff;      module procedure amax_diff_dir_GF;   end interface

        contains

        function amax_diff_GF(u) result(amax_diff)
          implicit none
          type(grid_field),intent(in) :: u
          real(cp),dimension(3) :: amax_diff
          amax_diff(1) = amax_diff_x_GF(u)
          amax_diff(2) = amax_diff_y_GF(u)
          amax_diff(3) = amax_diff_z_GF(u)
        end function

        function amax_diff_dir_GF(u,dir) result(amax_diff)
          implicit none
          type(grid_field),intent(in) :: u
          integer,intent(in) :: dir
          real(cp) :: amax_diff
          select case(dir)
          case (1); amax_diff = amax_diff_x_GF(u)
          case (2); amax_diff = amax_diff_y_GF(u)
          case (3); amax_diff = amax_diff_z_GF(u)
          case default
          stop 'Error: bad dir in amax_diff_dir_GF in GF_amax_diff.f90'
          end select
        end function

        function amax_diff_func(u,n) result(amax_diff)
          implicit none
          integer,intent(in) :: n
          real(cp),dimension(n),intent(in) :: u
          real(cp) :: amax_diff
          amax_diff = maxval(abs(u - u(1)))
        end function

        function amax_diff_x_GF(u) result(amax_diff)
          implicit none
          type(grid_field),intent(in) :: u
          integer :: j,k
          real(cp) :: amax_diff
          amax_diff = 0.0_cp
          do k=1,u%s(3)
          do j=1,u%s(2)
            amax_diff = maxval((/amax_diff,amax_diff_func(u%f(1:u%s(1),j,k),u%s(1))/))
          enddo
          enddo
        end function

        function amax_diff_y_GF(u) result(amax_diff)
          implicit none
          type(grid_field),intent(in) :: u
          integer :: i,k
          real(cp) :: amax_diff
          amax_diff = 0.0_cp
          do k=1,u%s(3)
          do i=1,u%s(1)
            amax_diff = maxval((/amax_diff,amax_diff_func(u%f(i,1:u%s(2),k),u%s(2))/))
          enddo
          enddo
        end function

        function amax_diff_z_GF(u) result(amax_diff)
          implicit none
          type(grid_field),intent(in) :: u
          integer :: i,j
          real(cp) :: amax_diff
          amax_diff = 0.0_cp
          do j=1,u%s(2)
          do i=1,u%s(1)
            amax_diff = maxval((/amax_diff,amax_diff_func(u%f(i,j,1:u%s(3)),u%s(3))/))
          enddo
          enddo
        end function

      end module
      module GF_assign_ghost_mod
        use current_precision_mod
        use grid_field_mod
        use GF_assign_plane_mod
        implicit none

        abstract interface
          subroutine plane_op(GF,val)
            import grid_field,cp
            implicit none
            type(grid_field),intent(inout) :: GF
            real(cp),intent(in) :: val
          end subroutine
        end interface

        private
        public :: plane_op
        public :: assign_ghost_all
        public :: assign_ghost_xmin
        public :: assign_ghost_ymin
        public :: assign_ghost_zmin
        public :: assign_ghost_xmax
        public :: assign_ghost_ymax
        public :: assign_ghost_zmax

        public :: assign_ghost_xmin_xmax
        public :: assign_ghost_ymin_ymax
        public :: assign_ghost_zmin_zmax

        interface assign_ghost_xmin_xmax; module procedure assign_ghost_xmin_xmax_GF; end interface
        interface assign_ghost_ymin_ymax; module procedure assign_ghost_ymin_ymax_GF; end interface
        interface assign_ghost_zmin_zmax; module procedure assign_ghost_zmin_zmax_GF; end interface

        contains

        subroutine assign_ghost_all(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_x(U,val,1)
          call assign_plane_x(U,val,U%s(1))
          call assign_plane_y(U,val,1)
          call assign_plane_y(U,val,U%s(2))
          call assign_plane_z(U,val,1)
          call assign_plane_z(U,val,U%s(3))
        end subroutine

        subroutine assign_ghost_xmin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_x(U,val,1)
        end subroutine
        subroutine assign_ghost_xmax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_x(U,val,U%s(1))
        end subroutine
        subroutine assign_ghost_xmin_xmax_GF(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_2_planes_x(U,val,1,U%s(1))
        end subroutine

        subroutine assign_ghost_ymin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_y(U,val,1)
        end subroutine
        subroutine assign_ghost_ymax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_y(U,val,U%s(2))
        end subroutine
        subroutine assign_ghost_ymin_ymax_GF(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_2_planes_y(U,val,1,U%s(2))
        end subroutine

        subroutine assign_ghost_zmin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_z(U,val,1)
        end subroutine
        subroutine assign_ghost_zmax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_z(U,val,U%s(3))
        end subroutine
        subroutine assign_ghost_zmin_zmax_GF(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_2_planes_z(U,val,1,U%s(3))
        end subroutine

      end module
      module GF_assign_ghost_periodic_mod
        use current_precision_mod
        use grid_field_mod
        use GF_assign_plane_mod
        implicit none

        abstract interface
          subroutine plane_op(GF,val)
            import grid_field
            implicit none
            type(grid_field),intent(inout) :: GF
            type(grid_field),intent(in) :: val
          end subroutine
        end interface

        private
        public :: plane_op
        public :: assign_ghost_periodic_all
        public :: assign_ghost_periodic_xmin
        public :: assign_ghost_periodic_ymin
        public :: assign_ghost_periodic_zmin
        public :: assign_ghost_periodic_xmax
        public :: assign_ghost_periodic_ymax
        public :: assign_ghost_periodic_zmax

        contains

        subroutine assign_ghost_periodic_all(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid_field),intent(in) :: val
          call assign_plane_x(U,val,1,1)
          call assign_plane_x(U,val,U%s(1),val%s(1))
          call assign_plane_y(U,val,1,1)
          call assign_plane_y(U,val,U%s(2),val%s(2))
          call assign_plane_z(U,val,1,1)
          call assign_plane_z(U,val,U%s(3),val%s(3))
        end subroutine

        subroutine assign_ghost_periodic_xmin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid_field),intent(in) :: val
          call assign_plane_x(U,val,1,1)
        end subroutine
        subroutine assign_ghost_periodic_xmax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid_field),intent(in) :: val
          call assign_plane_x(U,val,U%s(1),val%s(1))
        end subroutine

        subroutine assign_ghost_periodic_ymin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid_field),intent(in) :: val
          call assign_plane_y(U,val,1,1)
        end subroutine
        subroutine assign_ghost_periodic_ymax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid_field),intent(in) :: val
          call assign_plane_y(U,val,U%s(2),val%s(2))
        end subroutine

        subroutine assign_ghost_periodic_zmin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid_field),intent(in) :: val
          call assign_plane_z(U,val,1,1)
        end subroutine
        subroutine assign_ghost_periodic_zmax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid_field),intent(in) :: val
          call assign_plane_z(U,val,U%s(3),val%s(3))
        end subroutine

      end module
      module GF_assign_wall_mod
        use current_precision_mod
        use grid_field_mod
        use GF_assign_plane_mod
        implicit none

        abstract interface
          subroutine plane_op(GF,val)
            import grid_field,cp
            implicit none
            type(grid_field),intent(inout) :: GF
            real(cp),intent(in) :: val
          end subroutine
        end interface

        private
        public :: plane_op
        public :: assign_wall_xmin
        public :: assign_wall_ymin
        public :: assign_wall_zmin
        public :: assign_wall_xmax
        public :: assign_wall_ymax
        public :: assign_wall_zmax

        contains

        subroutine assign_wall_xmin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_x(U,val,2)
        end subroutine

        subroutine assign_wall_xmax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_x(U,val,U%s(1)-1)
        end subroutine

        subroutine assign_wall_ymin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_y(U,val,2)
        end subroutine

        subroutine assign_wall_ymax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_y(U,val,U%s(2)-1)
        end subroutine

        subroutine assign_wall_zmin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_z(U,val,2)
        end subroutine

        subroutine assign_wall_zmax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call assign_plane_z(U,val,U%s(3)-1)
        end subroutine

      end module
      module GF_aux_mod
        use grid_field_mod
        use grid_field_extend_mod
        use GF_assign_mod
        use GF_subtract_mod
        use grid_mod
        use data_location_extend_mod
        use current_precision_mod
        implicit none
        private

        public :: swap
        public :: abs
        public :: min,max,amin,amax
        public :: mean,sum,size

        public :: insist_amax_lt_tol

        interface swap;                     module procedure swap_GF;                end interface
        interface abs;                      module procedure abs_GF;                 end interface
        interface min;                      module procedure min_GF;                 end interface
        interface max;                      module procedure max_GF;                 end interface
        interface min;                      module procedure min_pad_GF;             end interface
        interface max;                      module procedure max_pad_GF;             end interface
        interface amin;                     module procedure amin_GF;                end interface
        interface amax;                     module procedure amax_GF;                end interface
        interface mean;                     module procedure mean_GF;                end interface
        interface sum;                      module procedure sum_GF;                 end interface
        interface sum;                      module procedure sum_GF_pad;             end interface
        interface size;                     module procedure size_GF;                end interface
        interface insist_amax_lt_tol;       module procedure insist_amax_lt_tol_GF;  end interface
        interface insist_amax_lt_tol;       module procedure insist_amax_lt_tol_GF_2;end interface

        contains

        subroutine abs_GF(a)
          implicit none
          type(grid_field),intent(inout) :: a
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          a%f(i,j,k) = abs(a%f(i,j,k))
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          a%f = abs(a%f)
#endif
        end subroutine

        subroutine swap_GF(a,b,c)
          implicit none
          type(grid_field),intent(inout) :: a,b,c
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          !$OMP PARALLEL DO
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          c%f(i,j,k) = a%f(i,j,k)
          a%f(i,j,k) = b%f(i,j,k)
          b%f(i,j,k) = c%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
#else
          c%f = a%f
          a%f = b%f
          b%f = c%f
#endif
        end subroutine

        function min_GF(a) result(m)
          implicit none
          type(grid_field),intent(in) :: a
          real(cp) :: m
          m = minval(a%f)
        end function

        function max_GF(a) result(m)
          implicit none
          type(grid_field),intent(in) :: a
          real(cp) :: m
          m = maxval(a%f)
        end function

        function min_pad_GF(a,pad) result(m)
          implicit none
          type(grid_field),intent(in) :: a
          integer,intent(in) :: pad
          real(cp) :: m
          m = minval(a%f(1+pad:a%s(1)-pad,1+pad:a%s(2)-pad,1+pad:a%s(3)-pad))
        end function

        function max_pad_GF(a,pad) result(m)
          implicit none
          type(grid_field),intent(in) :: a
          integer,intent(in) :: pad
          real(cp) :: m
          m = maxval(a%f(1+pad:a%s(1)-pad,1+pad:a%s(2)-pad,1+pad:a%s(3)-pad))
        end function

        function amin_GF(a) result(m)
          implicit none
          type(grid_field),intent(in) :: a
          real(cp) :: m
          m = minval(abs(a%f))
        end function

        function amax_GF(a) result(m)
          implicit none
          type(grid_field),intent(in) :: a
          real(cp) :: m
          m = maxval(abs(a%f))
        end function

        function mean_GF(a) result(m)
          implicit none
          type(grid_field),intent(in) :: a
          real(cp) :: m
          m = sum(a)/(max(1,size(a%f)))
        end function

        function sum_GF(a) result(m)
          implicit none
          type(grid_field),intent(in) :: a
          real(cp) :: m
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          real(cp) :: mTemp
          mTemp = 0.0_cp
          !$OMP PARALLEL DO REDUCTION(+:mTemp)
          do k=1,a%s(3); do j=1,a%s(2); do i=1,a%s(1)
          mTemp = mTemp + a%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
          m = mTemp
#else
          m = sum(a%f)
#endif
        end function

        function sum_GF_pad(a,pad) result(m)
          implicit none
          type(grid_field),intent(in) :: a
          integer,intent(in) :: pad
          real(cp) :: m
#ifdef _PARALLELIZE_GF_
          integer :: i,j,k
          real(cp) :: mTemp
          mTemp = 0.0_cp
          !$OMP PARALLEL DO REDUCTION(+:mTemp)
          do k=1+pad,a%s(3)-pad; do j=1+pad,a%s(2)-pad; do i=1+pad,a%s(1)-pad
          mTemp = mTemp + a%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
          m = mTemp
#else
          m = sum(a%f(1+pad:a%s(1)-1,1+pad:a%s(2)-1,1+pad:a%s(3)-1))
#endif
        end function

        function size_GF(a) result(s)
          implicit none
          type(grid_field),intent(in) :: a
          integer :: s
          s = a%s_1D
        end function

        subroutine insist_amax_lt_tol_GF(U,caller)
          implicit none
          type(grid_field),intent(in) :: U
          character(len=*),intent(in) :: caller
          real(cp) :: tol,amx_U
          tol = 10.0_cp**(-10.0_cp)
          amx_U = amax(U)
          if (.not.(amx_U.lt.tol)) then
            write(*,*) 'Error: tol > amax(U) in ',caller,' in insist_above_tol_GF in GF_aux.f90'
            write(*,*) 'tol = ',tol
            write(*,*) 'amax(U) = ',amx_U
            stop 'Done'
          endif
        end subroutine

        subroutine insist_amax_lt_tol_GF_2(A,B,caller)
          implicit none
          type(grid_field),intent(in) :: A,B
          character(len=*),intent(in) :: caller
          type(grid_field) :: C
          real(cp) :: tol,amx_C
          tol = 10.0_cp**(-10.0_cp)
          call init(C,A)
          call subtract(C,A,B)
          amx_C = amax(C)
          if (.not.(amx_C.lt.tol)) then
            write(*,*) '-------------------------------------------- A'; call print_physical(A)
            write(*,*) '-------------------------------------------- B'; call print_physical(B)
            write(*,*) '--------------------------------------------'
            write(*,*) 'Error: tol > amax(C) in ',caller,' in insist_above_tol_GF in GF_aux.f90'
            write(*,*) 'tol = ',tol
            write(*,*) 'amax(C) = ',amx_C
            stop 'Done'
          endif
          call delete(C)
        end subroutine

      end module
      module GF_cross_product_mod
        ! Compiler flags: (_PARALLELIZE_CROSS_PRODUCT_GF_)
        use grid_field_mod
        use GF_assign_mod
        implicit none
        private

        public :: cross_product_x
        public :: cross_product_y
        public :: cross_product_z
        interface cross_product_x;  module procedure cross_product_x_GF;   end interface
        interface cross_product_y;  module procedure cross_product_y_GF;   end interface
        interface cross_product_z;  module procedure cross_product_z_GF;   end interface

        contains

       subroutine cross_product_x_GF(AcrossB,Ay,Az,By,Bz)
         implicit none
         type(grid_field),intent(inout) :: AcrossB
         type(grid_field),intent(in) :: Ay,Az,By,Bz
         integer :: i,j,k
#ifdef _PARALLELIZE_CROSS_PRODUCT_GF_
         !$OMP PARALLEL DO

#endif
         do k=1,AcrossB%s(3); do j=1,AcrossB%s(2); do i=1,AcrossB%s(1)
           AcrossB%f(i,j,k) = Ay%f(i,j,k)*Bz%f(i,j,k) - Az%f(i,j,k)*By%f(i,j,k)
         enddo; enddo; enddo
#ifdef _PARALLELIZE_CROSS_PRODUCT_GF_
         !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine cross_product_y_GF(AcrossB,Ax,Az,Bx,Bz)
         implicit none
         type(grid_field),intent(inout) :: AcrossB
         type(grid_field),intent(in) :: Ax,Az,Bx,Bz
         integer :: i,j,k
#ifdef _PARALLELIZE_CROSS_PRODUCT_GF_
         !$OMP PARALLEL DO

#endif
         do k=1,AcrossB%s(3); do j=1,AcrossB%s(2); do i=1,AcrossB%s(1)
           AcrossB%f(i,j,k) = -(Ax%f(i,j,k)*Bz%f(i,j,k) - Az%f(i,j,k)*Bx%f(i,j,k))
         enddo; enddo; enddo
#ifdef _PARALLELIZE_CROSS_PRODUCT_GF_
         !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine cross_product_z_GF(AcrossB,Ax,Ay,Bx,By)
         implicit none
         type(grid_field),intent(inout) :: AcrossB
         type(grid_field),intent(in) :: Ax,Ay,Bx,By
         integer :: i,j,k
#ifdef _PARALLELIZE_CROSS_PRODUCT_GF_
         !$OMP PARALLEL DO

#endif
         do k=1,AcrossB%s(3); do j=1,AcrossB%s(2); do i=1,AcrossB%s(1)
           AcrossB%f(i,j,k) = Ax%f(i,j,k)*By%f(i,j,k) - Ay%f(i,j,k)*Bx%f(i,j,k)
         enddo; enddo; enddo
#ifdef _PARALLELIZE_CROSS_PRODUCT_GF_
         !$OMP END PARALLEL DO

#endif
       end subroutine

      end module
      module GF_diagonals_mod
      use current_precision_mod
      use data_location_extend_mod
      use grid_mod
      use grid_field_mod
      use GF_assign_mod
      implicit none

      private
      public :: laplacian_diagonal
      public :: curl_curl_diagonal

      contains

      subroutine laplacian_diagonal(diag,g,DL)
        ! Computes Laplacian diagonal: diag = diag( ∇•(∇) )
        implicit none
        type(grid_field),intent(inout) :: diag
        type(grid),intent(in) :: g
        type(data_location),intent(in) :: DL
        integer :: i,j,k,pnx,pny,pnz
        integer,dimension(3) :: p
        call assign(diag,0.0_cp)
        p = N_eye(DL); pnx = p(1); pny = p(2); pnz = p(3)
        !$OMP PARALLEL DO
        do k=2,diag%s(3)-1; do j=2,diag%s(2)-1; do i=2,diag%s(1)-1
        diag%f(i,j,k) = g%c(1)%stagN2CC%D%f(  i  )*g%c(1)%stagCC2N%U%f( i-1 ) + &
                        g%c(1)%stagN2CC%U%f(i-pnx)*g%c(1)%stagCC2N%D%f(i-pnx) + &
                        g%c(2)%stagN2CC%D%f(  j  )*g%c(2)%stagCC2N%U%f( j-1 ) + &
                        g%c(2)%stagN2CC%U%f(j-pny)*g%c(2)%stagCC2N%D%f(j-pny) + &
                        g%c(3)%stagN2CC%D%f(  k  )*g%c(3)%stagCC2N%U%f( k-1 ) + &
                        g%c(3)%stagN2CC%U%f(k-pnz)*g%c(3)%stagCC2N%D%f(k-pnz)
        enddo; enddo; enddo
        !$OMP END PARALLEL DO
      end subroutine

      subroutine curl_curl_diagonal(diag_x,diag_y,diag_z,g,sig_x,sig_y,sig_z) ! Verified 1/3/2016
        ! Computes curl-curl diagonal: diag = ∇x(σ∇x)
        implicit none
        type(grid_field),intent(inout) :: diag_x,diag_y,diag_z
        type(grid_field),intent(in) :: sig_x,sig_y,sig_z
        type(grid),intent(in) :: g
        integer :: i,j,k
        call assign(diag_x,0.0_cp)
        call assign(diag_y,0.0_cp)
        call assign(diag_z,0.0_cp)
        !$OMP PARALLEL DO
        do k=2,diag_x%s(3)-1; do j=2,diag_x%s(2)-1; do i=2,diag_x%s(1)-1
        diag_x%f(i,j,k) = -g%c(2)%stagN2CC%D%f(j)*sig_z%f(i,j, k )*g%c(2)%stagCC2N%U%f(j-1) - &
                           g%c(2)%stagN2CC%U%f(j)*sig_z%f(i,j+1,k)*g%c(2)%stagCC2N%D%f( j ) - &
                           g%c(3)%stagN2CC%D%f(k)*sig_y%f(i,j, k )*g%c(3)%stagCC2N%U%f(k-1) - &
                           g%c(3)%stagN2CC%U%f(k)*sig_y%f(i,j,k+1)*g%c(3)%stagCC2N%D%f( k )
        enddo; enddo; enddo
        !$OMP END PARALLEL DO
        !$OMP PARALLEL DO
        do k=2,diag_y%s(3)-1; do j=2,diag_y%s(2)-1; do i=2,diag_y%s(1)-1
        diag_y%f(i,j,k) = -g%c(1)%stagN2CC%D%f(i)*sig_z%f(i,j, k )*g%c(1)%stagCC2N%U%f(i-1) - &
                           g%c(1)%stagN2CC%U%f(i)*sig_z%f(i+1,j,k)*g%c(1)%stagCC2N%D%f( i ) - &
                           g%c(3)%stagN2CC%D%f(k)*sig_x%f(i,j, k )*g%c(3)%stagCC2N%U%f(k-1) - &
                           g%c(3)%stagN2CC%U%f(k)*sig_x%f(i,j,k+1)*g%c(3)%stagCC2N%D%f( k )
        enddo; enddo; enddo
        !$OMP END PARALLEL DO
        !$OMP PARALLEL DO
        do k=2,diag_z%s(3)-1; do j=2,diag_z%s(2)-1; do i=2,diag_z%s(1)-1
        diag_z%f(i,j,k) = -g%c(1)%stagN2CC%D%f(i)*sig_y%f(i, j ,k)*g%c(1)%stagCC2N%U%f(i-1) - &
                           g%c(1)%stagN2CC%U%f(i)*sig_y%f(i+1,j,k)*g%c(1)%stagCC2N%D%f( i ) - &
                           g%c(2)%stagN2CC%D%f(j)*sig_x%f(i, j ,k)*g%c(2)%stagCC2N%U%f(j-1) - &
                           g%c(2)%stagN2CC%U%f(j)*sig_x%f(i,j+1,k)*g%c(2)%stagCC2N%D%f( j )
        enddo; enddo; enddo
        !$OMP END PARALLEL DO
      end subroutine

      end module
       module GF_interp_mod
       ! Compiler flags: (_DEBUG_INTERP_,_PARALLELIZE_INTERP_)
       use face_edge_corner_indexing_mod
       use current_precision_mod
       use grid_field_mod
       use grid_field_extend_mod
       use GF_extrap_mod
       use grid_mod
       implicit none

       private
       public :: interp_C2N
       public :: interp_N2C
       interface interp_C2N;      module procedure interp_C2N_GF;    end interface
       interface interp_N2C;      module procedure interp_N2C_GF;    end interface

       contains

       subroutine interp_C2N_GF(N,C,g,dir,x,y,z)
         !         N  C  N  C  N  C  N  C  N
         !         |--o--|--o--|--o--|--o--|      --> dir
         !               *     *     *
         implicit none
         type(grid_field),intent(inout) :: N
         type(grid_field),intent(in) :: C
         type(grid),intent(in) :: g
         integer,intent(in) :: dir,x,y,z
         integer :: i,j,k,t
#ifdef _DEBUG_INTERP_
         call insist_shape_match(C,N,dir,'interp_C2N_GF')
         call insist_shape_staggered(C,N,dir,'interp_C2N_GF')
#endif

#ifdef _PARALLELIZE_INTERP_
           !$OMP PARALLEL DO PRIVATE(t)

#endif
           do k=1,C%s(3)-z; do j=1,C%s(2)-y; do i=1,C%s(1)-x
           t = i*x + j*y + k*z
           N%f(i+x,j+y,k+z) = C%f(i+x,j+y,k+z)*g%c(dir)%theta%D%f(t) + &
                              C%f( i , j , k )*g%c(dir)%theta%U%f(t)
           enddo; enddo; enddo
#ifdef _PARALLELIZE_INTERP_
           !$OMP END PARALLEL DO

#endif
           call extrap(N,C,dir)
       end subroutine

       subroutine interp_N2C_GF(C,N,x,y,z)
         !         N  C  N  C  N  C  N  C  N
         !         |--o--|--o--|--o--|--o--|   --> dir
         !            *     *     *     *
         implicit none
         type(grid_field),intent(inout) :: C
         type(grid_field),intent(in) :: N
         integer,intent(in) :: x,y,z
         integer :: i,j,k
#ifdef _DEBUG_INTERP_
         call insist_shape_match(C,N,dir_given_eye((/x,y,z/)),'interp_N2C_GF')
         call insist_shape_staggered(C,N,dir_given_eye((/x,y,z/)),'interp_N2C_GF')
#endif

#ifdef _PARALLELIZE_INTERP_
           !$OMP PARALLEL DO

#endif
           do k=1,N%s(3)-z; do j=1,N%s(2)-y; do i=1,N%s(1)-x
           C%f(i,j,k) = 0.5_cp*(N%f( i , j , k )+&
                                N%f(i+x,j+y,k+z))
           enddo; enddo; enddo
#ifdef _PARALLELIZE_INTERP_
           !$OMP END PARALLEL DO

#endif
       end subroutine

       end module
      module GF_mean_along_dir_mod
        use grid_field_mod
        use grid_field_extend_mod
        use grid_mod
        use GF_assign_plane_mod
        use GF_plane_mean_mod
        use current_precision_mod
        implicit none
        private

        public :: mean_along_x
        public :: mean_along_y
        public :: mean_along_z

        interface mean_along_x;    module procedure mean_along_x_GF;     end interface
        interface mean_along_y;    module procedure mean_along_y_GF;     end interface
        interface mean_along_z;    module procedure mean_along_z_GF;     end interface

        contains

        subroutine mean_along_x_GF(u_mean,u,g)
          implicit none
          type(grid_field),intent(inout) :: u_mean
          type(grid_field),intent(in) :: u
          type(grid),intent(in) :: g
          integer :: i
          real(cp) :: temp
#ifdef _DEBUG_GF_
          call insist_shape_match(u,u_mean,'mean_along_x_GF')
#endif
#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO SHARED(g) PRIVATE(temp)

#endif
          do i=1,u%s(1)
            temp = plane_mean_x(u,g,i)
            call assign_plane_x(u_mean,temp,i)
          enddo
#ifdef _PARALLELIZE_GF_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        subroutine mean_along_y_GF(u_mean,u,g)
          implicit none
          type(grid_field),intent(inout) :: u_mean
          type(grid_field),intent(in) :: u
          type(grid),intent(in) :: g
          integer :: j
          real(cp) :: temp
#ifdef _DEBUG_GF_
          call insist_shape_match(u,u_mean,'mean_along_y_GF')
#endif
#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO SHARED(g) PRIVATE(temp)

#endif
          do j=1,u%s(2)
            temp = plane_mean_y(u,g,j)
            call assign_plane_y(u_mean,temp,j)
          enddo
#ifdef _PARALLELIZE_GF_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        subroutine mean_along_z_GF(u_mean,u,g)
          implicit none
          type(grid_field),intent(inout) :: u_mean
          type(grid_field),intent(in) :: u
          type(grid),intent(in) :: g
          integer :: k
          real(cp) :: temp
#ifdef _DEBUG_GF_
          call insist_shape_match(u,u_mean,'mean_along_z_GF')
#endif
#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO SHARED(g) PRIVATE(temp)

#endif
          do k=1,u%s(3)
            temp = plane_mean_z(u,g,k)
            call assign_plane_z(u_mean,temp,k)
          enddo
#ifdef _PARALLELIZE_GF_
          !$OMP END PARALLEL DO

#endif
        end subroutine

      end module
      module GF_multiply_wall_mod
        use current_precision_mod
        use grid_field_mod
        use GF_multiply_plane_mod
        implicit none

        abstract interface
          subroutine plane_op(GF,val)
            import grid_field,cp
            implicit none
            type(grid_field),intent(inout) :: GF
            real(cp),intent(in) :: val
          end subroutine
        end interface

        private
        public :: plane_op
        public :: multiply_wall_xmin
        public :: multiply_wall_ymin
        public :: multiply_wall_zmin
        public :: multiply_wall_xmax
        public :: multiply_wall_ymax
        public :: multiply_wall_zmax

        contains

        subroutine multiply_wall_xmin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call multiply_plane_x(U,val,2)
        end subroutine

        subroutine multiply_wall_xmax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call multiply_plane_x(U,val,U%s(1)-1)
        end subroutine

        subroutine multiply_wall_ymin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call multiply_plane_y(U,val,2)
        end subroutine

        subroutine multiply_wall_ymax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call multiply_plane_y(U,val,U%s(2)-1)
        end subroutine

        subroutine multiply_wall_zmin(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call multiply_plane_z(U,val,2)
        end subroutine

        subroutine multiply_wall_zmax(U,val)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: val
          call multiply_plane_z(U,val,U%s(3)-1)
        end subroutine

      end module
       module GF_prolongate_mod
       ! Compiler flags:(_PARALLELIZE_PROLONGATE_)
       use current_precision_mod
       use grid_mod
       use grid_field_extend_mod
       use face_edge_corner_indexing_mod
       use grid_field_mod
       use GF_extrap_mod
       use GF_assign_mod
       implicit none

       private
       public :: prolongate_C
       public :: prolongate_N
       interface prolongate_C;        module procedure prolongate_C_GF;            end interface
       interface prolongate_C;        module procedure prolongate_C_reset_GF;      end interface
       interface prolongate_N;        module procedure prolongate_N_GF;            end interface
       interface prolongate_N;        module procedure prolongate_N_reset_GF;      end interface

       contains

       subroutine prolongate_C_GF(p,u,g,dir,x,y,z)
         ! Prolongates cell centered data if N_cells along dir is even
         implicit none
         type(grid_field),intent(inout) :: p ! fine field (size = 2*s-1)
         type(grid_field),intent(in) :: u    ! original field (size = s)
         type(grid),intent(in) :: g          ! fine grid
         integer,intent(in) :: dir,x,y,z     ! x,y,z = eye(dir)
         real(cp) :: node_interp
         integer :: i,j,k,t,i_L,j_L,k_L,i_R,j_R,k_R
         ! Starting from the physical boundaries, assign cell on LEFT  side of node:
         ! Starting from the physical boundaries, assign cell on RIGHT side of node:

#ifdef _PARALLELIZE_PROLONGATE_
           !$OMP PARALLEL DO PRIVATE(t,i_L,j_L,k_L,i_R,j_R,k_R,node_interp)

#endif
         do k=1,u%s(3)-z
         do j=1,u%s(2)-y
         do i=1,u%s(1)-x
         t = i*x + j*y + k*z
         i_L = (1+x)*i-x
         j_L = (1+y)*j-y
         k_L = (1+z)*k-z
         i_R = (1+x)*i
         j_R = (1+y)*j
         k_R = (1+z)*k
         node_interp = u%f(i+x,j+y,k+z)*g%c(dir)%theta%D%f(t) + &
                       u%f( i , j , k )*g%c(dir)%theta%U%f(t)
         p%f(i_L,j_L,k_L) = 0.5_cp*(u%f( i , j , k ) + node_interp)
         p%f(i_R,j_R,k_R) = 0.5_cp*(u%f(i+x,j+y,k+z) + node_interp)
         enddo; enddo; enddo
#ifdef _PARALLELIZE_PROLONGATE_
           !$OMP END PARALLEL DO

#endif
         call extrap(p,dir) ! Extrapolate!
       end subroutine

       subroutine prolongate_N_GF(p,u,x,y,z) ! conceptually verified 11/21/2016
         ! Prolongates node centered data if N_cells along dir is even
         implicit none
         type(grid_field),intent(inout) :: p ! fine field (size = 2*s-1)
         type(grid_field),intent(in) :: u    ! original field (size = s)
         integer,intent(in) :: x,y,z     ! x,y,z = eye(dir)
         integer :: i,j,k,i_f,j_f,k_f
         ! Starting from the physical boundaries, odd locations have
         ! coincident values: Index for p must be even: 2n-2

#ifdef _PARALLELIZE_PROLONGATE_
           !$OMP PARALLEL DO PRIVATE(i_f,j_f,k_f)

#endif
         do k=1+z,u%s(3)-z
         do j=1+y,u%s(2)-y
         do i=1+x,u%s(1)-x
         i_f = (1+x)*i-2*x
         j_f = (1+y)*j-2*y
         k_f = (1+z)*k-2*z
         p%f(i_f,j_f,k_f) = u%f(i,j,k)
         enddo; enddo; enddo
#ifdef _PARALLELIZE_PROLONGATE_
           !$OMP END PARALLEL DO

#endif

         ! All even locations are interpolated: Index for p must be even: 2n-1 (starts at ghost)

#ifdef _PARALLELIZE_PROLONGATE_
           !$OMP PARALLEL DO PRIVATE(i_f,j_f,k_f)

#endif
         do k=1,u%s(3)-z
         do j=1,u%s(2)-y
         do i=1,u%s(1)-x
         i_f = (1+x)*i-x
         j_f = (1+y)*j-y
         k_f = (1+z)*k-z
         p%f(i_f,j_f,k_f) = u%f( i , j , k )*0.5_cp + &
                            u%f(i+x,j+y,k+z)*0.5_cp
         enddo; enddo; enddo
#ifdef _PARALLELIZE_PROLONGATE_
           !$OMP END PARALLEL DO

#endif
       end subroutine

       subroutine prolongate_C_reset_GF(u,g,dir,x,y,z)
         implicit none
         type(grid_field),intent(inout) :: u
         type(grid),intent(in) :: g
         integer,intent(in) :: dir,x,y,z
         type(grid_field) :: temp
         integer,dimension(3) :: e,s
         if (u%s(dir).gt.3) then
           e = eye_given_dir(dir)
           s = (u%s-e)*(e+1)
           call init(temp,s)
           call assign(temp,0.0_cp)
           call prolongate_C(temp,u,g,dir,x,y,z)
           call init(u,temp)
           call assign(u,temp)
           call delete(temp)
         endif
       end subroutine

       subroutine prolongate_N_reset_GF(u,dir,x,y,z)
         implicit none
         type(grid_field),intent(inout) :: u
         integer,intent(in) :: dir,x,y,z
         type(grid_field) :: temp
         integer,dimension(3) :: e,s
         if (u%s(dir).gt.4) then
           e = eye_given_dir(dir)
           s = (u%s-e)*(e+1)-e
           call init(temp,s)
           call assign(temp,0.0_cp)
           call prolongate_N(temp,u,x,y,z)
           call init(u,temp)
           call assign(u,temp)
           call delete(temp)
         endif
       end subroutine

       end module
       module GF_restrict_mod
       use current_precision_mod
       use grid_mod
       use face_edge_corner_indexing_mod
       use grid_field_mod
       use grid_field_extend_mod
       use GF_assign_mod
       use GF_assign_plane_mod
       use GF_extrap_mod
       implicit none

       private
       public :: restrict_C
       public :: restrict_N
       interface restrict_C;    module procedure restrict_C_GF;         end interface
       interface restrict_C;    module procedure restrict_C_reset_GF;   end interface
       interface restrict_N;    module procedure restrict_N_GF;         end interface
       interface restrict_N;    module procedure restrict_N_reset_GF;   end interface

       contains

       subroutine restrict_C_GF(r,u,g,dir,x,y,z)
         implicit none
         type(grid_field),intent(inout) :: r  ! coarse field
         type(grid_field),intent(in) :: u     ! original field
         type(grid),intent(in) :: g           ! u-grid
         integer,intent(in) :: dir,x,y,z ! x,y,z = eye(dir)
         real(cp) :: alpha,beta
         integer :: i,j,k,t,i_R,j_R,k_R
         if (mod(g%c(dir)%sc,2).eq.0) then
           !    Linearly interpolate the average of two cells to the cell center:
           ! or Linearly interpolate the two adjecent cells and average:
           do k=1+z,u%s(3)-z,1+z
           do j=1+y,u%s(2)-y,1+y
           do i=1+x,u%s(1)-x,1+x
           t = i*x + j*y + k*z
           i_R = i*(1-x)+x*i/2+x
           j_R = i*(1-y)+y*j/2+y
           k_R = i*(1-z)+z*k/2+z
           alpha = g%c(dir)%dhn%f(t)/(g%c(dir)%dhn%f(t)+g%c(dir)%dhn%f(t+1))
           beta  = 1.0_cp-alpha
           r%f(i_R,j_R,k_R) = u%f( i , j , k )*alpha + &
                              u%f(i+x,j+y,k+z)*beta
           enddo; enddo; enddo
           ! Linearly extrapolate to ghost points?
           call extrap(r,dir) ! Extrapolate!
         endif
       end subroutine

       subroutine restrict_N_GF(r,u,g,dir,x,y,z)
         ! u {N},  mod(sc/2,2)=0
         implicit none
         type(grid_field),intent(inout) :: r  ! coarse field
         type(grid_field),intent(in) :: u     ! original field
         type(grid),intent(in) :: g           ! u-grid
         integer,intent(in) :: dir,x,y,z ! x,y,z = eye(dir)
         real(cp) :: alpha,beta
         integer :: i,j,k,t,i_R,j_R,k_R
         if (mod(g%c(dir)%sc,2).eq.0) then
           ! Starting from the physical boundary, every odd becomes the
           ! average of the value itself and its linearly interpolated neighbors:
           do k=1+z,u%s(3)-z,1+z
           do j=1+y,u%s(2)-y,1+y
           do i=1+x,u%s(1)-x,1+x
           t = i*x + j*y + k*z
           i_R = i*(1-x)+x*i/2+x
           j_R = i*(1-y)+y*j/2+y
           k_R = i*(1-z)+z*k/2+z
           alpha = g%c(dir)%dhn%f(t)/(g%c(dir)%dhn%f(t)+g%c(dir)%dhn%f(t-1))
           beta  = 1.0_cp-alpha
           r%f(i_R,j_R,k_R) = 0.5_cp*(u%f( i , j , k ) + &
                                      u%f(i-x,j-y,k-z)*alpha + &
                                      u%f(i+x,j+y,k+z)*beta)
           enddo; enddo; enddo
           ! Boundary values, along dir, remain the same:
           !
           call assign_plane(r,u,2,2,dir)
           call assign_plane(r,u,r%s(dir)-1,u%s(dir)-1,dir)
           ! Linearly extrapolate to ghost points?
           call extrap(r,dir) ! Extrapolate!
         endif
       end subroutine

       subroutine restrict_C_reset_GF(u,g,dir,x,y,z)
         implicit none
         type(grid_field),intent(inout) :: u
         type(grid),intent(in) :: g
         integer,intent(in) :: dir,x,y,z
         type(grid_field) :: temp
         call init(temp,u%s/(eye_given_dir(dir)+1))
         call assign(temp,0.0_cp)
         call restrict_C(temp,u,g,dir,x,y,z)
         call init(u,temp)
         call assign(u,temp)
         call delete(temp)
       end subroutine

       subroutine restrict_N_reset_GF(u,g,dir,x,y,z)
         implicit none
         type(grid_field),intent(inout) :: u
         type(grid),intent(in) :: g
         integer,intent(in) :: dir,x,y,z
         type(grid_field) :: temp
         call init(temp,u%s/(eye_given_dir(dir)+1))
         call assign(temp,0.0_cp)
         call restrict_N(temp,u,g,dir,x,y,z)
         call init(u,temp)
         call assign(u,temp)
         call delete(temp)
       end subroutine

       end module
     module sim_params_init_mesh_mod
     use current_precision_mod
     use constants_mod
     use string_mod
     use dir_tree_mod
     use path_extend_mod
     use mesh_params_extend_mod
     use segment_extend_mod
     use mesh_quality_params_extend_mod
     use mesh_bank_mod
     use sim_params_mod
     use sim_params_aux_mod
     implicit none

     private
     public :: sim_params_init_mesh

     contains

     subroutine sim_params_init_mesh(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       logical,parameter :: T = .true.
       logical,parameter :: F = .false.
       ! call init(MQP,auto_find_N,max_mesh_stretch_ratio,N_max_points_add)
       call init(SP%MQP,T,2.0_cp,50)

       ! call define_mesh_SP_plasma_disruption(SP)
       ! call small_dataset(SP)
       ! call define_mesh_bandaru(SP)
       call define_mesh_hydro_LDC_Ghia(SP)
       ! call define_mesh_SP_full_BC_symmetric_geometry(SP)
       ! call define_mesh_SP_full_BC_3D_geometry(SP)
       ! call define_mesh_SP_MHD_LDC_Sergey_uniform(SP)
     end subroutine

     end module
      module GF_CFL_number_mod
        use grid_field_mod
        use GF_aux_mod
        use grid_mod
        use current_precision_mod
        implicit none
        private
        public :: CFL_number
        interface CFL_number;          module procedure CFL_number_GF;          end interface
        public :: dt_given_CFL_number
        interface dt_given_CFL_number; module procedure dt_given_CFL_number_GF; end interface

        contains

        function CFL_number_GF(U_CC,V_CC,W_CC,g,dt) result(CFL)
          ! Computes: CFL =  max(sum(u_i/dx_i)), i=1,3
          implicit none
          type(grid_field),intent(in) :: U_CC,V_CC,W_CC
          type(grid),intent(in) :: g
          real(cp),intent(in) :: dt
          real(cp),dimension(3) :: temp
          integer :: i,j,k
          real(cp) :: CFL
          CFL = 0.0_cp
          do k=1,U_CC%s(3); do j=1,U_CC%s(2); do i=1,U_CC%s(1)
            temp(1) = abs(U_CC%f(i,j,k)) / g%c(1)%dhn%f(i)
            temp(2) = abs(V_CC%f(i,j,k)) / g%c(2)%dhn%f(j)
            temp(3) = abs(W_CC%f(i,j,k)) / g%c(3)%dhn%f(k)
            CFL = maxval((/CFL,dt*sum(temp)/))
          enddo; enddo; enddo
        end function

        function dt_given_CFL_number_GF(U_CC,V_CC,W_CC,g,CFL) result(dt)
          ! Computes: dt =  CFL/max(sum(u_i/dx_i)), i=1,3
          implicit none
          type(grid_field),intent(in) :: U_CC,V_CC,W_CC
          type(grid),intent(in) :: g
          real(cp),intent(in) :: CFL
          real(cp),dimension(3) :: temp
          real(cp) :: temp_sum,u_max
          integer :: i,j,k
          real(cp) :: dt
          ! real(cp) :: dh_min
          temp_sum = 0.0_cp
          u_max = maxval((/amax(U_CC),amax(V_CC),amax(W_CC)/))
          do k=1,U_CC%s(3); do j=1,U_CC%s(2); do i=1,U_CC%s(1)
            ! temp(1) = g%c(1)%dhn%f(i)/abs(U_CC%f(i,j,k))
            ! temp(2) = g%c(2)%dhn%f(j)/abs(V_CC%f(i,j,k))
            ! temp(3) = g%c(3)%dhn%f(k)/abs(W_CC%f(i,j,k))
            temp(1) = g%c(1)%dhn%f(i)/u_max
            temp(2) = g%c(2)%dhn%f(j)/u_max
            temp(3) = g%c(3)%dhn%f(k)/u_max
            temp_sum = maxval( (/temp_sum,sum(temp)/) )
          enddo; enddo; enddo
          ! dh_min = minval((/g%c(1)%dhMin,g%c(2)%dhMin,g%c(3)%dhMin/))
          ! dt = minval((/dt_initial,CFL/temp_sum/))
          dt = CFL/temp_sum
        end function

      end module
      module GF_distributions_mod
        use grid_field_mod
        use GF_assign_mod
        use GF_assign_ghost_mod
        use GF_assign_plane_mod
        use GF_multiply_mod
        use grid_mod
        use grid_extend_mod
        use array_mod
        use data_location_extend_mod
        use current_precision_mod
        use face_edge_corner_indexing_mod
        use constants_mod
        implicit none
        private

        public :: inverse_area
        public :: volume
        public :: sine_waves
        public :: sinh_waves
        public :: cosine_waves
        public :: cosh_waves
        public :: random_noise
        public :: fringe_ALEX
        public :: fringe_SERGEY
        public :: smooth_lid
        public :: smooth_lid_Shatrov
        public :: smooth_lid_Leriche
        public :: fully_developed_duct_velocity
        public :: isolated_2D_eddy
        public :: single_2D_eddy
        public :: cylinder_2D_velocity
        public :: parabolic_1D
        public :: Taylor_Green_Vortex_U
        public :: Taylor_Green_Vortex_V
        public :: Taylor_Green_Vortex_P

        interface volume;                module procedure volume_DL_GF;                    end interface
        interface volume;                module procedure volume_GF;                       end interface
        interface inverse_area;          module procedure inverse_area_DL_GF;              end interface
        interface inverse_area;          module procedure inverse_area_GF;                 end interface
        interface sine_waves;            module procedure sine_waves_GF;                   end interface
        interface sinh_waves;            module procedure sinh_waves_GF;                   end interface
        interface cosine_waves;          module procedure cosine_waves_GF;                 end interface
        interface cosh_waves;            module procedure cosh_waves_GF;                   end interface
        interface fringe_ALEX;           module procedure fringe_ALEX_GF;                  end interface
        interface fringe_SERGEY;         module procedure fringe_SERGEY_GF;                end interface
        interface smooth_lid;            module procedure smooth_lid_GF;                   end interface
        interface smooth_lid_Leriche;    module procedure smooth_lid_Leriche_GF;           end interface
        interface smooth_lid_Leriche;    module procedure smooth_lid_Leriche_symmetric_GF; end interface
        interface smooth_lid_Shatrov;    module procedure smooth_lid_Shatrov_GF;           end interface
        interface random_noise;          module procedure random_noise_GF;                 end interface
        interface random_noise;          module procedure random_noise_GF_dir;             end interface
        interface parabolic_1D;          module procedure parabolic_1D_GF;                 end interface
        interface Taylor_Green_Vortex_U; module procedure Taylor_Green_Vortex_U_GF;        end interface
        interface Taylor_Green_Vortex_V; module procedure Taylor_Green_Vortex_V_GF;        end interface
        interface Taylor_Green_Vortex_P; module procedure Taylor_Green_Vortex_P_GF;        end interface

        contains

        subroutine volume_DL_GF(u,g,DL)
          ! Computes: volume(x(i),y(j),z(k)) = dx(i) dy(j) dz(k)
          implicit none
          type(grid_field),intent(inout) :: u
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          type(array),dimension(3) :: dh
          integer :: i,j,k
          integer,dimension(3) :: e
          call assign(u,0.0_cp)
          call get_coordinates_dual_dh(dh,g,DL)
          e = N_eye(DL)

#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO SHARED(g)

#endif
          do k=2,u%s(3)-1; do j=2,u%s(2)-1; do i=2,u%s(1)-1
              u%f(i,j,k) = dh(1)%f(i-e(1))*&
                           dh(2)%f(j-e(2))*&
                           dh(3)%f(k-e(3))
          enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_
          !$OMP END PARALLEL DO

#endif
          do i=1,3; call delete(dh(i)); enddo
        end subroutine

        subroutine volume_GF(u,g)
          implicit none
          type(grid_field),intent(inout) :: u
          type(grid),intent(in) :: g
          call volume(u,g,DL_CC())
        end subroutine

        subroutine inverse_area_DL_GF(u,g,DL,dir)
          ! Computes: volume(x(i),y(j),z(k)) = dx(i) dy(j) dz(k)
          implicit none
          type(grid_field),intent(inout) :: u
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          integer,intent(in) :: dir
          type(array),dimension(3) :: dh
          integer :: i,j,k
          integer,dimension(3) :: e
          call assign(u,0.0_cp)
          call get_coordinates_dual_dh(dh,g,DL)
          e = N_eye(DL)
          dh(dir)%f = 1.0_cp

#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO SHARED(g)

#endif
          do k=2,u%s(3)-1; do j=2,u%s(2)-1; do i=2,u%s(1)-1
              u%f(i,j,k) = 1.0_cp/(dh(1)%f(i-e(1))*&
                                   dh(2)%f(j-e(2))*&
                                   dh(3)%f(k-e(3)))
          enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_
          !$OMP END PARALLEL DO

#endif
          do i=1,3; call delete(dh(i)); enddo
          call assign_ghost_all(u,0.0_cp)
        end subroutine

        subroutine inverse_area_GF(u,g,dir)
          implicit none
          type(grid_field),intent(inout) :: u
          type(grid),intent(in) :: g
          integer,intent(in) :: dir
          call inverse_area(u,g,DL_CC(),dir)
        end subroutine

        subroutine sine_waves_GF(f,g,wavenum,phi,DL)
          implicit none
          type(grid_field),intent(inout) :: f
          type(grid),intent(in) :: g
          real(cp),dimension(3),intent(in) :: wavenum,phi
          type(data_location),intent(in) :: DL
          type(array),dimension(3) :: h
          integer :: i,j,k
          call get_coordinates_h(h,g,DL)
#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO SHARED(g)

#endif
          do k=1,f%s(3); do j=1,f%s(2); do i=1,f%s(1)
            f%f(i,j,k) = sin(wavenum(1)*PI*(h(1)%f(i) - phi(1)))*&
                         sin(wavenum(2)*PI*(h(2)%f(j) - phi(2)))*&
                         sin(wavenum(3)*PI*(h(3)%f(k) - phi(3)))
          enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_
          !$OMP END PARALLEL DO

#endif
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine sinh_waves_GF(f,g,wavenum,phi,DL)
          implicit none
          type(grid_field),intent(inout) :: f
          type(grid),intent(in) :: g
          real(cp),dimension(3),intent(in) :: wavenum,phi
          type(data_location),intent(in) :: DL
          type(array),dimension(3) :: h
          integer :: i,j,k
          call get_coordinates_h(h,g,DL)
#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO SHARED(g)

#endif
          do k=1,f%s(3); do j=1,f%s(2); do i=1,f%s(1)
            f%f(i,j,k) = sinh(wavenum(1)*PI*(h(1)%f(i) - phi(1)))*&
                         sinh(wavenum(2)*PI*(h(2)%f(j) - phi(2)))*&
                         sinh(wavenum(3)*PI*(h(3)%f(k) - phi(3)))
          enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_
          !$OMP END PARALLEL DO

#endif
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine cosine_waves_GF(f,g,wavenum,phi,DL)
          implicit none
          type(grid_field),intent(inout) :: f
          type(grid),intent(in) :: g
          real(cp),dimension(3),intent(in) :: wavenum,phi
          type(data_location),intent(in) :: DL
          type(array),dimension(3) :: h
          integer :: i,j,k

          call get_coordinates_h(h,g,DL)
#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO SHARED(g)

#endif
          do k=1,f%s(3); do j=1,f%s(2); do i=1,f%s(1)
          f%f(i,j,k) = cos(wavenum(1)*PI*(h(1)%f(i) - phi(1)))*&
                       cos(wavenum(2)*PI*(h(2)%f(j) - phi(2)))*&
                       cos(wavenum(3)*PI*(h(3)%f(k) - phi(3)))
          enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_
          !$OMP END PARALLEL DO

#endif
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine cosh_waves_GF(f,g,wavenum,phi,DL)
          implicit none
          type(grid_field),intent(inout) :: f
          type(grid),intent(in) :: g
          real(cp),dimension(3),intent(in) :: wavenum,phi
          type(data_location),intent(in) :: DL
          type(array),dimension(3) :: h
          integer :: i,j,k

          call get_coordinates_h(h,g,DL)
#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO SHARED(g)

#endif
          do k=1,f%s(3); do j=1,f%s(2); do i=1,f%s(1)
          f%f(i,j,k) = cosh(wavenum(1)*PI*(h(1)%f(i) - phi(1)))*&
                       cosh(wavenum(2)*PI*(h(2)%f(j) - phi(2)))*&
                       cosh(wavenum(3)*PI*(h(3)%f(k) - phi(3)))
          enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_
          !$OMP END PARALLEL DO

#endif
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine fringe_ALEX_GF(B,g,DL,dir)
          implicit none
          type(grid_field),intent(inout) :: B
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          integer,intent(in) :: dir
          type(array),dimension(3) :: h
          real(cp) :: Bstretch,Bshift,theta,val
          integer :: i
          Bstretch = 0.45_cp   ! stretching parameter
          Bshift = 12.5_cp     ! shift parameter
          call get_coordinates_h(h,g,DL)
          do i=1,B%s(dir)
            theta = dble(h(dir)%f(i)-Bshift*Bstretch)
            val = 0.5_cp*(1.0_cp-tanh(theta))
            call assign_plane(B,val,i,dir)
          enddo
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine fringe_SERGEY_GF(B,g,DL,dir)
          implicit none
          type(grid_field),intent(inout) :: B
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          integer,intent(in) :: dir
          type(array),dimension(3) :: h
          type(grid_field) :: temp
          real(cp) :: Bstretch,Bshift,theta,val
          integer :: i,i2
          Bstretch = 0.2_cp   ! Fringe slope
          Bshift = 10.0_cp    ! Fringe location
          call init(temp,B)
          call get_coordinates_h(h,g,DL)
          do i=1,B%s(dir)
            theta = dble((h(dir)%f(i)-Bshift)/Bstretch)
            val = 0.5_cp*(1.0_cp+tanh(theta))
            call assign_plane(temp,val,i,dir)
          enddo
          call assign(B,temp)
          i2 = 0
          do i=1+(B%s(dir)-1)/2,B%s(dir)
            call assign_plane(B,temp,i,1+(B%s(dir)+1)/2-i2,dir)
          enddo
          call delete(temp)
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine smooth_lid_GF(U,g,DL,plane,n)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          integer,intent(in) :: plane
          real(cp),intent(in) :: n
          type(array),dimension(3) :: h
          real(cp),dimension(3) :: L
          integer,dimension(2) :: a
          integer,dimension(3) :: e
          real(cp) :: xhat,yhat
          integer :: i,j,i_p,j_p,k_p,p
          call get_coordinates_h(h,g,DL)
          a = adj_dir_given_dir(plane)
          e = eye_given_dir(plane)
          L = (/(g%c(i)%maxRange/2.0_cp,i=1,3)/)
          do i=1,U%s(a(1))
          do j=1,U%s(a(2))
          do p=1,U%s(plane)
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            xhat = ( h(a(1))%f(i) / L(a(1)) )**n
            yhat = ( h(a(2))%f(j) / L(a(2)) )**n
            U%f(i_p,j_p,k_p) = (1.0_cp - xhat)*(1.0_cp - yhat)
          enddo
          enddo
          enddo
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine smooth_lid_Leriche_GF(U,g,DL,plane,n)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          integer,intent(in) :: plane
          real(cp),intent(in) :: n
          type(array),dimension(3) :: h
          real(cp),dimension(3) :: L
          integer,dimension(2) :: a
          integer,dimension(3) :: e
          real(cp) :: xhat,yhat
          integer :: i,j,i_p,j_p,k_p,p
          call get_coordinates_h(h,g,DL)
          a = adj_dir_given_dir(plane)
          e = eye_given_dir(plane)
          L = (/(g%c(i)%maxRange/2.0_cp,i=1,3)/)
          do i=1,U%s(a(1))
          do j=1,U%s(a(2))
          do p=1,U%s(plane)
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            xhat = ( h(a(1))%f(i) / L(a(1)) )**n
            yhat = ( h(a(2))%f(j) / L(a(2)) )**n
            if ((abs(xhat).lt.1.0_cp).and.(abs(yhat).lt.1.0_cp)) then
              U%f(i_p,j_p,k_p) = ((1.0_cp - xhat)**2.0_cp)*((1.0_cp - yhat)**2.0_cp)
            else
              U%f(i_p,j_p,k_p) = 2.0_cp
            endif
          enddo
          enddo
          enddo
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine smooth_lid_Leriche_symmetric_GF(U,g,DL,plane,n,symmetric_dir)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          integer,intent(in) :: plane,symmetric_dir
          real(cp),intent(in) :: n
          type(array),dimension(3) :: h
          real(cp),dimension(3) :: L
          integer,dimension(2) :: a
          integer,dimension(3) :: e
          real(cp) :: xhat,yhat
          integer :: i,j,i_p,j_p,k_p,p
          call get_coordinates_h(h,g,DL)
          a = adj_dir_given_dir(plane)
          e = eye_given_dir(plane)
          L = (/(g%c(i)%maxRange/2.0_cp,i=1,3)/)
          call insist_valid_dir(symmetric_dir,'smooth_lid_Leriche_symmetric_GF')
          L(symmetric_dir) = 2.0_cp*L(symmetric_dir)
          do i=1,U%s(a(1))
          do j=1,U%s(a(2))
          do p=1,U%s(plane)
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            xhat = ( h(a(1))%f(i) / L(a(1)) )**n
            yhat = ( h(a(2))%f(j) / L(a(2)) )**n
            if ((abs(xhat).lt.1.0_cp).and.(abs(yhat).lt.1.0_cp)) then
              U%f(i_p,j_p,k_p) = ((1.0_cp - xhat)**2.0_cp)*((1.0_cp - yhat)**2.0_cp)
            endif
          enddo
          enddo
          enddo
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine smooth_lid_Shatrov_GF(U,g,DL,plane,k_lid)
          ! This profile was shifted to enforce 0 < x,y,z < 1
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          integer,intent(in) :: plane
          real(cp),intent(in) :: k_lid
          type(array),dimension(3) :: h
          real(cp),dimension(3) :: L,hmin
          integer,dimension(2) :: a
          integer,dimension(3) :: e
          real(cp) :: xhat,yhat
          real(cp) :: x_01,y_01
          real(cp) :: xhat_parabolic,yhat_parabolic
          real(cp) :: xhat_flip,yhat_flip
          integer :: i,j,i_p,j_p,k_p,p
          call get_coordinates_h(h,g,DL)
          a = adj_dir_given_dir(plane)
          e = eye_given_dir(plane)
          L = (/(g%c(i)%hmax-g%c(i)%hmin,i=1,3)/)
          hmin = (/(g%c(i)%hmin,i=1,3)/)
          do i=1,U%s(a(1))
          do j=1,U%s(a(2))
          do p=1,U%s(plane)
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            x_01 = abs((h(a(1))%f(i) - hmin(a(1)))/L(a(1)))
            y_01 = abs((h(a(2))%f(j) - hmin(a(2)))/L(a(2)))
            xhat_parabolic = ( 1.0_cp - 2.0_cp*x_01 )**2.0_cp
            yhat_parabolic = ( 1.0_cp - 2.0_cp*y_01 )**2.0_cp
            xhat_flip = 1.0_cp - xhat_parabolic
            yhat_flip = 1.0_cp - yhat_parabolic
            xhat = exp( -k_lid*abs(xhat_flip) ) ! abs prevents large ghost BC values
            yhat = exp( -k_lid*abs(yhat_flip) ) ! abs prevents large ghost BC values
            U%f(i_p,j_p,k_p) = ((1.0_cp - xhat)**2.0_cp)*((1.0_cp - yhat)**2.0_cp)
          enddo
          enddo
          enddo
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine fully_developed_duct_velocity(U,g,DL,dir,posNeg)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          type(array),dimension(3) :: h
          integer,intent(in) :: dir,posNeg
          integer :: i,j,i_p,j_p,k_p
          real(cp) :: alpha,height,width,F,A,A1,A2,A3
          integer :: p,n,m,nMax,mMax
          integer,dimension(3) :: s,e
          integer,dimension(2) :: d
          ! For max number of iterations in
          ! infinite series solution:
          nMax = 100; mMax = 100
          F = 1.0_cp
          s = get_shape(g,DL)
          d = adj_dir_given_dir(dir)
          e = eye_given_dir(dir)
          call get_coordinates_h(h,g,DL)
          width  = (g%c(d(1))%hmax - g%c(d(1))%hmin)/2.0_cp
          height = (g%c(d(2))%hmax - g%c(d(2))%hmin)/2.0_cp
          alpha = width/height
          do p=1,s(dir)
          do m=1,mMax; do n=1,nMax
          do j=2,s(d(2))-1; do i=2,s(d(1))-1
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            A1 = 16.0_cp*F*alpha**2.0_cp*height**2.0_cp/&
            ((real(m,cp)*PI)**2.0_cp+(alpha*real(n,cp)*PI)**2.0_cp)
            A2 = 1.0_cp/(real(m,cp)*PI)*1.0_cp/(real(n,cp)*PI)
            A3 = (1.0_cp-cos(real(m,cp)*PI))*(1.0_cp-cos(real(n,cp)*PI))
            A = A1*A2*A3
            U%f(i_p,j_p,k_p) = U%f(i_p,j_p,k_p) + &
            A*sin(real(m,cp)*PI*(h(d(1))%f(i)-g%c(d(1))%hmin)/(2.0_cp*width))*&
              sin(real(n,cp)*PI*(h(d(2))%f(j)-g%c(d(2))%hmin)/(2.0_cp*height))
          enddo; enddo
          enddo; enddo
          enddo
          if (posNeg.eq.-1) call multiply(U,-1.0_cp)
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine isolated_2D_eddy(U,V,DL_U,DL_V,g,dir,vsign)
          ! From
          !      Weiss, N. O. The Expulsion of Magnetic Flux
          !      by Eddies. Proc. R. Soc. A Math. Phys. Eng.
          !      Sci. 293, 310–328 (1966).
          !
          ! Computes
          !           U = curl(psi)
          ! Where
          !           psi = (-1/(2 pi)) cos(2 pi x) cos(2 pi y)
          !           u = dpsi/dy
          !           v =-dpsi/dx
          ! Computes
          !       u = dpsi/dx_1 = k cos(2 pi x_1) sin(2 pi y_2)
          !       v = dpsi/dx_2 = k sin(2 pi x_1) cos(2 pi y_2)
          implicit none
          type(grid_field),intent(inout) :: U,V
          type(data_location),intent(in) :: DL_U,DL_V
          type(grid),intent(in) :: g
          integer,intent(in) :: dir,vsign
          type(array),dimension(3) :: h
          integer :: i,j,p,i_p,j_p,k_p
          integer,dimension(3) :: s,e
          integer,dimension(2) :: d
          real(cp) :: two
          two = 2.0_cp
          d = adj_dir_given_dir(dir)
          e = eye_given_dir(dir)
          call assign(U,0.0_cp)
          call assign(V,0.0_cp)
          call get_coordinates_h(h,g,DL_U)
          s = get_shape(g,DL_U)
          do p=1,s(dir)
          do j=2,s(d(2))-1; do i=2,s(d(1))-1
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            U%f(i_p,j_p,k_p) = cos(two*PI*h(d(1))%f(i))*sin(two*PI*h(d(2))%f(j))
          enddo; enddo
          enddo
          call get_coordinates_h(h,g,DL_V)
          s = get_shape(g,DL_V)
          do p=1,s(dir)
          do j=2,s(d(2))-1; do i=2,s(d(1))-1
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            V%f(i_p,j_p,k_p) =-sin(two*PI*h(d(1))%f(i))*cos(two*PI*h(d(2))%f(j))
          enddo; enddo
          enddo
          if (vsign.eq.-1) then
            call multiply(U,-1.0_cp)
            call multiply(V,-1.0_cp)
          endif
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine single_2D_eddy(U,V,g,DL_U,DL_V,dir,vsign)
          ! From
          !      Weiss, N. O. The Expulsion of Magnetic Flux
          !      by Eddies. Proc. R. Soc. A Math. Phys. Eng.
          !      Sci. 293, 310–328 (1966).
          !
          ! Computes
          !           U = curl(psi)
          ! Where
          !           psi = (-1/pi) (1-4 y^2)^4 cos(pi x)
          !           u = dpsi/dy = (-1/pi) cos(pi x) 4 (1-4 y^2)^3(-8y)
          !                       = (32y/pi) cos(pi x) (1-4 y^2)^3
          !           v =-dpsi/dx = (1-4 y^2)^4 sin(pi x)
          !           w = 0
          ! Computes
          !       u = dpsi/dy =   (32y/pi) cos(pi x) (1-4 y^2)^3
          !       v =-dpsi/dx = - (1-4 y^2)^4 sin(pi x)
          implicit none
          type(grid_field),intent(inout) :: U,V
          type(data_location),intent(in) :: DL_U,DL_V
          type(grid),intent(in) :: g
          integer,intent(in) :: dir,vsign
          type(array),dimension(3) :: h
          integer :: i,j,p,i_p,j_p,k_p
          integer,dimension(3) :: s,e
          integer,dimension(2) :: d
          real(cp) :: one,two,three,four
          d = adj_dir_given_dir(dir)
          e = eye_given_dir(dir)
          call assign(U,0.0_cp)
          call assign(V,0.0_cp)
          one = 1.0_cp;   two = 2.0_cp
          three = 3.0_cp; four = 4.0_cp
          s = get_shape(g,DL_U)
          call get_coordinates_h(h,g,DL_U)
          do p=1,s(dir)
          do j=2,s(d(2))-1; do i=2,s(d(1))-1
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            u%f(i_p,j_p,k_p)=(32.0_cp*h(d(2))%f(j)/PI)*((one-four*h(d(2))%f(j)**two)**three)*cos(PI*h(d(1))%f(i))
          enddo;enddo
          enddo
          s = get_shape(g,DL_V)
          call get_coordinates_h(h,g,DL_V)
          do p=1,s(dir)
          do j=2,s(d(2))-1; do i=2,s(d(1))-1
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            v%f(i_p,j_p,k_p) = - ((one-four*h(d(2))%f(j)**two)**four)*sin(PI*h(d(1))%f(i))
          enddo;enddo
          enddo
          if (vsign.eq.-1) then
            call multiply(U,-1.0_cp)
            call multiply(V,-1.0_cp)
          endif
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine cylinder_2D_velocity(U,V,g,DL_U,DL_V,dir,vsign)
          ! From
          !      Weiss, N. O. The Expulsion of Magnetic Flux
          !      by Eddies. Proc. R. Soc. A Math. Phys. Eng.
          !      Sci. 293, 310–328 (1966).
          !
          ! Computes
          !           U = curl(psi)
          ! Where
          !           psi = (-1/pi) (1-4 y^2)^4 cos(pi x)
          !           u = dpsi/dy = (-1/pi) cos(pi x) 4 (1-4 y^2)^3(-8y)
          !                       = (32y/pi) cos(pi x) (1-4 y^2)^3
          !           v =-dpsi/dx = (1-4 y^2)^4 sin(pi x)
          !           w = 0
          ! Computes
          !       u = dpsi/dy =   (32y/pi) cos(pi x) (1-4 y^2)^3
          !       v =-dpsi/dx = - (1-4 y^2)^4 sin(pi x)
          implicit none
          type(grid_field),intent(inout) :: U,V
          type(data_location),intent(in) :: DL_U,DL_V
          type(grid),intent(in) :: g
          integer,intent(in) :: dir,vsign
          type(array),dimension(3) :: h
          integer :: i,j,p,i_p,j_p,k_p
          integer,dimension(3) :: s,e
          integer,dimension(2) :: d
          real(cp),dimension(3) :: hc
          real(cp) :: r,theta,r0,two,omega0
          d = adj_dir_given_dir(dir)
          e = eye_given_dir(dir)
          two = 2.0_cp
          omega0 = 1.0_cp
          r0 = 1.0_cp
          call assign(U,0.0_cp)
          call assign(V,0.0_cp)
          hc = (/((g%c(i)%hmax+g%c(i)%hmin)/2.0_cp,i=1,3)/)
          s = get_shape(g,DL_U)
          call get_coordinates_h(h,g,DL_U)
          do p=1,s(dir); do j=2,s(d(2))-1; do i=2,s(d(1))-1
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            r = sqrt((h(d(1))%f(i)-hc(d(1)))**two + (h(d(2))%f(j)-hc(d(2)))**two)
            theta = atan2(h(d(2))%f(j),h(d(1))%f(i))
            if (r.lt.r0) u%f(i_p,j_p,k_p) =-omega0*r*sin(theta)
          enddo;enddo; enddo
          s = get_shape(g,DL_V)
          call get_coordinates_h(h,g,DL_V)
          do p=1,s(dir); do j=2,s(d(2))-1; do i=2,s(d(1))-1
            i_p = e(1)*p + i*(1-e(1))
            j_p = e(2)*p + (i*(1-e(3)) + j*(1-e(1)))*(1-e(2))
            k_p = e(3)*p + j*(1-e(3))
            r = sqrt((h(d(1))%f(i)-hc(d(1)))**two + (h(d(2))%f(j)-hc(d(2)))**two)
            theta = atan2(h(d(2))%f(j),h(d(1))%f(i))
            if (r.lt.r0) v%f(i_p,j_p,k_p) = omega0*r*cos(theta)
          enddo;enddo; enddo
          if (vsign.eq.-1) then
            call multiply(U,-1.0_cp)
            call multiply(V,-1.0_cp)
          endif
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine parabolic_1D_GF(U,g,DL,dir)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          integer,intent(in) :: dir
          type(array),dimension(3) :: h
          integer :: i
          real(cp) :: temp
          call assign(U,0.0_cp)
          call get_coordinates_h(h,g,DL)
          do i=1,h(dir)%N
            temp = 0.5_cp*(1.0_cp - h(dir)%f(i)**2.0_cp)
            call assign_plane(U,temp,i,dir)
          enddo
          do i=1,3; call delete(h(i)); enddo
        end subroutine

        subroutine random_noise_GF(f)
          implicit none
          type(grid_field),intent(inout) :: f
          integer :: i,j,k
          real(cp) :: r
#ifdef _PARALLELIZE_GF_
          !$OMP PARALLEL DO PRIVATE(r)

#endif
          do k=1,f%s(3); do j=1,f%s(2); do i=1,f%s(1)
          call random_number(r)
          f%f(i,j,k) = r
          enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_
          !$OMP END PARALLEL DO

#endif
        end subroutine

        subroutine random_noise_GF_dir(f,dir)
          implicit none
          type(grid_field),intent(inout) :: f
          integer,intent(in) :: dir
          real(cp) :: r
          integer :: i,j,k
          select case(dir)
          case (1)
            do i=1,f%s(1)
            call random_number(r)
            f%f(i,:,:) = r
            enddo
          case (2)
            do j=1,f%s(2)
            call random_number(r)
            f%f(:,j,:) = r
            enddo
          case (3)
            do k=1,f%s(3)
            call random_number(r)
            f%f(:,:,k) = r
            enddo
          end select
        end subroutine

        subroutine Taylor_Green_Vortex_U_GF(U,g,DL,Re,t)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          real(cp),intent(in) :: Re,t
          type(array),dimension(3) :: h
          real(cp) :: F,nu
          integer :: i,j,k
          nu = 1.0_cp/Re
          F = exp(-2.0_cp*nu*t)
          call get_coordinates_h(h,g,DL)
          do k=1,U%s(3); do j=1,U%s(2); do i=1,U%s(1)
          U%f(i,j,k) = cos(h(1)%f(i))*sin(h(2)%f(j))*F
          enddo; enddo; enddo
          do i=1,3; call delete(h(i)); enddo
        end subroutine
        subroutine Taylor_Green_Vortex_V_GF(V,g,DL,Re,t)
          implicit none
          type(grid_field),intent(inout) :: V
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          real(cp),intent(in) :: Re,t
          type(array),dimension(3) :: h
          real(cp) :: F,nu
          integer :: i,j,k
          nu = 1.0_cp/Re
          F = exp(-2.0_cp*nu*t)
          call get_coordinates_h(h,g,DL)
          do k=1,V%s(3); do j=1,V%s(2); do i=1,V%s(1)
          V%f(i,j,k) = -sin(h(1)%f(i))*cos(h(2)%f(j))*F
          enddo; enddo; enddo
          do i=1,3; call delete(h(i)); enddo
        end subroutine
        subroutine Taylor_Green_Vortex_P_GF(P,g,DL,Re,t)
          implicit none
          type(grid_field),intent(inout) :: P
          type(grid),intent(in) :: g
          type(data_location),intent(in) :: DL
          real(cp),intent(in) :: Re,t
          type(array),dimension(3) :: h
          real(cp) :: F,nu
          integer :: i,j,k
          nu = 1.0_cp/Re
          F = exp(-2.0_cp*nu*t)
          call get_coordinates_h(h,g,DL)
          do k=1,P%s(3); do j=1,P%s(2); do i=1,P%s(1)
          P%f(i,j,k) = - 0.25_cp*( cos(2.0_cp*h(1)%f(i))+cos(2.0_cp*h(2)%f(j)) ) * F*F
          enddo; enddo; enddo
          do i=1,3; call delete(h(i)); enddo
        end subroutine

      end module
      module GF_mirror_about_plane_mod
        use current_precision_mod
        use grid_field_mod
        use grid_field_extend_mod
        use GF_add_mod
        use GF_aux_mod
        use GF_multiply_mod
        use GF_assign_mod
        use GF_assign_plane_mod
        use GF_multiply_plane_mod
        use grid_mod

        implicit none
        private

        public :: mirror_about_hmin,mirror_about_hmax
        interface mirror_about_hmin;  module procedure mirror_about_hmin_GF; end interface
        interface mirror_about_hmax;  module procedure mirror_about_hmax_GF; end interface

        interface mirror_about_xmin;  module procedure mirror_about_xmin_GF; end interface
        interface mirror_about_ymin;  module procedure mirror_about_ymin_GF; end interface
        interface mirror_about_zmin;  module procedure mirror_about_zmin_GF; end interface

        interface mirror_about_xmax;  module procedure mirror_about_xmax_GF; end interface
        interface mirror_about_ymax;  module procedure mirror_about_ymax_GF; end interface
        interface mirror_about_zmax;  module procedure mirror_about_zmax_GF; end interface

        contains

        subroutine mirror_about_hmin_GF(U,dir,mirror_sign,N_along_dir)
          implicit none
          type(grid_field),intent(inout) :: U
          integer,intent(in) :: dir,N_along_dir
          real(cp),intent(in) :: mirror_sign
          select case (dir)
          case (1); call mirror_about_xmin(U,mirror_sign,N_along_dir)
          case (2); call mirror_about_ymin(U,mirror_sign,N_along_dir)
          case (3); call mirror_about_zmin(U,mirror_sign,N_along_dir)
          case default
          write(*,*) 'Error: bad dir in mirror_about_hmin_GF in GF_mirror_about_plane.f90'
          stop 'Done'
          end select
        end subroutine

        subroutine mirror_about_hmax_GF(U,dir,mirror_sign,N_along_dir)
          implicit none
          type(grid_field),intent(inout) :: U
          integer,intent(in) :: dir,N_along_dir
          real(cp),intent(in) :: mirror_sign
          select case (dir)
          case (1); call mirror_about_xmax(U,mirror_sign,N_along_dir)
          case (2); call mirror_about_ymax(U,mirror_sign,N_along_dir)
          case (3); call mirror_about_zmax(U,mirror_sign,N_along_dir)
          case default
          write(*,*) 'Error: bad dir in mirror_about_hmin_GF in GF_mirror_about_plane.f90'
          stop 'Done'
          end select
        end subroutine

        ! *************************************************************
        ! *************************************************************
        ! *************************************************************

        subroutine mirror_about_xmin_GF(U,mirror_sign,N_along_dir)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: mirror_sign
          integer,intent(in) :: N_along_dir
          type(grid_field) :: temp
          integer :: i,i_reverse,i_temp
          call init(temp,(/2*U%s(1)-2-N_along_dir,U%s(2),U%s(3)/))
          do i=1,U%s(1)
            i_reverse = U%s(1)-i+1
            i_temp = temp%s(1)-i+1
            call assign_plane_x(temp,U,i_temp,i_reverse)
          enddo
          do i=1+N_along_dir,U%s(1)
            i_reverse = U%s(1)-i+1
            call assign_plane_x(temp,U,i,i_reverse)
            call multiply_plane_x(temp,mirror_sign,i)
          enddo
          call init(U,temp)
          call assign(U,temp)
        end subroutine

        subroutine mirror_about_ymin_GF(U,mirror_sign,N_along_dir)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: mirror_sign
          integer,intent(in) :: N_along_dir
          type(grid_field) :: temp
          integer :: i,i_reverse,i_temp
          call init(temp,(/U%s(1),2*U%s(2)-2-N_along_dir,U%s(3)/))
          do i=1,U%s(2)
            i_reverse = U%s(2)-i+1
            i_temp = temp%s(2)-i+1
            call assign_plane_y(temp,U,i_temp,i_reverse)
          enddo
          do i=1+N_along_dir,U%s(2)
            i_reverse = U%s(2)-i+1
            call assign_plane_y(temp,U,i,i_reverse)
            call multiply_plane_y(temp,mirror_sign,i)
          enddo
          call init(U,temp)
          call assign(U,temp)
        end subroutine

        subroutine mirror_about_zmin_GF(U,mirror_sign,N_along_dir)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: mirror_sign
          integer,intent(in) :: N_along_dir
          type(grid_field) :: temp
          integer :: i,i_reverse,i_temp
          call init(temp,(/U%s(1),U%s(2),2*U%s(3)-2-N_along_dir/))
          do i=1,U%s(3)
            i_reverse = U%s(3)-i+1
            i_temp = temp%s(3)-i+1
            call assign_plane_z(temp,U,i_temp,i_reverse)
          enddo
          do i=1+N_along_dir,U%s(3)
            i_reverse = U%s(3)-i+1
            call assign_plane_z(temp,U,i,i_reverse)
            call multiply_plane_z(temp,mirror_sign,i)
          enddo
          call init(U,temp)
          call assign(U,temp)
        end subroutine

        subroutine mirror_about_xmax_GF(U,mirror_sign,N_along_dir)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: mirror_sign
          integer,intent(in) :: N_along_dir
          type(grid_field) :: temp
          integer :: i,i_reverse,i_temp
          call init(temp,(/2*U%s(1)-2-N_along_dir,U%s(2),U%s(3)/))
          do i=1,U%s(1)
            call assign_plane_x(temp,U,i,i)
          enddo
          do i=1,U%s(1)-N_along_dir
            i_reverse = U%s(1)-i+1
            i_temp = temp%s(1)-i+1
            call assign_plane_x(temp,U,i_temp,i)
            call multiply_plane_x(temp,mirror_sign,i_temp)
          enddo
          call init(U,temp)
          call assign(U,temp)
        end subroutine

        subroutine mirror_about_ymax_GF(U,mirror_sign,N_along_dir)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: mirror_sign
          integer,intent(in) :: N_along_dir
          type(grid_field) :: temp
          integer :: i,i_reverse,i_temp
          call init(temp,(/U%s(1),2*U%s(2)-2-N_along_dir,U%s(3)/))
          do i=1,U%s(2)
            call assign_plane_y(temp,U,i,i)
          enddo
          do i=1,U%s(2)-N_along_dir
            i_reverse = U%s(2)-i+1
            i_temp = temp%s(2)-i+1
            call assign_plane_y(temp,U,i_temp,i)
            call multiply_plane_y(temp,mirror_sign,i_temp)
          enddo
          call init(U,temp)
          call assign(U,temp)
        end subroutine

        subroutine mirror_about_zmax_GF(U,mirror_sign,N_along_dir)
          implicit none
          type(grid_field),intent(inout) :: U
          real(cp),intent(in) :: mirror_sign
          integer,intent(in) :: N_along_dir
          type(grid_field) :: temp
          integer :: i,i_reverse,i_temp
          call init(temp,(/U%s(1),U%s(2),2*U%s(3)-2-N_along_dir/))
          do i=1,U%s(3)
            call assign_plane_z(temp,U,i,i)
          enddo
          do i=1,U%s(3)-N_along_dir
            i_reverse = U%s(3)-i+1
            i_temp = temp%s(3)-i+1
            call assign_plane_z(temp,U,i_temp,i)
            call multiply_plane_z(temp,mirror_sign,i_temp)
          enddo
          call init(U,temp)
          call assign(U,temp)
        end subroutine

      end module
       module GF_norms_mod
       use current_precision_mod
       use grid_field_mod
       use grid_field_extend_mod
       use GF_aux_mod
       use grid_mod
       implicit none

       private
       public :: compute_Ln_norm
       public :: compute_Linf_norm

       ! Interfaces:
       ! Ln(e,u,n) = L(n) = ΣΣΣ u(i,j,k)ⁿ
       ! Linf(e,u) = L(∞) = max(abs(u))

       interface compute_Ln_norm;    module procedure Ln_GF_1; end interface
       interface compute_Ln_norm;    module procedure Ln_GF_3; end interface
       interface compute_Ln_norm;    module procedure Ln_GF_9; end interface
       interface compute_Linf_norm;  module procedure Linf_GF; end interface

       contains

       subroutine Ln_GF_1(e,u,n)
         implicit none
         real(cp),intent(inout) :: e
         type(grid_field),intent(in) :: u
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: i,j,k
         temp = 0.0_cp
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP PARALLEL DO REDUCTION(+:temp)

#endif
         do k=1,U%s(3); do j=1,U%s(2); do i=1,U%s(1)
           temp = temp + U%f(i,j,k)**n
         enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP END PARALLEL DO

#endif
         e = temp
       end subroutine

       subroutine Ln_GF_3(e,u_x,u_y,u_z,n)
         implicit none
         real(cp),intent(inout) :: e
         type(grid_field),intent(in) :: u_x,u_y,u_z
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: i,j,k
         temp = 0.0_cp
#ifdef _DEBUG_GF_NORMS_
         call insist_shape_match(u_x,u_y,'Ln_GF_3 (1)')
         call insist_shape_match(u_x,u_z,'Ln_GF_3 (2)')
#endif

#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP PARALLEL DO REDUCTION(+:temp)

#endif
         do k=1,u_x%s(3); do j=1,u_x%s(2); do i=1,u_x%s(1)
           temp = temp + u_x%f(i,j,k)**n+&
                         u_y%f(i,j,k)**n+&
                         u_z%f(i,j,k)**n
         enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP END PARALLEL DO

#endif
         e = temp
       end subroutine

       subroutine Ln_GF_9(e,u_xx,u_xy,u_xz,u_yx,u_yy,u_yz,u_zx,u_zy,u_zz,n)
         implicit none
         real(cp),intent(inout) :: e
         type(grid_field),intent(in) :: u_xx,u_xy,u_xz,u_yx,u_yy,u_yz,u_zx,u_zy,u_zz
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: i,j,k
         temp = 0.0_cp
#ifdef _DEBUG_GF_NORMS_
         call insist_shape_match(u_xx,u_xy,'Ln_GF_9 (1)')
         call insist_shape_match(u_xx,u_xy,'Ln_GF_9 (2)')
         call insist_shape_match(u_xx,u_xz,'Ln_GF_9 (3)')
         call insist_shape_match(u_xx,u_yx,'Ln_GF_9 (4)')
         call insist_shape_match(u_xx,u_yy,'Ln_GF_9 (5)')
         call insist_shape_match(u_xx,u_yz,'Ln_GF_9 (6)')
         call insist_shape_match(u_xx,u_zx,'Ln_GF_9 (7)')
         call insist_shape_match(u_xx,u_zy,'Ln_GF_9 (8)')
         call insist_shape_match(u_xx,u_zz,'Ln_GF_9 (9)')
#endif

#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP PARALLEL DO REDUCTION(+:temp)

#endif
         do k=1,u_xx%s(3); do j=1,u_xx%s(2); do i=1,u_xx%s(1)
           temp = temp + &
           u_xx%f(i,j,k)**n+&
           u_xy%f(i,j,k)**n+&
           u_xy%f(i,j,k)**n+&
           u_xz%f(i,j,k)**n+&
           u_yx%f(i,j,k)**n+&
           u_yy%f(i,j,k)**n+&
           u_yz%f(i,j,k)**n+&
           u_zx%f(i,j,k)**n+&
           u_zy%f(i,j,k)**n+&
           u_zz%f(i,j,k)**n
         enddo; enddo; enddo
#ifdef _PARALLELIZE_GF_NORMS_
         !$OMP END PARALLEL DO

#endif
         e = temp
       end subroutine

       subroutine Linf_GF(e,u)
         implicit none
         real(cp),intent(inout) :: e
         type(grid_field),intent(in) :: u
         e = amax(u)
       end subroutine

       end module
      module GF_symmetry_error_mod
        use current_precision_mod
        use even_odd_mod
        use grid_field_mod
        use GF_add_mod
        use GF_aux_mod
        use GF_multiply_mod
        use GF_assign_mod
        use GF_assign_plane_mod
        use GF_plane_sum_mod
        use grid_mod
        implicit none

        private
        public :: symmetry_error_x
        public :: symmetry_error_y
        public :: symmetry_error_z
        public :: symmetry_local_x
        public :: symmetry_local_y
        public :: symmetry_local_z

        interface symmetry_error_x;  module procedure symmetry_error_x_GF; end interface
        interface symmetry_error_y;  module procedure symmetry_error_y_GF; end interface
        interface symmetry_error_z;  module procedure symmetry_error_z_GF; end interface

        interface symmetry_local_x;  module procedure symmetry_local_x_GF; end interface
        interface symmetry_local_y;  module procedure symmetry_local_y_GF; end interface
        interface symmetry_local_z;  module procedure symmetry_local_z_GF; end interface

        contains

        ! *******************************************************************
        ! *******************************************************************
        ! *******************************************************************

        function symmetry_error_x_GF(U) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          type(grid_field) :: temp
          real(cp) :: F
          call init(temp,U)
          call assign(temp,U)
          call symmetry_local_x(temp)
          F = amax(temp)
          call delete(temp)
        end function

        function symmetry_error_y_GF(U) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          type(grid_field) :: temp
          real(cp) :: F
          call init(temp,U)
          call assign(temp,U)
          call symmetry_local_y(temp)
          F = amax(temp)
          call delete(temp)
        end function

        function symmetry_error_z_GF(U) result(F)
          implicit none
          type(grid_field),intent(in) :: U
          type(grid_field) :: temp
          real(cp) :: F
          call init(temp,U)
          call assign(temp,U)
          call symmetry_local_z(temp)
          F = amax(temp)
          call delete(temp)
        end function

        ! ********************************************************************
        ! ********************************************************************
        ! ********************************************************************

        subroutine symmetry_local_x_GF(U)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid_field) :: temp
          integer :: i
          call init(temp,U)
          do i=1,U%s(1); call assign_plane_x(temp,U,i,U%s(1)-i+1); enddo
          call multiply(temp,-1.0_cp)
          call add(U,temp)
          call delete(temp)
        end subroutine

        subroutine symmetry_local_y_GF(U)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid_field) :: temp
          integer :: i
          call init(temp,U)
          do i=1,U%s(2); call assign_plane_y(temp,U,i,U%s(2)-i+1); enddo
          call multiply(temp,-1.0_cp)
          call add(U,temp)
          call delete(temp)
        end subroutine

        subroutine symmetry_local_z_GF(U)
          implicit none
          type(grid_field),intent(inout) :: U
          type(grid_field) :: temp
          integer :: i
          call init(temp,U)
          do i=1,U%s(3); call assign_plane_z(temp,U,i,U%s(3)-i+1); enddo
          call multiply(temp,-1.0_cp)
          call add(U,temp)
          call delete(temp)
        end subroutine

      end module
     module sim_params_extend_mod
     use sim_params_mod
     use sim_params_aux_mod
     use sim_params_init_mesh_mod
     use sim_params_init_solver_config_mod
     use sim_params_init_flow_config_mod
     use sim_params_init_export_mod
     use sim_params_init_logicals_mod
     use sim_params_init_DPs_mod
     implicit none

     private
     public :: sim_params
     public :: init

     interface init; module procedure init_SP; end interface

     contains

     subroutine init_SP(SP)
       implicit none
       type(sim_params),intent(inout) :: SP
       call delete(SP)
       call sim_params_init_logicals(SP)
       call sim_params_init_mesh(SP)
       call sim_params_init_DPs(SP)
       call sim_params_init_export(SP)
       call sim_params_init_solver_config(SP)
       call sim_params_init_flow_config(SP)
       call post_process(SP)
     end subroutine

     end module
       module single_procedure_plane_op_extend_mod
       use single_procedure_plane_op_mod
       use IO_tools_mod
       use GF_assign_ghost_mod

       implicit none
       private
       public :: init
       public :: insist_defined

       interface init;           module procedure init_SP;           end interface
       interface insist_defined; module procedure insist_defined_SP; end interface

       contains

       subroutine init_SP(SP,P,ID)
         implicit none
         type(single_procedure_plane_op),intent(inout) :: SP
         procedure(plane_op) :: P
         integer,intent(in) :: ID
         call delete(SP)
         SP%P => P
         SP%ID = ID
         SP%defined = .true.
       end subroutine

       subroutine insist_defined_SP(SP,caller)
         implicit none
         type(single_procedure_plane_op),intent(in) :: SP
         character(len=*),intent(in) :: caller
         if (.not.SP%defined) then
         write(*,*) 'Error: SP is not defined in ',caller,' in single_procedure_plane_op.f90'
         stop 'Done'
         endif
       end subroutine

       end module
      module GF_mod
        use current_precision_mod
        use grid_mod
        use grid_field_mod
        use grid_field_extend_mod
        use GF_assign_mod
        use GF_magnitude_mod
        use GF_add_mod
        use GF_add_product_mod
        use GF_product_add_mod
        use GF_subtract_mod
        use GF_multiply_mod
        use GF_divide_mod
        use GF_aux_mod
        use GF_distributions_mod
        use GF_assign_plane_mod
        use GF_assign_plane_ave_mod
        use GF_add_plane_mod
        use GF_plane_sum_mod
        use GF_symmetry_error_mod
        use GF_assign_ghost_mod
        use GF_assign_ghost_periodic_mod
        use GF_assign_wall_mod
        use GF_multiply_plane_mod
        use GF_cross_product_mod
        use GF_multiply_wall_mod
        use GF_square_mod
        use GF_square_root_mod
        use GF_mean_along_dir_mod
        use GF_mirror_about_plane_mod
        use GF_restrict_mod
        use GF_prolongate_mod
        use GF_CFL_number_mod
        use GF_Fourier_number_mod
        use GF_Robin_BC_coeff_mod
        use GF_amax_diff_mod

        implicit none
        private

        public :: grid_field
        public :: init,delete,display,print,export,import ! Essentials
        public :: print_info
        public :: display_info
        public :: print_physical
        public :: init_CC
        public :: init_Face
        public :: init_Edge
        public :: init_Node

        ! GF_distributions_mod
        public :: inverse_area
        public :: volume
        public :: sine_waves
        public :: sinh_waves
        public :: cosine_waves
        public :: cosh_waves
        public :: random_noise
        public :: fringe_ALEX
        public :: fringe_SERGEY
        public :: smooth_lid
        public :: smooth_lid_Shatrov
        public :: smooth_lid_Leriche
        public :: fully_developed_duct_velocity
        public :: isolated_2D_eddy
        public :: single_2D_eddy
        public :: cylinder_2D_velocity
        public :: parabolic_1D
        public :: Taylor_Green_Vortex_U
        public :: Taylor_Green_Vortex_V
        public :: Taylor_Green_Vortex_P

        ! GF_surface_flux_mod
        public :: plane_sum_x
        public :: plane_sum_y
        public :: plane_sum_z

        ! GF_symmetry_error_mod
        ! GF_assign_plane
        public :: symmetry_error_x,assign_plane_x,add_plane_x,symmetry_local_x
        public :: symmetry_error_y,assign_plane_y,add_plane_y,symmetry_local_y
        public :: symmetry_error_z,assign_plane_z,add_plane_z,symmetry_local_z

        public :: multiply_plane_x,assign_plane_ave_x,assign_plane_ave
        public :: multiply_plane_y,assign_plane_ave_y,assign_plane_ave
        public :: multiply_plane_z,assign_plane_ave_z,assign_plane_ave

        ! GF_assign_mod
        public :: assign,assign_negative
        public :: add,subtract
        public :: multiply,divide
        public :: swap
        public :: add_product
        public :: product_add

        public :: mean_along_x
        public :: mean_along_y
        public :: mean_along_z
        public :: amax_diff

        public :: mirror_about_hmin,mirror_about_hmax

        public :: assign_ghost_all
        public :: multiply_plane
        public :: add_plane
        public :: assign_plane
        public :: assign_ghost_xmin,assign_wall_xmin,multiply_wall_xmin
        public :: assign_ghost_ymin,assign_wall_ymin,multiply_wall_ymin
        public :: assign_ghost_zmin,assign_wall_zmin,multiply_wall_zmin
        public :: assign_ghost_xmax,assign_wall_xmax,multiply_wall_xmax
        public :: assign_ghost_ymax,assign_wall_ymax,multiply_wall_ymax
        public :: assign_ghost_zmax,assign_wall_zmax,multiply_wall_zmax

        public :: assign_ghost_periodic_xmin
        public :: assign_ghost_periodic_ymin
        public :: assign_ghost_periodic_zmin

        public :: assign_ghost_xmin_xmax
        public :: assign_ghost_ymin_ymax
        public :: assign_ghost_zmin_zmax

        ! GF_aux_mod
        public :: abs,insist_amax_lt_tol,square,square_root,min,max,amin,amax
        public :: mean,sum,size
        public :: magnitude

        public :: cross_product_x
        public :: cross_product_y
        public :: cross_product_z

        public :: prolongate_C,restrict_C
        public :: prolongate_N,restrict_N

        public :: CFL_number
        public :: dt_given_CFL_number
        public :: Fourier_number
        public :: Robin_BC_coeff

        public :: insist_allocated
        public :: insist_shape_staggered
        public :: insist_shape_match

      end module
       module procedure_array_plane_op_extend_mod
       use procedure_array_plane_op_mod
       use IO_tools_mod
       use single_procedure_plane_op_mod
       use single_procedure_plane_op_extend_mod
       use GF_assign_ghost_mod

       implicit none
       private
       public :: init
       public :: add,remove,check_unique,sort

       interface init;             module procedure init_PA;             end interface
       interface add;              module procedure add_PA;              end interface
       interface add;              module procedure add_PA_SP;           end interface
       interface remove;           module procedure remove_PA;           end interface
       interface check_unique;     module procedure check_unique_PA;     end interface
       interface sort;             module procedure sort_PA;             end interface

       contains

       subroutine init_PA(PA,N)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: PA
         integer,intent(in) :: N
         call delete(PA)
         if (N.lt.1) stop 'Error: N must > 1 in init_PA in procedure_array_plane_op.f90'
         allocate(PA%SP(N))
         PA%N = N
         PA%defined = .false.
       end subroutine

       ! *****************************************************************
       ! ***************************** OTHER *****************************
       ! *****************************************************************

       subroutine add_PA(PA,P,ID)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: PA
         procedure(plane_op) :: P
         integer,intent(in) :: ID
         type(procedure_array_plane_op) :: temp
         integer :: i
         if (PA%defined) then
           call init(temp,PA)
           call init(PA,temp%N+1)
           do i=1,temp%N; call init(PA%SP(i),temp%SP(i)); enddo
           i = PA%N
           call init(PA%SP(i),P,ID)
           call delete(temp)
         else
           call init(PA,1)
           call init(PA%SP(1),P,ID)
         endif
         PA%defined = .true.
       end subroutine

       subroutine add_PA_SP(PA,SP)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: PA
         type(single_procedure_plane_op),intent(in) :: SP
         call add(PA,SP%P,SP%ID)
       end subroutine

       subroutine remove_PA(PA,ID)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: PA
         integer,intent(in) :: ID
         type(procedure_array_plane_op) :: temp
         integer :: i
         if (PA%defined) then
           call delete(temp)
           do i=1,PA%N
             if (PA%SP(i)%ID.ne.ID) call add(temp,PA%SP(i))
           enddo
           call init(PA,temp)
           call delete(temp)
         else; call delete(PA)
         endif
       end subroutine

       subroutine check_unique_PA(PA,caller)
         implicit none
         type(procedure_array_plane_op),intent(in) :: PA
         character(len=*),intent(in) :: caller
         integer :: i,j,violating_ID
         logical :: unique_set
         unique_set = .true.; violating_ID = 0
         do i=1,PA%N; do j=i,PA%N
         if (i.ne.j) then
         if (PA%SP(i)%ID.eq.PA%SP(j)%ID) then
           unique_set = .false.
           violating_ID = i
         endif
         endif
         enddo; enddo
         if (.not.unique_set) then
           write(*,*) 'Error: too many BCs in procedure_array_plane_op in ',caller,'in procedure_array_plane_op.f90'
           write(*,*) 'violating_ID = ',violating_ID
           stop 'Done'
         endif
       end subroutine

       subroutine check_unique_array(a,N,caller)
         implicit none
         integer,intent(in) :: N
         integer,dimension(N),intent(in) :: a
         character(len=*),intent(in) :: caller
         integer,dimension(N) :: i_order
         logical,dimension(N) :: L
         integer :: i,j,s
         s = size(a)
         if ((N.lt.1).or.(s.ne.N)) then
           write(*,*) 'Error: bad array size in ',caller,' in procedure_array_plane_op.f90'; stop 'Done'
         endif
         i_order = (/(i,i=1,N)/)
         do i=1,N; L(i) = any((/(a(j).eq.i_order(i),j=1,N)/)); enddo
         if (.not.all(L)) then
           write(*,*) 'Error: non-unique array in ',caller,' in procedure_array_plane_op.f90'
           write(*,*) 'N = ',N
           write(*,*) 'a = ',a
           stop 'Done'
         endif
       end subroutine

       subroutine sort_PA(PA,order,N)
         implicit none
         type(procedure_array_plane_op),intent(inout) :: PA
         integer,intent(in) :: N
         integer,dimension(N),intent(in) :: order
         type(procedure_array_plane_op) :: temp
         integer :: i,j
         if ((PA%N.ne.N).or.(size(PA%SP).ne.N)) then
           stop 'Error: bad array size in sort_PA in procedure_array_plane_op.f90'
         endif
         call check_unique(PA,'sort_PA')
         call check_unique_array(order,N,'sort_PA')
         call init(temp,PA)
         call delete(PA)
         do i=1,N; do j=1,N
           if (temp%SP(j)%ID.eq.order(i)) call add(PA,temp%SP(j))
         enddo; enddo
         call delete(temp)
       end subroutine

       end module
       module apply_BCs_faces_bridge_mod
       use current_precision_mod
       use apply_BCs_faces_raw_mod
       use apply_face_BC_op_mod
       use GF_mod
       use face_SD_mod
       use face_SD_extend_mod

       implicit none
       private
       public :: apply_face_BC_op

       public :: Dirichlet_C
       public :: Dirichlet_N
       public :: Neumann_C
       public :: Neumann_N
       public :: Periodic_C
       public :: Periodic_C_prescribed
       public :: Periodic_N
       public :: Periodic_N_prescribed
       public :: Robin_C
       public :: Robin_C_prescribed
       public :: Robin_N
       public :: Symmetric_C
       public :: Symmetric_N
       public :: antisymmetric_C
       public :: antisymmetric_N

       contains

       ! *********************************************************************************
       ! ********************************* DIRICHLET *************************************
       ! *********************************************************************************

       subroutine Dirichlet_C(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Dirichlet_C_GF(GF,surf,&
                               FSD%G(face)%M(1:3)%i2(1),&
                               FSD%G(face)%M(1:3)%i2(2),&
                               FSD%I(face)%M(1:3)%i2(1),&
                               FSD%I(face)%M(1:3)%i2(2),&
                               FSD%i_2D(face)%i,&
                               0)
       end subroutine
       subroutine F_Dirichlet_C_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Dirichlet_C(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                surf%f,&
                                surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Dirichlet_N(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Dirichlet_N_GF(GF,surf,&
                               FSD%G(face)%M(1:3)%i2(1),&
                               FSD%G(face)%M(1:3)%i2(2),&
                               FSD%B(face)%M(1:3)%i2(1),&
                               FSD%B(face)%M(1:3)%i2(2),&
                               FSD%I(face)%M(1:3)%i2(1),&
                               FSD%I(face)%M(1:3)%i2(2),&
                               FSD%i_2D(face)%i,&
                               0)
       end subroutine
       subroutine F_Dirichlet_N_GF(bulk,surf,G1,G2,B1,B2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,B1,B2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Dirichlet_N(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                bulk%f(B1(1):B2(1),B1(2):B2(2),B1(3):B2(3)),&
                                bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                surf%f,&
                                surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       ! *********************************************************************************
       ! *********************************** NEUMANN *************************************
       ! *********************************************************************************

       subroutine Neumann_C(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Neumann_C_GF(GF,surf,&
                             FSD%G(face)%M(1:3)%i2(1),&
                             FSD%G(face)%M(1:3)%i2(2),&
                             FSD%I(face)%M(1:3)%i2(1),&
                             FSD%I(face)%M(1:3)%i2(2),&
                             FSD%i_2D(face)%i,&
                             FSD%dh(face),&
                             FSD%nhat(face),&
                             0)
       end subroutine
       subroutine F_Neumann_C_GF(bulk,surf,G1,G2,I1,I2,iR,dh,nhat,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         real(cp),intent(in) :: dh,nhat
         integer,intent(in) :: p
         call apply_Neumann_C(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                              bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                              surf%f,&
                              dh*nhat,surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Neumann_N(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Neumann_N_GF(GF,surf,&
                             FSD%G(face)%M(1:3)%i2(1),&
                             FSD%G(face)%M(1:3)%i2(2),&
                             FSD%I(face)%M(1:3)%i2(1),&
                             FSD%I(face)%M(1:3)%i2(2),&
                             FSD%i_2D(face)%i,&
                             FSD%dh(face),&
                             FSD%nhat(face),&
                             0)
       end subroutine
       subroutine F_Neumann_N_GF(bulk,surf,G1,G2,I1,I2,iR,dh,nhat,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         real(cp),intent(in) :: dh,nhat
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Neumann_N(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                              bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                              surf%f,&
                              dh*nhat,surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       ! *********************************************************************************
       ! ********************************** PERIODIC *************************************
       ! *********************************************************************************

       subroutine Periodic_C(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Periodic_C_GF(GF,surf,&
                              FSD%G(face)%M(1:3)%i2(1),&
                              FSD%G(face)%M(1:3)%i2(2),&
                              FSD%I_OPP(face)%M(1:3)%i2(1),&
                              FSD%I_OPP(face)%M(1:3)%i2(2),&
                              FSD%i_2D(face)%i,&
                              0)
       end subroutine
       subroutine F_Periodic_C_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         ! apply_Periodic_C(ug,ui_opp,x,y,p)
         call apply_Periodic_C(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                               bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                               surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Periodic_C_prescribed(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Periodic_C_prescribed_GF(GF,surf,&
                                         FSD%G(face)%M(1:3)%i2(1),&
                                         FSD%G(face)%M(1:3)%i2(2),&
                                         FSD%i_2D(face)%i,&
                                         0)
       end subroutine
       subroutine F_Periodic_C_prescribed_GF(bulk,surf,G1,G2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         ! apply_Periodic_C(ug,ui_opp,x,y,p)
         call apply_Periodic_C(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                               surf%f,&
                               surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Periodic_N(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Periodic_N_GF(GF,surf,&
                              FSD%G_periodic_N(face)%M(1:3)%i2(1),&
                              FSD%G_periodic_N(face)%M(1:3)%i2(2),&
                              FSD%I_OPP_periodic_N(face)%M(1:3)%i2(1),&
                              FSD%I_OPP_periodic_N(face)%M(1:3)%i2(2),&
                              FSD%i_2D(face)%i,&
                              0)
       end subroutine
       subroutine F_Periodic_N_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Periodic_N(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                               bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                               surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Periodic_N_prescribed(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Periodic_N_prescribed_GF(GF,surf,&
                                         FSD%G(face)%M(1:3)%i2(1),&
                                         FSD%G(face)%M(1:3)%i2(2),&
                                         FSD%i_2D(face)%i,&
                                         0)
       end subroutine
       subroutine F_Periodic_N_prescribed_GF(bulk,surf,G1,G2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Periodic_N(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                               surf%f,&
                               surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       ! *********************************************************************************
       ! ************************************ ROBIN **************************************
       ! *********************************************************************************

       subroutine Robin_C(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Robin_C_GF(GF,surf,&
                           FSD%G(face)%M(1:3)%i2(1),&
                           FSD%G(face)%M(1:3)%i2(2),&
                           FSD%I(face)%M(1:3)%i2(1),&
                           FSD%I(face)%M(1:3)%i2(2),&
                           FSD%i_2D(face)%i,&
                           FSD%dh(face),&
                           FSD%nhat(face),&
                           FSD%c_w(face),&
                           0)
       end subroutine
       subroutine F_Robin_C_GF(bulk,surf,G1,G2,I1,I2,iR,dh,nhat,c_w,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         real(cp),intent(in) :: dh,nhat,c_w
         integer,intent(in) :: p
         call apply_Robin_C(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                            bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                            surf%f,&
                            dh,nhat,c_w,surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Robin_C_prescribed(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Robin_C_prescribed_GF(GF,surf,&
                           FSD%G(face)%M(1:3)%i2(1),&
                           FSD%G(face)%M(1:3)%i2(2),&
                           FSD%i_2D(face)%i,&
                           0)
       end subroutine
       subroutine F_Robin_C_prescribed_GF(bulk,surf,G1,G2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_assign(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                           surf%f,&
                           surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Robin_N(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Robin_N_GF(GF,surf,&
                           FSD%G(face)%M(1:3)%i2(1),&
                           FSD%G(face)%M(1:3)%i2(2),&
                           FSD%I(face)%M(1:3)%i2(1),&
                           FSD%I(face)%M(1:3)%i2(2),&
                           FSD%B(face)%M(1:3)%i2(1),&
                           FSD%B(face)%M(1:3)%i2(2),&
                           FSD%i_2D(face)%i,&
                           FSD%dh(face),&
                           FSD%nhat(face),&
                           FSD%c_w(face),&
                           0)
       end subroutine
       subroutine F_Robin_N_GF(bulk,surf,G1,G2,I1,I2,B1,B2,iR,dh,nhat,c_w,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2,B1,B2
         integer,dimension(2),intent(in) :: iR
         real(cp),intent(in) :: dh,nhat,c_w
         integer,intent(in) :: p
         call apply_Robin_N(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                            bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                            bulk%f(B1(1):B2(1),B1(2):B2(2),B1(3):B2(3)),&
                            surf%f,&
                            dh,nhat,c_w,surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       ! *********************************************************************************
       ! ************************************ SYMMETRIC **********************************
       ! *********************************************************************************

       subroutine Symmetric_C(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Symmetric_C_GF(GF,surf,&
                               FSD%G(face)%M(1:3)%i2(1),&
                               FSD%G(face)%M(1:3)%i2(2),&
                               FSD%I(face)%M(1:3)%i2(1),&
                               FSD%I(face)%M(1:3)%i2(2),&
                               FSD%i_2D(face)%i,&
                               0)
       end subroutine
       subroutine F_Symmetric_C_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Symmetric_C(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Symmetric_N(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Symmetric_N_GF(GF,surf,&
                               FSD%G(face)%M(1:3)%i2(1),&
                               FSD%G(face)%M(1:3)%i2(2),&
                               FSD%I(face)%M(1:3)%i2(1),&
                               FSD%I(face)%M(1:3)%i2(2),&
                               FSD%i_2D(face)%i,&
                               0)
       end subroutine
       subroutine F_Symmetric_N_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Symmetric_N(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       ! *********************************************************************************
       ! ******************************* ANTI-SYMMETRIC **********************************
       ! *********************************************************************************

       subroutine antisymmetric_C(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_antisymmetric_C_GF(GF,surf,&
                                    FSD%G(face)%M(1:3)%i2(1),&
                                    FSD%G(face)%M(1:3)%i2(2),&
                                    FSD%I(face)%M(1:3)%i2(1),&
                                    FSD%I(face)%M(1:3)%i2(2),&
                                    FSD%i_2D(face)%i,&
                                    0)
       end subroutine
       subroutine F_antisymmetric_C_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_antisymmetric_C(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                     bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                     surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine antisymmetric_N(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_antisymmetric_N_GF(GF,surf,&
                                    FSD%G(face)%M(1:3)%i2(1),&
                                    FSD%G(face)%M(1:3)%i2(2),&
                                    FSD%I(face)%M(1:3)%i2(1),&
                                    FSD%I(face)%M(1:3)%i2(2),&
                                    FSD%i_2D(face)%i,&
                                    0)
       end subroutine
       subroutine F_antisymmetric_N_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_antisymmetric_N(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                     bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                     surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       end module
       module apply_BCs_faces_bridge_implicit_mod
       use current_precision_mod
       use apply_BCs_faces_raw_implicit_mod
       use apply_face_BC_op_mod
       use GF_mod
       use face_SD_mod
       use face_SD_extend_mod

       implicit none
       private
       public :: apply_face_BC_op

       public :: Dirichlet_C_implicit
       public :: Dirichlet_N_implicit
       public :: Neumann_C_implicit
       public :: Neumann_N_implicit
       public :: Periodic_C_implicit
       public :: Periodic_C_prescribed_implicit
       public :: Periodic_N_implicit
       public :: Periodic_N_prescribed_implicit
       public :: Robin_C_implicit
       public :: Robin_C_implicit_prescribed
       public :: Robin_N_implicit
       public :: Symmetric_C_implicit
       public :: Symmetric_N_implicit
       public :: antisymmetric_C_implicit
       public :: antisymmetric_N_implicit

       contains

       ! *********************************************************************************
       ! ********************************* DIRICHLET *************************************
       ! *********************************************************************************

       subroutine Dirichlet_C_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Dirichlet_C_GF(GF,surf,&
                               FSD%G(face)%M(1:3)%i2(1),&
                               FSD%G(face)%M(1:3)%i2(2),&
                               FSD%I(face)%M(1:3)%i2(1),&
                               FSD%I(face)%M(1:3)%i2(2),&
                               FSD%i_2D(face)%i,&
                               0)
       end subroutine
       subroutine F_Dirichlet_C_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Dirichlet_C_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                         bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                         surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Dirichlet_N_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Dirichlet_N_GF(GF,surf,&
                               FSD%G(face)%M(1:3)%i2(1),&
                               FSD%G(face)%M(1:3)%i2(2),&
                               FSD%B(face)%M(1:3)%i2(1),&
                               FSD%B(face)%M(1:3)%i2(2),&
                               FSD%I(face)%M(1:3)%i2(1),&
                               FSD%I(face)%M(1:3)%i2(2),&
                               FSD%i_2D(face)%i,&
                               0)
       end subroutine
       subroutine F_Dirichlet_N_GF(bulk,surf,G1,G2,B1,B2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,B1,B2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Dirichlet_N_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                         bulk%f(B1(1):B2(1),B1(2):B2(2),B1(3):B2(3)),&
                                         bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                         surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       ! *********************************************************************************
       ! *********************************** NEUMANN *************************************
       ! *********************************************************************************

       subroutine Neumann_C_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Neumann_C_GF(GF,surf,&
                             FSD%G(face)%M(1:3)%i2(1),&
                             FSD%G(face)%M(1:3)%i2(2),&
                             FSD%I(face)%M(1:3)%i2(1),&
                             FSD%I(face)%M(1:3)%i2(2),&
                             FSD%i_2D(face)%i,&
                             0)
       end subroutine
       subroutine F_Neumann_C_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Neumann_C_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                       bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                       surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Neumann_N_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Neumann_N_GF(GF,surf,&
                             FSD%G(face)%M(1:3)%i2(1),&
                             FSD%G(face)%M(1:3)%i2(2),&
                             FSD%I(face)%M(1:3)%i2(1),&
                             FSD%I(face)%M(1:3)%i2(2),&
                             FSD%i_2D(face)%i,&
                             0)
       end subroutine
       subroutine F_Neumann_N_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Neumann_N_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                       bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                       surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       ! *********************************************************************************
       ! ********************************** PERIODIC *************************************
       ! *********************************************************************************

       subroutine Periodic_C_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Periodic_C_GF(GF,surf,&
                              FSD%G(face)%M(1:3)%i2(1),&
                              FSD%G(face)%M(1:3)%i2(2),&
                              FSD%I_OPP(face)%M(1:3)%i2(1),&
                              FSD%I_OPP(face)%M(1:3)%i2(2),&
                              FSD%i_2D(face)%i,&
                              0)
       end subroutine
       subroutine F_Periodic_C_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         ! apply_Periodic_C(ug,ui_opp,x,y,p)
         call apply_Periodic_C_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                        bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                        surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Periodic_C_prescribed_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Periodic_C_prescribed_GF(GF,surf,&
                              FSD%G(face)%M(1:3)%i2(1),&
                              FSD%G(face)%M(1:3)%i2(2),&
                              FSD%i_2D(face)%i,&
                              0)
       end subroutine
       subroutine F_Periodic_C_prescribed_GF(bulk,surf,G1,G2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         ! apply_Periodic_C(ug,ui_opp,x,y,p)
         call apply_Periodic_C_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                        surf%f,&
                                        surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Periodic_N_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Periodic_N_GF(GF,surf,&
                              FSD%G_periodic_N(face)%M(1:3)%i2(1),&
                              FSD%G_periodic_N(face)%M(1:3)%i2(2),&
                              FSD%I_OPP_periodic_N(face)%M(1:3)%i2(1),&
                              FSD%I_OPP_periodic_N(face)%M(1:3)%i2(2),&
                              FSD%i_2D(face)%i,&
                              0)
       end subroutine
       subroutine F_Periodic_N_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Periodic_N_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                        bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                        surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Periodic_N_prescribed_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Periodic_N_prescribed_GF(GF,surf,&
                              FSD%G_periodic_N(face)%M(1:3)%i2(1),&
                              FSD%G_periodic_N(face)%M(1:3)%i2(2),&
                              FSD%i_2D(face)%i,&
                              0)
       end subroutine
       subroutine F_Periodic_N_prescribed_GF(bulk,surf,G1,G2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Periodic_N_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                        surf%f,&
                                        surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       ! *********************************************************************************
       ! ************************************ ROBIN **************************************
       ! *********************************************************************************

       subroutine Robin_C_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Robin_C_GF(GF,surf,&
                           FSD%G(face)%M(1:3)%i2(1),&
                           FSD%G(face)%M(1:3)%i2(2),&
                           FSD%I(face)%M(1:3)%i2(1),&
                           FSD%I(face)%M(1:3)%i2(2),&
                           FSD%i_2D(face)%i,&
                           FSD%dh(face),&
                           FSD%nhat(face),&
                           FSD%c_w(face),&
                           0)
       end subroutine
       subroutine F_Robin_C_GF(bulk,surf,G1,G2,I1,I2,iR,dh,nhat,c_w,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         real(cp),intent(in) :: dh,nhat,c_w
         integer,intent(in) :: p
         call apply_Robin_C_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                     bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                     dh,nhat,c_w,surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Robin_C_implicit_prescribed(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Robin_C_prescribed_GF(GF,surf,&
                           FSD%G(face)%M(1:3)%i2(1),&
                           FSD%G(face)%M(1:3)%i2(2),&
                           FSD%I(face)%M(1:3)%i2(1),&
                           FSD%I(face)%M(1:3)%i2(2),&
                           FSD%i_2D(face)%i,&
                           FSD%dh(face),&
                           FSD%nhat(face),&
                           FSD%c_w(face),&
                           0)
       end subroutine
       subroutine F_Robin_C_prescribed_GF(bulk,surf,G1,G2,I1,I2,iR,dh,nhat,c_w,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         real(cp),intent(in) :: dh,nhat,c_w
         integer,intent(in) :: p
         call apply_Robin_C_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                     bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                     dh,nhat,c_w,surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Robin_N_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Robin_N_GF(GF,surf,&
                           FSD%G(face)%M(1:3)%i2(1),&
                           FSD%G(face)%M(1:3)%i2(2),&
                           FSD%B(face)%M(1:3)%i2(1),&
                           FSD%B(face)%M(1:3)%i2(2),&
                           FSD%I(face)%M(1:3)%i2(1),&
                           FSD%I(face)%M(1:3)%i2(2),&
                           FSD%i_2D(face)%i,&
                           FSD%dh(face),&
                           FSD%nhat(face),&
                           FSD%c_w(face),&
                           0)
       end subroutine
       subroutine F_Robin_N_GF(bulk,surf,G1,G2,B1,B2,I1,I2,iR,dh,nhat,c_w,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,B1,B2,I1,I2
         integer,dimension(2),intent(in) :: iR
         real(cp),intent(in) :: dh,nhat,c_w
         integer,intent(in) :: p
         call apply_Robin_N_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                     bulk%f(B1(1):B2(1),B1(2):B2(2),B1(3):B2(3)),&
                                     bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                     dh,nhat,c_w,surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       ! *********************************************************************************
       ! ********************************** SYMMETRIC ************************************
       ! *********************************************************************************

       subroutine Symmetric_C_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Symmetric_C_GF(GF,surf,&
                               FSD%G(face)%M(1:3)%i2(1),&
                               FSD%G(face)%M(1:3)%i2(2),&
                               FSD%I_OPP(face)%M(1:3)%i2(1),&
                               FSD%I_OPP(face)%M(1:3)%i2(2),&
                               FSD%i_2D(face)%i,&
                               0)
       end subroutine
       subroutine F_Symmetric_C_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         ! apply_Symmetric_C(ug,ui,x,y,p)
         call apply_Symmetric_C_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                         bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                         surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine Symmetric_N_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_Symmetric_N_GF(GF,surf,&
                               FSD%G(face)%M(1:3)%i2(1),&
                               FSD%G(face)%M(1:3)%i2(2),&
                               FSD%I_OPP(face)%M(1:3)%i2(1),&
                               FSD%I_OPP(face)%M(1:3)%i2(2),&
                               FSD%i_2D(face)%i,&
                               0)
       end subroutine
       subroutine F_Symmetric_N_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_Symmetric_N_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                         bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                         surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       ! *********************************************************************************
       ! ********************************** SYMMETRIC ************************************
       ! *********************************************************************************

       subroutine antisymmetric_C_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_antisymmetric_C_GF(GF,surf,&
                                    FSD%G(face)%M(1:3)%i2(1),&
                                    FSD%G(face)%M(1:3)%i2(2),&
                                    FSD%I_OPP(face)%M(1:3)%i2(1),&
                                    FSD%I_OPP(face)%M(1:3)%i2(2),&
                                    FSD%i_2D(face)%i,&
                                    0)
       end subroutine
       subroutine F_antisymmetric_C_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         ! apply_antisymmetric_C(ug,ui,x,y,p)
         call apply_antisymmetric_C_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                              bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                              surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       subroutine antisymmetric_N_implicit(GF,surf,FSD,face)
         implicit none
         type(grid_field),intent(inout) :: GF
         type(grid_field),intent(in) :: surf
         type(face_SD),intent(in) :: FSD
         integer,intent(in) :: face
         call F_antisymmetric_N_GF(GF,surf,&
                                    FSD%G(face)%M(1:3)%i2(1),&
                                    FSD%G(face)%M(1:3)%i2(2),&
                                    FSD%I_OPP(face)%M(1:3)%i2(1),&
                                    FSD%I_OPP(face)%M(1:3)%i2(2),&
                                    FSD%i_2D(face)%i,&
                                    0)
       end subroutine
       subroutine F_antisymmetric_N_GF(bulk,surf,G1,G2,I1,I2,iR,p)
         implicit none
         type(grid_field),intent(inout) :: bulk
         type(grid_field),intent(in) :: surf
         integer,dimension(3),intent(in) :: G1,G2,I1,I2
         integer,dimension(2),intent(in) :: iR
         integer,intent(in) :: p
         call apply_antisymmetric_N_implicit(bulk%f(G1(1):G2(1),G1(2):G2(2),G1(3):G2(3)),&
                                              bulk%f(I1(1):I2(1),I1(2):I2(2),I1(3):I2(3)),&
                                              surf%s(iR(1)),surf%s(iR(2)),p)
       end subroutine

       end module
       module block_extend_mod
       use block_mod
       use current_precision_mod
       use grid_mod
       use grid_extend_mod
       use GF_mod
       use sparse_mod
       use sparse_extend_mod
       use face_edge_corner_indexing_mod
       use data_location_extend_mod
       use IO_tools_mod
       use GF_diagonals_mod
       implicit none

       private
       public :: init

       public :: init_FEC
       public :: init_vol
       public :: init_apply_BC_order

       public :: restrict
       public :: prolongate

       public :: mirror_about_hmin
       public :: mirror_about_hmax

       interface init;               module procedure init_block;               end interface

       interface init_FEC;           module procedure init_FEC_block;           end interface
       interface init_apply_BC_order;module procedure init_apply_BC_order_block;end interface

       interface restrict;           module procedure restrict_dir_b;           end interface
       interface prolongate;         module procedure prolongate_dir_b;         end interface

       interface mirror_about_hmin;  module procedure mirror_about_hmin_b;      end interface
       interface mirror_about_hmax;  module procedure mirror_about_hmax_b;      end interface

       interface init_vol;           module procedure init_vol_block;           end interface

       contains

       subroutine init_block(B,g)
         implicit none
         type(block),intent(inout) :: B
         type(grid),intent(in) :: g
         call delete(B)
         call init(B%g,g)
         call init_vol_block(B)
       end subroutine

       subroutine init_vol_block(B)
         implicit none
         type(block),intent(inout) :: B
         ! type(data_location) :: DL
         ! integer :: i
         ! if (allocated(B%vol)) then
         ! do i=1,8; call delete(B%vol(i)); enddo; deallocate(B%vol)
         ! endif
         ! allocate(B%vol(8))
         ! call init_CC(B%vol(1),B%g)
         ! call init_Node(B%vol(2),B%g)
         ! call init_Face(B%vol(3),B%g,1)
         ! call init_Face(B%vol(4),B%g,2)
         ! call init_Face(B%vol(5),B%g,3)
         ! call init_Edge(B%vol(6),B%g,1)
         ! call init_Edge(B%vol(7),B%g,2)
         ! call init_Edge(B%vol(8),B%g,3)
         ! call init_CC(DL);     call volume(B%vol(1),B%g,DL)
         ! call init_Node(DL);   call volume(B%vol(2),B%g,DL)
         ! call init_Face(DL,1); call volume(B%vol(3),B%g,DL)
         ! call init_Face(DL,2); call volume(B%vol(4),B%g,DL)
         ! call init_Face(DL,3); call volume(B%vol(5),B%g,DL)
         ! call init_Edge(DL,1); call volume(B%vol(6),B%g,DL)
         ! call init_Edge(DL,2); call volume(B%vol(7),B%g,DL)
         ! call init_Edge(DL,3); call volume(B%vol(8),B%g,DL)
         ! call delete(DL)
         call suppress_warnings(B)
       end subroutine

       subroutine init_FEC_block(B)
         implicit none
         type(block),intent(inout) :: B
         integer :: i
         call delete_FEC_block(B)
         i=6;  allocate(B%f(i));  do i=1,6; call get_face_GI(B%f(i),B%g,i);   enddo
         ! i=12; allocate(B%e(i));  do i=1,12;call get_edge_GI(B%e(i),B%g,i);   enddo
         ! i=8;  allocate(B%c(i));  do i=1,8; call get_corner_GI(B%c(i),B%g,i); enddo

         i=6;  allocate(B%fb(i)); do i=1,6; call get_face_b(  B%fb(i),B%g,i); enddo
         ! i=12; allocate(B%eb(i)); do i=1,12;call get_edge_b(  B%eb(i),B%g,i); enddo
         ! i=8;  allocate(B%cb(i)); do i=1,8; call get_corner_b(B%cb(i),B%g,i); enddo
       end subroutine

       subroutine init_apply_BC_order_block(B,apply_BC_order)
         implicit none
         type(block),intent(inout) :: B
         integer,dimension(6),intent(in) :: apply_BC_order
         B%apply_BC_order = apply_BC_order
       end subroutine

       subroutine mirror_about_hmin_b(B,dir)
         implicit none
         type(block),intent(inout) :: B
         integer,intent(in) :: dir
         call mirror_about_hmin(B%g,dir)
       end subroutine
       subroutine mirror_about_hmax_b(B,dir)
         implicit none
         type(block),intent(inout) :: B
         integer,intent(in) :: dir
         call mirror_about_hmax(B%g,dir)
       end subroutine

       subroutine delete_FEC_block(B)
         implicit none
         type(block),intent(inout) :: B
         integer :: i
         if (allocated(B%f)) then; do i=1,6;  call delete(B%f(i)); enddo; deallocate(B%f); endif
         if (allocated(B%fb)) then; do i=1,6;  call delete(B%fb(i)); enddo; deallocate(B%fb); endif

         ! if (allocated(B%e)) then; do i=1,12; call delete(B%e(i)); enddo; deallocate(B%e); endif
         ! if (allocated(B%eb)) then; do i=1,12; call delete(B%eb(i)); enddo; deallocate(B%eb); endif

         ! if (allocated(B%c)) then; do i=1,8;  call delete(B%c(i)); enddo; deallocate(B%c); endif
         ! if (allocated(B%cb)) then; do i=1,8;  call delete(B%cb(i)); enddo; deallocate(B%cb); endif
       end subroutine

       ! **********************************************************
       ! ************************ MG ******************************
       ! **********************************************************

       subroutine restrict_dir_b(B,dir)
         implicit none
         type(block),intent(inout) :: B
         integer,intent(in) :: dir
         call restrict(B%g,dir)
         call init_vol_block(B)
         call init_FEC_block(B)
       end subroutine

       subroutine prolongate_dir_b(B,dir)
         implicit none
         type(block),intent(inout) :: B
         integer,intent(in) :: dir
         call prolongate(B%g,dir)
         call init_vol_block(B)
         call init_FEC_block(B)
       end subroutine

       end module
       module mesh_extend_mod
       use mesh_mod
      ! Pre-processor directives: (_DEBUG_MESH_)
       use current_precision_mod
       use IO_tools_mod
       use grid_mod
       use block_mod
       use block_extend_mod
       use grid_extend_mod
       use block_extend_mod
       use coordinates_mod
       use coordinates_extend_mod
       use face_edge_corner_indexing_mod
       use stitch_mod
       use GF_mod
       use mesh_props_mod
       implicit none

       private
       public :: mesh
       public :: init,delete,display,print,export,import
       public :: display_info,print_info

       public :: add
       public :: patch

       public :: restrict_x,restrict_xy
       public :: restrict
       public :: prolongate

       public :: init_props
       public :: init_apply_BC_order
       public :: mirror_about_hmin
       public :: mirror_about_hmax
       public :: compare


#ifdef _DEBUG_COORDINATES_
      public :: checkmesh
#endif

       interface init;                module procedure init_grid;               end interface
       interface display_info;        module procedure display_mesh_info;       end interface
       interface print_info;          module procedure print_mesh_info;         end interface

       interface add;                 module procedure addGrid;                 end interface
       interface init_props;          module procedure init_props_mesh;         end interface
       interface init_apply_BC_order; module procedure init_apply_BC_order_mesh;end interface
       interface init_FEC;            module procedure init_FEC_mesh;           end interface
       interface patch;               module procedure patch_blocks;            end interface

       interface restrict;            module procedure restrictmesh1;           end interface
       interface restrict;            module procedure restrictmesh3;           end interface
       interface restrict;            module procedure restrict_dir_m;          end interface
       interface prolongate;          module procedure prolongate_dir_m;        end interface

       interface mirror_about_hmin;   module procedure mirror_about_hmin_m;     end interface
       interface mirror_about_hmax;   module procedure mirror_about_hmax_m;     end interface

       interface compare;             module procedure compare_mesh;            end interface

       contains

       subroutine init_grid(m,g)
         implicit none
         type(mesh),intent(inout) :: m
         type(grid),intent(in) :: g
         call delete(m)
         allocate(m%B(1))
         call init(m%B(1),g)
         m%s = 1
         call init_props(m)
         call insist_allocated_mesh(m,'init_grid')
         m%defined = .true.
       end subroutine

       subroutine display_mesh_info(m,un)
         implicit none
         type(mesh), intent(in) :: m
         integer,intent(in) :: un
         integer :: i
         if (un.ne.6) then
           do i = 1,m%s
             write(un,*) ' ------------- mesh ------------- grid ID = ',i
             call display(m%B(i)%g,un)
           enddo
           write(un,*) ' -------------------------------- '
         else
           if (m%s.lt.5) then
             do i = 1,m%s
               write(un,*) ' ------------- mesh ------------- grid ID = ',i
                 call display(m%B(i)%g,un)
             enddo
           write(un,*) ' -------------------------------- '
           else
           write(un,*) 'Many grids. To see details, see info file or change limits in mesh.f90'
           endif
         endif
         if (m%s.gt.1) then
           write(un,*) ' *********** mesh props *********** '
           write(un,*) 's,volume = ',m%s,m%MP%volume
           write(un,*) 'N_cells_tot,N_cells = ',m%MP%N_cells_tot,m%MP%N_cells
           write(un,*) 'min/max(h)_x = ',(/m%MP%hmin(1),m%MP%hmax(1)/)
           write(un,*) 'min/max(h)_y = ',(/m%MP%hmin(2),m%MP%hmax(2)/)
           write(un,*) 'min/max(h)_z = ',(/m%MP%hmin(3),m%MP%hmax(3)/)
           write(un,*) 'min/max(dh)_x = ',(/m%MP%dhmin(1),m%MP%dhmax(1)/)
           write(un,*) 'min/max(dh)_y = ',(/m%MP%dhmin(2),m%MP%dhmax(2)/)
           write(un,*) 'min/max(dh)_z = ',(/m%MP%dhmin(3),m%MP%dhmax(3)/)
           write(un,*) ' ********************************** '
         endif
       end subroutine

       subroutine print_mesh_info(m)
         implicit none
         type(mesh), intent(in) :: m
         call display(m,6)
       end subroutine

       ! **************************************************************
       ! **************************************************************
       ! **************************************************************

       subroutine addGrid(m,g)
         implicit none
         type(mesh),intent(inout) :: m
         type(grid),intent(in) :: g
         type(mesh) :: temp
         integer :: i
         if (allocated(m%B)) then
           if (m%s.lt.1) stop 'Error: allocated mesh but size<1 in addGrid mesh.f90'
           call init(temp,m)
           call delete(m)
           m%s = temp%s + 1
           allocate(m%B(m%s))
           do i=1,temp%s; call init(m%B(i),temp%B(i)); enddo
           call init(m%B(m%s),g)
           call delete(temp)
         else
           allocate(m%B(1))
           call init(m%B(1),g)
           m%s = 1
         endif
         call init_props(m)
         call insist_allocated_mesh(m,'addGrid')
         m%defined = .true.
       end subroutine

       subroutine remove_stitches(m)
         implicit none
         type(mesh),intent(inout) :: m
         integer :: i
         do i=1,m%s
         enddo
       end subroutine

       subroutine mirror_about_hmin_m(m,dir)
         implicit none
         type(mesh),intent(inout) :: m
         integer,intent(in) :: dir
         integer :: i
         do i=1,m%s; call mirror_about_hmin(m%B(i),dir); enddo
       end subroutine

       subroutine mirror_about_hmax_m(m,dir)
         implicit none
         type(mesh),intent(inout) :: m
         integer,intent(in) :: dir
         integer :: i
         do i=1,m%s; call mirror_about_hmax(m%B(i),dir); enddo
       end subroutine

       subroutine init_props_mesh(m)
         implicit none
         type(mesh),intent(inout) :: m
         integer :: i,j
         call init_FEC(m)
         call insist_allocated_mesh(m,'init_props_mesh')
         if (m%s.gt.1) then
           do j=1,3
             m%MP%hmin(j)  = minval( (/(m%B(i)%g%c(j)%hmin  , i=2,m%s)/) )
             m%MP%dhmin(j) = minval( (/(m%B(i)%g%c(j)%dhmin , i=2,m%s)/) )
             m%MP%hmax(j)  = maxval( (/(m%B(i)%g%c(j)%hmax  , i=2,m%s)/) )
             m%MP%dhmax(j) = maxval( (/(m%B(i)%g%c(j)%dhmax , i=2,m%s)/) )
           enddo
         else
           do j=1,3
             m%MP%hmin(j)  = m%B(1)%g%c(j)%hmin
             m%MP%dhmin(j) = m%B(1)%g%c(j)%dhmin
             m%MP%hmax(j)  = m%B(1)%g%c(j)%hmax
             m%MP%dhmax(j) = m%B(1)%g%c(j)%dhmax
           enddo
         endif
         m%MP%N_cells = 0; m%MP%N_cells_tot = 0; m%MP%volume = 0.0_cp
         do i=1,m%s; m%MP%volume = m%MP%volume + m%B(i)%g%volume; enddo
         do i=1,m%s; call init_vol(m%B(i)); enddo
         do i=1,m%s;do j=1,3; m%MP%N_cells(j) = m%MP%N_cells(j) + m%B(i)%g%c(j)%N; enddo; enddo
         do i=1,m%s;m%MP%N_cells_tot=m%MP%N_cells_tot+m%B(i)%g%c(1)%N*m%B(i)%g%c(2)%N*m%B(i)%g%c(3)%N;enddo

         m%MP%dhmin_min = minval((/m%MP%dhmin(1),m%MP%dhmin(2),m%MP%dhmin(3)/))
         m%MP%dhmax_max = maxval((/m%MP%dhmax(1),m%MP%dhmax(2),m%MP%dhmax(3)/))

         m%MP%plane(1) = all((/(m%B(i)%g%c(1)%N.eq.1,i=1,m%s)/))
         m%MP%plane(2) = all((/(m%B(i)%g%c(2)%N.eq.1,i=1,m%s)/))
         m%MP%plane(3) = all((/(m%B(i)%g%c(3)%N.eq.1,i=1,m%s)/))
         m%MP%plane_any = any(m%MP%plane)
         do i=1,3
          ! call init(m%MP%int_tensor(i),i)
          m%MP%int_tensor(i)%eye = eye_given_dir(i)
         enddo
       end subroutine

       subroutine init_apply_BC_order_mesh(m,apply_BC_order)
         implicit none
         type(mesh),intent(inout) :: m
         integer,dimension(6),intent(in) :: apply_BC_order
         integer :: i
         do i=1,m%s; call init_apply_BC_order(m%B(i),apply_BC_order); enddo
       end subroutine

       subroutine init_FEC_mesh(m)
         implicit none
         type(mesh),intent(inout) :: m
         integer :: i
         call insist_allocated_mesh(m,'init_FEC_mesh')
         do i=1,m%s; call init_FEC(m%B(i)); enddo
       end subroutine

       subroutine patch_blocks(m)
         implicit none
         type(mesh),intent(inout) :: m
         real(cp) :: tol
         call insist_allocated_mesh(m,'patch_blocks')
         call remove_stitches(m)
         if (m%s.gt.1) then
           tol = 0.01_cp
           ! Remove all patches first
           call init_props(m) ! Need dhmin etc.
           call patch_Faces(m,tol)
           call patch_Edges(m,tol)
           call patch_Corners(m,tol)
         endif
       end subroutine

       subroutine patch_Faces(m,tol) ! 6 faces per grid
         ! Find blocks that share a face.
         implicit none
         type(mesh),intent(inout) :: m
         real(cp),intent(in) :: tol
         integer :: i,j,k
         integer,dimension(2) :: f,a
         logical,dimension(5) :: TF_face
         do k=1,3; do i=1,m%s; do j=1,m%s
           if (i.ne.j) then
             TF_face(1) = abs(m%B(i)%g%c(k)%hmin-m%B(j)%g%c(k)%hmax).lt.tol*m%MP%dhmin(k) ! Contact face
             a = adj_dir_given_dir(k)
             TF_face(2) = abs(m%B(i)%g%c(a(1))%hmin-m%B(j)%g%c(a(1))%hmin).lt.tol*m%MP%dhmin(a(1)) ! Adjacent face 1 hmin
             TF_face(3) = abs(m%B(i)%g%c(a(1))%hmax-m%B(j)%g%c(a(1))%hmax).lt.tol*m%MP%dhmin(a(1)) ! Adjacent face 1 hmax
             TF_face(4) = abs(m%B(i)%g%c(a(2))%hmin-m%B(j)%g%c(a(2))%hmin).lt.tol*m%MP%dhmin(a(2)) ! Adjacent face 2 hmin
             TF_face(5) = abs(m%B(i)%g%c(a(2))%hmax-m%B(j)%g%c(a(2))%hmax).lt.tol*m%MP%dhmin(a(2)) ! Adjacent face 2 hmax

             if (all(TF_face)) then
               f = normal_faces_given_dir(k)
               ! call stitch_faces(m%B(i),m%B(j),f(1),f(2))
             endif
           endif
         enddo; enddo; enddo
         do k=1,3; do i=1,m%s
            f = normal_faces_given_dir(k)
         enddo; enddo
       end subroutine

       subroutine patch_Edges(m,tol) ! 12 edges per grid
         implicit none
         type(mesh),intent(inout) :: m
         real(cp),intent(in) :: tol
         call patch_Edges_diag(m,tol)
         call patch_Edges_adjoin_face(m)
       end subroutine

       subroutine patch_Edges_diag(m,tol) ! 12 edges per grid
         ! Find grids who share an edge, but NOT a face.
         implicit none
         type(mesh),intent(inout) :: m
         real(cp),intent(in) :: tol
         integer :: i,j,k
         integer,dimension(2) :: a
         integer,dimension(4) :: e
         logical,dimension(6) :: TF_edge
         do k=1,3; do i=1,m%s; do j=1,m%s
           if (i.ne.j) then
             TF_edge(1) = abs(m%B(i)%g%c(k)%hmin-m%B(j)%g%c(k)%hmin).lt.tol*m%MP%dhmin(k) ! Edge direction (min)
             TF_edge(2) = abs(m%B(i)%g%c(k)%hmax-m%B(j)%g%c(k)%hmax).lt.tol*m%MP%dhmin(k) ! Edge direction (max)
             a = adj_dir_given_dir(k)
             TF_edge(3) = abs(m%B(i)%g%c(a(1))%hmin-m%B(j)%g%c(a(1))%hmax).lt.tol*m%MP%dhmin(a(1)) ! min/max (a(1))
             TF_edge(4) = abs(m%B(i)%g%c(a(1))%hmax-m%B(j)%g%c(a(1))%hmin).lt.tol*m%MP%dhmin(a(1)) ! max/min (a(1))
             TF_edge(5) = abs(m%B(i)%g%c(a(2))%hmin-m%B(j)%g%c(a(2))%hmax).lt.tol*m%MP%dhmin(a(2)) ! min/max (a(2))
             TF_edge(6) = abs(m%B(i)%g%c(a(2))%hmax-m%B(j)%g%c(a(2))%hmin).lt.tol*m%MP%dhmin(a(2)) ! max/min (a(2))
             e = edges_given_dir(k)
           endif
         enddo; enddo; enddo
       end subroutine

       subroutine patch_Edges_adjoin_face(m) ! 12 edges per grid
         ! Remove edges that do not adjoin to 4 faces
         implicit none
         type(mesh),intent(inout) :: m
         integer :: i,k
         integer,dimension(2) :: a,f1,f2
         integer,dimension(4) :: e
         do k=1,3; do i=1,m%s
           a = adj_dir_given_dir(k)
           f1 = normal_faces_given_dir(a(1)); f2 = normal_faces_given_dir(a(2)); e = edges_given_dir(k)
         enddo; enddo
       end subroutine

       subroutine patch_Corners(m,tol) ! 8 corners per grid
         ! Find grids who share an corner, but NOT an edge.
         implicit none
         type(mesh),intent(inout) :: m
         real(cp),intent(in) :: tol
         integer :: i,k
         real(cp) :: suppress_warning
         suppress_warning = tol
         do i=1,m%s; do k=1,8
         enddo; enddo
       end subroutine

       function compare_mesh(a,b) result(L_all)
         implicit none
         type(mesh),intent(in) :: a,b
         logical,dimension(8) :: L
         integer :: i
         logical :: L_all
         real(cp) :: tol
         tol = 10.0_cp**(-12.0_cp)
         L(1) = all((/(abs(a%MP%hmax(i)-b%MP%hmax(i)).lt.tol,i=1,3)/))
         L(2) = all((/(abs(a%MP%hmin(i)-b%MP%hmin(i)).lt.tol,i=1,3)/))
         L(3) = all((/(abs(a%MP%dhmax(i)-b%MP%dhmax(i)).lt.tol,i=1,3)/))
         L(4) = all((/(abs(a%MP%dhmin(i)-b%MP%dhmin(i)).lt.tol,i=1,3)/))
         L(5) = abs(a%MP%volume-b%MP%volume).lt.tol
         L(6) = all((/(a%MP%N_cells(i)-b%MP%N_cells(i).eq.0,i=1,3)/))
         L(7) = a%MP%N_cells_tot-b%MP%N_cells_tot.eq.0
         L(8) = a%s-b%s.eq.0
         L_all = all(L)
       end function

       ! ------------------- restrict (for multimesh) --------------

       subroutine restrictmesh1(rm,m,dir)
         type(mesh),intent(inout) :: rm
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir
         integer :: i
         call insist_allocated_mesh(m,'restrictmesh1 (1)')
         call insist_allocated_mesh(rm,'restrictmesh1 (2)')
         do i = 1,m%s; call restrict(rm%B(i)%g%c(dir),m%B(i)%g%c(dir)) ;enddo
       end subroutine

       subroutine restrictmesh3(rm,m)
         type(mesh),intent(inout) :: rm
         type(mesh),intent(in) :: m
         integer :: i
         call insist_allocated_mesh(m,'restrictmesh3 (1)')
         call insist_allocated_mesh(rm,'restrictmesh3 (2)')
         do i = 1,m%s; call restrict(rm%B(i)%g,m%B(i)%g) ;enddo
       end subroutine

       subroutine restrict_dir_m(m,dir)
         type(mesh),intent(inout) :: m
         integer,intent(in) :: dir
         integer :: i
         do i = 1,m%s; call restrict(m%B(i),dir) ;enddo
       end subroutine

       subroutine prolongate_dir_m(m,dir)
         type(mesh),intent(inout) :: m
         integer,intent(in) :: dir
         integer :: i
         do i = 1,m%s; call prolongate(m%B(i),dir) ;enddo
         call init_props(m)
       end subroutine

       ! ---------------------------------------------- check mesh

#ifdef _DEBUG_COORDINATES_
       subroutine checkmesh(m)
         implicit none
         type(mesh),intent(in) :: m
         integer :: i
         do i = 1,m%s; call checkGrid(m%B(i)%g) ;enddo
       end subroutine
#endif

       subroutine insist_allocated_mesh(m,caller)
         implicit none
         type(mesh),intent(in) :: m
         character(len=*),intent(in) :: caller
         if (.not.allocated(m%B)) then
          write(*,*) 'Error: mesh not allocated in '//caller//' in mesh.f90'
          stop 'Done'
         elseif (size(m%B).ne.m%s) then
          write(*,*) 'Error: mesh size not correct in '//caller//' in mesh.f90'
          stop 'Done'
         endif
       end subroutine

       end module
       module single_boundary_extend_mod
       use single_boundary_mod
       use current_precision_mod
       use face_edge_corner_indexing_mod
       use data_location_extend_mod
       use grid_mod
       use block_extend_mod
       use GF_mod
       use bctype_extend_mod
       use IO_tools_mod
       implicit none

       private
       public :: single_boundary
       public :: init,delete,display,print,export,import ! Essentials

       public :: prolongate
       public :: restrict

       interface init;        module procedure init_GFs_SB_DL;  end interface
       interface prolongate;  module procedure prolongate_B;    end interface
       interface restrict;    module procedure restrict_B;      end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_GFs_SB_DL(SB,g,DL)
         implicit none
         type(single_boundary),intent(inout) :: SB
         type(grid),intent(in) :: g
         type(data_location),intent(in) :: DL
         call delete(SB)
               if (is_CC(DL)) then; call init_CC(  SB%b,g)
         elseif (is_Node(DL)) then; call init_Node(SB%b,g)
         elseif (is_Face(DL)) then; call init_Face(SB%b,g,get_Face(DL))
         elseif (is_Edge(DL)) then; call init_Edge(SB%b,g,get_Edge(DL))
         else; stop 'Error: bad DL f in init_GFs_SB_DL in single_boundary.f90'
         endif
               if (is_CC(DL)) then; call init_CC(  SB%b_modified,g)
         elseif (is_Node(DL)) then; call init_Node(SB%b_modified,g)
         elseif (is_Face(DL)) then; call init_Face(SB%b_modified,g,get_Face(DL))
         elseif (is_Edge(DL)) then; call init_Edge(SB%b_modified,g,get_Edge(DL))
         else; stop 'Error: bad DL f in init_GFs_SB_DL in single_boundary.f90'
         endif
               if (is_CC(DL)) then; call init_CC(  SB%b_total,g)
         elseif (is_Node(DL)) then; call init_Node(SB%b_total,g)
         elseif (is_Face(DL)) then; call init_Face(SB%b_total,g,get_Face(DL))
         elseif (is_Edge(DL)) then; call init_Edge(SB%b_total,g,get_Edge(DL))
         else; stop 'Error: bad DL f in init_GFs_SB_DL in single_boundary.f90'
         endif
         call assign(SB%b,0.0_cp)
         call assign(SB%b_modified,0.0_cp)
         call assign(SB%b_total,0.0_cp)
       end subroutine

       subroutine restrict_B(SB,g,DL,dir,x,y,z)
         implicit none
         integer,intent(in) :: dir,x,y,z
         type(single_boundary),intent(inout) :: SB
         type(grid),intent(in) :: g
         type(data_location),intent(in) :: DL
             if (CC_along(DL,dir)) then; call restrict_C(SB%b,g,dir,x,y,z)
                                         call restrict_C(SB%b_total,g,dir,x,y,z)
                                         call restrict_C(SB%b_modified,g,dir,x,y,z)
         elseif ( N_along(DL,dir)) then; call restrict_N(SB%b,g,dir,x,y,z)
                                         call restrict_N(SB%b_total,g,dir,x,y,z)
                                         call restrict_N(SB%b_modified,g,dir,x,y,z)
         else; stop 'Error: bad DL in restrict_B in single_boundary.f90'
         endif
       end subroutine

       subroutine prolongate_B(SB,g,DL,dir,x,y,z)
         implicit none
         type(single_boundary),intent(inout) :: SB
         integer,intent(in) :: dir,x,y,z
         type(grid),intent(in) :: g
         type(data_location),intent(in) :: DL
             if (CC_along(DL,dir)) then; call prolongate_C(SB%b,g,dir,x,y,z)
                                         call prolongate_C(SB%b_total,g,dir,x,y,z)
                                         call prolongate_C(SB%b_modified,g,dir,x,y,z)
         elseif ( N_along(DL,dir)) then; call prolongate_N(SB%b,dir,x,y,z)
                                         call prolongate_N(SB%b_total,dir,x,y,z)
                                         call prolongate_N(SB%b_modified,dir,x,y,z)
         else; stop 'Error: bad DL in prolongate_B in single_boundary.f90'
         endif
       end subroutine

       end module
       module single_procedure_extend_mod
       use single_procedure_mod
       use IO_tools_mod
       use GF_mod
       use apply_BCs_faces_bridge_mod
       use apply_face_BC_op_mod

       implicit none
       private
       public :: init
       public :: insist_defined

       interface init;           module procedure init_SP;           end interface
       interface insist_defined; module procedure insist_defined_SP; end interface

       contains

       subroutine init_SP(SP,P,ID)
         implicit none
         type(single_procedure),intent(inout) :: SP
         procedure(apply_face_BC_op) :: P
         integer,intent(in) :: ID
         call delete(SP)
         SP%P => P
         SP%ID = ID
         SP%defined = .true.
       end subroutine

       subroutine insist_defined_SP(SP,caller)
         implicit none
         type(single_procedure),intent(in) :: SP
         character(len=*),intent(in) :: caller
         if (.not.SP%defined) then
         write(*,*) 'Error: SP is not defined in ',caller,' in single_procedure.f90'
         stop 'Done'
         endif
       end subroutine

       end module
       module boundary_extend_mod
       use boundary_mod
       use current_precision_mod
       use face_edge_corner_indexing_mod
       use data_location_extend_mod
       use grid_mod
       use single_boundary_mod
       use single_boundary_extend_mod
       use block_extend_mod
       use block_mod
       use string_mod
       use GF_mod
       use bctype_extend_mod
       use BC_logicals_mod
       use IO_tools_mod
       use table_mod
       implicit none

       private
       public :: boundary
       public :: init ! Essentials

       ! Setters for type
       public :: init_Dirichlet
       public :: init_Neumann
       public :: init_Robin
       public :: init_periodic
       public :: init_symmetric
       public :: init_antisymmetric
       public :: set_prescribed

       public :: get_all_Neumann
       public :: get_all_Dirichlet
       public :: get_all_Robin
       public :: get_any_Neumann
       public :: get_any_Dirichlet
       public :: get_any_Robin

       public :: get_any_prescribed
       public :: insist_allocated

       public :: prolongate
       public :: restrict

       interface init;                module procedure init_GFs_boundary_DL;      end interface

       interface init;                module procedure init_vals_all_S;           end interface
       interface init;                module procedure init_vals_ID_GF;           end interface
       interface init;                module procedure init_val_ID_S;             end interface

       interface init_Dirichlet;      module procedure init_Dirichlet_all;        end interface
       interface init_Dirichlet;      module procedure init_Dirichlet_ID;         end interface
       interface init_Neumann;        module procedure init_Neumann_all;          end interface
       interface init_Neumann;        module procedure init_Neumann_ID;           end interface
       interface init_Robin;          module procedure init_Robin_all;            end interface
       interface init_Robin;          module procedure init_Robin_ID;             end interface
       interface init_periodic;       module procedure init_periodic_all;         end interface
       interface init_periodic;       module procedure init_periodic_ID;          end interface
       interface init_symmetric;      module procedure init_symmetric_all;        end interface
       interface init_symmetric;      module procedure init_symmetric_ID;         end interface
       interface init_antisymmetric;  module procedure init_antisymmetric_all;    end interface
       interface init_antisymmetric;  module procedure init_antisymmetric_ID;     end interface
       interface set_prescribed;      module procedure set_prescribed_ID;         end interface
       interface set_prescribed;      module procedure set_prescribed_all;        end interface

       interface define_logicals;     module procedure define_logicals_boundary;  end interface
       interface insist_allocated;    module procedure insist_allocated_boundary; end interface

       interface get_all_Neumann;     module procedure get_all_Neumann_B;         end interface
       interface get_all_Dirichlet;   module procedure get_all_Dirichlet_B;       end interface
       interface get_all_Robin;       module procedure get_all_Robin_B;           end interface
       interface get_any_Neumann;     module procedure get_any_Neumann_B;         end interface
       interface get_any_Dirichlet;   module procedure get_any_Dirichlet_B;       end interface
       interface get_any_Robin;       module procedure get_any_Robin_B;           end interface
       interface get_any_prescribed;  module procedure get_any_prescribed_B;      end interface

       interface prolongate;          module procedure prolongate_B;              end interface
       interface restrict;            module procedure restrict_B;                end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_GFs_boundary_DL(B,BL,DL,n,name)
         implicit none
         type(boundary),intent(inout) :: B
         type(block),intent(in) :: BL
         type(data_location),intent(in) :: DL
         integer,intent(in) :: n
         character(len=*),intent(in) :: name
         integer :: i
         call delete(B)
         allocate(B%SB(n))
         call init(B%name,name)
         B%n = n
             if (n.eq.6 ) then; do i=1,n; call init(B%SB(i),BL%fb(i),DL); enddo
         ! elseif (n.eq.12) then; do i=1,n; call init(B%SB(i),BL%eb(i),DL); enddo
         ! elseif (n.eq.8 ) then; do i=1,n; call init(B%SB(i),BL%cb(i),DL); enddo
         else; stop 'Error: bad input to init_GFs_boundary_DL in B.f90'
         endif
         call init_vals_all_S(B,0.0_cp)
         B%BCL%GFs_defined = .true.
         call define_logicals(B)
       end subroutine

       subroutine init_vals_all_S(B,val)
         implicit none
         type(boundary),intent(inout) :: B
         real(cp),intent(in) :: val
         integer :: i
         do i=1,B%n; call assign(B%SB(i)%b,val); enddo
         B%BCL%vals_defined = .true.
         call define_logicals(B)
       end subroutine

       subroutine init_vals_ID_GF(B,vals,ID)
         implicit none
         type(boundary),intent(inout) :: B
         type(grid_field),intent(in) :: vals
         integer,intent(in) :: ID
         call assign(B%SB(ID)%b,vals)
         B%BCL%vals_defined = .true.
         call define_logicals(B)
       end subroutine

       subroutine init_val_ID_S(B,val,ID)
         implicit none
         type(boundary),intent(inout) :: B
         real(cp),intent(in) :: val
         integer,intent(in) :: ID
         call assign(B%SB(ID)%b,val)
         B%BCL%vals_defined = .true.
         call define_logicals(B)
       end subroutine

       ! *******************************************************************************
       ! ********************************* INIT FACES **********************************
       ! *******************************************************************************

       subroutine init_Dirichlet_all(B)
         implicit none
         type(boundary),intent(inout) :: B
         integer :: i
         do i=1,B%n; call init_Dirichlet(B,i); enddo
       end subroutine
       subroutine init_Dirichlet_ID(B,ID)
         implicit none
         type(boundary),intent(inout) :: B
         integer,intent(in) :: ID
         call init_Dirichlet(B%SB(ID)%bct)
         call define_logicals(B)
         B%BCL%BCT_defined = .true.
       end subroutine

       subroutine init_Neumann_all(B)
         implicit none
         type(boundary),intent(inout) :: B
         integer :: i
         do i=1,B%n; call init_Neumann(B,i); enddo
       end subroutine
       subroutine init_Neumann_ID(B,ID)
         implicit none
         type(boundary),intent(inout) :: B
         integer,intent(in) :: ID
         call init_Neumann(B%SB(ID)%bct)
         call define_logicals(B)
         B%BCL%BCT_defined = .true.
       end subroutine

       subroutine init_Robin_all(B)
         implicit none
         type(boundary),intent(inout) :: B
         integer :: i
         do i=1,B%n; call init_Robin(B,i); enddo
       end subroutine
       subroutine init_Robin_ID(B,ID)
         implicit none
         type(boundary),intent(inout) :: B
         integer,intent(in) :: ID
         call init_Robin(B%SB(ID)%bct)
         call define_logicals(B)
         B%BCL%BCT_defined = .true.
       end subroutine

       subroutine init_periodic_all(B)
         implicit none
         type(boundary),intent(inout) :: B
         integer :: i
         do i=1,B%n; call init_periodic(B,i); enddo
       end subroutine
       subroutine init_periodic_ID(B,ID)
         implicit none
         type(boundary),intent(inout) :: B
         integer,intent(in) :: ID
         call init_periodic(B%SB(ID)%bct)
         call define_logicals(B)
         B%BCL%BCT_defined = .true.
       end subroutine

       subroutine init_symmetric_all(B)
         implicit none
         type(boundary),intent(inout) :: B
         integer :: i
         do i=1,B%n; call init_symmetric(B,i); enddo
       end subroutine
       subroutine init_symmetric_ID(B,ID)
         implicit none
         type(boundary),intent(inout) :: B
         integer,intent(in) :: ID
         call init_symmetric(B%SB(ID)%bct)
         call define_logicals(B)
         B%BCL%BCT_defined = .true.
       end subroutine

       subroutine init_antisymmetric_all(B)
         implicit none
         type(boundary),intent(inout) :: B
         integer :: i
         do i=1,B%n; call init_antisymmetric(B,i); enddo
       end subroutine
       subroutine init_antisymmetric_ID(B,ID)
         implicit none
         type(boundary),intent(inout) :: B
         integer,intent(in) :: ID
         call init_antisymmetric(B%SB(ID)%bct)
         call define_logicals(B)
         B%BCL%BCT_defined = .true.
       end subroutine

       subroutine set_prescribed_all(B)
         implicit none
         type(boundary),intent(inout) :: B
         integer :: i
         do i=1,B%n; call set_prescribed(B,i); enddo
       end subroutine
       subroutine set_prescribed_ID(B,ID)
         implicit none
         type(boundary),intent(inout) :: B
         integer,intent(in) :: ID
         call set_prescribed(B%SB(ID)%bct)
         call define_logicals(B)
       end subroutine

       ! *******************************************************************************
       ! ********************************* AUXILIARY ***********************************
       ! *******************************************************************************

       subroutine insist_allocated_boundary(B,caller)
         implicit none
         type(boundary),intent(in) :: B
         character(len=*),intent(in) :: caller
         if (.not.(allocated(B%SB).and.(size(B%SB).eq.B%n))) then
           write(*,*) 'Error: trying to copy unallocated BCs in '//caller//'in boundary.f90'
           write(*,*) 'size(B%SB) = ',size(B%SB)
           stop 'Done'
         endif
       end subroutine

       subroutine define_logicals_boundary(B)
         implicit none
         type(boundary),intent(inout) :: B
         integer :: i
         B%BCL%defined = B%BCL%GFs_defined.and.B%BCL%BCT_defined.and.B%BCL%vals_defined
         B%BCL%all_Dirichlet = all((/(is_Dirichlet(B%SB(i)%bct),i=1,B%n)/))
         B%BCL%all_Robin     = all((/(is_Robin(B%SB(i)%bct),i=1,B%n)/))
         B%BCL%all_Neumann   = all((/(is_Neumann(B%SB(i)%bct),i=1,B%n)/))

         B%BCL%any_Dirichlet = any((/(is_Dirichlet(B%SB(i)%bct),i=1,B%n)/))
         B%BCL%any_Robin     = any((/(is_Robin(B%SB(i)%bct),i=1,B%n)/))
         B%BCL%any_Neumann   = any((/(is_Neumann(B%SB(i)%bct),i=1,B%n)/))
         B%BCL%any_Prescribed= any((/(is_prescribed(B%SB(i)%bct),i=1,B%n)/))
       end subroutine

       function get_all_Neumann_B(B) result(L)
         implicit none
         type(boundary),intent(inout) :: B
         logical :: L
         L = B%BCL%all_Neumann
       end function

       function get_all_Dirichlet_B(B) result(L)
         implicit none
         type(boundary),intent(inout) :: B
         logical :: L
         L = B%BCL%all_Dirichlet
       end function

       function get_all_Robin_B(B) result(L)
         implicit none
         type(boundary),intent(inout) :: B
         logical :: L
         L = B%BCL%all_Robin
       end function

       function get_any_Neumann_B(B) result(L)
         implicit none
         type(boundary),intent(inout) :: B
         logical :: L
         L = B%BCL%any_Neumann
       end function

       function get_any_Dirichlet_B(B) result(L)
         implicit none
         type(boundary),intent(inout) :: B
         logical :: L
         L = B%BCL%any_Dirichlet
       end function

       function get_any_Robin_B(B) result(L)
         implicit none
         type(boundary),intent(inout) :: B
         logical :: L
         L = B%BCL%any_Robin
       end function

       function get_any_prescribed_B(B) result(L)
         implicit none
         type(boundary),intent(inout) :: B
         logical :: L
         L = B%BCL%any_prescribed
       end function

       subroutine restrict_B(B,g,DL,dir,x,y,z,n)
         implicit none
         integer,intent(in) :: n,dir,x,y,z
         type(boundary),intent(inout) :: B
         type(grid),dimension(n),intent(in) :: g
         type(data_location),intent(in) :: DL
         integer :: i
         do i=1,B%n; call restrict(B%SB(i),g(i),DL,dir,x,y,z); enddo
         do i=1,B%n; call restrict(B%SB(i),g(i),DL,dir,x,y,z); enddo
       end subroutine

       subroutine prolongate_B(B,g,DL,dir,x,y,z,n)
         implicit none
         type(boundary),intent(inout) :: B
         integer,intent(in) :: n,dir,x,y,z
         type(grid),dimension(n),intent(in) :: g
         type(data_location),intent(in) :: DL
         integer :: i
         do i=1,B%n; call prolongate(B%SB(i),g(i),DL,dir,x,y,z); enddo
         do i=1,B%n; call prolongate(B%SB(i),g(i),DL,dir,x,y,z); enddo
       end subroutine

       end module
       module generate_mesh_generic_mod
       use current_precision_mod
       use mesh_params_mod
       use grid_init_mod
       use grid_continue_mod
       use grid_connect_mod
       use coordinate_stretch_parameters_mod
       use dimensionless_params_mod
       use string_mod
       use grid_mod
       use mesh_extend_mod
       use mesh_quality_params_mod
       implicit none

       private
       public :: generate_mesh_generic

       contains

       subroutine generate_mesh_generic(m,MP,DP,caller)
         implicit none
         type(mesh),intent(inout) :: m
         type(dimensionless_params),intent(in) :: DP
         type(mesh_params),intent(in) :: MP
         character(len=*),intent(in) :: caller
         type(string) :: d
         type(mesh_quality_params) :: MQP
         type(grid) :: g
         real(cp) :: a,b,L,beta,tau,yc,buffer
         integer :: j,N_cells,dir
         call init(MQP,MP%MQP)
         if (MP%n_base.gt.0) then
           do j=1,MP%n_base
             call init(d,MP%s_base(j)%distribution)
             a = MP%s_base(j)%hmin
             b = MP%s_base(j)%hmax
             N_cells = MP%s_base(j)%N_cells
             dir = MP%s_base(j)%dir
             tau = MP%s_base(j)%tau
             yc = MP%s_base(j)%yc
             buffer = MP%s_base(j)%buffer
             beta = Re_Ha_BL_1D(DP%Re*buffer,DP%Ha*buffer,a,b)
             if (N_cells.gt.0) then

                 if (str(d).eq.'grid_uniform') then;            call grid_uniform(g,a,b,N_cells,dir)
             elseif (str(d).eq.'grid_Roberts_L') then;          call grid_Roberts_L(g,a,b,N_cells,beta,dir,MQP)
             elseif (str(d).eq.'grid_Roberts_R') then;          call grid_Roberts_R(g,a,b,N_cells,beta,dir,MQP)
             elseif (str(d).eq.'grid_Roberts_B') then;          call grid_Roberts_B(g,a,b,N_cells,beta,dir,MQP)
             elseif (str(d).eq.'grid_cluster') then;            call grid_cluster(g,a,b,N_cells,yc,tau,dir,MQP)
             else
             write(*,*) 'Error: bad distribution in mesh base '//caller// ' for mesh '//str(d)
             stop 'Done in generate_mesh_generic.f90'
             endif

             endif
           enddo
         endif
         if (MP%n_ext.gt.0) then
           do j=1,MP%n_ext
             call init(d,MP%s_ext(j)%distribution)
             a = MP%s_ext(j)%hmin
             b = MP%s_ext(j)%hmax
             L = MP%s_ext(j)%L
             N_cells = MP%s_ext(j)%N_cells
             tau = MP%s_ext(j)%tau
             buffer = MP%s_ext(j)%buffer
             beta = Re_Ha_BL_1D(DP%Re*buffer,DP%Ha*buffer,a,b)
             dir = MP%s_ext(j)%dir
             if (N_cells.gt.0) then
                   if (str(d).eq.'ext_uniform_IO') then;          call ext_uniform_IO(g,N_cells,dir)
               elseif (str(d).eq.'ext_Roberts_near_IO') then;     call ext_Roberts_near_IO(g,L,N_cells,dir,MQP)
               elseif (str(d).eq.'ext_Roberts_far_IO') then;      call ext_Roberts_far_IO(g,L,N_cells,dir,MQP)
               elseif (str(d).eq.'ext_Roberts_B_IO') then;        call ext_Roberts_B_IO(g,L,N_cells,dir,MQP)
               elseif (str(d).eq.'ext_prep_uniform_IO') then;     call ext_prep_uniform_IO(g,N_cells,dir)
               elseif (str(d).eq.'ext_prep_Roberts_L_IO') then;   call ext_prep_Roberts_L_IO(g,L,N_cells,dir,MQP)
               elseif (str(d).eq.'ext_prep_Roberts_R_IO') then;   call ext_prep_Roberts_R_IO(g,L,N_cells,dir,MQP)
               elseif (str(d).eq.'ext_prep_Roberts_B_IO') then;   call ext_prep_Roberts_B_IO(g,L,N_cells,dir,MQP)
               elseif (str(d).eq.'ext_app_uniform_IO') then;      call ext_app_uniform_IO(g,N_cells,dir)
               elseif (str(d).eq.'ext_app_Roberts_L_IO') then;    call ext_app_Roberts_L_IO(g,L,N_cells,dir,MQP)
               elseif (str(d).eq.'ext_app_Roberts_R_IO') then;    call ext_app_Roberts_R_IO(g,L,N_cells,dir,MQP)
               elseif (str(d).eq.'ext_app_Roberts_B_IO') then;    call ext_app_Roberts_B_IO(g,L,N_cells,dir,MQP)
               elseif (str(d).eq.'ext_app_Roberts_C2F_IO') then;  call ext_app_Roberts_C2F_IO(g,L,N_cells,dir,MQP)
               elseif (str(d).eq.'ext_prep_Roberts_C2F_IO') then; call ext_prep_Roberts_C2F_IO(g,L,N_cells,dir,MQP)
               else
               write(*,*) 'Error: bad distribution in mesh extend '//caller// ' for mesh '//str(d)
               stop 'Done in generate_mesh_generic.f90'
               endif
             endif
           enddo
         endif
         call add(m,g)
         call init_props(m)
         call patch(m)
         call delete(g)
         call delete(MQP)
         call delete(d)
       end subroutine

       end module
       module mesh_block_extend_mod
       use mesh_block_mod
       ! This module is used to export the block to visualize
       ! each grid on the block (all FECs).
       use mesh_extend_mod
       use block_extend_mod
       use block_mod
       use IO_tools_mod
       implicit none

       private
       public :: mesh_block
       public :: init,delete,display,print,export,import ! Essentials

       interface init;   module procedure init_mesh_block;   end interface

       contains

       subroutine init_mesh_block(MB,B)
         implicit none
         type(mesh_block),intent(inout) :: MB
         type(block),intent(in) :: B
         type(block) :: temp
         integer :: i
         call delete(MB%m)
         call delete(MB%B)
         call init(MB%m,B%g)
         call init(temp,B%g)
         call init_FEC(temp)
         do i=1,6;  call add(MB%m,temp%f(i)); enddo
         ! do i=1,12; call add(MB%m,temp%e(i)); enddo
         ! do i=1,8;  call add(MB%m,temp%c(i)); enddo

         ! do i=1,6;  call add(MB%m,temp%fb(i)); enddo
         ! do i=1,12; call add(MB%m,temp%eb(i)); enddo
         ! do i=1,8;  call add(MB%m,temp%cb(i)); enddo
         call delete(temp)
       end subroutine

       end module
       module physical_domain_extend_mod
       use physical_domain_mod
       use current_precision_mod
       use mesh_mod
       use mesh_extend_mod
       use IO_tools_mod
       use datatype_conversion_mod
       use physical_sub_domain_mod
       use physical_sub_domain_extend_mod
       use data_location_extend_mod
       use grid_mod
       use mesh_extend_mod
       implicit none

       private
       public :: init,display,print

       public :: add,init_mixed

       public :: pick_extrema_bot
       public :: pick_extrema_top

       interface init;             module procedure init_PD_mesh;            end interface
       interface init;             module procedure init_PD_grid;            end interface
       interface print;            module procedure print_PD;                end interface

       interface add;              module procedure add_physical_sub_domain; end interface
       interface add;              module procedure add_PD_grid;             end interface

       interface init_mixed;       module procedure init_mixed_PD;           end interface

       interface pick_extrema_bot; module procedure pick_extrema_bot_PD;     end interface
       interface pick_extrema_top; module procedure pick_extrema_top_PD;     end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_PD_mesh(D,m_R1,m_R2)
         implicit none
         type(physical_domain),intent(inout) :: D
         type(mesh),intent(in) :: m_R1,m_R2
         type(physical_sub_domain) :: temp
         integer :: j,k
         call delete(D)
         ! Make all possible/necessary physical_sub_domains:
         if (m_R2%s.gt.m_R1%s) then
           do k=1,m_R2%s; do j=1,m_R1%s
             call init(temp,m_R1%B(j)%g,m_R2%B(k)%g,j,k)
             if (temp%defined) call add(D,temp)
           enddo; enddo
         else
           do k=1,m_R1%s; do j=1,m_R2%s
             call init(temp,m_R1%B(k)%g,m_R2%B(j)%g,k,j)
             if (temp%defined) call add(D,temp)
           enddo; enddo
         endif
         D%defined = size(D%sd).gt.0
       end subroutine

       subroutine init_PD_grid(D,g_R1,g_R2,g_id_1,g_id_2)
         implicit none
         type(physical_domain),intent(inout) :: D
         type(grid),intent(in) :: g_R1,g_R2
         integer,intent(in) :: g_id_1,g_id_2
         call delete(D)
         call add(D,g_R1,g_R2,g_id_1,g_id_2)
         D%defined = size(D%sd).gt.0
       end subroutine

       subroutine init_mixed_PD(D,DL)
         implicit none
         type(physical_domain),intent(inout) :: D
         type(data_location),intent(in) :: DL
         integer :: i
         if (D%defined) then
           do i=1,D%s; call init_mixed(D%sd(i),DL); enddo
         endif
       end subroutine

       subroutine print_PD(D,name)
         implicit none
         type(physical_domain),intent(in) :: D
         character(len=*),intent(in) :: name
         integer :: i
         write(*,*) 'N-physical_sub_domains = ',D%s
         do i=1,D%s; call print(D%sd(i),name//'_'//int2str(i)); enddo
       end subroutine

       ! **********************************************************
       ! **********************************************************
       ! **********************************************************

       subroutine add_PD_grid(D,g_R1,g_R2,g_id_1,g_id_2)
         implicit none
         type(physical_domain),intent(inout) :: D
         type(grid),intent(in) :: g_R1,g_R2
         integer,intent(in) :: g_id_1,g_id_2
         type(physical_sub_domain) :: temp
         call init(temp,g_R1,g_R2,g_id_1,g_id_2)
         if (temp%defined) call add(D,temp)
         call delete(temp)
         D%defined = size(D%sd).gt.0
       end subroutine

       subroutine add_physical_sub_domain(D,sd)
         implicit none
         type(physical_domain),intent(inout) :: D
         type(physical_sub_domain),intent(in) :: sd
         type(physical_domain) :: temp
         integer :: i
         if (.not.allocated(D%sd)) then
           D%s = 1
           allocate(D%sd(D%s))
           call init(D%sd(D%s),sd)
         else
           call init(temp,D)
           call delete(D)
           D%s = temp%s + 1
           allocate(D%sd(D%s))
           do i=1,D%s-1; call init(D%sd(i),temp%sd(i)); enddo
           call init(D%sd(D%s),sd)
           call delete(temp)
         endif
         D%defined = size(D%sd).gt.0
       end subroutine

       subroutine pick_extrema_bot_PD(D,i,dir)
         implicit none
         type(physical_domain),intent(inout) :: D
         integer,intent(in) :: i,dir
         call pick_extrema_bot(D%sd(i),dir)
       end subroutine

       subroutine pick_extrema_top_PD(D,i,dir)
         implicit none
         type(physical_domain),intent(inout) :: D
         integer,intent(in) :: i,dir
         call pick_extrema_top(D%sd(i),dir)
       end subroutine

       end module
       module procedure_array_extend_mod
       use procedure_array_mod
       use IO_tools_mod
       use single_procedure_mod
       use single_procedure_extend_mod
       use apply_BCs_faces_bridge_mod
       use apply_face_BC_op_mod

       implicit none
       private
       public :: init

       public :: add,remove,check_unique,sort
       public :: add_PA
       public :: insist_allocated
       public :: insist_defined

       interface init;             module procedure init_PA;             end interface
       interface insist_defined;   module procedure insist_defined_PA;   end interface
       interface insist_allocated; module procedure insist_allocated_PA; end interface

       interface add;              module procedure add_PA;              end interface
       interface add;              module procedure add_PA_SP;           end interface
       interface remove;           module procedure remove_PA;           end interface
       interface check_unique;     module procedure check_unique_PA;     end interface
       interface sort;             module procedure sort_PA;             end interface

       contains

       subroutine init_PA(PA,N)
         implicit none
         type(procedure_array),intent(inout) :: PA
         integer,intent(in) :: N
         call delete(PA)
         if (N.lt.1) stop 'Error: N must > 1 in init_PA in procedure_array.f90'
         allocate(PA%SP(N))
         PA%N = N
         PA%defined = .false.
       end subroutine

       ! *****************************************************************
       ! ***************************** OTHER *****************************
       ! *****************************************************************

       subroutine add_PA(PA,P,ID)
         implicit none
         type(procedure_array),intent(inout) :: PA
         procedure(apply_face_BC_op) :: P
         integer,intent(in) :: ID
         type(procedure_array) :: temp
         integer :: i
         if (PA%defined) then
           if (.not.in_set_array((/(PA%SP(i)%ID,i=1,PA%N)/),ID,PA%N,'add_PA')) then
             call init(temp,PA)
             call init(PA,temp%N+1)
             do i=1,temp%N; call init(PA%SP(i),temp%SP(i)); enddo
             i = PA%N
             call init(PA%SP(i),P,ID)
             call delete(temp)
           endif
         else
           call init(PA,1)
           call init(PA%SP(1),P,ID)
         endif
         PA%defined = .true.
       end subroutine

       subroutine add_PA_SP(PA,SP)
         implicit none
         type(procedure_array),intent(inout) :: PA
         type(single_procedure),intent(in) :: SP
         call add(PA,SP%P,SP%ID)
       end subroutine

       subroutine remove_PA(PA,ID)
         implicit none
         type(procedure_array),intent(inout) :: PA
         integer,intent(in) :: ID
         type(procedure_array) :: temp
         integer :: i
         if (PA%defined) then
           call delete(temp)
           do i=1,PA%N
             if (PA%SP(i)%ID.ne.ID) call add(temp,PA%SP(i))
           enddo
           call init(PA,temp)
           call delete(temp)
         else; call delete(PA)
         endif
       end subroutine

       subroutine check_unique_PA(PA,caller)
         implicit none
         type(procedure_array),intent(in) :: PA
         character(len=*),intent(in) :: caller
         integer :: i,j,violating_ID
         logical :: unique_set
         unique_set = .true.; violating_ID = 0
         do i=1,PA%N; do j=i,PA%N
         if (i.ne.j) then
         if (PA%SP(i)%ID.eq.PA%SP(j)%ID) then
           unique_set = .false.
           violating_ID = i
         endif
         endif
         enddo; enddo
         if (.not.unique_set) then
           write(*,*) 'Error: too many BCs in procedure_array in ',caller,' in procedure_array.f90'
           write(*,*) 'violating_ID = ',violating_ID
           call print(PA)
           stop 'Done'
         endif
       end subroutine

       subroutine check_unique_array(a,N,caller)
         implicit none
         integer,intent(in) :: N
         integer,dimension(N),intent(in) :: a
         character(len=*),intent(in) :: caller
         if (.not.unique_array(a,N,caller)) then
           write(*,*) 'Error: non-unique array in ',caller,' in procedure_array.f90'
           write(*,*) 'N = ',N
           write(*,*) 'a = ',a
           stop 'Done'
         endif
       end subroutine

       function unique_array(a,N,caller) result(L_all)
         implicit none
         integer,intent(in) :: N
         integer,dimension(N),intent(in) :: a
         character(len=*),intent(in) :: caller
         logical,dimension(N) :: match
         logical :: L_all
         integer :: i,j
         if ((N.lt.1).or.(size(a).ne.N)) then
           write(*,*) 'Error: bad array size in ',caller,' in procedure_array.f90'; stop 'Done'
         endif
         match = .false.
         do i=1,N;do j=1,N
         if (i.ne.j) match(i) = a(j).eq.a(i)
         enddo; enddo
         L_all = .not.any(match)
       end function

       function in_set_array(a,i,N,caller) result(L_any)
         implicit none
         integer,intent(in) :: N,i
         integer,dimension(N),intent(in) :: a
         character(len=*),intent(in) :: caller
         logical,dimension(N) :: L
         logical :: L_any
         integer :: j
         if ((N.lt.1).or.(size(a).ne.N)) then
           write(*,*) 'Error: bad array size in ',caller,' in procedure_array.f90'; stop 'Done'
         endif
         do j=1,N; L(j) = a(j).eq.i; enddo
         L_any = any(L)
       end function

       subroutine sort_PA(PA,order,N)
         implicit none
         type(procedure_array),intent(inout) :: PA
         integer,intent(in) :: N
         integer,dimension(N),intent(in) :: order
         type(procedure_array) :: temp
         integer :: i,j
         if (PA%N.lt.1) then
           call delete(PA)
         else
           call check_unique(PA,'sort_PA')
           call check_unique_array(order,N,'sort_PA')
           call init(temp,PA)
           call delete(PA)
           do i=1,N; do j=1,temp%N
             if (temp%SP(j)%ID.eq.order(i)) call add(PA,temp%SP(j))
           enddo; enddo
           call delete(temp)
         endif
       end subroutine

       subroutine insist_defined_PA(PA,caller)
         implicit none
         type(procedure_array),intent(in) :: PA
         character(len=*),intent(in) :: caller
         integer :: i
         do i=1,PA%N
         call insist_defined(PA%SP(i),caller)
         enddo
         if (.not.PA%defined) then
           write(*,*) 'Error: PA must be defined in ',caller,' in procedure_array.f90'
           stop 'Done'
         endif
       end subroutine

       subroutine insist_allocated_PA(PA,caller)
         implicit none
         type(procedure_array),intent(in) :: PA
         character(len=*),intent(in) :: caller
         if (.not.allocated(PA%SP)) then
           write(*,*) 'Error: PA must be allocated in ',caller,' in procedure_array.f90'
           stop 'Done'
         endif
       end subroutine

       end module
       module boundary_conditions_extend_mod
       use boundary_conditions_mod
       ! Making BCs is a 3 step process:
       !
       !       1) Set the block
       !             call init(BCs,B)
       !       2) Set type (can use grid information)
       !             call init_Dirichlet(BCs); call init_Dirichlet(BCs,face)
       !             call init_Neumann(BCs);   call init_Neumann(BCs,face)
       !             call init_periodic(BCs);  call init_periodic(BCs,face)
       !       3) Set values
       !             call init(BCs,0.0_cp)       (default)
       !             call init(BCs,0.0_cp,face)
       !             call init(BCs,vals,face)
       !
       ! The convention for the faces is:
       !   face = {1:6} = {x_min,x_max,y_min,y_max,z_min,z_max}
       !
       !
       !
       !
       !              ^
       !              |
       !              |
       !              |-------------/
       !             /             / |
       !            /             /  |
       !           /             /   |
       !          |--------------    |____________>
       !          |             |   /
       !          |             |  /
       !          |             | /
       !          |_____________|/
       !         /
       !        /
       !       /
       !

       use current_precision_mod
       use face_edge_corner_indexing_mod
       use data_location_extend_mod
       use grid_mod
       use block_extend_mod
       use block_mod
       use string_mod
       use face_SD_mod
       use face_SD_extend_mod
       use GF_mod
       use bctype_extend_mod
       use BC_logicals_mod
       use IO_tools_mod
       use table_mod
       use boundary_mod
       use boundary_extend_mod
       use procedure_array_mod
       use procedure_array_extend_mod
       use apply_face_BC_op_mod
       use apply_BCs_faces_bridge_mod
       use apply_BCs_faces_bridge_implicit_mod
       implicit none

       private
       public :: init ! Essentials

       ! Setters for type
       public :: init_Dirichlet
       public :: init_Neumann
       public :: init_Robin
       public :: init_periodic
       public :: init_symmetric
       public :: init_antisymmetric

       public :: set_prescribed

       public :: init_PA_face

       public :: get_all_Dirichlet
       public :: get_all_Neumann
       public :: get_all_Robin
       public :: get_any_Dirichlet
       public :: get_any_Neumann
       public :: get_any_Robin
       public :: get_any_Prescribed

       public :: init_props
       public :: defined
       public :: insist_allocated

       public :: restrict
       public :: prolongate

       interface init;               module procedure init_GFs_BCs_DL;         end interface

       interface init;               module procedure init_vals_all_S;         end interface
       interface init;               module procedure init_vals_face_GF;       end interface
       interface init;               module procedure init_val_face_S;         end interface

       interface defined;            module procedure defined_BCs;             end interface
       interface init_Dirichlet;     module procedure init_Dirichlet_all;      end interface
       interface init_Dirichlet;     module procedure init_Dirichlet_face;     end interface
       interface init_Neumann;       module procedure init_Neumann_all;        end interface
       interface init_Neumann;       module procedure init_Neumann_face;       end interface
       interface init_Robin;         module procedure init_Robin_all;          end interface
       interface init_Robin;         module procedure init_Robin_face;         end interface
       interface init_periodic;      module procedure init_periodic_all;       end interface
       interface init_periodic;      module procedure init_periodic_face;      end interface
       interface init_symmetric;     module procedure init_symmetric_all;      end interface
       interface init_symmetric;     module procedure init_symmetric_face;     end interface
       interface init_antisymmetric; module procedure init_antisymmetric_all;  end interface
       interface init_antisymmetric; module procedure init_antisymmetric_face; end interface
       interface set_prescribed;     module procedure set_prescribed_all;      end interface
       interface set_prescribed;     module procedure set_prescribed_face;     end interface
       interface init_PA_face;       module procedure init_PA_face_BC;         end interface

       interface get_all_Dirichlet;  module procedure get_all_Dirichlet_BCs;   end interface
       interface get_all_Neumann;    module procedure get_all_Neumann_BCs;     end interface
       interface get_all_Robin;      module procedure get_all_Robin_BCs;       end interface
       interface get_any_Dirichlet;  module procedure get_any_Dirichlet_BCs;   end interface
       interface get_any_Neumann;    module procedure get_any_Neumann_BCs;     end interface
       interface get_any_Robin;      module procedure get_any_Robin_BCs;       end interface
       interface get_any_Prescribed; module procedure get_any_Prescribed_BCs;  end interface

       interface define_logicals;    module procedure define_logicals_BCs;     end interface
       interface insist_allocated;   module procedure insist_allocated_BCs;    end interface

       interface init_props;         module procedure init_props_BCs;          end interface

       interface restrict;           module procedure restrict_BCs;            end interface
       interface prolongate;         module procedure prolongate_BCs;          end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_GFs_BCs_DL(BC,B,DL)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         type(block),intent(in) :: B
         type(data_location),intent(in) :: DL
         call delete(BC)
         call init(BC%face,B,DL,6,'face')
         ! call init(BC%edge,B,DL,12,'edge')
         ! call init(BC%corner,B,DL,8,'corner')
         BC%apply_BC_order = B%apply_BC_order
         call init(BC%DL,DL)
         call init(BC%f_BCs,B%g,B%f)
         ! call init(BC%e_BCs,B%g,B%e)
         ! call init(BC%c_BCs,B%g,B%c)
         call init_mixed(BC%f_BCs,DL)
         call init_vals_all_S(BC,0.0_cp)
         BC%BCL%GFs_defined = .true.
         call define_logicals(BC)
       end subroutine

       subroutine init_vals_all_S(BC,val)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         real(cp),intent(in) :: val
         call init(BC%face,val)
         ! call init(BC%edge,val)
         ! call init(BC%corner,val)
         call define_logicals(BC)
         BC%BCL%vals_defined = .true.
       end subroutine

       subroutine init_vals_face_GF(BC,vals,face)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         type(grid_field),intent(in) :: vals
         integer,intent(in) :: face
         ! call assign(BC%face(ID)%b,vals)
         call assign(BC%face%SB(face)%b,vals)
         call assign(BC%face%SB(face)%b_total,vals)
         call assign(BC%face%SB(face)%b_modified,0.0_cp)
         BC%BCL%vals_defined = .true.
         call define_logicals(BC)
       end subroutine

       subroutine init_val_face_S(BC,val,face)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         real(cp),intent(in) :: val
         integer,intent(in) :: face
         ! call assign(BC%face(ID)%b,val)
         call assign(BC%face%SB(face)%b,val)
         call assign(BC%face%SB(face)%b_total,val)
         call assign(BC%face%SB(face)%b_modified,0.0_cp)
         BC%BCL%vals_defined = .true.
         call define_logicals(BC)
       end subroutine

       ! *******************************************************************************
       ! ********************************* INIT FACES **********************************
       ! *******************************************************************************

       function defined_BCs(BC) result(d)
         implicit none
         type(boundary_conditions),intent(in) :: BC
         logical :: d
         d = BC%BCL%defined
       end function

       subroutine init_Dirichlet_all(BC)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer :: i
         do i=1,6; call init_Dirichlet_face(BC,i); enddo
       end subroutine
       subroutine init_Dirichlet_face(BC,face)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer,intent(in) :: face
         integer :: dir
         dir = dir_given_face(face)
         call check_prereq(BC)
         call init_Dirichlet(BC%face,face)
         call init_PA_face(BC,face)
         call define_logicals(BC)
         BC%BCL%BCT_defined = .true.
       end subroutine

       subroutine init_Neumann_all(BC)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer :: i
         do i=1,6; call init_Neumann(BC,i); enddo
       end subroutine
       subroutine init_Neumann_face(BC,face)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer,intent(in) :: face
         integer :: dir
         dir = dir_given_face(face)
         call check_prereq(BC)
         call init_Neumann(BC%face,face)
         call init_PA_face(BC,face)
         BC%BCL%BCT_defined = .true.
         call define_logicals(BC)
       end subroutine

       subroutine init_Robin_all(BC)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer :: i
         do i=1,6; call init_Robin_face(BC,i); enddo
       end subroutine
       subroutine init_Robin_face(BC,face)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer,intent(in) :: face
         integer :: dir
         dir = dir_given_face(face)
         call check_prereq(BC)
         call init_Robin(BC%face,face)
         call init_PA_face(BC,face)
         BC%BCL%BCT_defined = .true.
         call define_logicals(BC)
       end subroutine

       subroutine init_Periodic_all(BC)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer :: i
         do i=1,6; call init_Periodic_face(BC,i); enddo
       end subroutine
       subroutine init_Periodic_face(BC,face)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer,intent(in) :: face
         integer :: dir
         dir = dir_given_face(face)
         call check_prereq(BC)
         call init_Periodic(BC%face,face)
         call init_PA_face(BC,face)
         BC%BCL%BCT_defined = .true.
         call define_logicals(BC)
       end subroutine

       subroutine init_symmetric_all(BC)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer :: i
         do i=1,6; call init_symmetric_face(BC,i); enddo
       end subroutine
       subroutine init_symmetric_face(BC,face)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer,intent(in) :: face
         integer :: dir
         dir = dir_given_face(face)
         call check_prereq(BC)
         call init_Symmetric(BC%face,face)
         call init_PA_face(BC,face)
         BC%BCL%BCT_defined = .true.
         call define_logicals(BC)
       end subroutine

       subroutine init_antisymmetric_all(BC)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer :: i
         do i=1,6; call init_antisymmetric_face(BC,i); enddo
       end subroutine
       subroutine init_antisymmetric_face(BC,face)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer,intent(in) :: face
         integer :: dir
         dir = dir_given_face(face)
         call check_prereq(BC)
         call init_antisymmetric(BC%face,face)
         call init_PA_face(BC,face)
         BC%BCL%BCT_defined = .true.
         call define_logicals(BC)
       end subroutine

       subroutine set_prescribed_all(BC)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer :: i
         do i=1,6; call set_prescribed(BC,i); enddo
       end subroutine
       subroutine set_prescribed_face(BC,face)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer,intent(in) :: face
         integer :: dir
         dir = dir_given_face(face)
         call check_prereq(BC)
         call set_prescribed(BC%face,face)
         call define_logicals(BC)
       end subroutine

       subroutine init_PA_face_BC(BC,face)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         integer,intent(in) :: face
         integer :: dir
         dir = dir_given_face(face)
         call check_prereq(BC)
         call remove(BC%PA_face_BCs,face)
         call remove(BC%PA_face_implicit_BCs,face)
         if (CC_along(BC%DL,dir)) then
           if (is_prescribed(BC%face%SB(face)%bct)) then
             if (is_Dirichlet(BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Dirichlet_C,face)
             if (is_Neumann(  BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Neumann_C  ,face)
             if (is_Periodic( BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Periodic_C_prescribed ,face)
             if (is_Robin(    BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Robin_C  ,face)
             if (is_Dirichlet(BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Dirichlet_C_implicit,face)
             if (is_Neumann(  BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Neumann_C_implicit  ,face)
             if (is_Periodic( BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Periodic_C_implicit ,face)
             if (is_Robin(    BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Robin_C_implicit,face)
           else
             if (is_Dirichlet(BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Dirichlet_C,face)
             if (is_Neumann(  BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Neumann_C  ,face)
             if (is_Periodic( BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Periodic_C ,face)
             if (is_Robin(    BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Robin_C ,face)
             if (is_Dirichlet(BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Dirichlet_C_implicit,face)
             if (is_Neumann(  BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Neumann_C_implicit  ,face)
             if (is_Periodic( BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Periodic_C_implicit ,face)
             if (is_Robin(    BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Robin_C_implicit    ,face)
           endif
         elseif ( N_along(BC%DL,dir)) then
           if (is_prescribed(BC%face%SB(face)%bct)) then
             if (is_Dirichlet(BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Dirichlet_N,face)
             if (is_Neumann(  BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Neumann_N  ,face)
             if (is_Periodic( BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Periodic_N_prescribed,face)
             if (is_Robin(    BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Robin_N    ,face)
             if (is_Dirichlet(BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Dirichlet_N_implicit,face)
             if (is_Neumann(  BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Neumann_N_implicit  ,face)
             if (is_Periodic( BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Periodic_N_implicit ,face)
             if (is_Robin(    BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Robin_N_implicit    ,face)
           else
             if (is_Dirichlet(BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Dirichlet_N,face)
             if (is_Neumann(  BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Neumann_N  ,face)
             if (is_Periodic( BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Periodic_N ,face)
             if (is_Robin(    BC%face%SB(face)%bct)) call add_PA(BC%PA_face_BCs,Robin_N    ,face)
             if (is_Dirichlet(BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Dirichlet_N_implicit,face)
             if (is_Neumann(  BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Neumann_N_implicit  ,face)
             if (is_Periodic( BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Periodic_N_implicit ,face)
             if (is_Robin(    BC%face%SB(face)%bct)) call add_PA(BC%PA_face_implicit_BCs,Robin_N_implicit    ,face)
           endif
           else; stop 'Error: bad DL in init_PA_face_BC in boundary_conditions.f90'
         endif
       end subroutine

       ! *******************************************************************************
       ! ********************************* INIT EDGES **********************************
       ! *******************************************************************************

       ! *******************************************************************************
       ! ********************************* AUXILIARY ***********************************
       ! *******************************************************************************

       subroutine check_prereq(BC)
         implicit none
         type(boundary_conditions),intent(in) :: BC
         if (.not.BC%BCL%GFs_defined) stop 'Error: BC GFs must be defined before type is defined in boundary_conditions.f90'
       end subroutine

       subroutine insist_allocated_BCs(BC,caller)
         implicit none
         type(boundary_conditions),intent(in) :: BC
         character(len=*),intent(in) :: caller
         if (.not.BC%BCL%defined) then
           write(*,*) 'Error: BC not defined in '//caller//' in boundary_conditions.f90'
           stop 'Done'
         endif
       end subroutine

       subroutine define_logicals_BCs(BC)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         logical,dimension(3) :: L
         BC%BCL%defined = BC%BCL%GFs_defined.and.BC%BCL%BCT_defined.and.BC%BCL%vals_defined

         L(1) = get_all_Dirichlet(BC%face)
         ! L(2) = get_all_Dirichlet(BC%edge)
         ! L(3) = get_all_Dirichlet(BC%corner)
         BC%BCL%all_Dirichlet = L(1) ! all()

         L(1) = get_all_Robin(BC%face)
         ! L(2) = get_all_Robin(BC%edge)
         ! L(3) = get_all_Robin(BC%corner)
         BC%BCL%all_Robin = L(1) ! all()

         L(1) = get_all_Neumann(BC%face)
         ! L(2) = get_all_Neumann(BC%edge)
         ! L(3) = get_all_Neumann(BC%corner)
         BC%BCL%all_Neumann = L(1) ! all()

         L(1) = get_any_Dirichlet(BC%face)
         ! L(2) = get_any_Dirichlet(BC%edge)
         ! L(3) = get_any_Dirichlet(BC%corner)
         BC%BCL%any_Dirichlet = L(1) ! any()

         L(1) = get_any_Robin(BC%face)
         ! L(2) = get_any_Robin(BC%edge)
         ! L(3) = get_any_Robin(BC%corner)
         BC%BCL%any_Robin = L(1) ! any()

         L(1) = get_any_Neumann(BC%face)
         ! L(2) = get_any_Neumann(BC%edge)
         ! L(3) = get_any_Neumann(BC%corner)
         BC%BCL%any_Neumann = L(1) ! any()

         L(1) = get_any_Prescribed(BC%face)
         ! L(2) = get_any_Prescribed(BC%edge)
         ! L(3) = get_any_Prescribed(BC%corner)
         BC%BCL%any_Prescribed = L(1) ! any()
       end subroutine

       function get_all_Dirichlet_BCs(BC) result(L)
         implicit none
         type(boundary_conditions),intent(in) :: BC
         logical :: L
         L = BC%BCL%all_Dirichlet
       end function

       function get_all_Neumann_BCs(BC) result(L)
         implicit none
         type(boundary_conditions),intent(in) :: BC
         logical :: L
         L = BC%BCL%all_Neumann
       end function

       function get_all_Robin_BCs(BC) result(L)
         implicit none
         type(boundary_conditions),intent(in) :: BC
         logical :: L
         L = BC%BCL%all_Robin
       end function

       function get_any_Dirichlet_BCs(BC) result(L)
         implicit none
         type(boundary_conditions),intent(in) :: BC
         logical :: L
         L = BC%BCL%any_Dirichlet
       end function

       function get_any_Neumann_BCs(BC) result(L)
         implicit none
         type(boundary_conditions),intent(in) :: BC
         logical :: L
         L = BC%BCL%any_Neumann
       end function

       function get_any_Robin_BCs(BC) result(L)
         implicit none
         type(boundary_conditions),intent(in) :: BC
         logical :: L
         L = BC%BCL%any_Robin
       end function

       function get_any_Prescribed_BCs(BC) result(L)
         implicit none
         type(boundary_conditions),intent(in) :: BC
         logical :: L
         L = BC%BCL%any_Prescribed
       end function

       subroutine init_props_BCs(BC,c_w,Robin_coeff)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         real(cp),intent(in),dimension(6) :: c_w,Robin_coeff
         call define_logicals(BC)
         call init_mixed(BC%f_BCs,BC%DL)
         call init_Robin_coeff(BC%f_BCs,c_w,Robin_coeff)
         call sort(BC%PA_face_BCs,BC%apply_BC_order,6)
         call sort(BC%PA_face_implicit_BCs,BC%apply_BC_order,6)
       end subroutine

       subroutine restrict_BCs(BC,B,dir)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         type(block),intent(in) :: B
         integer,intent(in) :: dir
         integer,dimension(3) :: eye
         integer :: x,y,z
         real(cp),dimension(6) :: c_w,Robin_coeff
         eye = eye_given_dir(dir)
         x = eye(1); y = eye(2); z = eye(3)
         if (BC%BCL%defined) then
           call restrict(BC%face,B%fb,BC%DL,dir,x,y,z,BC%face%n)
           ! call restrict(BC%edge,B%eb,BC%DL,dir,x,y,z,BC%edge%n)
           ! call restrict(BC%face,B%cb,BC%DL,dir,x,y,z,BC%corner%n)
           call init(BC%f_BCs,B%g,B%f)
           ! call init(BC%e_BCs,B%g,B%e)
           ! call init(BC%c_BCs,B%g,B%c)
           Robin_coeff = BC%f_BCs%Robin_coeff
           c_w = BC%f_BCs%c_w
           call init_props(BC,c_w,Robin_coeff)
         endif
       end subroutine

       subroutine prolongate_BCs(BC,B,dir)
         implicit none
         type(boundary_conditions),intent(inout) :: BC
         type(block),intent(in) :: B
         integer,intent(in) :: dir
         integer,dimension(3) :: eye
         integer :: x,y,z
         real(cp),dimension(6) :: c_w,Robin_coeff
         eye = eye_given_dir(dir)
         x = eye(1); y = eye(2); z = eye(3)
         if (BC%BCL%defined) then
           call prolongate(BC%face,B%fb,BC%DL,dir,x,y,z,BC%face%n)
           ! call prolongate(BC%edge,B%eb,BC%DL,dir,x,y,z,BC%edge%n)
           ! call prolongate(BC%face,B%cb,BC%DL,dir,x,y,z,BC%corner%n)
           call init(BC%f_BCs,B%g,B%f)
           ! call init(BC%e_BCs,B%g,B%e)
           ! call init(BC%c_BCs,B%g,B%c)
           Robin_coeff = BC%f_BCs%Robin_coeff
           c_w = BC%f_BCs%c_w
           call init_props(BC,c_w,Robin_coeff)
         endif
       end subroutine

       end module
      module block_field_extend_mod
        ! Compiler flags: (_PARALLELIZE_BF_PLANE_)
        use block_field_mod
        use current_precision_mod
        use grid_mod
        use block_mod
        use block_extend_mod
        use bctype_extend_mod
        use data_location_extend_mod
        use GF_mod
        use block_extend_mod
        use data_location_extend_mod
        use procedure_array_mod
        use procedure_array_extend_mod
        use procedure_array_plane_op_mod
        use procedure_array_plane_op_extend_mod
        use face_edge_corner_indexing_mod
        use boundary_conditions_mod
        use boundary_conditions_extend_mod
        implicit none
        private

        public :: init_CC
        public :: init_Face
        public :: init_Edge
        public :: init_Node

        public :: init_BCs
        public :: init_BC_props
        public :: set_procedures

        public :: inverse_area
        public :: volume
        public :: cosine_waves
        public :: sine_waves
        public :: random_noise

        public :: square,square_root,abs
        public :: insist_amax_lt_tol

        public :: assign_BCs
        public :: assign_BC_vals
        public :: update_BC_vals
        public :: assign_Neumann_BCs
        public :: assign_Neumann_BCs_wall_normal
        public :: multiply_Neumann_BCs
        public :: multiply_BCs_by_nhat
        public :: assign_Dirichlet_BCs
        public :: assign_Periodic_BCs
        public :: assign_Robin_BCs
        public :: multiply_Robin_coeff
        public :: multiply_nhat
        public :: assign_ghost_XPeriodic
        public :: assign_ghost_N_XPeriodic
        public :: assign_wall_Periodic_single
        public :: assign_wall_Dirichlet
        public :: multiply_wall_Neumann
        public :: set_prescribed_BCs
        public :: set_BCs_homogeneous

        public :: plane_sum_x
        public :: plane_sum_y
        public :: plane_sum_z
        public :: boundary_flux

        public :: mirror_about_hmin,mirror_about_hmax

        public :: assign_ghost_xmin_xmax
        public :: assign_ghost_ymin_ymax
        public :: assign_ghost_zmin_zmax

        public :: symmetry_error_x
        public :: symmetry_error_y
        public :: symmetry_error_z

        public :: symmetry_local_x
        public :: symmetry_local_y
        public :: symmetry_local_z

        public :: cross_product_x
        public :: cross_product_y
        public :: cross_product_z

        public :: CFL_number
        public :: dt_given_CFL_number
        public :: Fourier_number
        public :: Robin_BC_coeff

        public :: get_any_Dirichlet
        public :: get_any_Neumann
        public :: get_any_Robin
        public :: get_any_Prescribed

        public :: set_necessary_for_restart

        public :: restrict
        public :: prolongate

       interface init_CC;                     module procedure init_CC_BF;                      end interface
       interface init_Face;                   module procedure init_Face_BF;                    end interface
       interface init_Edge;                   module procedure init_Edge_BF;                    end interface
       interface init_Node;                   module procedure init_Node_BF;                    end interface

       interface init_BCs;                    module procedure init_BC_val;                     end interface
       interface init_BCs;                    module procedure init_BC_block_DL;                end interface
       interface init_BC_props;               module procedure init_BC_props_BF;                end interface
       interface set_procedures;              module procedure set_procedures_BF;               end interface
       interface set_necessary_for_restart;   module procedure set_necessary_for_restart_BF;    end interface

       interface inverse_area;                module procedure inverse_area_DL_BF;              end interface
       interface volume;                      module procedure volume_DL_BF;                    end interface
       interface volume;                      module procedure volume_BF;                       end interface
       interface cosine_waves;                module procedure cosine_waves_BF;                 end interface
       interface sine_waves;                  module procedure sine_waves_BF;                   end interface
       interface random_noise;                module procedure random_noise_BF;                 end interface
       interface random_noise;                module procedure random_noise_BF_dir;             end interface
       interface cross_product_x;             module procedure cross_product_x_BF;              end interface
       interface cross_product_y;             module procedure cross_product_y_BF;              end interface
       interface cross_product_z;             module procedure cross_product_z_BF;              end interface

       interface CFL_number;                  module procedure CFL_number_BF;                   end interface
       interface dt_given_CFL_number;         module procedure dt_given_CFL_number_BF;          end interface
       interface Fourier_number;              module procedure Fourier_number_BF;               end interface
       interface Robin_BC_coeff;              module procedure Robin_BC_coeff_BF;               end interface

       interface get_any_Dirichlet;           module procedure get_any_Dirichlet_BF;            end interface
       interface get_any_Neumann;             module procedure get_any_Neumann_BF;              end interface
       interface get_any_Robin;               module procedure get_any_Robin_BF;                end interface
       interface get_any_Prescribed;          module procedure get_any_Prescribed_BF;           end interface


       interface square;                      module procedure square_BF;                       end interface
       interface square_root;                 module procedure square_root_BF;                  end interface
       interface abs;                         module procedure abs_BF;                          end interface
       interface insist_amax_lt_tol;          module procedure insist_amax_lt_tol_BF;           end interface

       interface assign_BCs;                  module procedure assign_BCs_BF;                   end interface
       interface assign_BC_vals;              module procedure assign_BC_vals_BF;               end interface
       interface update_BC_vals;              module procedure update_BC_vals_BF;               end interface
       interface assign_Dirichlet_BCs;        module procedure assign_Dirichlet_BCs_BF;         end interface
       interface assign_Periodic_BCs;         module procedure assign_Periodic_BCs_BF;          end interface
       interface assign_Neumann_BCs;          module procedure assign_Neumann_BCs_faces_BF;     end interface
       interface assign_Neumann_BCs_wall_normal; module procedure assign_Neumann_BCs_wall_normal_BF;     end interface
       interface multiply_Neumann_BCs;        module procedure multiply_Neumann_BCs_BF;         end interface
       interface multiply_BCs_by_nhat;        module procedure multiply_BCs_by_nhat_BF;         end interface
       interface assign_Robin_BCs;            module procedure assign_Robin_BCs_faces_BF;       end interface
       interface assign_Robin_BCs;            module procedure assign_Robin_BCs_dir_BF;         end interface
       interface multiply_Robin_coeff;        module procedure multiply_Robin_coeff_BF;         end interface
       interface multiply_nhat;               module procedure multiply_nhat_BF;                end interface
       interface assign_ghost_XPeriodic;      module procedure assign_ghost_XPeriodic_BF;       end interface
       interface assign_ghost_XPeriodic;      module procedure assign_ghost_XPeriodic_BF2;      end interface
       interface assign_ghost_N_XPeriodic;    module procedure assign_ghost_N_XPeriodic_BF;     end interface
       interface assign_ghost_N_XPeriodic;    module procedure assign_ghost_N_XPeriodic_BF2;    end interface
       interface assign_wall_Periodic_single; module procedure assign_wall_Periodic_single_BF;  end interface
       interface assign_wall_Periodic_single; module procedure assign_wall_Periodic_single_BF2; end interface
       interface assign_wall_Dirichlet;       module procedure assign_wall_Dirichlet_BF;        end interface
       interface assign_wall_Dirichlet;       module procedure assign_wall_Dirichlet_BF2;       end interface
       interface multiply_wall_Neumann;       module procedure multiply_wall_Neumann_BF;        end interface
       interface multiply_wall_Neumann;       module procedure multiply_wall_Neumann_BF2;       end interface
       interface set_prescribed_BCs;          module procedure set_prescribed_BCs_BF;           end interface
       interface set_BCs_homogeneous;         module procedure set_BCs_homogeneous_BF;          end interface

       interface plane_sum_x;                 module procedure plane_sum_x_BF;                  end interface
       interface plane_sum_y;                 module procedure plane_sum_y_BF;                  end interface
       interface plane_sum_z;                 module procedure plane_sum_z_BF;                  end interface
       interface boundary_flux;               module procedure boundary_flux_BF;                end interface
       interface boundary_flux;               module procedure boundary_flux_SF_BF;             end interface

       interface assign_ghost_xmin_xmax;      module procedure assign_ghost_xmin_xmax_BF;       end interface
       interface assign_ghost_ymin_ymax;      module procedure assign_ghost_ymin_ymax_BF;       end interface
       interface assign_ghost_zmin_zmax;      module procedure assign_ghost_zmin_zmax_BF;       end interface

       interface mirror_about_hmin;           module procedure mirror_about_hmin_BF;            end interface
       interface mirror_about_hmax;           module procedure mirror_about_hmax_BF;            end interface

       interface symmetry_error_x;            module procedure symmetry_error_x_BF;             end interface
       interface symmetry_error_y;            module procedure symmetry_error_y_BF;             end interface
       interface symmetry_error_z;            module procedure symmetry_error_z_BF;             end interface

       interface symmetry_local_x;            module procedure symmetry_local_x_BF;             end interface
       interface symmetry_local_y;            module procedure symmetry_local_y_BF;             end interface
       interface symmetry_local_z;            module procedure symmetry_local_z_BF;             end interface

       interface restrict;                    module procedure restrict_BF;                     end interface
       interface restrict;                    module procedure restrict_reset_BF;               end interface
       interface prolongate;                  module procedure prolongate_BF;                   end interface
       interface prolongate;                  module procedure prolongate_reset_BF;             end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_CC_BF(BF,B)
         implicit none
         type(block_field),intent(inout) :: BF
         type(block),intent(in) :: B
         call init_CC(BF%GF,B%g)
         call init_CC(BF%DL)
         call set_procedures(BF)
       end subroutine

       subroutine init_Face_BF(BF,B,dir)
         implicit none
         type(block_field),intent(inout) :: BF
         type(block),intent(in) :: B
         integer,intent(in) :: dir
         call init_Face(BF%GF,B%g,dir)
         call init_Face(BF%DL,dir)
         call set_procedures(BF)
       end subroutine

       subroutine init_Edge_BF(BF,B,dir)
         implicit none
         type(block_field),intent(inout) :: BF
         type(block),intent(in) :: B
         integer,intent(in) :: dir
         call init_Edge(BF%GF,B%g,dir)
         call init_Edge(BF%DL,dir)
         call set_procedures(BF)
       end subroutine

       subroutine init_Node_BF(BF,B)
         implicit none
         type(block_field),intent(inout) :: BF
         type(block),intent(in) :: B
         call init_Node(BF%GF,B%g)
         call init_Node(BF%DL)
         call set_procedures(BF)
       end subroutine

       subroutine set_assign_ghost_all_faces(BF)
         implicit none
         type(block_field),intent(inout) :: BF
         call delete(BF%PA_assign_ghost_XPeriodic)
         call delete(BF%PA_assign_ghost_N_XPeriodic)
         if (defined(BF%BCs)) then
         if(.not.is_Periodic(BF%BCs%face%SB(1)%bct))then
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_xmin,1)
         if (N_along(BF%DL,1)) call add(BF%PA_assign_ghost_N_XPeriodic,assign_ghost_xmin,1)
         endif
         if(.not.is_Periodic(BF%BCs%face%SB(2)%bct))then
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_xmax,2)
         if (N_along(BF%DL,1)) call add(BF%PA_assign_ghost_N_XPeriodic,assign_ghost_xmax,2)
         endif
         if(.not.is_Periodic(BF%BCs%face%SB(3)%bct))then
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_ymin,3)
         if (N_along(BF%DL,2)) call add(BF%PA_assign_ghost_N_XPeriodic,assign_ghost_ymin,3)
         endif
         if(.not.is_Periodic(BF%BCs%face%SB(4)%bct))then
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_ymax,4)
         if (N_along(BF%DL,2)) call add(BF%PA_assign_ghost_N_XPeriodic,assign_ghost_ymax,4)
         endif
         if(.not.is_Periodic(BF%BCs%face%SB(5)%bct))then
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_zmin,5)
         if (N_along(BF%DL,3)) call add(BF%PA_assign_ghost_N_XPeriodic,assign_ghost_zmin,5)
         endif
         if(.not.is_Periodic(BF%BCs%face%SB(6)%bct))then
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_zmax,6)
         if (N_along(BF%DL,3)) call add(BF%PA_assign_ghost_N_XPeriodic,assign_ghost_zmax,6)
         endif
         else
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_xmin,1)
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_xmax,2)
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_ymin,3)
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_ymax,4)
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_zmin,5)
         call add(BF%PA_assign_ghost_XPeriodic,assign_ghost_zmax,6)
         endif
       end subroutine

       subroutine set_assign_wall_Dirichlet(BF)
         implicit none
         type(block_field),intent(inout) :: BF
         call delete(BF%PA_assign_wall_Dirichlet)
         if (defined(BF%BCs)) then
           if (N_along(BF%DL,1).and.(is_Dirichlet(BF%BCs%face%SB(1)%bct))) then
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_xmin,1)
           endif
           if (N_along(BF%DL,1).and.(is_Dirichlet(BF%BCs%face%SB(2)%bct))) then
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_xmax,2)
           endif
           if (N_along(BF%DL,2).and.(is_Dirichlet(BF%BCs%face%SB(3)%bct))) then
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_ymin,3)
           endif
           if (N_along(BF%DL,2).and.(is_Dirichlet(BF%BCs%face%SB(4)%bct))) then
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_ymax,4)
           endif
           if (N_along(BF%DL,3).and.(is_Dirichlet(BF%BCs%face%SB(5)%bct))) then
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_zmin,5)
           endif
           if (N_along(BF%DL,3).and.(is_Dirichlet(BF%BCs%face%SB(6)%bct))) then
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_zmax,6)
           endif
         else
           if (N_along(BF%DL,1)) then
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_xmin,1)
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_xmax,2)
           endif
           if (N_along(BF%DL,2)) then
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_ymin,3)
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_ymax,4)
           endif
           if (N_along(BF%DL,3)) then
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_zmin,5)
           call add(BF%PA_assign_wall_Dirichlet,assign_wall_zmax,6)
           endif
         endif
       end subroutine

       subroutine set_assign_wall_Periodic_single_BF(BF)
         implicit none
         type(block_field),intent(inout) :: BF
         logical,dimension(4) :: L
         integer :: i
         call delete(BF%PA_assign_wall_Periodic_single)
         if (defined(BF%BCs)) then
           L(1) = N_along(BF%DL,1)
           L(2) = is_Periodic(BF%BCs%face%SB(1)%bct)
           L(3) = is_Periodic(BF%BCs%face%SB(2)%bct)
           L(4) = BF%GF%s(1).gt.4
           BF%many_cell_N_periodic(1) = all(L)
           if (all(L)) call add(BF%PA_assign_wall_Periodic_single,assign_wall_xmax,2)

           L(1) = N_along(BF%DL,2)
           L(2) = is_Periodic(BF%BCs%face%SB(3)%bct)
           L(3) = is_Periodic(BF%BCs%face%SB(4)%bct)
           L(4) = BF%GF%s(2).gt.4
           BF%many_cell_N_periodic(2) = all(L)
           if (all(L)) call add(BF%PA_assign_wall_Periodic_single,assign_wall_ymax,4)

           L(1) = N_along(BF%DL,3)
           L(2) = is_Periodic(BF%BCs%face%SB(5)%bct)
           L(3) = is_Periodic(BF%BCs%face%SB(6)%bct)
           L(4) = BF%GF%s(3).gt.4
           BF%many_cell_N_periodic(3) = all(L)
           if (all(L)) call add(BF%PA_assign_wall_Periodic_single,assign_wall_zmax,6)

           do i=1,3
             L(1) = N_along(BF%DL,i)
             L(2) = CC_along(BF%DL,i)
             L(3) = BF%GF%s(i).gt.4
             L(4) = BF%GF%s(i).gt.3
             BF%many_cell(i) = (L(1).and.L(3)).or.(L(2).and.L(4))
           enddo
         endif
       end subroutine

       subroutine set_multiply_wall_Neumann(BF)
         implicit none
         type(block_field),intent(inout) :: BF
         call delete(BF%PA_multiply_wall_Neumann)
         if (defined(BF%BCs)) then
           if (N_along(BF%DL,1).and.(is_Neumann(BF%BCs%face%SB(1)%bct))) then
           call add(BF%PA_multiply_wall_Neumann,multiply_wall_xmin,1); endif
           if (N_along(BF%DL,1).and.(is_Neumann(BF%BCs%face%SB(2)%bct))) then
           call add(BF%PA_multiply_wall_Neumann,multiply_wall_xmax,2); endif
           if (N_along(BF%DL,2).and.(is_Neumann(BF%BCs%face%SB(3)%bct))) then
           call add(BF%PA_multiply_wall_Neumann,multiply_wall_ymin,3); endif
           if (N_along(BF%DL,2).and.(is_Neumann(BF%BCs%face%SB(4)%bct))) then
           call add(BF%PA_multiply_wall_Neumann,multiply_wall_ymax,4); endif
           if (N_along(BF%DL,3).and.(is_Neumann(BF%BCs%face%SB(5)%bct))) then
           call add(BF%PA_multiply_wall_Neumann,multiply_wall_zmin,5); endif
           if (N_along(BF%DL,3).and.(is_Neumann(BF%BCs%face%SB(6)%bct))) then
           call add(BF%PA_multiply_wall_Neumann,multiply_wall_zmax,6); endif
         else
           if (N_along(BF%DL,1)) then; call add(BF%PA_multiply_wall_Neumann,multiply_wall_xmin,1)
                                       call add(BF%PA_multiply_wall_Neumann,multiply_wall_xmax,2)
           endif
           if (N_along(BF%DL,2)) then; call add(BF%PA_multiply_wall_Neumann,multiply_wall_ymin,3)
                                       call add(BF%PA_multiply_wall_Neumann,multiply_wall_ymax,4)
           endif
           if (N_along(BF%DL,3)) then; call add(BF%PA_multiply_wall_Neumann,multiply_wall_zmin,5)
                                       call add(BF%PA_multiply_wall_Neumann,multiply_wall_zmax,6)
           endif
         endif
       end subroutine

       subroutine init_BC_val(BF,val)
         implicit none
         type(block_field),intent(inout) :: BF
         real(cp),intent(in) :: val
         call init(BF%BCs,val)
       end subroutine

       subroutine init_BC_block_DL(BF,B,DL)
         implicit none
         type(block_field),intent(inout) :: BF
         type(block),intent(in) :: B
         type(data_location),intent(in) :: DL
         call init(BF%BCs,B,DL)
       end subroutine

       subroutine init_BC_props_BF(BF,c_w,Robin_coeff)
         implicit none
         type(block_field),intent(inout) :: BF
         real(cp),dimension(6),intent(in) :: c_w,Robin_coeff
         call init_props(BF%BCs,c_w,Robin_coeff)
         call set_procedures(BF)
       end subroutine

       subroutine set_procedures_BF(BF)
         implicit none
         type(block_field),intent(inout) :: BF
         call set_assign_ghost_all_faces(BF)
         call set_assign_wall_Dirichlet(BF)
         call set_multiply_wall_Neumann(BF)
         call set_assign_wall_Periodic_single_BF(BF)
       end subroutine

       subroutine inverse_area_DL_BF(u,B,DL,dir)
         implicit none
         type(block_field),intent(inout) :: u
         type(block),intent(in) :: B
         type(data_location),intent(in) :: DL
         integer,intent(in) :: dir
         call inverse_area(u%GF,B%g,DL,dir)
       end subroutine

       subroutine volume_DL_BF(u,B,DL) ! Computes: volume(x(i),y(j),z(k)) = dx(i) dy(j) dz(k)
         implicit none
         type(block_field),intent(inout) :: u
         type(block),intent(in) :: B
         type(data_location),intent(in) :: DL
         call volume(u%GF,B%g,DL)
       end subroutine

       subroutine volume_BF(u,B) ! Computes: volume(x(i),y(j),z(k)) = dx(i) dy(j) dz(k)
         implicit none
         type(block_field),intent(inout) :: u
         type(block),intent(in) :: B
         call volume(u%GF,B%g)
       end subroutine

       subroutine sine_waves_BF(u,B,wavenum,phi,DL)
         implicit none
         type(block_field),intent(inout) :: u
         type(block),intent(in) :: B
         type(data_location),intent(in) :: DL
         real(cp),dimension(3),intent(in) :: wavenum,phi
         call sine_waves(u%GF,B%g,wavenum,phi,DL)
       end subroutine

       subroutine cosine_waves_BF(u,B,wavenum,phi,DL)
         implicit none
         type(block_field),intent(inout) :: u
         type(block),intent(in) :: B
         type(data_location),intent(in) :: DL
         real(cp),dimension(3),intent(in) :: wavenum,phi
         call cosine_waves(u%GF,B%g,wavenum,phi,DL)
       end subroutine

       subroutine random_noise_BF(u)
         implicit none
         type(block_field),intent(inout) :: u
         call random_noise(u%GF)
       end subroutine

       subroutine random_noise_BF_dir(u,dir)
         implicit none
         type(block_field),intent(inout) :: u
         integer,intent(in) :: dir
         call random_noise(u%GF,dir)
       end subroutine

       subroutine cross_product_x_BF(AcrossB,Ay,Az,By,Bz)
         implicit none
         type(block_field),intent(inout) :: AcrossB
         type(block_field),intent(in) :: Ay,Az,By,Bz
         call cross_product_x(AcrossB%GF,Ay%GF,Az%GF,By%GF,Bz%GF)
       end subroutine
       subroutine cross_product_y_BF(AcrossB,Ax,Az,Bx,Bz)
         implicit none
         type(block_field),intent(inout) :: AcrossB
         type(block_field),intent(in) :: Ax,Az,Bx,Bz
         call cross_product_y(AcrossB%GF,Ax%GF,Az%GF,Bx%GF,Bz%GF)
       end subroutine
       subroutine cross_product_z_BF(AcrossB,Ax,Ay,Bx,By)
         implicit none
         type(block_field),intent(inout) :: AcrossB
         type(block_field),intent(in) :: Ax,Ay,Bx,By
         call cross_product_z(AcrossB%GF,Ax%GF,Ay%GF,Bx%GF,By%GF)
       end subroutine

       function CFL_number_BF(U_CC,V_CC,W_CC,B,dt) result(CFL)
         implicit none
         type(block_field),intent(in) :: U_CC,V_CC,W_CC
         type(block),intent(in) :: B
         real(cp),intent(in) :: dt
         real(cp) :: CFL
         CFL = CFL_number(U_CC%GF,V_CC%GF,W_CC%GF,B%g,dt)
       end function

       function dt_given_CFL_number_BF(U_CC,V_CC,W_CC,B,CFL) result(dt)
         implicit none
         type(block_field),intent(in) :: U_CC,V_CC,W_CC
         type(block),intent(in) :: B
         real(cp),intent(in) :: CFL
         real(cp) :: dt
         dt = dt_given_CFL_number(U_CC%GF,V_CC%GF,W_CC%GF,B%g,CFL)
       end function

       function Fourier_number_BF(alpha,B,dt) result(Fourier)
         implicit none
         real(cp),intent(in) :: alpha
         type(block),intent(in) :: B
         real(cp),intent(in) :: dt
         real(cp) :: Fourier
         Fourier = Fourier_number(alpha,B%g,dt)
       end function

       function Robin_BC_coeff_BF(c_w,B) result(coeff)
         implicit none
         real(cp),dimension(6),intent(in) :: c_w
         type(block),intent(in) :: B
         real(cp),dimension(6) :: coeff
         coeff = Robin_BC_coeff(c_w,B%g)
       end function

       function get_any_Dirichlet_BF(BF) result(L)
         implicit none
         type(block_field),intent(in) :: BF
         logical :: L
         L = get_any_Dirichlet(BF%BCs)
       end function

       function get_any_Neumann_BF(BF) result(L)
         implicit none
         type(block_field),intent(in) :: BF
         logical :: L
         L = get_any_Neumann(BF%BCs)
       end function

       function get_any_Robin_BF(BF) result(L)
         implicit none
         type(block_field),intent(in) :: BF
         logical :: L
         L = get_any_Robin(BF%BCs)
       end function

       function get_any_Prescribed_BF(BF) result(L)
         implicit none
         type(block_field),intent(in) :: BF
         logical :: L
         L = get_any_Prescribed(BF%BCs)
       end function

       subroutine set_necessary_for_restart_BF(u)
         implicit none
         type(block_field),intent(inout) :: u
         u%necessary_for_restart = .true.
       end subroutine

       subroutine square_BF(u)
         implicit none
         type(block_field),intent(inout) :: u
         call square(u%GF)
       end subroutine

       subroutine square_root_BF(u)
         implicit none
         type(block_field),intent(inout) :: u
         call square_root(u%GF)
       end subroutine

       subroutine abs_BF(u)
         implicit none
         type(block_field),intent(inout) :: u
         call abs(u%GF)
       end subroutine

       subroutine insist_amax_lt_tol_BF(u,caller)
         implicit none
         type(block_field),intent(in) :: u
         character(len=*),intent(in) :: caller
         call insist_amax_lt_tol(u%GF,caller)
       end subroutine

       subroutine assign_BCs_BF(u,f)
         implicit none
         type(block_field),intent(inout) :: u
         type(block_field),intent(in) :: f
         if (defined(u%BCs)) then
           call assign_plane_x(u%BCs%face%SB(1)%b,f%GF,1,     2     )
           call assign_plane_x(u%BCs%face%SB(2)%b,f%GF,1,f%GF%s(1)-1)
           call assign_plane_y(u%BCs%face%SB(3)%b,f%GF,1,     2     )
           call assign_plane_y(u%BCs%face%SB(4)%b,f%GF,1,f%GF%s(2)-1)
           call assign_plane_z(u%BCs%face%SB(5)%b,f%GF,1,     2     )
           call assign_plane_z(u%BCs%face%SB(6)%b,f%GF,1,f%GF%s(3)-1)
         endif
       end subroutine

       subroutine assign_BC_vals_BF(A,B)
         implicit none
         type(block_field),intent(inout) :: A
         type(block_field),intent(in) :: B
         integer :: i
#ifdef _DEBUG_BF_
         if (.not.(defined(A%BCs).and.defined(B%BCs))) stop 'Error: BCs not defined in BF.f90'
#endif
         do i=1,6; call assign(A%BCs%face%SB(i)%b         ,B%BCs%face%SB(i)%b         ); enddo
         do i=1,6; call assign(A%BCs%face%SB(i)%b_total   ,B%BCs%face%SB(i)%b_total   ); enddo
         do i=1,6; call assign(A%BCs%face%SB(i)%b_modified,B%BCs%face%SB(i)%b_modified); enddo
       end subroutine

       subroutine update_BC_vals_BF(A)
         implicit none
         type(block_field),intent(inout) :: A
         integer :: i
#ifdef _DEBUG_BF_
         if (.not.(defined(A%BCs))) stop 'Error: BCs not defined in update_BC_vals_BF in BF.f90'
#endif
         do i=1,6
         call add(A%BCs%face%SB(i)%b_total,A%BCs%face%SB(i)%b,A%BCs%face%SB(i)%b_modified)
         enddo
       end subroutine

       subroutine assign_Dirichlet_BCs_BF(A,B)
         implicit none
         type(block_field),intent(inout) :: A
         type(block_field),intent(in) :: B
         integer :: i,dir
         if (defined(A%BCs)) then
           do i=1,6
             dir = dir_given_face(i)
             if (is_Dirichlet(A%BCs%face%SB(i)%bct)) then
             if (N_along(B%DL,dir)) then
               if (min_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,       2     ,dir)
               if (max_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,B%GF%s(dir)-1,dir)
             else
               if (min_face(i)) call assign_plane_ave(A%BCs%face%SB(i)%b_modified,B%GF,1,     1     ,      2      ,dir)
               if (max_face(i)) call assign_plane_ave(A%BCs%face%SB(i)%b_modified,B%GF,1,B%GF%s(dir),B%GF%s(dir)-1,dir)
             endif
             endif
           enddo
         endif
       end subroutine

       subroutine assign_Periodic_BCs_BF(A,B)
         implicit none
         type(block_field),intent(inout) :: A
         type(block_field),intent(in) :: B
         integer,dimension(3) :: p
         integer :: i,dir,i_opp_e,i_opp_s
         if (defined(A%BCs)) then
           do i=1,6
             dir = dir_given_face(i)
             p = N_eye(A%DL)
             i_opp_e = B%GF%s(dir)-1-p(dir)
             i_opp_s = 2+p(dir)
             if (is_Periodic(A%BCs%face%SB(i)%bct)) then
             if (N_along(B%DL,dir)) then
               if (min_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,i_opp_e,dir)
               if (max_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,i_opp_s,dir)
             else
               if (min_face(i)) call assign_plane_ave(A%BCs%face%SB(i)%b_modified,B%GF,1,i_opp_e+1,i_opp_e,dir)
               if (max_face(i)) call assign_plane_ave(A%BCs%face%SB(i)%b_modified,B%GF,1,i_opp_s-1,i_opp_s,dir)
             endif
             endif
           enddo
         endif
       end subroutine

       subroutine assign_Neumann_BCs_faces_BF(A,B,dir)
         implicit none
         type(block_field),intent(inout) :: A
         type(block_field),intent(in) :: B
         integer,intent(in) :: dir
         integer :: i,j
         integer,dimension(2) :: faces
         if (defined(A%BCs)) then
           faces = normal_faces_given_dir(dir)
           do j=1,2
             i = faces(j)
             if (is_Neumann(A%BCs%face%SB(i)%bct)) then
             if (N_along(B%DL,dir)) then
               if (min_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,       2     ,dir)
               if (max_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,B%GF%s(dir)-1,dir)
             else
               if (min_face(i)) call assign_plane_ave(A%BCs%face%SB(i)%b_modified,B%GF,1,     1     ,      2      ,dir)
               if (max_face(i)) call assign_plane_ave(A%BCs%face%SB(i)%b_modified,B%GF,1,B%GF%s(dir),B%GF%s(dir)-1,dir)
             endif
             endif
           enddo
         endif
       end subroutine

       subroutine assign_Neumann_BCs_wall_normal_BF(A,B,dir)
         implicit none
         type(block_field),intent(inout) :: A
         type(block_field),intent(in) :: B
         integer,intent(in) :: dir
         integer :: i,j
         integer,dimension(2) :: faces
         if (defined(A%BCs)) then
           faces = normal_faces_given_dir(dir)
           do j=1,2
             i = faces(j)
             if (is_Neumann(A%BCs%face%SB(i)%bct)) then
             if (N_along(B%DL,dir)) then
               if (min_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,       2     ,dir)
               if (max_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,B%GF%s(dir)-1,dir)
             endif
             endif
           enddo
         endif
       end subroutine

       subroutine multiply_Neumann_BCs_BF(A,scale)
         implicit none
         type(block_field),intent(inout) :: A
         real(cp),intent(in) :: scale
         integer :: i
         if (defined(A%BCs)) then
           do i=1,6
             if (is_Neumann(A%BCs%face%SB(i)%bct)) then
             call multiply(A%BCs%face%SB(i)%b_modified,scale)
             endif
           enddo
         endif
       end subroutine

       subroutine multiply_BCs_by_nhat_BF(A)
         implicit none
         type(block_field),intent(inout) :: A
         integer :: i
         if (defined(A%BCs)) then
           do i=1,6
             call multiply(A%BCs%face%SB(i)%b_modified,A%BCs%f_BCs%nhat(i))
           enddo
         endif
       end subroutine

       subroutine assign_Robin_BCs_dir_BF(A,B,dir)
         implicit none
         type(block_field),intent(inout) :: A
         type(block_field),intent(in) :: B
         integer,intent(in) :: dir
         integer :: i,j
         integer,dimension(2) :: faces
         if (defined(A%BCs)) then
           faces = normal_faces_given_dir(dir)
           do j=1,2
             i = faces(j)
             if (is_Robin(A%BCs%face%SB(i)%bct)) then
             if (N_along(B%DL,dir)) then
               if (min_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,       2     ,dir)
               if (max_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,B%GF%s(dir)-1,dir)
             else
               if (min_face(i)) call assign_plane_ave(A%BCs%face%SB(i)%b_modified,B%GF,1,     1     ,      2      ,dir)
               if (max_face(i)) call assign_plane_ave(A%BCs%face%SB(i)%b_modified,B%GF,1,B%GF%s(dir),B%GF%s(dir)-1,dir)
             endif
             endif
           enddo
         endif
       end subroutine

       subroutine assign_Robin_BCs_faces_BF(A,B)
         implicit none
         type(block_field),intent(inout) :: A
         type(block_field),intent(in) :: B
         integer :: i,dir
         if (defined(A%BCs)) then
           do i=1,6
             dir = dir_given_face(i)
             if (is_Robin(A%BCs%face%SB(i)%bct)) then
             if (N_along(B%DL,dir)) then
               if (min_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,       2     ,dir)
               if (max_face(i)) call assign_plane(A%BCs%face%SB(i)%b_modified,B%GF,1,B%GF%s(dir)-1,dir)
             else
               if (min_face(i)) call assign_plane_ave(A%BCs%face%SB(i)%b_modified,B%GF,1,     1     ,      2      ,dir)
               if (max_face(i)) call assign_plane_ave(A%BCs%face%SB(i)%b_modified,B%GF,1,B%GF%s(dir),B%GF%s(dir)-1,dir)
             endif
             endif
           enddo
         endif
       end subroutine

       subroutine multiply_Robin_coeff_BF(A)
         implicit none
         type(block_field),intent(inout) :: A
         integer :: i,dir
         if (defined(A%BCs)) then
           do i=1,6
             dir = dir_given_face(i)
             if (is_Robin(A%BCs%face%SB(i)%bct)) then
               call multiply(A%BCs%face%SB(i)%b_modified,A%BCs%f_BCs%Robin_coeff(i))
             endif
           enddo
         endif
       end subroutine

       subroutine multiply_nhat_BF(A,A_with_BCs)
         implicit none
         type(block_field),intent(inout) :: A
         type(block_field),intent(in) :: A_with_BCs
         integer :: i,dir
         if (defined(A_with_BCs%BCs)) then
           do i=1,6
             dir = dir_given_face(i)
             if (N_along(A%DL,dir)) then
               if (min_face(i)) call multiply_plane(A%GF,A_with_BCs%BCs%f_BCs%nhat(i),       2     ,dir)
               if (max_face(i)) call multiply_plane(A%GF,A_with_BCs%BCs%f_BCs%nhat(i),A%GF%s(dir)-1,dir)
             endif
           enddo
         endif
       end subroutine

       subroutine set_prescribed_BCs_BF(A)
         implicit none
         type(block_field),intent(inout) :: A
         integer :: i,dir
         if (defined(A%BCs)) then
           do i=1,6
            dir = dir_given_face(i)
            if (A%many_cell(dir)) call set_prescribed(A%BCs,i)
            call init_PA_face(A%BCs,i)
           enddo
         endif
       end subroutine

       subroutine set_BCs_homogeneous_BF(A)
         implicit none
         type(block_field),intent(inout) :: A
         integer :: i
         if (defined(A%BCs)) then
           do i=1,6; call init(A%BCs,0.0_cp,i); enddo
         endif
       end subroutine

       subroutine assign_ghost_XPeriodic_BF(u,val)
         implicit none
         type(block_field),intent(inout) :: u
         real(cp),intent(in) :: val
         integer :: i
         if (u%PA_assign_ghost_XPeriodic%defined) then
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP PARALLEL DO

#endif
         do i=1,u%PA_assign_ghost_XPeriodic%N
         call u%PA_assign_ghost_XPeriodic%SP(i)%P(u%GF,val)
         enddo
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP END PARALLEL DO

#endif
         endif
       end subroutine
       subroutine assign_ghost_XPeriodic_BF2(u,val,u_with_BCs)
         implicit none
         type(block_field),intent(inout) :: u
         real(cp),intent(in) :: val
         type(block_field),intent(in) :: u_with_BCs
         integer :: i
         if (u_with_BCs%PA_assign_ghost_XPeriodic%defined) then
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP PARALLEL DO

#endif
         do i=1,u_with_BCs%PA_assign_ghost_XPeriodic%N
         call u_with_BCs%PA_assign_ghost_XPeriodic%SP(i)%P(u%GF,val)
         enddo
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP END PARALLEL DO

#endif
         endif
       end subroutine

       subroutine assign_ghost_N_XPeriodic_BF(u,val)
         implicit none
         type(block_field),intent(inout) :: u
         real(cp),intent(in) :: val
         integer :: i
         if (u%PA_assign_ghost_N_XPeriodic%defined) then
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP PARALLEL DO

#endif
         do i=1,u%PA_assign_ghost_N_XPeriodic%N
         call u%PA_assign_ghost_N_XPeriodic%SP(i)%P(u%GF,val)
         enddo
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP END PARALLEL DO

#endif
         endif
       end subroutine
       subroutine assign_ghost_N_XPeriodic_BF2(u,val,u_with_BCs)
         implicit none
         type(block_field),intent(inout) :: u
         real(cp),intent(in) :: val
         type(block_field),intent(in) :: u_with_BCs
         integer :: i
         if (u_with_BCs%PA_assign_ghost_N_XPeriodic%defined) then
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP PARALLEL DO

#endif
         do i=1,u_with_BCs%PA_assign_ghost_N_XPeriodic%N
         call u_with_BCs%PA_assign_ghost_N_XPeriodic%SP(i)%P(u%GF,val)
         enddo
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP END PARALLEL DO

#endif
         endif
       end subroutine

       subroutine assign_wall_Dirichlet_BF(u,val)
         implicit none
         type(block_field),intent(inout) :: u
         real(cp),intent(in) :: val
         integer :: i
         if (u%PA_assign_wall_Dirichlet%defined) then
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP PARALLEL DO

#endif
         do i=1,u%PA_assign_wall_Dirichlet%N
         call u%PA_assign_wall_Dirichlet%SP(i)%P(u%GF,val)
         enddo
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP END PARALLEL DO

#endif
         endif
       end subroutine

       subroutine assign_wall_Dirichlet_BF2(u,val,u_with_BCs)
         implicit none
         type(block_field),intent(inout) :: u
         type(block_field),intent(in) :: u_with_BCs
         real(cp),intent(in) :: val
         integer :: i
         if (u_with_BCs%PA_assign_wall_Dirichlet%defined) then
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP PARALLEL DO

#endif
         do i=1,u_with_BCs%PA_assign_wall_Dirichlet%N
         call u_with_BCs%PA_assign_wall_Dirichlet%SP(i)%P(u%GF,val)
         enddo
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP END PARALLEL DO

#endif
         endif
       end subroutine

       subroutine assign_wall_Periodic_single_BF(u,val)
         implicit none
         type(block_field),intent(inout) :: u
         real(cp),intent(in) :: val
         integer :: i
         if (u%PA_assign_wall_Periodic_single%defined) then
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP PARALLEL DO

#endif
         do i=1,u%PA_assign_wall_Periodic_single%N
         call u%PA_assign_wall_Periodic_single%SP(i)%P(u%GF,val)
         enddo
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP END PARALLEL DO

#endif
         endif
       end subroutine

       subroutine assign_wall_Periodic_single_BF2(u,val,u_with_BCs)
         implicit none
         type(block_field),intent(inout) :: u
         type(block_field),intent(in) :: u_with_BCs
         real(cp),intent(in) :: val
         integer :: i
         if (u_with_BCs%PA_assign_wall_Periodic_single%defined) then
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP PARALLEL DO

#endif
         do i=1,u_with_BCs%PA_assign_wall_Periodic_single%N
         call u_with_BCs%PA_assign_wall_Periodic_single%SP(i)%P(u%GF,val)
         enddo
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP END PARALLEL DO

#endif
         endif
       end subroutine

       subroutine multiply_wall_Neumann_BF(u,val)
         implicit none
         type(block_field),intent(inout) :: u
         real(cp),intent(in) :: val
         integer :: i
         if (u%PA_multiply_wall_Neumann%defined) then
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP PARALLEL DO

#endif
         do i=1,u%PA_multiply_wall_Neumann%N
         call u%PA_multiply_wall_Neumann%SP(i)%P(u%GF,val)
         enddo
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP END PARALLEL DO

#endif
         endif
       end subroutine

       subroutine multiply_wall_Neumann_BF2(u,val,u_with_BCs)
         implicit none
         type(block_field),intent(inout) :: u
         type(block_field),intent(in) :: u_with_BCs
         real(cp),intent(in) :: val
         integer :: i
         if (u_with_BCs%PA_multiply_wall_Neumann%defined) then
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP PARALLEL DO

#endif
         do i=1,u_with_BCs%PA_multiply_wall_Neumann%N
         call u_with_BCs%PA_multiply_wall_Neumann%SP(i)%P(u%GF,val)
         enddo
#ifdef _PARALLELIZE_BF_PLANE_
         !$OMP END PARALLEL DO

#endif
         endif
       end subroutine

       subroutine assign_ghost_xmin_xmax_BF(u,val)
         implicit none
         type(block_field),intent(inout) :: u
         real(cp),intent(in) :: val
         call assign_ghost_xmin_xmax(u%GF,val)
       end subroutine
       subroutine assign_ghost_ymin_ymax_BF(u,val)
         implicit none
         type(block_field),intent(inout) :: u
         real(cp),intent(in) :: val
         call assign_ghost_ymin_ymax(u%GF,val)
       end subroutine
       subroutine assign_ghost_zmin_zmax_BF(u,val)
         implicit none
         type(block_field),intent(inout) :: u
         real(cp),intent(in) :: val
         call assign_ghost_zmin_zmax(u%GF,val)
       end subroutine

       subroutine mirror_about_hmin_BF(u,dir,mirror_sign)
         implicit none
         type(block_field),intent(inout) :: u
         integer,intent(in) :: dir
         real(cp),intent(in) :: mirror_sign
         integer,dimension(3) :: N_along_dir
         N_along_dir = N_eye(u%DL)
         call mirror_about_hmin(u%GF,dir,mirror_sign,N_along_dir(dir))
       end subroutine
       subroutine mirror_about_hmax_BF(u,dir,mirror_sign)
         implicit none
         type(block_field),intent(inout) :: u
         integer,intent(in) :: dir
         real(cp),intent(in) :: mirror_sign
         integer,dimension(3) :: N_along_dir
         N_along_dir = N_eye(u%DL)
         call mirror_about_hmax(u%GF,dir,mirror_sign,N_along_dir(dir))
       end subroutine

       function plane_sum_x_BF(u,B,p) result(PS)
         implicit none
         type(block_field),intent(in) :: u
         type(block),intent(in) :: B
         integer,intent(in) :: p
         real(cp) :: PS
         PS = plane_sum_x(u%GF,B%g,p,1.0_cp)
       end function

       function plane_sum_y_BF(u,B,p) result(PS)
         implicit none
         type(block_field),intent(in) :: u
         type(block),intent(in) :: B
         integer,intent(in) :: p
         real(cp) :: PS
         PS = plane_sum_y(u%GF,B%g,p,1.0_cp)
       end function

       function plane_sum_z_BF(u,B,p) result(PS)
         implicit none
         type(block_field),intent(in) :: u
         type(block),intent(in) :: B
         integer,intent(in) :: p
         real(cp) :: PS
         PS = plane_sum_z(u%GF,B%g,p,1.0_cp)
       end function

       subroutine boundary_flux_BF(BF,x,y,z,B,temp_x,temp_y,temp_z)
         implicit none
         real(cp),intent(inout) :: BF
         type(block_field),intent(in) :: x,y,z
         type(block_field),intent(inout) :: temp_x,temp_y,temp_z
         type(block),intent(in) :: B
         logical,dimension(3) :: L
         L(1) = is_Face(x%DL).and.(get_Face(x%DL).eq.1)
         L(2) = is_Face(y%DL).and.(get_Face(y%DL).eq.2)
         L(3) = is_Face(z%DL).and.(get_Face(z%DL).eq.3)
         if (all(L)) then
         BF = 0.0_cp
         call assign(temp_x%GF,x%GF); call assign_ghost_XPeriodic(temp_x,0.0_cp)
         call assign(temp_y%GF,y%GF); call assign_ghost_XPeriodic(temp_y,0.0_cp)
         call assign(temp_z%GF,z%GF); call assign_ghost_XPeriodic(temp_z,0.0_cp)
         BF = BF + plane_sum_x(temp_x%GF,B%g,2,-1.0_cp)
         BF = BF + plane_sum_x(temp_x%GF,B%g,temp_x%GF%s(1)-1,1.0_cp)
         BF = BF + plane_sum_y(temp_y%GF,B%g,2,-1.0_cp)
         BF = BF + plane_sum_y(temp_y%GF,B%g,temp_y%GF%s(2)-1,1.0_cp)
         BF = BF + plane_sum_z(temp_z%GF,B%g,2,-1.0_cp)
         BF = BF + plane_sum_z(temp_z%GF,B%g,temp_z%GF%s(3)-1,1.0_cp)
         else; stop 'Error: boundary flux only offered for face data in BF.f90'
         endif
       end subroutine

       subroutine boundary_flux_SF_BF(BF,phi,B,temp_phi)
         implicit none
         real(cp),intent(inout) :: BF
         type(block_field),intent(in) :: phi
         type(block),intent(in) :: B
         type(block_field),intent(inout) :: temp_phi
         logical,dimension(3) :: L
         L(1) = is_Face(phi%DL).and.(get_Face(phi%DL).eq.1)
         L(2) = is_Face(phi%DL).and.(get_Face(phi%DL).eq.2)
         L(3) = is_Face(phi%DL).and.(get_Face(phi%DL).eq.3)
         BF = 0.0_cp
         if (any(L)) then
           call assign(temp_phi%GF,phi%GF)
           call assign_ghost_XPeriodic(temp_phi,0.0_cp)
              if (L(1)) then
           BF = BF + plane_sum_x(temp_phi%GF,B%g,2,-1.0_cp)
           BF = BF + plane_sum_x(temp_phi%GF,B%g,temp_phi%GF%s(1)-1,1.0_cp)
           elseif(L(2)) then
           BF = BF + plane_sum_y(temp_phi%GF,B%g,2,-1.0_cp)
           BF = BF + plane_sum_y(temp_phi%GF,B%g,temp_phi%GF%s(2)-1,1.0_cp)
           elseif(L(3)) then
           BF = BF + plane_sum_z(temp_phi%GF,B%g,2,-1.0_cp)
           BF = BF + plane_sum_z(temp_phi%GF,B%g,temp_phi%GF%s(3)-1,1.0_cp)
           endif
         endif
       end subroutine

       function symmetry_error_x_BF(u) result(SE)
         implicit none
         type(block_field),intent(in) :: u
         real(cp) :: SE
         SE = symmetry_error_x(u%GF)
       end function

       function symmetry_error_y_BF(u) result(SE)
         implicit none
         type(block_field),intent(in) :: u
         real(cp) :: SE
         SE = symmetry_error_y(u%GF)
       end function

       function symmetry_error_z_BF(u) result(SE)
         implicit none
         type(block_field),intent(in) :: u
         real(cp) :: SE
         SE = symmetry_error_z(u%GF)
       end function

       subroutine symmetry_local_x_BF(u)
         implicit none
         type(block_field),intent(inout) :: u
         call symmetry_local_x(u%GF)
       end subroutine

       subroutine symmetry_local_y_BF(u)
         implicit none
         type(block_field),intent(inout) :: u
         call symmetry_local_y(u%GF)
       end subroutine

       subroutine symmetry_local_z_BF(u)
         implicit none
         type(block_field),intent(inout) :: u
         call symmetry_local_z(u%GF)
       end subroutine

       subroutine restrict_BF(r,u,B,dir)
         implicit none
         type(block_field),intent(inout) :: r
         type(block_field),intent(in) :: u
         type(block),intent(in) :: B
         integer,intent(in) :: dir
         integer,dimension(3) :: eye
         integer :: x,y,z
         eye = eye_given_dir(dir)
         x = eye(1); y = eye(2); z = eye(3)
         if (CC_along(u%DL,dir))    then; call restrict_C(r%GF,u%GF,B%g,dir,x,y,z)
         elseif (N_along(u%DL,dir)) then; call restrict_N(r%GF,u%GF,B%g,dir,x,y,z)
         else; stop 'Error: bad DL in restrict_BF in BF.f90'
         endif
       end subroutine

       subroutine restrict_reset_BF(u,B,dir)
         implicit none
         type(block_field),intent(inout) :: u
         type(block),intent(in) :: B
         integer,intent(in) :: dir
         integer,dimension(3) :: eye
         integer :: i,x,y,z
         real(cp),dimension(6) :: c_w,Robin_coeff
         eye = eye_given_dir(dir)
         x = eye(1); y = eye(2); z = eye(3)
         if (CC_along(u%DL,dir))    then; call restrict_C(u%GF,B%g,dir,x,y,z)
         elseif (N_along(u%DL,dir)) then; call restrict_N(u%GF,B%g,dir,x,y,z)
         else; stop 'Error: bad DL in restrict_BF in BF.f90'
         endif

         if (defined(u%BCs)) then
         do i=1,6
         if (dir_given_face(i).ne.dir) then ! only restrict BCs along surface tangent directions
           if (CC_along(u%DL,dir))    then; call restrict_C(u%BCs%face%SB(i)%b,B%fb(i),dir,x,y,z)
           elseif (N_along(u%DL,dir)) then; call restrict_N(u%BCs%face%SB(i)%b,B%fb(i),dir,x,y,z)
           else; stop 'Error: bad DL in restrict_BF in BF.f90'
           endif
         endif
         enddo
         Robin_coeff = u%BCs%f_BCs%Robin_coeff
         c_w = u%BCs%f_BCs%c_w
         call restrict(u%BCs,B,dir)
         call init_BC_props(u,c_w,Robin_coeff)
         endif
       end subroutine

       subroutine prolongate_BF(r,u,B,dir)
         implicit none
         type(block_field),intent(inout) :: r
         type(block_field),intent(in) :: u
         type(block),intent(in) :: B
         integer,intent(in) :: dir
         integer,dimension(3) :: eye
         integer :: x,y,z
         eye = eye_given_dir(dir)
         x = eye(1); y = eye(2); z = eye(3)
         if (CC_along(u%DL,dir))    then; call prolongate_C(r%GF,u%GF,B%g,dir,x,y,z)
         elseif (N_along(u%DL,dir)) then; call prolongate_N(r%GF,u%GF,x,y,z)
         else; stop 'Error: bad DL in prolongate_BF in BF.f90'
         endif
       end subroutine

       subroutine prolongate_reset_BF(u,B,dir)
         implicit none
         type(block_field),intent(inout) :: u
         type(block),intent(in) :: B
         integer,intent(in) :: dir
         integer,dimension(3) :: eye
         integer :: x,y,z
         real(cp),dimension(6) :: c_w,Robin_coeff
         eye = eye_given_dir(dir)
         x = eye(1); y = eye(2); z = eye(3)
             if (CC_along(u%DL,dir)) then; call prolongate_C(u%GF,B%g,dir,x,y,z)
         elseif ( N_along(u%DL,dir)) then; call prolongate_N(u%GF,dir,x,y,z)
         else; stop 'Error: bad DL in prolongate_BF in BF.f90'
         endif
         if (defined(u%BCs)) then
           Robin_coeff = u%BCs%f_BCs%Robin_coeff
           c_w = u%BCs%f_BCs%c_w
           call prolongate(u%BCs,B,dir)
           call init_BC_props(u,c_w,Robin_coeff)
         endif
       end subroutine

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module SF_mod
       use block_field_extend_mod
       use current_precision_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use data_location_mod
       use block_field_mod
       use dir_manip_mod
       implicit none

       private
       public :: SF
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,get_necessary_for_restart,suppress_warnings

       interface init;                     module procedure init_copy_SF;                end interface
       interface delete;                   module procedure delete_SF;                   end interface
       interface display;                  module procedure display_SF;                  end interface
       interface display_short;            module procedure display_short_SF;            end interface
       interface display;                  module procedure display_wrap_SF;             end interface
       interface print;                    module procedure print_SF;                    end interface
       interface print_short;              module procedure print_short_SF;              end interface
       interface export;                   module procedure export_SF;                   end interface
       interface export_primitives;        module procedure export_primitives_SF;        end interface
       interface import;                   module procedure import_SF;                   end interface
       interface export_folder_structure;  module procedure export_folder_structure_SF;  end interface
       interface export_structured;        module procedure export_structured_D_SF;      end interface
       interface import_structured;        module procedure import_structured_D_SF;      end interface
       interface import_primitives;        module procedure import_primitives_SF;        end interface
       interface export;                   module procedure export_wrap_SF;              end interface
       interface import;                   module procedure import_wrap_SF;              end interface
       interface set_IO_dir;               module procedure set_IO_dir_SF;               end interface
       interface make_IO_dir;              module procedure make_IO_dir_SF;              end interface
       interface get_necessary_for_restart;module procedure get_necessary_for_restart_SF;end interface
       interface suppress_warnings;        module procedure suppress_warnings_SF;        end interface

       type SF
         integer :: s = 0
         type(block_field),dimension(:),allocatable :: BF
         logical :: all_neumann = .false.
         integer :: numEl = 0
         integer :: numPhysEl = 0
         real(cp) :: vol = 0.0_cp
         type(data_location) :: DL
       end type

       contains

       subroutine init_copy_SF(this,that)
         implicit none
         type(SF),intent(inout) :: this
         type(SF),intent(in) :: that
         integer :: i_BF
         integer :: s_BF
         call delete(this)
         this%s = that%s
         if (allocated(that%BF)) then
           s_BF = size(that%BF)
           if (s_BF.gt.0) then
             allocate(this%BF(s_BF))
             do i_BF=1,s_BF
               call init(this%BF(i_BF),that%BF(i_BF))
             enddo
           endif
         endif
         this%all_neumann = that%all_neumann
         this%numEl = that%numEl
         this%numPhysEl = that%numPhysEl
         this%vol = that%vol
         call init(this%DL,that%DL)
       end subroutine

       subroutine delete_SF(this)
         implicit none
         type(SF),intent(inout) :: this
         integer :: i_BF
         integer :: s_BF
         this%s = 0
         if (allocated(this%BF)) then
           s_BF = size(this%BF)
           do i_BF=1,s_BF
             call delete(this%BF(i_BF))
           enddo
           deallocate(this%BF)
         endif
         this%all_neumann = .false.
         this%numEl = 0
         this%numPhysEl = 0
         this%vol = 0.0_cp
         call delete(this%DL)
       end subroutine

       subroutine display_SF(this,un)
         implicit none
         type(SF),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_BF
         integer :: s_BF
         write(un,*) 's           = ',this%s
         if (allocated(this%BF)) then
           s_BF = size(this%BF)
           do i_BF=1,s_BF
             call display(this%BF(i_BF),un)
           enddo
         endif
         write(un,*) 'all_neumann = ',this%all_neumann
         write(un,*) 'numEl       = ',this%numEl
         write(un,*) 'numPhysEl   = ',this%numPhysEl
         write(un,*) 'vol         = ',this%vol
         call display(this%DL,un)
       end subroutine

       subroutine display_short_SF(this,un)
         implicit none
         type(SF),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_BF
         integer :: s_BF
         write(un,*) 's           = ',this%s
         if (allocated(this%BF)) then
           s_BF = size(this%BF)
           do i_BF=1,s_BF
             call display(this%BF(i_BF),un)
           enddo
         endif
         write(un,*) 'all_neumann = ',this%all_neumann
         write(un,*) 'numEl       = ',this%numEl
         write(un,*) 'numPhysEl   = ',this%numPhysEl
         write(un,*) 'vol         = ',this%vol
         call display(this%DL,un)
       end subroutine

       subroutine display_wrap_SF(this,dir,name)
         implicit none
         type(SF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_SF(this)
         implicit none
         type(SF),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_SF(this)
         implicit none
         type(SF),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_SF(this,un)
         implicit none
         type(SF),intent(in) :: this
         integer,intent(in) :: un
         integer :: i_BF
         integer :: s_BF
         call export_primitives(this,un)
         if (allocated(this%BF)) then
           s_BF = size(this%BF)
           write(un,*) s_BF
           if (s_BF.gt.0) then
             do i_BF=1,s_BF
               call export(this%BF(i_BF),un)
             enddo
           else
             write(un,*) 0
           endif
         endif
         call export(this%DL,un)
       end subroutine

       subroutine import_SF(this,un)
         implicit none
         type(SF),intent(inout) :: this
         integer,intent(in) :: un
         integer :: i_BF
         integer :: s_BF
         call delete(this)
         call import_primitives(this,un)
         read(un,*) s_BF
         if (s_BF.gt.0) then
           allocate(this%BF(s_BF))
           do i_BF=1,s_BF
             call import(this%BF(i_BF),un)
           enddo
         endif
         call import(this%DL,un)
       end subroutine

       subroutine export_primitives_SF(this,un)
         implicit none
         type(SF),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 's            = ';write(un,*) this%s
         write(un,*) 'all_neumann  = ';write(un,*) this%all_neumann
         write(un,*) 'numEl        = ';write(un,*) this%numEl
         write(un,*) 'numPhysEl    = ';write(un,*) this%numPhysEl
         write(un,*) 'vol          = ';write(un,*) this%vol
       end subroutine

       subroutine import_primitives_SF(this,un)
         implicit none
         type(SF),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%s
         read(un,*); read(un,*) this%all_neumann
         read(un,*); read(un,*) this%numEl
         read(un,*); read(un,*) this%numPhysEl
         read(un,*); read(un,*) this%vol
       end subroutine

       subroutine export_wrap_SF(this,dir,name)
         implicit none
         type(SF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_SF(this,dir,name)
         implicit none
         type(SF),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       function get_necessary_for_restart_SF(this) result(L)
         implicit none
         type(SF),intent(in) :: this
         logical :: L
         integer :: i_BF
         integer :: s_BF
         if (allocated(this%BF)) then
           s_BF = size(this%BF)
           L = all((/(get_necessary_for_restart(this%BF(i_BF)),i_BF=1,&
           s_BF)/))
         else
           L = .false.
         endif
       end function

       subroutine set_IO_dir_SF(this,dir)
         implicit none
         type(SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_BF
         integer :: s_BF
         call suppress_warnings(this)
         if (allocated(this%BF)) then
           s_BF = size(this%BF)
           do i_BF=1,s_BF
             call set_IO_dir(this%BF(i_BF),&
             dir//'BF_'//int2str(i_BF)//fortran_PS)
           enddo
         endif
         call set_IO_dir(this%DL,dir//'DL'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_SF(this,dir)
         implicit none
         type(SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_BF
         integer :: s_BF
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         if (allocated(this%BF)) then
           s_BF = size(this%BF)
           do i_BF=1,s_BF
             call make_IO_dir(this%BF(i_BF),&
             dir//'BF_'//int2str(i_BF)//fortran_PS)
           enddo
         endif
         call make_IO_dir(this%DL,dir//'DL'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_SF(this,dir)
         implicit none
         type(SF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_BF
         integer :: s_BF
         integer :: un
         if (allocated(this%BF)) then
           s_BF = size(this%BF)
           write(un,*) s_BF
           do i_BF=1,s_BF
             call export_structured(this%BF(i_BF),&
             dir//'BF_'//int2str(i_BF)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         call export_structured(this%DL,dir//'DL'//fortran_PS)
       end subroutine

       subroutine export_structured_D_SF(this,dir)
         implicit none
         type(SF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: i_BF
         integer :: s_BF
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         if (allocated(this%BF)) then
           s_BF = size(this%BF)
           write(un,*) s_BF
           do i_BF=1,s_BF
             call export_structured(this%BF(i_BF),&
             dir//'BF_'//int2str(i_BF)//fortran_PS)
           enddo
         else
           write(un,*) 0
         endif
         call export_structured(this%DL,dir//'DL'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_SF(this,dir)
         implicit none
         type(SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: i_BF
         integer :: s_BF
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         read(un,*) s_BF
         if (s_BF.gt.0) then
           if (.not.allocated(this%BF)) then
             allocate(this%BF(s_BF))
           endif
           do i_BF=1,s_BF
             call import_structured(this%BF(i_BF),&
             dir//'BF_'//int2str(i_BF)//fortran_PS)
           enddo
         endif
         call import_structured(this%DL,dir//'DL'//fortran_PS)
         if (allocated(this%BF)) then
           s_BF = size(this%BF)
           do i_BF=1,s_BF
             call set_procedures(this%BF(i_BF))
           enddo
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_SF(this)
         implicit none
         type(SF),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module mesh_domain_extend_mod
       use mesh_domain_mod
       use IO_tools_mod
       use physical_domain_mod
       use physical_domain_extend_mod
       use physical_sub_domain_mod
       use physical_sub_domain_extend_mod
       use block_field_mod
       use block_field_extend_mod
       use mesh_extend_mod
       implicit none

       private
       public :: mesh_domain
       public :: init,delete,display,print,export,import ! Essentials
       public :: print_D
       public :: add,init_other

       public :: prolongate

       interface init;       module procedure init_MD;       end interface
       interface print_D;    module procedure print_MD;      end interface

       interface add;        module procedure add_subdomain; end interface
       interface init_other; module procedure init_other_MD; end interface

       interface prolongate; module procedure prolongate_MD; end interface

       contains

       subroutine init_MD(MD,m_R1,m_R2)
         implicit none
         type(mesh_domain),intent(inout) :: MD
         type(mesh),intent(in) :: m_R1,m_R2
         call init(MD%D,m_R1,m_R2)
         call init(MD%m_R1,m_R1)
         call init(MD%m_R2,m_R2)
       end subroutine

       subroutine print_MD(MD,name)
         implicit none
         type(mesh_domain),intent(in) :: MD
         character(len=*),intent(in) :: name
         call print(MD%D,name)
       end subroutine

       subroutine add_subdomain(MD,sd)
         implicit none
         type(mesh_domain),intent(inout) :: MD
         type(physical_sub_domain),intent(in) :: sd
         call add(MD%D,sd)
       end subroutine

       subroutine init_other_MD(m_other,m,MD)
         implicit none
         type(mesh),intent(inout) :: m_other
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         call delete(m_other)
         if (compare(m,MD%m_R1)) then;     call init(m_other,MD%m_R2)
         elseif (compare(m,MD%m_R2)) then; call init(m_other,MD%m_R1)
         else; stop 'Error: case not found in init_other_MD in mesh_domain.f90'
         endif
       end subroutine

       subroutine prolongate_MD(MD,dir)
         implicit none
         type(mesh_domain),intent(inout) :: MD
         integer,intent(in) :: dir
         call prolongate(MD%m_R1,dir)
         call prolongate(MD%m_R2,dir)
         call init(MD%D,MD%m_R1,MD%m_R2)
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module FFT_Solver_SF_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use norms_mod
       use string_mod
       use SF_mod
       use dir_manip_mod
       implicit none

       private
       public :: FFT_Solver_SF
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_FFT_Solver_SF;              end interface
       interface delete;                 module procedure delete_FFT_Solver_SF;                 end interface
       interface display;                module procedure display_FFT_Solver_SF;                end interface
       interface display_short;          module procedure display_short_FFT_Solver_SF;          end interface
       interface display;                module procedure display_wrap_FFT_Solver_SF;           end interface
       interface print;                  module procedure print_FFT_Solver_SF;                  end interface
       interface print_short;            module procedure print_short_FFT_Solver_SF;            end interface
       interface export;                 module procedure export_FFT_Solver_SF;                 end interface
       interface export_primitives;      module procedure export_primitives_FFT_Solver_SF;      end interface
       interface import;                 module procedure import_FFT_Solver_SF;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_FFT_Solver_SF;end interface
       interface export_structured;      module procedure export_structured_D_FFT_Solver_SF;    end interface
       interface import_structured;      module procedure import_structured_D_FFT_Solver_SF;    end interface
       interface import_primitives;      module procedure import_primitives_FFT_Solver_SF;      end interface
       interface export;                 module procedure export_wrap_FFT_Solver_SF;            end interface
       interface import;                 module procedure import_wrap_FFT_Solver_SF;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_FFT_Solver_SF;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_FFT_Solver_SF;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_FFT_Solver_SF;      end interface

       type FFT_Solver_SF
         type(SF) :: f
         type(SF) :: res
         type(SF) :: vol
         type(SF) :: coeff
         integer :: direction = 0
         type(norms) :: norm
         type(string) :: var_name
       end type

       contains

       subroutine init_copy_FFT_Solver_SF(this,that)
         implicit none
         type(FFT_Solver_SF),intent(inout) :: this
         type(FFT_Solver_SF),intent(in) :: that
         call delete(this)
         call init(this%f,that%f)
         call init(this%res,that%res)
         call init(this%vol,that%vol)
         call init(this%coeff,that%coeff)
         this%direction = that%direction
         call init(this%norm,that%norm)
         call init(this%var_name,that%var_name)
       end subroutine

       subroutine delete_FFT_Solver_SF(this)
         implicit none
         type(FFT_Solver_SF),intent(inout) :: this
         call delete(this%f)
         call delete(this%res)
         call delete(this%vol)
         call delete(this%coeff)
         this%direction = 0
         call delete(this%norm)
         call delete(this%var_name)
       end subroutine

       subroutine display_FFT_Solver_SF(this,un)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         integer,intent(in) :: un
         call display(this%f,un)
         call display(this%res,un)
         call display(this%vol,un)
         call display(this%coeff,un)
         write(un,*) 'direction = ',this%direction
         call display(this%norm,un)
         call display(this%var_name,un)
       end subroutine

       subroutine display_short_FFT_Solver_SF(this,un)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         integer,intent(in) :: un
         call display(this%f,un)
         call display(this%res,un)
         call display(this%vol,un)
         call display(this%coeff,un)
         write(un,*) 'direction = ',this%direction
         call display(this%norm,un)
         call display(this%var_name,un)
       end subroutine

       subroutine display_wrap_FFT_Solver_SF(this,dir,name)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_FFT_Solver_SF(this)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_FFT_Solver_SF(this)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_FFT_Solver_SF(this,un)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%f,un)
         call export(this%res,un)
         call export(this%vol,un)
         call export(this%coeff,un)
         call export(this%norm,un)
         call export(this%var_name,un)
       end subroutine

       subroutine import_FFT_Solver_SF(this,un)
         implicit none
         type(FFT_Solver_SF),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%f,un)
         call import(this%res,un)
         call import(this%vol,un)
         call import(this%coeff,un)
         call import(this%norm,un)
         call import(this%var_name,un)
       end subroutine

       subroutine export_primitives_FFT_Solver_SF(this,un)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'direction  = ';write(un,*) this%direction
       end subroutine

       subroutine import_primitives_FFT_Solver_SF(this,un)
         implicit none
         type(FFT_Solver_SF),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%direction
       end subroutine

       subroutine export_wrap_FFT_Solver_SF(this,dir,name)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_FFT_Solver_SF(this,dir,name)
         implicit none
         type(FFT_Solver_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_FFT_Solver_SF(this,dir)
         implicit none
         type(FFT_Solver_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%f,dir//'f'//fortran_PS)
         call set_IO_dir(this%res,dir//'res'//fortran_PS)
         call set_IO_dir(this%vol,dir//'vol'//fortran_PS)
         call set_IO_dir(this%coeff,dir//'coeff'//fortran_PS)
         call set_IO_dir(this%norm,dir//'norm'//fortran_PS)
         call set_IO_dir(this%var_name,dir//'var_name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_FFT_Solver_SF(this,dir)
         implicit none
         type(FFT_Solver_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         if (get_necessary_for_restart(this%f)) then
           call make_IO_dir(this%f,dir//'f'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%res)) then
           call make_IO_dir(this%res,dir//'res'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call make_IO_dir(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%coeff)) then
           call make_IO_dir(this%coeff,dir//'coeff'//fortran_PS)
         endif
         call make_IO_dir(this%norm,dir//'norm'//fortran_PS)
         call make_IO_dir(this%var_name,dir//'var_name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_FFT_Solver_SF(this,dir)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         if (get_necessary_for_restart(this%f)) then
           call export_structured(this%f,dir//'f'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%res)) then
           call export_structured(this%res,dir//'res'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call export_structured(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%coeff)) then
           call export_structured(this%coeff,dir//'coeff'//fortran_PS)
         endif
         call export_structured(this%norm,dir//'norm'//fortran_PS)
         call export_structured(this%var_name,dir//'var_name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_FFT_Solver_SF(this,dir)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         if (get_necessary_for_restart(this%f)) then
           call export_structured(this%f,dir//'f'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%res)) then
           call export_structured(this%res,dir//'res'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call export_structured(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%coeff)) then
           call export_structured(this%coeff,dir//'coeff'//fortran_PS)
         endif
         call export_structured(this%norm,dir//'norm'//fortran_PS)
         call export_structured(this%var_name,dir//'var_name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_FFT_Solver_SF(this,dir)
         implicit none
         type(FFT_Solver_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         if (get_necessary_for_restart(this%f)) then
           call import_structured(this%f,dir//'f'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%res)) then
           call import_structured(this%res,dir//'res'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call import_structured(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%coeff)) then
           call import_structured(this%coeff,dir//'coeff'//fortran_PS)
         endif
         call import_structured(this%norm,dir//'norm'//fortran_PS)
         call import_structured(this%var_name,dir//'var_name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_FFT_Solver_SF(this)
         implicit none
         type(FFT_Solver_SF),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module SF_extend_mod
      use SF_mod
        use current_precision_mod
        use IO_tools_mod
        use array_mod
        use data_location_extend_mod
        use mesh_extend_mod
        use mesh_domain_extend_mod
        use boundary_conditions_extend_mod
        use GF_mod
        use block_field_mod
        use block_field_extend_mod
        implicit none
        private

        ! Initialization / Deletion (allocate/deallocate)
        public :: SF
        public :: init,delete,display,print,export,import ! Essentials
        ! Grid initialization
        public :: init_CC
        public :: init_Node
        public :: init_Face
        public :: init_Edge

        public :: is_CC
        public :: is_Node
        public :: is_Face
        public :: is_Edge

        public :: get_DL

        public :: inverse_area
        public :: volume
        public :: sine_waves
        public :: cosine_waves
        public :: random_noise

        public :: plane_sum_x
        public :: plane_sum_y
        public :: plane_sum_z
        public :: boundary_flux

        public :: symmetry_error_x,symmetry_local_x
        public :: symmetry_error_y,symmetry_local_y
        public :: symmetry_error_z,symmetry_local_z

        public :: mirror_about_hmin,mirror_about_hmax

        public :: multiply_volume
        public :: mean_along_dir
        public :: amax_diff
        public :: subtract_mean_along_dir

        public :: assign_BCs
        public :: assign_BC_vals
        public :: update_BC_vals
        public :: assign_Dirichlet_BCs
        public :: assign_Periodic_BCs
        public :: assign_Neumann_BCs
        public :: assign_Neumann_BCs_wall_normal
        public :: multiply_Neumann_BCs
        public :: multiply_BCs_by_nhat
        public :: assign_Robin_BCs
        public :: multiply_Robin_coeff
        public :: multiply_nhat
        public :: assign_wall_Periodic_single
        public :: assign_ghost_XPeriodic
        public :: assign_ghost_N_XPeriodic
        public :: assign_wall_Dirichlet
        public :: multiply_wall_Neumann
        public :: set_prescribed_BCs
        public :: set_BCs_homogeneous

        public :: get_any_Dirichlet
        public :: get_any_Neumann
        public :: get_any_Robin
        public :: get_any_Prescribed

        public :: init_BCs,init_BC_Dirichlet,init_BC_mesh
        public :: init_BC_props
        public :: set_procedures
        public :: set_necessary_for_restart
        public :: dot_product
        public :: cross_product_x
        public :: cross_product_y
        public :: cross_product_z

        public :: CFL_number
        public :: dt_given_CFL_number
        public :: Fourier_number
        public :: Robin_BC_coeff

        public :: restrict
        public :: prolongate

        ! Monitoring
        public :: print_BCs
        public :: export_BCs

        ! Operators
        public :: assign,assign_negative
        public :: add,subtract
        public :: multiply,divide
        public :: invert
        public :: add_product,product_add,swap
        ! Auxiliary
        public :: square,square_root,min,max,amin,amax
        public :: mean,sum,abs,insist_amax_lt_tol
        public :: magnitude

        public :: assign_ghost_xmin_xmax
        public :: assign_ghost_ymin_ymax
        public :: assign_ghost_zmin_zmax

        interface init;                     module procedure init_DL_SF;                   end interface
        interface init;                     module procedure init_SF_copy_mesh;            end interface

        interface init_CC;                  module procedure init_SF_CC;                   end interface
        interface init_Node;                module procedure init_SF_Node;                 end interface
        interface init_Face;                module procedure init_SF_Face;                 end interface
        interface init_Edge;                module procedure init_SF_Edge;                 end interface

        interface init_CC;                  module procedure init_SF_CC_D;                 end interface
        interface init_Node;                module procedure init_SF_Node_D;               end interface
        interface init_Face;                module procedure init_SF_Face_D;               end interface
        interface init_Edge;                module procedure init_SF_Edge_D;               end interface

        interface init_CC;                  module procedure init_SF_CC_assign;            end interface
        interface init_Node;                module procedure init_SF_Node_assign;          end interface
        interface init_Face;                module procedure init_SF_Face_assign;          end interface
        interface init_Edge;                module procedure init_SF_Edge_assign;          end interface

        interface init_BCs;                 module procedure init_BCs_SF_SF;               end interface
        interface init_BC_Dirichlet;        module procedure init_BC_Dirichlet_SF;         end interface
        interface init_BCs;                 module procedure init_BC_val_SF;               end interface
        interface init_BC_mesh;             module procedure init_BC_mesh_SF;              end interface
        interface init_BC_props;            module procedure init_BC_props_SF;             end interface
        interface set_procedures;           module procedure set_procedures_SF;            end interface
        interface set_necessary_for_restart;module procedure set_necessary_for_restart_SF; end interface

        interface print_BCs;                module procedure print_BCs_SF;                 end interface
        interface export_BCs;               module procedure export_BCs_SF;                end interface

        interface multiply_volume;          module procedure multiply_volume_SF;           end interface
        interface mean_along_dir;           module procedure mean_along_dir_SF;            end interface
        interface amax_diff;                module procedure amax_diff_SF;                 end interface
        interface amax_diff;                module procedure amax_diff_dir_SF;             end interface
        interface subtract_mean_along_dir;  module procedure subtract_mean_along_dir_SF;   end interface

        interface is_CC;                    module procedure is_CC_SF;                     end interface
        interface is_Node;                  module procedure is_Node_SF;                   end interface
        interface is_Face;                  module procedure is_Face_SF;                   end interface
        interface is_Edge;                  module procedure is_Edge_SF;                   end interface

        interface get_DL;                   module procedure get_DL_SF;                    end interface

        interface inverse_area;             module procedure inverse_area_SF;              end interface
        interface volume;                   module procedure volume_SF;                    end interface
        interface sine_waves;               module procedure sine_waves_SF;                end interface
        interface cosine_waves;             module procedure cosine_waves_SF;              end interface
        interface random_noise;             module procedure random_noise_SF;              end interface
        interface random_noise;             module procedure random_noise_SF_dir;          end interface

        interface assign_BCs;               module procedure assign_BCs_SF;                end interface
        interface assign_BC_vals;           module procedure assign_BC_vals_SF;            end interface
        interface update_BC_vals;           module procedure update_BC_vals_SF;            end interface
        interface assign_Dirichlet_BCs;     module procedure assign_Dirichlet_BCs_SF;      end interface
        interface assign_Periodic_BCs;      module procedure assign_Periodic_BCs_SF;       end interface
        interface assign_Neumann_BCs;       module procedure assign_Neumann_BCs_faces_SF;  end interface
        interface assign_Neumann_BCs_wall_normal; module procedure assign_Neumann_BCs_wall_normal_SF;  end interface
        interface multiply_Neumann_BCs;     module procedure multiply_Neumann_BCs_SF;      end interface
        interface multiply_BCs_by_nhat;     module procedure multiply_BCs_by_nhat_SF;      end interface
        interface assign_Robin_BCs;         module procedure assign_Robin_BCs_dir_SF;      end interface
        interface assign_Robin_BCs;         module procedure assign_Robin_BCs_faces_SF;    end interface
        interface multiply_Robin_coeff;     module procedure multiply_Robin_coeff_SF;      end interface
        interface multiply_nhat;            module procedure multiply_nhat_SF;             end interface
        interface assign_ghost_XPeriodic;   module procedure assign_ghost_XPeriodic_SF;    end interface
        interface assign_ghost_XPeriodic;   module procedure assign_ghost_XPeriodic_SF2;   end interface
        interface assign_ghost_N_XPeriodic; module procedure assign_ghost_N_XPeriodic_SF;  end interface
        interface assign_ghost_N_XPeriodic; module procedure assign_ghost_N_XPeriodic_SF2; end interface
        interface assign_wall_Dirichlet;    module procedure assign_wall_Dirichlet_SF;     end interface
        interface assign_wall_Dirichlet;    module procedure assign_wall_Dirichlet_SF2;    end interface
        interface assign_wall_Periodic_single;     module procedure assign_wall_Periodic_single_SF;      end interface
        interface assign_wall_Periodic_single;     module procedure assign_wall_Periodic_single_SF2;      end interface
        interface multiply_wall_Neumann;    module procedure multiply_wall_Neumann_SF;     end interface
        interface multiply_wall_Neumann;    module procedure multiply_wall_Neumann_SF2;    end interface
        interface set_prescribed_BCs;       module procedure set_prescribed_BCs_SF;        end interface
        interface set_BCs_homogeneous;      module procedure set_BCs_homogeneous_SF;       end interface

        interface get_any_Dirichlet;        module procedure get_any_Dirichlet_SF;         end interface
        interface get_any_Neumann;          module procedure get_any_Neumann_SF;           end interface
        interface get_any_Robin;            module procedure get_any_Robin_SF;             end interface
        interface get_any_Prescribed;       module procedure get_any_Prescribed_SF;        end interface

        interface plane_sum_x;              module procedure plane_sum_x_SF;               end interface
        interface plane_sum_y;              module procedure plane_sum_y_SF;               end interface
        interface plane_sum_z;              module procedure plane_sum_z_SF;               end interface
        interface boundary_flux;            module procedure boundary_flux_SF;             end interface
        interface boundary_flux;            module procedure boundary_flux_SF_SF;          end interface

        interface symmetry_error_x;         module procedure symmetry_error_x_SF;          end interface
        interface symmetry_error_y;         module procedure symmetry_error_y_SF;          end interface
        interface symmetry_error_z;         module procedure symmetry_error_z_SF;          end interface

        interface symmetry_local_x;         module procedure symmetry_local_x_SF;          end interface
        interface symmetry_local_y;         module procedure symmetry_local_y_SF;          end interface
        interface symmetry_local_z;         module procedure symmetry_local_z_SF;          end interface

        interface mirror_about_hmin;        module procedure mirror_about_hmin_SF;         end interface
        interface mirror_about_hmax;        module procedure mirror_about_hmax_SF;         end interface

        interface assign_ghost_xmin_xmax;   module procedure assign_ghost_xmin_xmax_SF;    end interface
        interface assign_ghost_ymin_ymax;   module procedure assign_ghost_ymin_ymax_SF;    end interface
        interface assign_ghost_zmin_zmax;   module procedure assign_ghost_zmin_zmax_SF;    end interface

        interface cross_product_x;          module procedure cross_product_x_SF;           end interface
        interface cross_product_y;          module procedure cross_product_y_SF;           end interface
        interface cross_product_z;          module procedure cross_product_z_SF;           end interface

        interface CFL_number;               module procedure CFL_number_SF;                end interface
        interface dt_given_CFL_number;      module procedure dt_given_CFL_number_SF;       end interface
        interface Fourier_number;           module procedure Fourier_number_SF;            end interface
        interface Robin_BC_coeff;           module procedure Robin_BC_coeff_SF;            end interface

        interface restrict;                 module procedure restrict_SF;                  end interface
        interface restrict;                 module procedure restrict_reset_SF;            end interface
        interface restrict;                 module procedure restrict_all_reset_SF;        end interface
        interface prolongate;               module procedure prolongate_SF;                end interface
        interface prolongate;               module procedure prolongate_reset_SF;          end interface
        interface prolongate;               module procedure prolongate_all_reset_SF;      end interface

        ! COMPUTATION ROUTINES:

        interface assign;                   module procedure assign_SF_S;                  end interface
        interface assign;                   module procedure assign_SF_SF;                 end interface
        interface assign_negative;          module procedure assign_negative_SF_SF;        end interface

        interface add;                      module procedure add_SF_SF;                    end interface
        interface add;                      module procedure add_SF_SF_SF;                 end interface
        interface add;                      module procedure add_SF_SF_SF_SF;              end interface
        interface add;                      module procedure add_SF_S;                     end interface
        interface add;                      module procedure add_S_SF;                     end interface
        interface add;                      module procedure add_SF_SF9;                   end interface

        interface add_product;              module procedure add_product_SF_SF_S;          end interface
        interface add_product;              module procedure add_product_SF_SF_SF;         end interface
        interface product_add;              module procedure product_add_SF_SF_S;          end interface
        interface product_add;              module procedure product_add_SF_SF_SF;         end interface

        interface multiply;                 module procedure multiply_SF_SF;               end interface
        interface multiply;                 module procedure multiply_SF_SF_SF;            end interface
        interface multiply;                 module procedure multiply_SF_SF_S;             end interface
        interface multiply;                 module procedure multiply_SF_S;                end interface
        interface multiply;                 module procedure multiply_S_SF;                end interface

        interface subtract;                 module procedure subtract_SF_SF;               end interface
        interface subtract;                 module procedure subtract_SF_SF_SF;            end interface
        interface subtract;                 module procedure subtract_SF_S;                end interface
        interface subtract;                 module procedure subtract_S_SF;                end interface

        interface divide;                   module procedure divide_SF_SF;                 end interface
        interface divide;                   module procedure divide_SF_SF_SF;              end interface
        interface divide;                   module procedure divide_SF_S_SF;               end interface
        interface divide;                   module procedure divide_SF_S;                  end interface
        interface divide;                   module procedure divide_S_SF;                  end interface

        interface invert;                   module procedure invert_SF;                    end interface
        interface square;                   module procedure square_SF;                    end interface
        interface square_root;              module procedure square_root_SF;               end interface
        interface abs;                      module procedure abs_SF;                       end interface
        interface magnitude;                module procedure magnitude_SF_SF_SF;           end interface
        interface insist_amax_lt_tol;       module procedure insist_amax_lt_tol_SF;        end interface

        interface swap;                     module procedure swap_SF;                      end interface
        interface min;                      module procedure min_SF;                       end interface
        interface max;                      module procedure max_SF;                       end interface
        interface min;                      module procedure min_pad_SF;                   end interface
        interface max;                      module procedure max_pad_SF;                   end interface
        interface amin;                     module procedure amin_SF;                      end interface
        interface amax;                     module procedure amax_SF;                      end interface
        interface mean;                     module procedure mean_SF;                      end interface
        interface sum;                      module procedure sum_SF;                       end interface
        interface sum;                      module procedure sum_SF_pad;                   end interface
        interface dot_product;              module procedure dot_product_SF;               end interface

      contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

        subroutine init_DL_SF(f,m,DL)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(data_location),intent(in) :: DL
                if (is_CC(DL)) then; call init_CC(f,m)
          elseif (is_Node(DL)) then; call init_Node(f,m)
          elseif (is_Face(DL)) then; call init_Face(f,m,get_Face(DL))
          elseif (is_Edge(DL)) then; call init_Edge(f,m,get_Edge(DL))
          else; stop 'Error: Bad DL in SF.f90'
          endif
        end subroutine

        subroutine init_SF_copy_mesh(f,f_in,m)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: f_in
          type(mesh),intent(in) :: m
          type(SF) :: temp
                if (is_CC(f_in%DL)) then; call init_CC(temp,m)
          elseif (is_Node(f_in%DL)) then; call init_Node(temp,m)
          elseif (is_Face(f_in%DL)) then; call init_Face(temp,m,get_Face(f_in%DL))
          elseif (is_Edge(f_in%DL)) then; call init_Edge(temp,m,get_Edge(f_in%DL))
          else; stop 'Error: bad datatype in init_SF_copy_mesh in SF.f90'
          endif
          call init(f,temp)
          call delete(temp)
        end subroutine

       ! **********************************************************
       ! **********************************************************
       ! **********************************************************

        subroutine computeNumEl(f)
          implicit none
          type(SF),intent(inout) :: f
          integer :: i
          f%numEl = 0
          f%numPhysEl = 0
          do i=1,f%s
          f%numEl = f%numEl + f%BF(i)%GF%s(1)*f%BF(i)%GF%s(2)*f%BF(i)%GF%s(3)
          f%numPhysEl = f%numPhysEl + (f%BF(i)%GF%s(1)-2)*(f%BF(i)%GF%s(2)-2)*(f%BF(i)%GF%s(3)-2)
          enddo
        end subroutine

        subroutine init_SF_CC(f,m)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer :: i
          call delete(f)
          allocate(f%BF(m%s)); f%s = m%s
          do i=1,f%s; call init_CC(f%BF(i),m%B(i)); enddo
          call computeNumEl(f)
          call init_CC(f%DL)
        end subroutine

        subroutine init_SF_CC_D(f,m,MD)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(mesh_domain),intent(in) :: MD
              if (compare(m,MD%m_R1)) then; call init_CC(f,MD%m_R2)
          elseif (compare(m,MD%m_R2)) then; call init_CC(f,MD%m_R1)
          else; stop 'Error: case not found in init_SF_CC_D in SF.f90'
          endif
        end subroutine

        subroutine init_SF_CC_assign(f,m,val)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_CC(f,m); call assign(f,val)
        end subroutine

        subroutine init_SF_Face(f,m,dir)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          integer :: i
          call delete(f)
          allocate(f%BF(m%s)); f%s = m%s
          do i=1,f%s; call init_Face(f%BF(i),m%B(i),dir); enddo
          call computeNumEl(f)
          call init_Face(f%DL,dir)
        end subroutine

        subroutine init_SF_Face_D(f,m,dir,MD)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          type(mesh_domain),intent(in) :: MD
              if (compare(m,MD%m_R1)) then; call init_Face(f,MD%m_R2,dir)
          elseif (compare(m,MD%m_R2)) then; call init_Face(f,MD%m_R1,dir)
          else; stop 'Error: case not found in init_SF_Face_D in SF.f90'
          endif
        end subroutine

        subroutine init_SF_Face_assign(f,m,dir,val)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          real(cp),intent(in) :: val
          call init_Face(f,m,dir); call assign(f,val)
        end subroutine

        subroutine init_SF_Edge(f,m,dir)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          integer :: i
          call delete(f)
          allocate(f%BF(m%s)); f%s = m%s
          do i=1,f%s; call init_Edge(f%BF(i),m%B(i),dir); enddo
          call computeNumEl(f)
          call init_Edge(f%DL,dir)
        end subroutine

        subroutine init_SF_Edge_D(f,m,dir,MD)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          type(mesh_domain),intent(in) :: MD
              if (compare(m,MD%m_R1)) then; call init_Edge(f,MD%m_R2,dir)
          elseif (compare(m,MD%m_R2)) then; call init_Edge(f,MD%m_R1,dir)
          else; stop 'Error: case not found in init_SF_Edge_D in SF.f90'
          endif
        end subroutine

        subroutine init_SF_Edge_assign(f,m,dir,val)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          real(cp),intent(in) :: val
          call init_Edge(f,m,dir); call assign(f,val)
        end subroutine

        subroutine init_SF_Node(f,m)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer :: i
          call delete(f)
          allocate(f%BF(m%s)); f%s = m%s
          do i=1,f%s; call init_Node(f%BF(i),m%B(i)); enddo
          call computeNumEl(f)
          call init_Node(f%DL)
        end subroutine

        subroutine init_SF_Node_D(f,m,MD)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(mesh_domain),intent(in) :: MD
              if (compare(m,MD%m_R1)) then; call init_Node(f,MD%m_R2)
          elseif (compare(m,MD%m_R2)) then; call init_Node(f,MD%m_R1)
          else; stop 'Error: case not found in init_SF_Node_D in SF.f90'
          endif
        end subroutine

        subroutine init_SF_Node_assign(f,m,val)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_Node(f,m); call assign(f,val)
        end subroutine

        ! ***********************************************************
        ! *************************** BCS ***************************
        ! ***********************************************************

        subroutine init_BCs_SF_SF(f,g)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g
          integer :: i
          do i=1,f%s; call init(f%BF(i)%BCs,g%BF(i)%BCs); enddo
        end subroutine

        subroutine init_BC_Dirichlet_SF(f)
          implicit none
          type(SF),intent(inout) :: f
          integer :: i
          do i=1,f%s; call init_Dirichlet(f%BF(i)%BCs); enddo
        end subroutine

        subroutine init_BC_val_SF(f,val,c_w,Robin_coeff)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: val
          real(cp),dimension(6),intent(in) :: c_w,Robin_coeff
          integer :: i
          do i=1,f%s; call init_BCs(f%BF(i),val); enddo
          f%all_Neumann = all((/(f%BF(i)%BCs%BCL%all_Neumann,i=1,f%s)/))
          call init_BC_props(f,c_w,Robin_coeff)
        end subroutine

        subroutine init_BC_mesh_SF(f,m)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer :: i
          do i=1,f%s; call init_BCs(f%BF(i),m%B(i),f%DL); enddo
        end subroutine

        subroutine init_BC_props_SF(f,c_w,Robin_coeff)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),dimension(6),intent(in) :: c_w,Robin_coeff
          integer :: i
          do i=1,f%s
            call init_BC_props(f%BF(i),c_w,Robin_coeff)
          enddo
        end subroutine

        subroutine set_procedures_SF(f)
          implicit none
          type(SF),intent(inout) :: f
          integer :: i
          do i=1,f%s
            call set_procedures(f%BF(i))
          enddo
        end subroutine

        subroutine set_necessary_for_restart_SF(f)
          implicit none
          type(SF),intent(inout) :: f
          integer :: i
          do i=1,f%s; call set_necessary_for_restart(f%BF(i)); enddo
        end subroutine


        ! ***********************************************************
        ! ***********************************************************
        ! ***********************************************************

        function is_CC_SF(u) result(L)
          implicit none
          type(SF),intent(in) :: u
          logical :: L
          L = is_CC(u%DL)
        end function

        function is_Node_SF(u) result(L)
          implicit none
          type(SF),intent(in) :: u
          logical :: L
          L = is_Node(u%DL)
        end function

        function is_Face_SF(u) result(L)
          implicit none
          type(SF),intent(in) :: u
          logical :: L
          L = is_Face(u%DL)
        end function

        function is_Edge_SF(u) result(L)
          implicit none
          type(SF),intent(in) :: u
          logical :: L
          L = is_Edge(u%DL)
        end function

        function get_DL_SF(u) result(DL)
          implicit none
          type(SF),intent(in) :: u
          type(data_location) :: DL
          DL = u%DL
        end function

        subroutine volume_SF(u,m) ! Computes: volume(x(i),y(j),z(k)) = dx(i) dy(j) dz(k)
          implicit none
          type(SF),intent(inout) :: u
          type(mesh),intent(in) :: m
          integer :: i
          call assign(u,0.0_cp)
          do i=1,m%s
            call volume(u%BF(i),m%B(i),u%DL)
          enddo
          u%vol = sum(u)
        end subroutine

        subroutine inverse_area_SF(u,m,dir)
          implicit none
          type(SF),intent(inout) :: u
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          integer :: i
          call assign(u,0.0_cp)
          do i=1,m%s
            call inverse_area(u%BF(i),m%B(i),u%DL,dir)
          enddo
        end subroutine

        subroutine sine_waves_SF(u,m,wavenum,phi)
          implicit none
          type(SF),intent(inout) :: u
          type(mesh),intent(in) :: m
          real(cp),dimension(3),intent(in) :: wavenum,phi
          integer :: i
          do i=1,m%s; call sine_waves(u%BF(i),m%B(i),wavenum,phi,u%DL); enddo
        end subroutine

        subroutine cosine_waves_SF(u,m,wavenum,phi)
          implicit none
          type(SF),intent(inout) :: u
          type(mesh),intent(in) :: m
          real(cp),dimension(3),intent(in) :: wavenum,phi
          integer :: i
          do i=1,m%s; call cosine_waves(u%BF(i),m%B(i),wavenum,phi,u%DL); enddo
        end subroutine

        subroutine random_noise_SF(u)
          implicit none
          type(SF),intent(inout) :: u
          integer :: i
          do i=1,u%s; call random_noise(u%BF(i)); enddo
        end subroutine

        subroutine random_noise_SF_dir(u,dir)
          implicit none
          type(SF),intent(inout) :: u
          integer,intent(in) :: dir
          integer :: i
          do i=1,u%s; call random_noise(u%BF(i),dir); enddo
        end subroutine

        subroutine assign_BC_vals_SF(A,B)
          implicit none
          type(SF),intent(inout) :: A
          type(SF),intent(in) :: B
          integer :: i
          do i=1,A%s; call assign_BC_vals(A%BF(i),B%BF(i)); enddo
        end subroutine

        subroutine update_BC_vals_SF(A)
          implicit none
          type(SF),intent(inout) :: A
          integer :: i
          do i=1,A%s; call update_BC_vals(A%BF(i)); enddo
        end subroutine

        subroutine assign_BCs_SF(A,B)
          implicit none
          type(SF),intent(inout) :: A
          type(SF),intent(in) :: B
          integer :: i
          do i=1,A%s; call assign_BCs(A%BF(i),B%BF(i)); enddo
        end subroutine
        subroutine assign_Dirichlet_BCs_SF(A,B)
          implicit none
          type(SF),intent(inout) :: A
          type(SF),intent(in) :: B
          integer :: i
          do i=1,A%s; call assign_Dirichlet_BCs(A%BF(i),B%BF(i)); enddo
        end subroutine
        subroutine assign_Periodic_BCs_SF(A,B)
          implicit none
          type(SF),intent(inout) :: A
          type(SF),intent(in) :: B
          integer :: i
          do i=1,A%s; call assign_Periodic_BCs(A%BF(i),B%BF(i)); enddo
        end subroutine
        subroutine assign_Neumann_BCs_faces_SF(A,B,dir)
          implicit none
          type(SF),intent(inout) :: A
          type(SF),intent(in) :: B
          integer,intent(in) :: dir
          integer :: i
          do i=1,A%s; call assign_Neumann_BCs(A%BF(i),B%BF(i),dir); enddo
        end subroutine
        subroutine assign_Neumann_BCs_wall_normal_SF(A,B,dir)
          implicit none
          type(SF),intent(inout) :: A
          type(SF),intent(in) :: B
          integer,intent(in) :: dir
          integer :: i
          do i=1,A%s; call assign_Neumann_BCs_wall_normal(A%BF(i),B%BF(i),dir); enddo
        end subroutine
        subroutine multiply_Neumann_BCs_SF(A,scale)
          implicit none
          type(SF),intent(inout) :: A
          real(cp),intent(in) :: scale
          integer :: i
          do i=1,A%s; call multiply_Neumann_BCs(A%BF(i),scale); enddo
        end subroutine
        subroutine multiply_BCs_by_nhat_SF(A)
          implicit none
          type(SF),intent(inout) :: A
          integer :: i
          do i=1,A%s; call multiply_BCs_by_nhat(A%BF(i)); enddo
        end subroutine
        subroutine assign_Robin_BCs_dir_SF(A,B,dir)
          implicit none
          type(SF),intent(inout) :: A
          type(SF),intent(in) :: B
          integer,intent(in) :: dir
          integer :: i
          do i=1,A%s; call assign_Robin_BCs(A%BF(i),B%BF(i),dir); enddo
        end subroutine
        subroutine assign_Robin_BCs_faces_SF(A,B)
          implicit none
          type(SF),intent(inout) :: A
          type(SF),intent(in) :: B
          integer :: i
          do i=1,A%s; call assign_Robin_BCs(A%BF(i),B%BF(i)); enddo
        end subroutine

        subroutine multiply_Robin_coeff_SF(u)
          implicit none
          type(SF),intent(inout) :: u
          integer :: i
          do i=1,u%s; call multiply_Robin_coeff(u%BF(i)); enddo
        end subroutine
        subroutine multiply_nhat_SF(u,u_with_BCs)
          implicit none
          type(SF),intent(inout) :: u
          type(SF),intent(in) :: u_with_BCs
          integer :: i
          do i=1,u%s; call multiply_nhat(u%BF(i),u_with_BCs%BF(i)); enddo
        end subroutine

        subroutine assign_ghost_XPeriodic_SF(u,val)
          implicit none
          type(SF),intent(inout) :: u
          real(cp),intent(in) :: val
          integer :: i
          do i=1,u%s; call assign_ghost_XPeriodic(u%BF(i),val); enddo
        end subroutine
        subroutine assign_ghost_XPeriodic_SF2(u,val,u_with_BCs)
          implicit none
          type(SF),intent(inout) :: u
          real(cp),intent(in) :: val
          type(SF),intent(in) :: u_with_BCs
          integer :: i
          do i=1,u%s; call assign_ghost_XPeriodic(u%BF(i),val,u_with_BCs%BF(i)); enddo
        end subroutine

        subroutine assign_ghost_N_XPeriodic_SF(u,val)
          implicit none
          type(SF),intent(inout) :: u
          real(cp),intent(in) :: val
          integer :: i
          do i=1,u%s; call assign_ghost_N_XPeriodic(u%BF(i),val); enddo
        end subroutine
        subroutine assign_ghost_N_XPeriodic_SF2(u,val,u_with_BCs)
          implicit none
          type(SF),intent(inout) :: u
          real(cp),intent(in) :: val
          type(SF),intent(in) :: u_with_BCs
          integer :: i
          do i=1,u%s; call assign_ghost_N_XPeriodic(u%BF(i),val,u_with_BCs%BF(i)); enddo
        end subroutine

        subroutine assign_wall_Dirichlet_SF(u,val)
          implicit none
          type(SF),intent(inout) :: u
          real(cp),intent(in) :: val
          integer :: i
          do i=1,u%s; call assign_wall_Dirichlet(u%BF(i),val); enddo
        end subroutine
        subroutine assign_wall_Dirichlet_SF2(u,val,u_with_BCs)
          implicit none
          type(SF),intent(inout) :: u
          real(cp),intent(in) :: val
          type(SF),intent(in) :: u_with_BCs
          integer :: i
          do i=1,u%s; call assign_wall_Dirichlet(u%BF(i),val,u_with_BCs%BF(i)); enddo
        end subroutine

        subroutine assign_wall_Periodic_single_SF(u,val)
          implicit none
          type(SF),intent(inout) :: u
          real(cp),intent(in) :: val
          integer :: i
          do i=1,u%s; call assign_wall_Periodic_single(u%BF(i),val); enddo
        end subroutine
        subroutine assign_wall_Periodic_single_SF2(u,val,u_with_BCs)
          implicit none
          type(SF),intent(inout) :: u
          real(cp),intent(in) :: val
          type(SF),intent(in) :: u_with_BCs
          integer :: i
          do i=1,u%s; call assign_wall_Periodic_single(u%BF(i),val,u_with_BCs%BF(i)); enddo
        end subroutine

        subroutine multiply_wall_Neumann_SF(u,val)
          implicit none
          type(SF),intent(inout) :: u
          real(cp),intent(in) :: val
          integer :: i
          do i=1,u%s; call multiply_wall_Neumann(u%BF(i),val); enddo
        end subroutine
        subroutine multiply_wall_Neumann_SF2(u,val,u_with_BCs)
          implicit none
          type(SF),intent(inout) :: u
          real(cp),intent(in) :: val
          type(SF),intent(in) :: u_with_BCs
          integer :: i
          do i=1,u%s; call multiply_wall_Neumann(u%BF(i),val,u_with_BCs%BF(i)); enddo
        end subroutine

        subroutine set_prescribed_BCs_SF(u)
          implicit none
          type(SF),intent(inout) :: u
          integer :: i
          do i=1,u%s; call set_prescribed_BCs(u%BF(i)); enddo
        end subroutine

        subroutine set_BCs_homogeneous_SF(u)
          implicit none
          type(SF),intent(inout) :: u
          integer :: i
          do i=1,u%s; call set_BCs_homogeneous(u%BF(i)); enddo
        end subroutine

        function get_any_Dirichlet_SF(u) result(L)
          implicit none
          type(SF),intent(in) :: u
          logical :: L
          integer :: i
          L = any((/(get_any_Dirichlet(u%BF(i)),i=1,u%s)/))
        end function

        function get_any_Neumann_SF(u) result(L)
          implicit none
          type(SF),intent(in) :: u
          logical :: L
          integer :: i
          L = any((/(get_any_Neumann(u%BF(i)),i=1,u%s)/))
        end function

        function get_any_Robin_SF(u) result(L)
          implicit none
          type(SF),intent(in) :: u
          logical :: L
          integer :: i
          L = any((/(get_any_Robin(u%BF(i)),i=1,u%s)/))
        end function

        function get_any_Prescribed_SF(u) result(L)
          implicit none
          type(SF),intent(in) :: u
          logical :: L
          integer :: i
          L = any((/(get_any_Prescribed(u%BF(i)),i=1,u%s)/))
        end function

        function plane_sum_x_SF(u,m,p) result(SP)
          implicit none
          type(SF),intent(in) :: u
          type(mesh),intent(in) :: m
          integer,intent(in) :: p
          integer :: i
          real(cp) :: SP
          SP = 0.0_cp
          do i=1,m%s; SP = SP + plane_sum_x(u%BF(i),m%B(i),p); enddo
        end function

        function plane_sum_y_SF(u,m,p) result(SP)
          implicit none
          type(SF),intent(in) :: u
          type(mesh),intent(in) :: m
          integer,intent(in) :: p
          integer :: i
          real(cp) :: SP
          SP = 0.0_cp
          do i=1,m%s; SP = SP + plane_sum_y(u%BF(i),m%B(i),p); enddo
        end function

        function plane_sum_z_SF(u,m,p) result(SP)
          implicit none
          type(SF),intent(in) :: u
          type(mesh),intent(in) :: m
          integer,intent(in) :: p
          integer :: i
          real(cp) :: SP
          SP = 0.0_cp
          do i=1,m%s; SP = SP + plane_sum_z(u%BF(i),m%B(i),p); enddo
        end function

        subroutine boundary_flux_SF(BF,x,y,z,m,x_temp,y_temp,z_temp)
          implicit none
          real(cp),intent(inout) :: BF
          type(SF),intent(in) :: x,y,z
          type(mesh),intent(in) :: m
          type(SF),intent(inout) :: x_temp,y_temp,z_temp
          real(cp) :: temp
          integer :: i
          BF = 0.0_cp; temp = 0.0_cp
          do i=1,m%s
            call boundary_flux(temp,x%BF(i),y%BF(i),z%BF(i),m%B(i),&
                x_temp%BF(i),y_temp%BF(i),z_temp%BF(i)); BF = BF+temp
          enddo
        end subroutine

        subroutine boundary_flux_SF_SF(BF,phi,m,temp_phi)
          implicit none
          real(cp),intent(inout) :: BF
          type(SF),intent(in) :: phi
          type(mesh),intent(in) :: m
          type(SF),intent(inout) :: temp_phi
          real(cp) :: temp
          integer :: i
          BF = 0.0_cp; temp = 0.0_cp
          do i=1,m%s;
            call boundary_flux(temp,phi%BF(i),m%B(i),temp_phi%BF(i)); BF = BF+temp
          enddo
        end subroutine

        function symmetry_error_x_SF(u) result(SE)
          implicit none
          type(SF),intent(in) :: u
          integer :: i
          real(cp) :: SE
          SE = 0.0_cp
          do i=1,u%s; SE = SE + symmetry_error_x(u%BF(i)); enddo
        end function

        function symmetry_error_y_SF(u) result(SE)
          implicit none
          type(SF),intent(in) :: u
          integer :: i
          real(cp) :: SE
          SE = 0.0_cp
          do i=1,u%s; SE = SE + symmetry_error_y(u%BF(i)); enddo
        end function

        function symmetry_error_z_SF(u) result(SE)
          implicit none
          type(SF),intent(in) :: u
          integer :: i
          real(cp) :: SE
          SE = 0.0_cp
          do i=1,u%s; SE = SE + symmetry_error_z(u%BF(i)); enddo
        end function

        subroutine symmetry_local_x_SF(u)
          implicit none
          type(SF),intent(inout) :: u
          integer :: i
          do i=1,u%s; call symmetry_local_x(u%BF(i)); enddo
        end subroutine

        subroutine symmetry_local_y_SF(u)
          implicit none
          type(SF),intent(inout) :: u
          integer :: i
          do i=1,u%s; call symmetry_local_y(u%BF(i)); enddo
        end subroutine

        subroutine symmetry_local_z_SF(u)
          implicit none
          type(SF),intent(inout) :: u
          integer :: i
          do i=1,u%s; call symmetry_local_z(u%BF(i)); enddo
        end subroutine

        subroutine mirror_about_hmin_SF(u,dir,mirror_sign)
          implicit none
          type(SF),intent(inout) :: u
          integer,intent(in) :: dir
          real(cp),intent(in) :: mirror_sign
          integer :: i
          do i=1,u%s; call mirror_about_hmin(u%BF(i),dir,mirror_sign); enddo
        end subroutine
        subroutine mirror_about_hmax_SF(u,dir,mirror_sign)
          implicit none
          type(SF),intent(inout) :: u
          integer,intent(in) :: dir
          real(cp),intent(in) :: mirror_sign
          integer :: i
          do i=1,u%s; call mirror_about_hmax(u%BF(i),dir,mirror_sign); enddo
        end subroutine

        subroutine multiply_volume_SF(f,m)
          implicit none
          type(SF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(SF) :: vol
          call init(vol,f)
          call volume(vol,m)
          call multiply(f,vol)
          call delete(vol)
        end subroutine

       subroutine mean_along_dir_SF(x_mean,x,m,dir)
         ! Computes  L⁻¹ ∫∫ x_CC dA in plane p along direction dir in grid t
         implicit none
         type(SF),intent(inout) :: x_mean
         type(SF),intent(in) :: x
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir
         integer :: t
         select case (dir)
         case (1); do t=1,m%s; call mean_along_x(x_mean%BF(t)%GF,x%BF(t)%GF,m%B(t)%g); enddo
         case (2); do t=1,m%s; call mean_along_y(x_mean%BF(t)%GF,x%BF(t)%GF,m%B(t)%g); enddo
         case (3); do t=1,m%s; call mean_along_z(x_mean%BF(t)%GF,x%BF(t)%GF,m%B(t)%g); enddo
         case default; stop 'Error: dir must = 1,2,3 in mean_along_dir in SF.f90'
         end select
       end subroutine

       function amax_diff_SF(x) result(x_amax_diff)
         implicit none
         type(SF),intent(in) :: x
         real(cp),dimension(3) :: x_amax_diff
         real(cp),dimension(3) :: temp
         integer :: t
         x_amax_diff = 0.0_cp
         do t=1,x%s
         temp = amax_diff(x%BF(t)%GF)
         x_amax_diff(1) = maxval((/x_amax_diff(1),temp(1)/))
         x_amax_diff(2) = maxval((/x_amax_diff(2),temp(2)/))
         x_amax_diff(3) = maxval((/x_amax_diff(3),temp(3)/))
         enddo
       end function

       function amax_diff_dir_SF(x,dir) result(x_amax_diff)
         implicit none
         type(SF),intent(in) :: x
         integer,intent(in) :: dir
         real(cp) :: x_amax_diff
         integer :: t
         x_amax_diff = 0.0_cp
         do t=1,x%s
         x_amax_diff = maxval((/x_amax_diff,amax_diff(x%BF(t)%GF,dir)/))
         enddo
       end function

       subroutine subtract_mean_along_dir_SF(x,m,dir,x_temp)
         implicit none
         type(SF),intent(inout) :: x,x_temp
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir
         call mean_along_dir(x_temp,x,m,dir)
         call subtract(x,x_temp)
       end subroutine

        subroutine print_BCs_SF(f,name)
          implicit none
          type(SF),intent(in) :: f
          character(len=*),intent(in) :: name
          call display_BCs_SF(f,name,6)
        end subroutine

        subroutine export_BCs_SF(f,dir,name)
          implicit none
          type(SF),intent(in) :: f
          character(len=*),intent(in) :: dir,name
          integer :: un
          un = new_and_open(dir,name//'_BoundaryConditions')
          call display_BCs_SF(f,name,un)
          call close_and_message(un,dir,name//'_BoundaryConditions')
        end subroutine

        subroutine display_BCs_SF(f,name,un)
          implicit none
          type(SF),intent(in) :: f
          character(len=*),intent(in) :: name
          integer,intent(in) :: un
          integer :: i
          write(un,*) ' ------ BCs for ' // name // ' ------ '
          do i=1,f%s
            call display(f%BF(i)%BCs,un)
          enddo
          write(un,*) ' ------------------------------------ '
        end subroutine

        ! ****************************************************************
        ! ****************************************************************
        ! ********************* COMPUTATION ROUTINES *********************
        ! ****************************************************************
        ! ****************************************************************

        subroutine assign_SF_SF(f,g)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g
          integer :: i
          do i=1,f%s; call assign(f%BF(i)%GF,g%BF(i)%GF); enddo
        end subroutine

        subroutine assign_SF_S(f,g)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: g
          integer :: i
          do i=1,f%s; call assign(f%BF(i)%GF,g); enddo
        end subroutine

        subroutine assign_negative_SF_SF(f,g)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g
          integer :: i
          do i=1,f%s; call assign_negative(f%BF(i)%GF,g%BF(i)%GF); enddo
        end subroutine

      ! ------------------- ADD ------------------------

        subroutine add_SF_SF(f,g)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g
          integer :: i
          do i=1,f%s; call add(f%BF(i)%GF,g%BF(i)%GF); enddo
        end subroutine

        subroutine add_SF_SF_SF(f,g,r)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g,r
          integer :: i
          do i=1,f%s; call add(f%BF(i)%GF,g%BF(i)%GF,r%BF(i)%GF); enddo
        end subroutine

        subroutine add_SF_SF_SF_SF(f,g,r,q)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g,r,q
          integer :: i
          do i=1,f%s; call add(f%BF(i)%GF,g%BF(i)%GF,r%BF(i)%GF,q%BF(i)%GF); enddo
        end subroutine

        subroutine add_SF_S(f,g)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: g
          integer :: i
          do i=1,f%s; call add(f%BF(i)%GF,g); enddo
        end subroutine

        subroutine add_S_SF(g2,f)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: g2
          integer :: i
          do i=1,f%s; call add(g2,f%BF(i)%GF); enddo
        end subroutine

        subroutine add_SF_SF9(A,B1,B2,B3,B4,B5,B6,B7,B8,B9)
          implicit none
          type(SF),intent(inout) :: A
          type(SF),intent(in) :: B1,B2,B3,B4,B5,B6,B7,B8,B9
          integer :: i
          do i=1,A%s; call add(A%BF(i)%GF,B1%BF(i)%GF,B2%BF(i)%GF,B3%BF(i)%GF,&
                                       B4%BF(i)%GF,B5%BF(i)%GF,B6%BF(i)%GF,&
                                       B7%BF(i)%GF,B8%BF(i)%GF,B9%BF(i)%GF); enddo
        end subroutine

       ! ------------------- ADD PRODUCT ------------------------

        subroutine add_product_SF_SF_S(f,g,r)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g
          real(cp),intent(in) :: r
          integer :: i
          do i=1,f%s; call add_product(f%BF(i)%GF,g%BF(i)%GF,r); enddo
        end subroutine

        subroutine add_product_SF_SF_SF(f,g,r)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g
          type(SF),intent(in) :: r
          integer :: i
          do i=1,f%s; call add_product(f%BF(i)%GF,g%BF(i)%GF,r%BF(i)%GF); enddo
        end subroutine

        subroutine product_add_SF_SF_S(f,r,g)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: r
          type(SF),intent(in) :: g
          integer :: i
          do i=1,f%s; call product_add(f%BF(i)%GF,r,g%BF(i)%GF); enddo
        end subroutine

        subroutine product_add_SF_SF_SF(f,r,g)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: r
          type(SF),intent(in) :: g
          integer :: i
          do i=1,f%s; call product_add(f%BF(i)%GF,r%BF(i)%GF,g%BF(i)%GF); enddo
        end subroutine

      ! ------------------- SUBTRACT ------------------------

        subroutine subtract_SF_SF(f,g)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g
          integer :: i
          do i=1,f%s; call subtract(f%BF(i)%GF,g%BF(i)%GF); enddo
        end subroutine

        subroutine subtract_SF_SF_SF(f,g,q)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g,q
          integer :: i
          do i=1,f%s; call subtract(f%BF(i)%GF,g%BF(i)%GF,q%BF(i)%GF); enddo
        end subroutine

        subroutine subtract_SF_S(f,g)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: g
          integer :: i
          do i=1,f%s; call subtract(f%BF(i)%GF,g); enddo
        end subroutine

        subroutine subtract_S_SF(g2,f)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: g2
          integer :: i
          do i=1,f%s; call subtract(g2,f%BF(i)%GF); enddo
        end subroutine

      ! ------------------- MULTIPLY ------------------------

        subroutine multiply_SF_SF(f,g)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g
          integer :: i
          do i=1,f%s; call multiply(f%BF(i)%GF,g%BF(i)%GF); enddo
        end subroutine

        subroutine multiply_SF_SF_SF(f,g,q)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g,q
          integer :: i
          do i=1,f%s; call multiply(f%BF(i)%GF,g%BF(i)%GF,q%BF(i)%GF); enddo
        end subroutine

        subroutine multiply_SF_SF_S(f,g,q)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g
          real(cp),intent(in) :: q
          integer :: i
          do i=1,f%s; call multiply(f%BF(i)%GF,g%BF(i)%GF,q); enddo
        end subroutine

        subroutine multiply_SF_S(f,g)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: g
          integer :: i
          do i=1,f%s; call multiply(f%BF(i)%GF,g); enddo
        end subroutine

        subroutine multiply_S_SF(g2,f)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: g2
          integer :: i
          do i=1,f%s; call multiply(f%BF(i)%GF,g2); enddo
        end subroutine

      ! ------------------- DIVIDE ------------------------

        subroutine divide_SF_SF(f,g)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g
          integer :: i
          do i=1,f%s; call divide(f%BF(i)%GF,g%BF(i)%GF); enddo
        end subroutine

        subroutine divide_SF_SF_SF(f,g,q)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: g,q
          integer :: i
          do i=1,f%s; call divide(f%BF(i)%GF,g%BF(i)%GF,q%BF(i)%GF); enddo
        end subroutine

        subroutine divide_SF_S_SF(f,g,q)
          implicit none
          type(SF),intent(inout) :: f
          type(SF),intent(in) :: q
          real(cp),intent(in) :: g
          integer :: i
          do i=1,f%s; call divide(f%BF(i)%GF,g,q%BF(i)%GF); enddo
        end subroutine

        subroutine divide_SF_S(f,g)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: g
          integer :: i
          do i=1,f%s; call divide(f%BF(i)%GF,g); enddo
        end subroutine

        subroutine divide_S_SF(g2,f)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: g2
          integer :: i
          do i=1,f%s; call divide(g2,f%BF(i)%GF); enddo
        end subroutine

      ! ------------------- Magnitude ------------------------

        subroutine magnitude_SF_SF_SF(R,x,y,z)
          implicit none
          type(SF),intent(inout) :: R
          type(SF),intent(in) :: x,y,z
          integer :: i
          do i=1,R%s; call magnitude(R%BF(i)%GF,&
                                     x%BF(i)%GF,&
                                     y%BF(i)%GF,&
                                     z%BF(i)%GF); enddo
        end subroutine

      ! ------------------- OTHER ------------------------

        subroutine invert_SF(f)
          implicit none
          type(SF),intent(inout) :: f
          integer :: i
          do i=1,f%s; call divide(1.0_cp,f%BF(i)%GF); enddo
        end subroutine

        subroutine square_SF(f)
          implicit none
          type(SF),intent(inout) :: f
          integer :: i
          do i=1,f%s; call square(f%BF(i)%GF); enddo
        end subroutine

        subroutine square_root_SF(f)
          implicit none
          type(SF),intent(inout) :: f
          integer :: i
          do i=1,f%s; call square_root(f%BF(i)%GF); enddo
        end subroutine

        subroutine abs_SF(u)
          implicit none
          type(SF),intent(inout) :: u
          integer :: i
          do i=1,u%s; call abs(u%BF(i)); enddo
        end subroutine

        subroutine insist_amax_lt_tol_SF(u,caller)
          implicit none
          type(SF),intent(in) :: u
          character(len=*),intent(in) :: caller
          integer :: i
          do i=1,u%s; call insist_amax_lt_tol(u%BF(i),caller); enddo
        end subroutine

        subroutine swap_SF(f,g,q)
          implicit none
          type(SF),intent(inout) :: f,g,q
          integer :: i
          do i=1,f%s; call swap(f%BF(i)%GF,g%BF(i)%GF,q%BF(i)%GF); enddo
        end subroutine

        function min_SF(f) result(m)
          implicit none
          type(SF),intent(in) :: f
          real(cp) :: m
          integer :: i
          m = 0.0_cp
          do i=1,f%s
            m = minval((/m,min(f%BF(i)%GF)/))
          enddo
        end function

        function max_SF(f) result(m)
          implicit none
          type(SF),intent(in) :: f
          real(cp) :: m
          integer :: i
          m = 0.0_cp
          do i=1,f%s
            m = maxval((/m,max(f%BF(i)%GF)/))
          enddo
        end function

        function min_pad_SF(f,pad) result(m)
          implicit none
          type(SF),intent(in) :: f
          integer,intent(in) :: pad
          real(cp) :: m
          integer :: i
          m = 0.0_cp
          do i=1,f%s
            m = minval((/m,min(f%BF(i)%GF,pad)/))
          enddo
        end function

        function max_pad_SF(f,pad) result(m)
          implicit none
          type(SF),intent(in) :: f
          integer,intent(in) :: pad
          real(cp) :: m
          integer :: i
          m = 0.0_cp
          do i=1,f%s
            m = maxval((/m,max(f%BF(i)%GF,pad)/))
          enddo
        end function

        function amin_SF(f) result(m)
          implicit none
          type(SF),intent(in) :: f
          real(cp) :: m
          integer :: i
          m = 0.0_cp
          do i=1,f%s
            m = minval(abs((/m,amin(f%BF(i)%GF)/)))
          enddo
        end function

        function amax_SF(f) result(m)
          implicit none
          type(SF),intent(in) :: f
          real(cp) :: m
          integer :: i
          m = 0.0_cp
          do i=1,f%s
            m = maxval(abs((/m,amax(f%BF(i)%GF)/)))
          enddo
        end function

        function mean_SF(a) result(m)
          implicit none
          type(SF),intent(in) :: a
          real(cp) :: m
          integer :: i,s
          m = sum(a)
          s = 0
          do i=1,a%s
            s = s + size(a%BF(i)%GF)
          enddo
          m = m/real(s,cp)
        end function

        function sum_SF(a) result(m)
          implicit none
          type(SF),intent(in) :: a
          real(cp) :: m
          integer :: i
          m = 0.0_cp
          do i=1,a%s
            m = m + sum(a%BF(i)%GF)
          enddo
        end function

        function sum_SF_pad(a,pad) result(m)
          implicit none
          type(SF),intent(in) :: a
          integer,intent(in) :: pad
          real(cp) :: m
          integer :: i
          m = 0.0_cp
          do i=1,a%s
            m = m + sum(a%BF(i)%GF,pad)
          enddo
        end function

        function dot_product_SF(A,B,temp) result(dot)
          implicit none
          type(SF),intent(in) :: A,B
          type(SF),intent(inout) :: temp
          real(cp) :: dot
          call multiply(temp,A,B)
          dot = sum(temp)
        end function

        subroutine assign_ghost_xmin_xmax_SF(f,val)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: val
          integer :: t
          do t=1,f%s; call assign_ghost_xmin_xmax(f%BF(t),val); enddo
        end subroutine
        subroutine assign_ghost_ymin_ymax_SF(f,val)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: val
          integer :: t
          do t=1,f%s; call assign_ghost_ymin_ymax(f%BF(t),val); enddo
        end subroutine
        subroutine assign_ghost_zmin_zmax_SF(f,val)
          implicit none
          type(SF),intent(inout) :: f
          real(cp),intent(in) :: val
          integer :: t
          do t=1,f%s; call assign_ghost_zmin_zmax(f%BF(t),val); enddo
        end subroutine

        subroutine cross_product_x_SF(ACrossB,Ay,Az,By,Bz)
          implicit none
          type(SF),intent(inout) :: ACrossB
          type(SF),intent(in) :: Ay,Az,By,Bz
          integer :: t
          do t=1,ACrossB%s
            call cross_product_x(ACrossB%BF(t),Ay%BF(t),Az%BF(t),By%BF(t),Bz%BF(t))
          enddo
        end subroutine
        subroutine cross_product_y_SF(ACrossB,Ax,Az,Bx,Bz)
          implicit none
          type(SF),intent(inout) :: ACrossB
          type(SF),intent(in) :: Ax,Az,Bx,Bz
          integer :: t
          do t=1,ACrossB%s
            call cross_product_y(ACrossB%BF(t),Ax%BF(t),Az%BF(t),Bx%BF(t),Bz%BF(t))
          enddo
        end subroutine
        subroutine cross_product_z_SF(ACrossB,Ax,Ay,Bx,By)
          implicit none
          type(SF),intent(inout) :: ACrossB
          type(SF),intent(in) :: Ax,Ay,Bx,By
          integer :: t
          do t=1,ACrossB%s
            call cross_product_z(ACrossB%BF(t),Ax%BF(t),Ay%BF(t),Bx%BF(t),By%BF(t))
          enddo
        end subroutine

        function CFL_number_SF(U_CC,V_CC,W_CC,m,dt) result(CFL)
          implicit none
          type(SF),intent(in) :: U_CC,V_CC,W_CC
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: dt
          type(array) :: a
          real(cp) :: CFL
          integer :: t
          call init(a,m%s)
          do t=1,m%s
            call init(a,CFL_number(U_CC%BF(t),V_CC%BF(t),W_CC%BF(t),m%B(t),dt),t)
          enddo
          CFL = maxval(a%f)
          call delete(a)
        end function

        function dt_given_CFL_number_SF(U_CC,V_CC,W_CC,m,CFL) result(dt)
          implicit none
          type(SF),intent(in) :: U_CC,V_CC,W_CC
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: CFL
          type(array) :: a
          real(cp) :: dt
          integer :: t
          call init(a,m%s)
          do t=1,m%s
            call init(a,dt_given_CFL_number(U_CC%BF(t),V_CC%BF(t),W_CC%BF(t),m%B(t),CFL),t)
          enddo
          dt = minval(a%f)
          call delete(a)
        end function

        function Fourier_number_SF(alpha,m,dt) result(Fourier)
          implicit none
          real(cp),intent(in) :: alpha
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: dt
          type(array) :: a
          real(cp) :: Fourier
          integer :: t
          call init(a,m%s)
          do t=1,m%s
            call init(a,Fourier_number(alpha,m%B(t),dt),t)
          enddo
          Fourier = maxval(a%f)
          call delete(a)
        end function

        function Robin_BC_coeff_SF(c_w,m) result(coeff)
          implicit none
          real(cp),dimension(6),intent(in) :: c_w
          type(mesh),intent(in) :: m
          real(cp),dimension(6) :: coeff
          real(cp),dimension(6) :: temp
          integer :: t
          coeff = 0.0_cp
          temp = coeff
          do t=1,m%s
            temp = Robin_BC_coeff(c_w,m%B(t))
            coeff = temp ! BAD DESIGN, BUT NOT SURE WHAT TO DO HERE...
          enddo
        end function

        subroutine restrict_SF(r,u,m,dir)
          implicit none
          type(SF),intent(inout) :: r
          type(SF),intent(in) :: u
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          integer :: t
          do t=1,m%s; call restrict(r%BF(t),u%BF(t),m%B(t),dir); enddo
        end subroutine

        subroutine restrict_reset_SF(u,m,dir)
          implicit none
          type(SF),intent(inout) :: u
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          integer :: t
          do t=1,m%s; call restrict(u%BF(t),m%B(t),dir); enddo
        end subroutine

        subroutine restrict_all_reset_SF(u,m)
          implicit none
          type(SF),intent(inout) :: u
          type(mesh),intent(in) :: m
          integer :: i
          do i=1,3; call restrict(u,m,i); enddo
        end subroutine

        subroutine prolongate_SF(r,u,m,dir)
          implicit none
          type(SF),intent(inout) :: r
          type(SF),intent(in) :: u
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          integer :: t
          do t=1,m%s; call prolongate(r%BF(t),u%BF(t),m%B(t),dir); enddo
        end subroutine

        subroutine prolongate_reset_SF(u,m,dir)
          implicit none
          type(SF),intent(inout) :: u
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          integer :: t
          do t=1,m%s; call prolongate(u%BF(t),m%B(t),dir); enddo
        end subroutine

        subroutine prolongate_all_reset_SF(u,m)
          implicit none
          type(SF),intent(inout) :: u
          type(mesh),intent(in) :: m
          integer :: i
          do i=1,3; call prolongate(u,m,i); enddo
        end subroutine

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module VF_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use SF_mod
       use dir_manip_mod
       implicit none

       private
       public :: VF
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,get_necessary_for_restart,suppress_warnings

       interface init;                     module procedure init_copy_VF;                end interface
       interface delete;                   module procedure delete_VF;                   end interface
       interface display;                  module procedure display_VF;                  end interface
       interface display_short;            module procedure display_short_VF;            end interface
       interface display;                  module procedure display_wrap_VF;             end interface
       interface print;                    module procedure print_VF;                    end interface
       interface print_short;              module procedure print_short_VF;              end interface
       interface export;                   module procedure export_VF;                   end interface
       interface export_primitives;        module procedure export_primitives_VF;        end interface
       interface import;                   module procedure import_VF;                   end interface
       interface export_folder_structure;  module procedure export_folder_structure_VF;  end interface
       interface export_structured;        module procedure export_structured_D_VF;      end interface
       interface import_structured;        module procedure import_structured_D_VF;      end interface
       interface import_primitives;        module procedure import_primitives_VF;        end interface
       interface export;                   module procedure export_wrap_VF;              end interface
       interface import;                   module procedure import_wrap_VF;              end interface
       interface set_IO_dir;               module procedure set_IO_dir_VF;               end interface
       interface make_IO_dir;              module procedure make_IO_dir_VF;              end interface
       interface get_necessary_for_restart;module procedure get_necessary_for_restart_VF;end interface
       interface suppress_warnings;        module procedure suppress_warnings_VF;        end interface

       type VF
         type(SF) :: x
         type(SF) :: y
         type(SF) :: z
       end type

       contains

       subroutine init_copy_VF(this,that)
         implicit none
         type(VF),intent(inout) :: this
         type(VF),intent(in) :: that
         call delete(this)
         call init(this%x,that%x)
         call init(this%y,that%y)
         call init(this%z,that%z)
       end subroutine

       subroutine delete_VF(this)
         implicit none
         type(VF),intent(inout) :: this
         call delete(this%x)
         call delete(this%y)
         call delete(this%z)
       end subroutine

       subroutine display_VF(this,un)
         implicit none
         type(VF),intent(in) :: this
         integer,intent(in) :: un
         call display(this%x,un)
         call display(this%y,un)
         call display(this%z,un)
       end subroutine

       subroutine display_short_VF(this,un)
         implicit none
         type(VF),intent(in) :: this
         integer,intent(in) :: un
         call display(this%x,un)
         call display(this%y,un)
         call display(this%z,un)
       end subroutine

       subroutine display_wrap_VF(this,dir,name)
         implicit none
         type(VF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_VF(this)
         implicit none
         type(VF),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_VF(this)
         implicit none
         type(VF),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_VF(this,un)
         implicit none
         type(VF),intent(in) :: this
         integer,intent(in) :: un
         call export(this%x,un)
         call export(this%y,un)
         call export(this%z,un)
       end subroutine

       subroutine import_VF(this,un)
         implicit none
         type(VF),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%x,un)
         call import(this%y,un)
         call import(this%z,un)
       end subroutine

       subroutine export_primitives_VF(this,un)
         implicit none
         type(VF),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_VF(this,un)
         implicit none
         type(VF),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_VF(this,dir,name)
         implicit none
         type(VF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         call export(this%x,dir,name//'_x')
         call export(this%y,dir,name//'_y')
         call export(this%z,dir,name//'_z')
       end subroutine

       subroutine import_wrap_VF(this,dir,name)
         implicit none
         type(VF),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         call import(this%x,dir,name//'_x')
         call import(this%y,dir,name//'_y')
         call import(this%z,dir,name//'_z')
       end subroutine

       function get_necessary_for_restart_VF(this) result(L)
         implicit none
         type(VF),intent(in) :: this
         logical :: L
         L = all((/get_necessary_for_restart(this%x),&
         get_necessary_for_restart(this%y),&
         get_necessary_for_restart(this%z)/))
       end function

       subroutine set_IO_dir_VF(this,dir)
         implicit none
         type(VF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%x,dir//'x'//fortran_PS)
         call set_IO_dir(this%y,dir//'y'//fortran_PS)
         call set_IO_dir(this%z,dir//'z'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_VF(this,dir)
         implicit none
         type(VF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         if (get_necessary_for_restart(this%x)) then
           call make_IO_dir(this%x,dir//'x'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%y)) then
           call make_IO_dir(this%y,dir//'y'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call make_IO_dir(this%z,dir//'z'//fortran_PS)
         endif
       end subroutine

       subroutine export_folder_structure_VF(this,dir)
         implicit none
         type(VF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         if (get_necessary_for_restart(this%x)) then
           call export_structured(this%x,dir//'x'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%y)) then
           call export_structured(this%y,dir//'y'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call export_structured(this%z,dir//'z'//fortran_PS)
         endif
       end subroutine

       subroutine export_structured_D_VF(this,dir)
         implicit none
         type(VF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         if (get_necessary_for_restart(this%x)) then
           call export_structured(this%x,dir//'x'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%y)) then
           call export_structured(this%y,dir//'y'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call export_structured(this%z,dir//'z'//fortran_PS)
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_VF(this,dir)
         implicit none
         type(VF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         if (get_necessary_for_restart(this%x)) then
           call import_structured(this%x,dir//'x'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%y)) then
           call import_structured(this%y,dir//'y'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call import_structured(this%z,dir//'z'//fortran_PS)
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_VF(this)
         implicit none
         type(VF),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module time_statistics_SF_mod
       use probe_mod
       use time_statistics_params_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use string_mod
       use SF_mod
       use dir_manip_mod
       implicit none

       private
       public :: time_statistics_SF
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_time_statistics_SF;              end interface
       interface delete;                 module procedure delete_time_statistics_SF;                 end interface
       interface display;                module procedure display_time_statistics_SF;                end interface
       interface display_short;          module procedure display_short_time_statistics_SF;          end interface
       interface display;                module procedure display_wrap_time_statistics_SF;           end interface
       interface print;                  module procedure print_time_statistics_SF;                  end interface
       interface print_short;            module procedure print_short_time_statistics_SF;            end interface
       interface export;                 module procedure export_time_statistics_SF;                 end interface
       interface export_primitives;      module procedure export_primitives_time_statistics_SF;      end interface
       interface import;                 module procedure import_time_statistics_SF;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_time_statistics_SF;end interface
       interface export_structured;      module procedure export_structured_D_time_statistics_SF;    end interface
       interface import_structured;      module procedure import_structured_D_time_statistics_SF;    end interface
       interface import_primitives;      module procedure import_primitives_time_statistics_SF;      end interface
       interface export;                 module procedure export_wrap_time_statistics_SF;            end interface
       interface import;                 module procedure import_wrap_time_statistics_SF;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_time_statistics_SF;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_time_statistics_SF;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_time_statistics_SF;      end interface
       interface export;                 module procedure export_DN_time_statistics_SF;              end interface
       interface import;                 module procedure import_DN_time_statistics_SF;              end interface
       interface export_structured;      module procedure export_structured_DN_time_statistics_SF;   end interface
       interface import_structured;      module procedure import_structured_DN_time_statistics_SF;   end interface

       type time_statistics_SF
         type(string) :: dir
         type(string) :: name
         type(SF) :: U_sum
         type(SF) :: U_ave
         type(probe) :: mean_energy
         type(SF) :: RMS
         type(time_statistics_params) :: TSP
       end type

       contains

       subroutine init_copy_time_statistics_SF(this,that)
         implicit none
         type(time_statistics_SF),intent(inout) :: this
         type(time_statistics_SF),intent(in) :: that
         call delete(this)
         call init(this%dir,that%dir)
         call init(this%name,that%name)
         call init(this%U_sum,that%U_sum)
         call init(this%U_ave,that%U_ave)
         call init(this%mean_energy,that%mean_energy)
         call init(this%RMS,that%RMS)
         call init(this%TSP,that%TSP)
       end subroutine

       subroutine delete_time_statistics_SF(this)
         implicit none
         type(time_statistics_SF),intent(inout) :: this
         call delete(this%dir)
         call delete(this%name)
         call delete(this%U_sum)
         call delete(this%U_ave)
         call delete(this%mean_energy)
         call delete(this%RMS)
         call delete(this%TSP)
       end subroutine

       subroutine display_time_statistics_SF(this,un)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         integer,intent(in) :: un
         call display(this%dir,un)
         call display(this%name,un)
         call display(this%U_sum,un)
         call display(this%U_ave,un)
         call display(this%mean_energy,un)
         call display(this%RMS,un)
         call display(this%TSP,un)
       end subroutine

       subroutine display_short_time_statistics_SF(this,un)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         integer,intent(in) :: un
         call display(this%dir,un)
         call display(this%name,un)
         call display(this%U_sum,un)
         call display(this%U_ave,un)
         call display(this%mean_energy,un)
         call display(this%RMS,un)
         call display(this%TSP,un)
       end subroutine

       subroutine display_wrap_time_statistics_SF(this,dir,name)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_time_statistics_SF(this)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_time_statistics_SF(this)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_time_statistics_SF(this,un)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         integer,intent(in) :: un
         call export(this%dir,un)
         call export(this%name,un)
         call export(this%U_sum,un)
         call export(this%U_ave,un)
         call export(this%mean_energy,un)
         call export(this%RMS,un)
         call export(this%TSP,un)
       end subroutine

       subroutine import_time_statistics_SF(this,un)
         implicit none
         type(time_statistics_SF),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%dir,un)
         call import(this%name,un)
         call import(this%U_sum,un)
         call import(this%U_ave,un)
         call import(this%mean_energy,un)
         call import(this%RMS,un)
         call import(this%TSP,un)
       end subroutine

       subroutine export_primitives_time_statistics_SF(this,un)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_time_statistics_SF(this,un)
         implicit none
         type(time_statistics_SF),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_time_statistics_SF(this,dir,name)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_time_statistics_SF(this,dir,name)
         implicit none
         type(time_statistics_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_time_statistics_SF(this)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_time_statistics_SF(this)
         implicit none
         type(time_statistics_SF),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_time_statistics_SF(this)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         call export_structured(this%U_sum,&
         str(this%dir)//'U_sum'//fortran_PS)
         call export_structured(this%U_ave,&
         str(this%dir)//'U_ave'//fortran_PS)
         call export_structured(this%mean_energy,&
         str(this%dir)//'mean_energy'//fortran_PS)
         call export_structured(this%RMS,str(this%dir)//'RMS'//fortran_PS)
         call export_structured(this%TSP,str(this%dir)//'TSP'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_time_statistics_SF(this)
         implicit none
         type(time_statistics_SF),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         call import_structured(this%U_sum,&
         str(this%dir)//'U_sum'//fortran_PS)
         call import_structured(this%U_ave,&
         str(this%dir)//'U_ave'//fortran_PS)
         call import_structured(this%mean_energy,&
         str(this%dir)//'mean_energy'//fortran_PS)
         call import_structured(this%RMS,str(this%dir)//'RMS'//fortran_PS)
         call import_structured(this%TSP,str(this%dir)//'TSP'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_time_statistics_SF(this,dir)
         implicit none
         type(time_statistics_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
         call set_IO_dir(this%U_sum,dir//'U_sum'//fortran_PS)
         call set_IO_dir(this%U_ave,dir//'U_ave'//fortran_PS)
         call set_IO_dir(this%mean_energy,dir//'mean_energy'//fortran_PS)
         call set_IO_dir(this%RMS,dir//'RMS'//fortran_PS)
         call set_IO_dir(this%TSP,dir//'TSP'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_time_statistics_SF(this,dir)
         implicit none
         type(time_statistics_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
         if (get_necessary_for_restart(this%U_sum)) then
           call make_IO_dir(this%U_sum,dir//'U_sum'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_ave)) then
           call make_IO_dir(this%U_ave,dir//'U_ave'//fortran_PS)
         endif
         call make_IO_dir(this%mean_energy,dir//'mean_energy'//fortran_PS)
         if (get_necessary_for_restart(this%RMS)) then
           call make_IO_dir(this%RMS,dir//'RMS'//fortran_PS)
         endif
         call make_IO_dir(this%TSP,dir//'TSP'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_time_statistics_SF(this,dir)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         if (get_necessary_for_restart(this%U_sum)) then
           call export_structured(this%U_sum,dir//'U_sum'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_ave)) then
           call export_structured(this%U_ave,dir//'U_ave'//fortran_PS)
         endif
         call export_structured(this%mean_energy,&
         dir//'mean_energy'//fortran_PS)
         if (get_necessary_for_restart(this%RMS)) then
           call export_structured(this%RMS,dir//'RMS'//fortran_PS)
         endif
         call export_structured(this%TSP,dir//'TSP'//fortran_PS)
       end subroutine

       subroutine export_structured_D_time_statistics_SF(this,dir)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         if (get_necessary_for_restart(this%U_sum)) then
           call export_structured(this%U_sum,dir//'U_sum'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_ave)) then
           call export_structured(this%U_ave,dir//'U_ave'//fortran_PS)
         endif
         call export_structured(this%mean_energy,&
         dir//'mean_energy'//fortran_PS)
         if (get_necessary_for_restart(this%RMS)) then
           call export_structured(this%RMS,dir//'RMS'//fortran_PS)
         endif
         call export_structured(this%TSP,dir//'TSP'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_time_statistics_SF(this,dir)
         implicit none
         type(time_statistics_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         if (get_necessary_for_restart(this%U_sum)) then
           call import_structured(this%U_sum,dir//'U_sum'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_ave)) then
           call import_structured(this%U_ave,dir//'U_ave'//fortran_PS)
         endif
         call import_structured(this%mean_energy,&
         dir//'mean_energy'//fortran_PS)
         if (get_necessary_for_restart(this%RMS)) then
           call import_structured(this%RMS,dir//'RMS'//fortran_PS)
         endif
         call import_structured(this%TSP,dir//'TSP'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_time_statistics_SF(this)
         implicit none
         type(time_statistics_SF),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module TF_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use VF_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: TF
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_TF;              end interface
       interface delete;                 module procedure delete_TF;                 end interface
       interface display;                module procedure display_TF;                end interface
       interface display_short;          module procedure display_short_TF;          end interface
       interface display;                module procedure display_wrap_TF;           end interface
       interface print;                  module procedure print_TF;                  end interface
       interface print_short;            module procedure print_short_TF;            end interface
       interface export;                 module procedure export_TF;                 end interface
       interface export_primitives;      module procedure export_primitives_TF;      end interface
       interface import;                 module procedure import_TF;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_TF;end interface
       interface export_structured;      module procedure export_structured_D_TF;    end interface
       interface import_structured;      module procedure import_structured_D_TF;    end interface
       interface import_primitives;      module procedure import_primitives_TF;      end interface
       interface export;                 module procedure export_wrap_TF;            end interface
       interface import;                 module procedure import_wrap_TF;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_TF;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_TF;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_TF;      end interface

       type TF
         type(VF) :: x
         type(VF) :: y
         type(VF) :: z
       end type

       contains

       subroutine init_copy_TF(this,that)
         implicit none
         type(TF),intent(inout) :: this
         type(TF),intent(in) :: that
         call delete(this)
         call init(this%x,that%x)
         call init(this%y,that%y)
         call init(this%z,that%z)
       end subroutine

       subroutine delete_TF(this)
         implicit none
         type(TF),intent(inout) :: this
         call delete(this%x)
         call delete(this%y)
         call delete(this%z)
       end subroutine

       subroutine display_TF(this,un)
         implicit none
         type(TF),intent(in) :: this
         integer,intent(in) :: un
         call display(this%x,un)
         call display(this%y,un)
         call display(this%z,un)
       end subroutine

       subroutine display_short_TF(this,un)
         implicit none
         type(TF),intent(in) :: this
         integer,intent(in) :: un
         call display(this%x,un)
         call display(this%y,un)
         call display(this%z,un)
       end subroutine

       subroutine display_wrap_TF(this,dir,name)
         implicit none
         type(TF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_TF(this)
         implicit none
         type(TF),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_TF(this)
         implicit none
         type(TF),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_TF(this,un)
         implicit none
         type(TF),intent(in) :: this
         integer,intent(in) :: un
         call export(this%x,un)
         call export(this%y,un)
         call export(this%z,un)
       end subroutine

       subroutine import_TF(this,un)
         implicit none
         type(TF),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%x,un)
         call import(this%y,un)
         call import(this%z,un)
       end subroutine

       subroutine export_primitives_TF(this,un)
         implicit none
         type(TF),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_TF(this,un)
         implicit none
         type(TF),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_TF(this,dir,name)
         implicit none
         type(TF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         call export(this%x,dir,name//'_x')
         call export(this%y,dir,name//'_y')
         call export(this%z,dir,name//'_z')
       end subroutine

       subroutine import_wrap_TF(this,dir,name)
         implicit none
         type(TF),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         call import(this%x,dir,name//'_x')
         call import(this%y,dir,name//'_y')
         call import(this%z,dir,name//'_z')
       end subroutine

       subroutine set_IO_dir_TF(this,dir)
         implicit none
         type(TF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%x,dir//'x'//fortran_PS)
         call set_IO_dir(this%y,dir//'y'//fortran_PS)
         call set_IO_dir(this%z,dir//'z'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_TF(this,dir)
         implicit none
         type(TF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         if (get_necessary_for_restart(this%x)) then
           call make_IO_dir(this%x,dir//'x'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%y)) then
           call make_IO_dir(this%y,dir//'y'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call make_IO_dir(this%z,dir//'z'//fortran_PS)
         endif
       end subroutine

       subroutine export_folder_structure_TF(this,dir)
         implicit none
         type(TF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         if (get_necessary_for_restart(this%x)) then
           call export_structured(this%x,dir//'x'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%y)) then
           call export_structured(this%y,dir//'y'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call export_structured(this%z,dir//'z'//fortran_PS)
         endif
       end subroutine

       subroutine export_structured_D_TF(this,dir)
         implicit none
         type(TF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         if (get_necessary_for_restart(this%x)) then
           call export_structured(this%x,dir//'x'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%y)) then
           call export_structured(this%y,dir//'y'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call export_structured(this%z,dir//'z'//fortran_PS)
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_TF(this,dir)
         implicit none
         type(TF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         if (get_necessary_for_restart(this%x)) then
           call import_structured(this%x,dir//'x'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%y)) then
           call import_structured(this%y,dir//'y'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call import_structured(this%z,dir//'z'//fortran_PS)
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_TF(this)
         implicit none
         type(TF),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module VF_extend_mod
        use VF_mod

        ! Rules:
        ! a = a + b => call add(a,b)
        ! a = a - b => call subtract(a,b)
        ! a = a * b => call multiply(a,b)
        ! a = a / b => call divide(a,b)
        ! a = b / a => call divide(b,a)
        ! OR
        ! c = a + b => call add(c,a,b)
        ! c = a - b => call subtract(c,a,b)
        ! c = a * b => call multiply(c,a,b)
        ! c = a / b => call divide(c,a,b)
        ! c = b / a => call divide(c,b,a)

        use current_precision_mod
        use data_location_extend_mod
        use mesh_extend_mod
        use mesh_domain_extend_mod
        use SF_extend_mod
        implicit none
        private

        ! Initialization / Deletion (allocate/deallocate)
        public :: VF
        public :: init,delete,display,print,export,import ! Essentials

        ! Grid initialization
        public :: init_CC
        public :: init_Face
        public :: init_Edge
        public :: init_Node

        public :: init_CC_Edge
        public :: init_Node_Edge

        public :: init_BCs
        public :: init_BC_mesh
        public :: init_BC_Dirichlet
        public :: init_BC_props
        public :: set_procedures
        public :: set_necessary_for_restart
        public :: multiply_volume

        public :: get_any_Dirichlet
        public :: get_any_Neumann
        public :: get_any_Robin
        public :: get_any_Prescribed

        public :: inverse_area
        public :: volume
        public :: sine_waves
        public :: cosine_waves
        public :: random_noise

        public :: assign_BCs
        public :: assign_BC_vals
        public :: update_BC_vals
        public :: assign_Dirichlet_BCs
        public :: assign_Periodic_BCs
        public :: assign_Neumann_BCs
        public :: assign_Neumann_BCs_wall_normal
        public :: multiply_Neumann_BCs
        public :: multiply_BCs_by_nhat
        public :: assign_Robin_BCs
        public :: multiply_Robin_coeff
        public :: multiply_nhat
        public :: assign_ghost_XPeriodic
        public :: assign_ghost_N_XPeriodic
        public :: assign_wall_Dirichlet
        public :: assign_wall_Periodic_single
        public :: multiply_wall_Neumann
        public :: set_prescribed_BCs
        public :: set_BCs_homogeneous

        public :: symmetry_error_x,symmetry_local_x
        public :: symmetry_error_y,symmetry_local_y
        public :: symmetry_error_z,symmetry_local_z

        public :: CFL_number
        public :: dt_given_CFL_number

        public :: dot_product,dot
        public :: cross_product

        public :: restrict
        public :: prolongate

        ! Monitoring
        public :: print_BCs
        public :: export_BCs

        ! Operators
        public :: assign,assign_negative
        public :: add,subtract
        public :: multiply,divide
        public :: add_product
        public :: product_add
        public :: square,square_root,invert,abs,insist_amax_lt_tol
        public :: mean,max,amin,amax
        public :: boundary_flux
        public :: sum
        public :: magnitude
        public :: assignX,assignY,assignZ

        public :: is_collocated
        public :: get_DL
        public :: is_CC
        public :: is_Node
        public :: is_Face
        public :: is_Edge
        public :: insist_collocated

        interface init;                     module procedure init_VF_copy_SF;               end interface
        interface init;                     module procedure init_DL_VF;                    end interface
        interface init;                     module procedure init_VF_copy_VF_mesh;          end interface

        interface init_CC;                  module procedure init_CC_VF;                    end interface
        interface init_Face;                module procedure init_Face_VF;                  end interface
        interface init_Edge;                module procedure init_Edge_VF;                  end interface
        interface init_Node;                module procedure init_Node_VF;                  end interface

        interface init_CC;                  module procedure init_CC_VF_MD;                 end interface
        interface init_Face;                module procedure init_Face_VF_MD;               end interface
        interface init_Edge;                module procedure init_Edge_VF_MD;               end interface
        interface init_Node;                module procedure init_Node_VF_MD;               end interface

        interface init_CC_Edge;             module procedure init_CC_Edge_VF;               end interface
        interface init_Node_Edge;           module procedure init_Node_Edge_VF;             end interface

        interface init_CC;                  module procedure init_CC_VF_assign;             end interface
        interface init_Face;                module procedure init_Face_VF_assign;           end interface
        interface init_Edge;                module procedure init_Edge_VF_assign;           end interface
        interface init_Node;                module procedure init_Node_VF_assign;           end interface
        interface multiply_volume;          module procedure multiply_volume_VF;            end interface

        interface inverse_area;             module procedure inverse_area_VF;               end interface
        interface volume;                   module procedure volume_VF;                     end interface
        interface sine_waves;               module procedure sine_waves_VF;                 end interface
        interface cosine_waves;             module procedure cosine_waves_VF;               end interface
        interface random_noise;             module procedure random_noise_VF;               end interface

        interface symmetry_error_x;         module procedure symmetry_error_x_VF;           end interface
        interface symmetry_error_y;         module procedure symmetry_error_y_VF;           end interface
        interface symmetry_error_z;         module procedure symmetry_error_z_VF;           end interface

        interface symmetry_local_x;         module procedure symmetry_local_x_VF;           end interface
        interface symmetry_local_y;         module procedure symmetry_local_y_VF;           end interface
        interface symmetry_local_z;         module procedure symmetry_local_z_VF;           end interface

        interface CFL_number;               module procedure CFL_number_VF;                 end interface
        interface dt_given_CFL_number;      module procedure dt_given_CFL_number_VF;        end interface

        interface assign_BCs;               module procedure assign_BCs_VF;                 end interface
        interface assign_BC_vals;           module procedure assign_BC_vals_VF;             end interface
        interface update_BC_vals;           module procedure update_BC_vals_VF;             end interface
        interface assign_Dirichlet_BCs;     module procedure assign_Dirichlet_BCs_VF;       end interface
        interface assign_Periodic_BCs;      module procedure assign_Periodic_BCs_VF;        end interface
        interface assign_Neumann_BCs;       module procedure assign_Neumann_BCs_faces_VF;   end interface
        interface assign_Neumann_BCs_wall_normal;  module procedure assign_Neumann_BCs_wall_normal_VF;   end interface
        interface multiply_Neumann_BCs;     module procedure multiply_Neumann_BCs_VF;       end interface
        interface multiply_BCs_by_nhat;     module procedure multiply_BCs_by_nhat_VF;       end interface
        interface assign_Robin_BCs;         module procedure assign_Robin_BCs_dir_VF;       end interface
        interface assign_Robin_BCs;         module procedure assign_Robin_BCs_faces_VF;     end interface
        interface multiply_Robin_coeff;     module procedure multiply_Robin_coeff_VF;       end interface
        interface multiply_nhat;            module procedure multiply_nhat_VF;              end interface
        interface assign_ghost_XPeriodic;   module procedure assign_ghost_XPeriodic_VF;     end interface
        interface assign_ghost_XPeriodic;   module procedure assign_ghost_XPeriodic_VF2;    end interface
        interface assign_ghost_N_XPeriodic; module procedure assign_ghost_N_XPeriodic_VF;   end interface
        interface assign_ghost_N_XPeriodic; module procedure assign_ghost_N_XPeriodic_VF2;  end interface
        interface assign_wall_Dirichlet;    module procedure assign_wall_Dirichlet_VF;      end interface
        interface assign_wall_Dirichlet;    module procedure assign_wall_Dirichlet_VF2;     end interface
        interface assign_wall_Periodic_single; module procedure assign_wall_Periodic_single_VF;      end interface
        interface assign_wall_Periodic_single; module procedure assign_wall_Periodic_single_VF2;     end interface
        interface multiply_wall_Neumann;    module procedure multiply_wall_Neumann_VF;      end interface
        interface multiply_wall_Neumann;    module procedure multiply_wall_Neumann_VF2;     end interface
        interface set_prescribed_BCs;       module procedure set_prescribed_BCs_VF;         end interface
        interface set_BCs_homogeneous;      module procedure set_BCs_homogeneous_VF;        end interface

        interface dot_product;              module procedure dot_product_VF;                end interface
        interface dot;                      module procedure dot_VF_SF;                     end interface

        interface cross_product;            module procedure cross_product_VF;              end interface

        interface restrict;                 module procedure restrict_VF;                   end interface
        interface restrict;                 module procedure restrict_dir_VF;               end interface
        interface prolongate;               module procedure prolongate_VF;                 end interface
        interface prolongate;               module procedure prolongate_dir_VF;             end interface

        interface is_collocated;            module procedure is_collocated_VF_DL;           end interface
        interface insist_collocated;        module procedure insist_collocated_VF;          end interface
        interface get_DL;                   module procedure get_DL_VF;                     end interface
        interface is_CC;                    module procedure is_CC_VF_DL;                   end interface
        interface is_Node;                  module procedure is_Node_VF_DL;                 end interface
        interface is_Face;                  module procedure is_Face_VF_DL;                 end interface
        interface is_Edge;                  module procedure is_Edge_VF_DL;                 end interface

        interface print_BCs;                module procedure print_BCs_VF;                  end interface
        interface init_BCs;                 module procedure init_BCs_VF_VF;                end interface
        interface init_BC_mesh;             module procedure init_BC_mesh_VF;               end interface
        interface init_BC_Dirichlet;        module procedure init_BC_Dirichlet_VF;          end interface
        interface export_BCs;               module procedure export_BCs_VF;                 end interface
        interface init_BC_props;            module procedure init_BC_props_VF;              end interface
        interface set_procedures;           module procedure set_procedures_VF;             end interface
        interface set_necessary_for_restart;module procedure set_necessary_for_restart_VF;    end interface

        interface get_any_Dirichlet;        module procedure get_any_Dirichlet_VF;          end interface
        interface get_any_Neumann;          module procedure get_any_Neumann_VF;            end interface
        interface get_any_Robin;            module procedure get_any_Robin_VF;              end interface
        interface get_any_Prescribed;       module procedure get_any_Prescribed_VF;         end interface

        ! COMPUTATION ROUTINES

        interface assignX;                  module procedure assign_VF_VF_X;                end interface
        interface assignY;                  module procedure assign_VF_VF_Y;                end interface
        interface assignZ;                  module procedure assign_VF_VF_Z;                end interface
        interface assignX;                  module procedure assign_VF_S_X;                 end interface
        interface assignY;                  module procedure assign_VF_S_Y;                 end interface
        interface assignZ;                  module procedure assign_VF_S_Z;                 end interface

        interface assign;                   module procedure assign_VF_S;                   end interface
        interface assign;                   module procedure assign_VF_SF;                  end interface
        interface assign;                   module procedure assign_VF_VF;                  end interface
        interface assign_negative;          module procedure assign_negative_VF_VF;         end interface

        interface add;                      module procedure add_VF_VF;                     end interface
        interface add;                      module procedure add_VF_VF_VF;                  end interface
        interface add;                      module procedure add_VF_SF;                     end interface
        interface add;                      module procedure add_SF_VF;                     end interface
        interface add;                      module procedure add_VF_S;                      end interface
        interface add;                      module procedure add_S_VF;                      end interface

        interface add_product;              module procedure add_product_VF_VF_S;           end interface
        interface product_add;              module procedure product_add_VF_VF_S;           end interface

        interface subtract;                 module procedure subtract_VF_VF;                end interface
        interface subtract;                 module procedure subtract_VF_VF_VF;             end interface
        interface subtract;                 module procedure subtract_VF_SF;                end interface
        interface subtract;                 module procedure subtract_VF_S;                 end interface
        interface subtract;                 module procedure subtract_S_VF;                 end interface

        interface multiply;                 module procedure multiply_VF_VF;                end interface
        interface multiply;                 module procedure multiply_VF_VF_VF;             end interface
        interface multiply;                 module procedure multiply_VF_VF_SF;             end interface
        interface multiply;                 module procedure multiply_VF_VF_S;              end interface
        interface multiply;                 module procedure multiply_VF_SF;                end interface
        interface multiply;                 module procedure multiply_SF_VF;                end interface
        interface multiply;                 module procedure multiply_VF_S;                 end interface
        interface multiply;                 module procedure multiply_VF_S3;                end interface
        interface multiply;                 module procedure multiply_S_VF;                 end interface

        interface divide;                   module procedure divide_VF_VF;                  end interface
        interface divide;                   module procedure divide_VF_SF;                  end interface
        interface divide;                   module procedure divide_VF_S_VF;                end interface
        interface divide;                   module procedure divide_VF_S;                   end interface
        interface divide;                   module procedure divide_S_VF;                   end interface

        interface magnitude;                module procedure magnitude_VF;                  end interface
        interface invert;                   module procedure invert_VF;                     end interface
        interface mean;                     module procedure mean_VF;                       end interface
        interface max;                      module procedure max_VF;                        end interface
        interface amax;                     module procedure amax_VF;                       end interface
        interface amin;                     module procedure amin_VF;                       end interface
        interface sum;                      module procedure sum_pad_VF;                    end interface
        interface boundary_flux;            module procedure boundary_flux_VF;              end interface

        interface square;                   module procedure square_VF;                     end interface
        interface square_root;              module procedure square_root_VF;                end interface
        interface abs;                      module procedure abs_VF;                        end interface
        interface insist_amax_lt_tol;       module procedure insist_amax_lt_tol_VF;         end interface

        contains

        ! **********************************************************
        ! ********************* ESSENTIALS *************************
        ! **********************************************************

        subroutine init_VF_copy_VF_mesh(f1,f2,m)
          implicit none
          type(VF),intent(inout) :: f1
          type(VF),intent(in) :: f2
          type(mesh),intent(in) :: m
          call init(f1%x,f2%x,m); call init(f1%y,f2%y,m); call init(f1%z,f2%z,m)
        end subroutine

        subroutine init_VF_copy_SF(f1,f2)
          implicit none
          type(VF),intent(inout) :: f1
          type(SF),intent(in) :: f2
          call init(f1%x,f2); call init(f1%y,f2); call init(f1%z,f2)
        end subroutine

        subroutine init_DL_VF(f,m,DL)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(data_location),dimension(3),intent(in) :: DL
          call init(f%x,m,DL(1))
          call init(f%y,m,DL(2))
          call init(f%z,m,DL(3))
        end subroutine

        ! **********************************************************
        ! **********************************************************
        ! **********************************************************

        subroutine print_BCs_VF(f,name)
          implicit none
          type(VF),intent(in) :: f
          character(len=*),intent(in) :: name
          call print_BCs(f%x,name//'_x')
          call print_BCs(f%y,name//'_y')
          call print_BCs(f%z,name//'_z')
        end subroutine

        subroutine init_BCs_VF_VF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          call init_BCs(f%x,g%x)
          call init_BCs(f%y,g%y)
          call init_BCs(f%z,g%z)
        end subroutine

        subroutine init_BC_mesh_VF(f,m)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_BC_mesh(f%x,m)
          call init_BC_mesh(f%y,m)
          call init_BC_mesh(f%z,m)
        end subroutine

        subroutine init_BC_Dirichlet_VF(f)
          implicit none
          type(VF),intent(inout) :: f
          call init_BC_Dirichlet(f%x)
          call init_BC_Dirichlet(f%y)
          call init_BC_Dirichlet(f%z)
        end subroutine

        subroutine init_BC_props_VF(f,c_w,Robin_coeff)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),dimension(6),intent(in) :: c_w,Robin_coeff
          call init_BC_props(f%x,c_w,Robin_coeff)
          call init_BC_props(f%y,c_w,Robin_coeff)
          call init_BC_props(f%z,c_w,Robin_coeff)
        end subroutine

        subroutine set_procedures_VF(f)
          implicit none
          type(VF),intent(inout) :: f
          call set_procedures(f%x)
          call set_procedures(f%y)
          call set_procedures(f%z)
        end subroutine

        subroutine set_necessary_for_restart_VF(f)
          implicit none
          type(VF),intent(inout) :: f
          call set_necessary_for_restart(f%x)
          call set_necessary_for_restart(f%y)
          call set_necessary_for_restart(f%z)
        end subroutine

        function get_any_Dirichlet_VF(f) result(L)
          implicit none
          type(VF),intent(in) :: f
          logical :: L
          L = any((/get_any_Dirichlet(f%x),get_any_Dirichlet(f%y),get_any_Dirichlet(f%z)/))
        end function

        function get_any_Neumann_VF(f) result(L)
          implicit none
          type(VF),intent(in) :: f
          logical :: L
          L = any((/get_any_Neumann(f%x),get_any_Neumann(f%y),get_any_Neumann(f%z)/))
        end function

        function get_any_Robin_VF(f) result(L)
          implicit none
          type(VF),intent(in) :: f
          logical :: L
          L = any((/get_any_Robin(f%x),get_any_Robin(f%y),get_any_Robin(f%z)/))
        end function

        function get_any_Prescribed_VF(f) result(L)
          implicit none
          type(VF),intent(in) :: f
          logical :: L
          L = any((/get_any_Prescribed(f%x),get_any_Prescribed(f%y),get_any_Prescribed(f%z)/))
        end function

        subroutine export_BCs_VF(f,dir,name)
          implicit none
          type(VF),intent(in) :: f
          character(len=*),intent(in) :: dir,name
          call export_BCs(f%x,dir,name//'_x')
          call export_BCs(f%y,dir,name//'_y')
          call export_BCs(f%z,dir,name//'_z')
        end subroutine

        function get_DL_VF(f) result(DL)
          implicit none
          type(VF),intent(in) :: f
          type(data_location),dimension(3) :: DL
          DL = (/f%x%DL,f%y%DL,f%z%DL/)
        end function

        function is_Face_VF_DL(f) result(L)
          implicit none
          type(VF),intent(in) :: f
          logical :: L
          L = is_Face_VF(get_DL(f))
        end function

        function is_Edge_VF_DL(f) result(L)
          implicit none
          type(VF),intent(in) :: f
          logical :: L
          L = is_Edge_VF(get_DL(f))
        end function

        function is_CC_VF_DL(f) result(L)
          implicit none
          type(VF),intent(in) :: f
          logical :: L
          L = is_CC_VF(get_DL(f))
        end function

        function is_Node_VF_DL(f) result(L)
          implicit none
          type(VF),intent(in) :: f
          logical :: L
          L = is_Node_VF(get_DL(f))
        end function

        function is_collocated_VF_DL(f) result(L)
          implicit none
          type(VF),intent(in) :: f
          type(data_location),dimension(3) :: DL
          logical :: L
          DL = get_DL(f)
          L = is_collocated_VF(DL)
        end function

        subroutine insist_collocated_VF(f,caller)
          implicit none
          type(VF),intent(in) :: f
          character(len=*),intent(in) :: caller
          if (.not.is_collocated(f)) then
            call print(f%x%DL)
            call print(f%y%DL)
            call print(f%z%DL)
            write(*,*) 'Error: DLs are not collocated in '//caller//' in VF.f90'
            stop 'Done'
          endif
        end subroutine

        subroutine volume_VF(u,m)
          implicit none
          type(VF),intent(inout) :: u
          type(mesh),intent(in) :: m
          call volume(u%x,m); call volume(u%y,m); call volume(u%z,m)
        end subroutine

        subroutine inverse_area_VF(u,m)
          implicit none
          type(VF),intent(inout) :: u
          type(mesh),intent(in) :: m
          call inverse_area(u%x,m,1)
          call inverse_area(u%y,m,2)
          call inverse_area(u%z,m,3)
        end subroutine

        subroutine sine_waves_VF(u,m,wavenum,phi)
          implicit none
          type(VF),intent(inout) :: u
          type(mesh),intent(in) :: m
          real(cp),dimension(3),intent(in) :: wavenum,phi
          call sine_waves(u%x,m,wavenum,phi)
          call sine_waves(u%y,m,wavenum,phi)
          call sine_waves(u%z,m,wavenum,phi)
        end subroutine

        subroutine cosine_waves_VF(u,m,wavenum,phi)
          implicit none
          type(VF),intent(inout) :: u
          type(mesh),intent(in) :: m
          real(cp),dimension(3),intent(in) :: wavenum,phi
          call cosine_waves(u%x,m,wavenum,phi)
          call cosine_waves(u%y,m,wavenum,phi)
          call cosine_waves(u%z,m,wavenum,phi)
        end subroutine

        subroutine random_noise_VF(u)
          implicit none
          type(VF),intent(inout) :: u
          call random_noise(u%x); call random_noise(u%y); call random_noise(u%z)
        end subroutine

        subroutine multiply_volume_VF(u,m)
          implicit none
          type(VF),intent(inout) :: u
          type(mesh),intent(in) :: m
          call multiply_volume(u%x,m); call multiply_volume(u%y,m); call multiply_volume(u%z,m)
        end subroutine

        subroutine init_CC_VF(f,m)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_CC(f%x,m); call init_CC(f%y,m); call init_CC(f%z,m)
        end subroutine

        subroutine init_CC_VF_MD(f,m,MD)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(mesh_domain),intent(in) :: MD
          call init_CC(f%x,m,MD); call init_CC(f%y,m,MD); call init_CC(f%z,m,MD)
        end subroutine

        subroutine init_Edge_VF(f,m)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_Edge(f%x,m,1); call init_Edge(f%y,m,2); call init_Edge(f%z,m,3)
        end subroutine

        subroutine init_Edge_VF_MD(f,m,MD)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(mesh_domain),intent(in) :: MD
          call init_Edge(f%x,m,1,MD); call init_Edge(f%y,m,2,MD); call init_Edge(f%z,m,3,MD)
        end subroutine

        subroutine init_Node_Edge_VF(f,m,dir)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          select case (dir)
          case (1); call init_Node(f%x,m);  call init_Face(f%y,m,3);call init_Face(f%z,m,2)
          case (2); call init_Face(f%x,m,3);call init_Node(f%y,m);  call init_Face(f%z,m,1)
          case (3); call init_Face(f%x,m,2);call init_Face(f%y,m,1);call init_Node(f%z,m)
          case default; stop 'Error: dir must = 1,2,3 in init_Node_Edge_VF in VF.f90'
          end select
        end subroutine

        subroutine init_Face_VF(f,m)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_Face(f%x,m,1); call init_Face(f%y,m,2); call init_Face(f%z,m,3)
        end subroutine

        subroutine init_Face_VF_MD(f,m,MD)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(mesh_domain),intent(in) :: MD
          call init_Face(f%x,m,1,MD); call init_Face(f%y,m,2,MD); call init_Face(f%z,m,3,MD)
        end subroutine

        subroutine init_CC_Edge_VF(f,m,dir)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          select case (dir)
          case (1); call init_CC  (f%x,m);  call init_Edge(f%y,m,2);call init_Edge(f%z,m,3)
          case (2); call init_Edge(f%x,m,1);call init_CC  (f%y,m);  call init_Edge(f%z,m,3)
          case (3); call init_Edge(f%x,m,1);call init_Edge(f%y,m,2);call init_CC  (f%z,m)
          case default; stop 'Error: dir must = 1,2,3 in init_Face_compliment_VF in VF.f90'
          end select
        end subroutine

        subroutine init_Node_VF(f,m)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_Node(f%x,m); call init_Node(f%y,m); call init_Node(f%z,m)
        end subroutine

        subroutine init_Node_VF_MD(f,m,MD)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(mesh_domain),intent(in) :: MD
          call init_Node(f%x,m,MD); call init_Node(f%y,m,MD); call init_Node(f%z,m,MD)
        end subroutine

        subroutine init_CC_VF_assign(f,m,val)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_CC(f%x,m,val); call init_CC(f%y,m,val); call init_CC(f%z,m,val)
        end subroutine

        subroutine init_Edge_VF_assign(f,m,val)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_Edge(f%x,m,1,val); call init_Edge(f%y,m,2,val); call init_Edge(f%z,m,3,val)
        end subroutine

        subroutine init_Face_VF_assign(f,m,val)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_Face(f%x,m,1,val); call init_Face(f%y,m,2,val); call init_Face(f%z,m,3,val)
        end subroutine

        subroutine init_Node_VF_assign(f,m,val)
          implicit none
          type(VF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_Node(f%x,m,val); call init_Node(f%y,m,val); call init_Node(f%z,m,val)
        end subroutine

        ! ****************************************************************
        ! ****************************************************************
        ! ********************* COMPUTATION ROUTINES *********************
        ! ****************************************************************
        ! ****************************************************************
        ! ----------------- ASSIGN ------------------

        subroutine assign_VF_VF_X(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          call assign(f%x,g%x)
        end subroutine

        subroutine assign_VF_VF_Y(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          call assign(f%y,g%y)
        end subroutine

        subroutine assign_VF_VF_Z(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          call assign(f%z,g%z)
        end subroutine

        subroutine assign_VF_S_X(f,g)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g
          call assign(f%x,g)
        end subroutine

        subroutine assign_VF_S_Y(f,g)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g
          call assign(f%y,g)
        end subroutine

        subroutine assign_VF_S_Z(f,g)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g
          call assign(f%z,g)
        end subroutine

        subroutine assign_VF_VF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          call assign(f%x,g%x); call assign(f%y,g%y); call assign(f%z,g%z)
        end subroutine

        subroutine assign_VF_SF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(SF),intent(in) :: g
          call assign(f%x,g); call assign(f%y,g); call assign(f%z,g)
        end subroutine

        subroutine assign_VF_S(f,g)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g
          call assign(f%x,g); call assign(f%y,g); call assign(f%z,g)
        end subroutine

        subroutine assign_negative_VF_VF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          call assign_negative(f%x,g%x); call assign_negative(f%y,g%y); call assign_negative(f%z,g%z)
        end subroutine

      ! ------------------- ADD ------------------------

        subroutine add_VF_VF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          call add(f%x,g%x); call add(f%y,g%y); call add(f%z,g%z)
        end subroutine

        subroutine add_VF_VF_VF(f,g,r)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g,r
          call add(f%x,g%x,r%x); call add(f%y,g%y,r%y); call add(f%z,g%z,r%z)
        end subroutine

        subroutine add_VF_SF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(SF),intent(in) :: g
          call add(f%x,g); call add(f%y,g); call add(f%z,g)
        end subroutine

        subroutine add_SF_VF(f,g)
          implicit none
          type(SF),intent(inout) :: f
          type(VF),intent(in) :: g
          call add(f,g%x,g%y,g%z)
        end subroutine

        subroutine add_VF_S(f,g)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g
          call add(f%x,g); call add(f%y,g); call add(f%z,g)
        end subroutine

        subroutine add_S_VF(g2,f)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g2
          call add(f%x,g2); call add(f%y,g2); call add(f%z,g2)
        end subroutine

      ! ------------------- ADD PRODUCT ------------------------

        subroutine add_product_VF_VF_S(f,g,r)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          real(cp),intent(in) :: r
          call add_product(f%x,g%x,r)
          call add_product(f%y,g%y,r)
          call add_product(f%z,g%z,r)
        end subroutine
        subroutine product_add_VF_VF_S(f,r,g)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: r
          type(VF),intent(in) :: g
          call product_add(f%x,r,g%x)
          call product_add(f%y,r,g%y)
          call product_add(f%z,r,g%z)
        end subroutine

      ! ------------------- SUBTRACT ------------------------

        subroutine subtract_VF_VF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          call subtract(f%x,g%x); call subtract(f%y,g%y); call subtract(f%z,g%z)
        end subroutine

        subroutine subtract_VF_VF_VF(f,g,q)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g,q
          call subtract(f%x,g%x,q%x); call subtract(f%y,g%y,q%y); call subtract(f%z,g%z,q%z)
        end subroutine

        subroutine subtract_VF_SF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(SF),intent(in) :: g
          call subtract(f%x,g); call subtract(f%y,g); call subtract(f%z,g)
        end subroutine

        subroutine subtract_VF_S(f,g)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g
          call subtract(f%x,g); call subtract(f%y,g); call subtract(f%z,g)
        end subroutine

        subroutine subtract_S_VF(g2,f)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g2
          call subtract(g2,f%x); call subtract(g2,f%y); call subtract(g2,f%z)
        end subroutine

      ! ------------------- MULTIPLY ------------------------

        subroutine multiply_VF_VF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          call multiply(f%x,g%x); call multiply(f%y,g%y); call multiply(f%z,g%z)
        end subroutine

        subroutine multiply_VF_VF_VF(f,g,q)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g,q
          call multiply(f%x,g%x,q%x); call multiply(f%y,g%y,q%y); call multiply(f%z,g%z,q%z)
        end subroutine

        subroutine multiply_VF_VF_SF(f,g,q)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          type(SF),intent(in) :: q
          call multiply(f%x,g%x,q); call multiply(f%y,g%y,q); call multiply(f%z,g%z,q)
        end subroutine

        subroutine multiply_VF_VF_S(f,g,q)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          real(cp),intent(in) :: q
          call multiply(f%x,g%x,q); call multiply(f%y,g%y,q); call multiply(f%z,g%z,q)
        end subroutine

        subroutine multiply_VF_SF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(SF),intent(in) :: g
          call multiply(f%x,g); call multiply(f%y,g); call multiply(f%z,g)
        end subroutine

        subroutine multiply_SF_VF(g2,f)
          implicit none
          type(VF),intent(inout) :: f
          type(SF),intent(in) :: g2
          call multiply(f%x,g2); call multiply(f%y,g2); call multiply(f%z,g2)
        end subroutine

        subroutine multiply_VF_S(f,g)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g
          call multiply(f%x,g); call multiply(f%y,g); call multiply(f%z,g)
        end subroutine

        subroutine multiply_VF_S3(f,g)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),dimension(3),intent(in) :: g
          call multiply(f%x,g(1)); call multiply(f%y,g(2)); call multiply(f%z,g(3))
        end subroutine

        subroutine multiply_S_VF(g2,f)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g2
          call multiply(f%x,g2); call multiply(f%y,g2); call multiply(f%z,g2)
        end subroutine

      ! ------------------- DIVIDE ------------------------

        subroutine divide_VF_VF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(VF),intent(in) :: g
          call divide(f%x,g%x); call divide(f%y,g%y); call divide(f%z,g%z)
        end subroutine

        subroutine divide_VF_SF(f,g)
          implicit none
          type(VF),intent(inout) :: f
          type(SF),intent(in) :: g
          call divide(f%x,g); call divide(f%y,g); call divide(f%z,g)
        end subroutine

        subroutine divide_VF_S_VF(f,g,q)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g
          type(VF),intent(inout) :: q
          call divide(f%x,g,q%x); call divide(f%y,g,q%y); call divide(f%z,g,q%z)
        end subroutine

        subroutine divide_VF_S(f,g)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g
          call divide(f%x,g); call divide(f%y,g); call divide(f%z,g)
        end subroutine

        subroutine divide_S_VF(g2,f)
          implicit none
          type(VF),intent(inout) :: f
          real(cp),intent(in) :: g2
          call divide(g2,f%x); call divide(g2,f%y); call divide(g2,f%z)
        end subroutine

      ! ------------------- OTHER ------------------------

        subroutine magnitude_VF(f,g)
          implicit none
          type(SF),intent(inout) :: f
          type(VF),intent(in) :: g
          call magnitude(f,g%x,g%y,g%z)
        end subroutine

        subroutine invert_VF(f)
          implicit none
          type(VF),intent(inout) :: f
          call invert(f%x); call invert(f%y); call invert(f%z)
        end subroutine

        function mean_VF(f) result (m)
          implicit none
          type(VF),intent(in) :: f
          real(cp) :: m
          m = (sum(f%x) + sum(f%y) + sum(f%z))/(f%x%numEl + f%y%numEl + f%z%numEl)
        end function

        function max_VF(f) result (m)
          implicit none
          type(VF),intent(in) :: f
          real(cp) :: m
          m = maxval((/max(f%x),max(f%y),max(f%z)/))
        end function

        function amin_VF(f) result (m)
          implicit none
          type(VF),intent(in) :: f
          real(cp) :: m
          m = minval((/abs(amin(f%x)),abs(amin(f%y)),abs(amin(f%z))/))
        end function

        function sum_pad_VF(f,pad) result (m)
          implicit none
          type(VF),intent(in) :: f
          integer,intent(in) :: pad
          real(cp) :: m
          m = sum(f%x,pad)+sum(f%y,pad)+sum(f%z,pad)
        end function

        subroutine boundary_flux_VF(BF,f,m,f_temp)
          implicit none
          real(cp),intent(inout) :: BF
          type(VF),intent(in) :: f
          type(mesh),intent(in) :: m
          type(VF),intent(inout) :: f_temp
          call boundary_flux(BF,f%x,f%y,f%z,m,f_temp%x,f_temp%y,f_temp%z)
        end subroutine

        function amax_VF(f) result (m)
          implicit none
          type(VF),intent(in) :: f
          real(cp) :: m
          m = maxval((/abs(amax(f%x)),abs(amax(f%y)),abs(amax(f%z))/))
        end function

        subroutine square_VF(f)
          implicit none
          type(VF),intent(inout) :: f
          call square(f%x); call square(f%y); call square(f%z)
        end subroutine

        subroutine square_root_VF(f)
          implicit none
          type(VF),intent(inout) :: f
          call square_root(f%x); call square_root(f%y); call square_root(f%z)
        end subroutine

        subroutine abs_VF(f)
          implicit none
          type(VF),intent(inout) :: f
          call abs(f%x); call abs(f%y); call abs(f%z)
        end subroutine

        subroutine insist_amax_lt_tol_VF(f,caller)
          implicit none
          type(VF),intent(in) :: f
          character(len=*),intent(in) :: caller
          call insist_amax_lt_tol(f%x,caller//'_x')
          call insist_amax_lt_tol(f%y,caller//'_y')
          call insist_amax_lt_tol(f%z,caller//'_z')
        end subroutine

        ! subroutine vectorSum(f,g)
        !   implicit none
        !   type(SF),intent(inout) :: f
        !   type(VF),intent(in) :: g
        !   call sum(f%x,g%x); call sum(f%y,g%y); call sum(f%z,g%z)
        ! end subroutine

        function dot_product_VF(A,B,temp) result(dot)
          implicit none
          type(VF),intent(in) :: A,B
          type(VF),intent(inout) :: temp
          real(cp) :: dot
          call multiply(temp,A,B)
          dot = sum(temp%x) + sum(temp%y) + sum(temp%z)
        end function

        subroutine dot_VF_SF(A,B,C,temp)
          implicit none
          type(SF),intent(inout) :: A
          type(VF),intent(in) :: B,C
          type(VF),intent(inout) :: temp
          call multiply(temp,B,C)
          call add(A,temp%x,temp%y,temp%z)
        end subroutine

        subroutine cross_product_VF(ACrossB,A,B)
          implicit none
          type(VF),intent(inout) :: ACrossB
          type(VF),intent(in) :: A,B
          call cross_product_x(ACrossB%x,A%y,A%z,B%y,B%z)
          call cross_product_y(ACrossB%y,A%x,A%z,B%x,B%z)
          call cross_product_z(ACrossB%z,A%x,A%y,B%x,B%y)
        end subroutine

        subroutine restrict_VF(A,m)
          implicit none
          type(VF),intent(inout) :: A
          type(mesh),intent(in) :: m
          call restrict(A%x,m)
          call restrict(A%y,m)
          call restrict(A%z,m)
        end subroutine

        subroutine restrict_dir_VF(A,m,dir)
          implicit none
          type(VF),intent(inout) :: A
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          call restrict(A%x,m,dir)
          call restrict(A%y,m,dir)
          call restrict(A%z,m,dir)
        end subroutine

        subroutine prolongate_VF(A,m)
          implicit none
          type(VF),intent(inout) :: A
          type(mesh),intent(in) :: m
          call prolongate(A%x,m)
          call prolongate(A%y,m)
          call prolongate(A%z,m)
        end subroutine

        subroutine prolongate_dir_VF(A,m,dir)
          implicit none
          type(VF),intent(inout) :: A
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          call prolongate(A%x,m,dir)
          call prolongate(A%y,m,dir)
          call prolongate(A%z,m,dir)
        end subroutine

        function symmetry_error_x_VF(A) result(SE)
          implicit none
          type(VF),intent(in) :: A
          real(cp) :: SE
          SE = symmetry_error_x(A%x) + symmetry_error_x(A%y) + symmetry_error_x(A%z)
        end function

        function symmetry_error_y_VF(A) result(SE)
          implicit none
          type(VF),intent(in) :: A
          real(cp) :: SE
          SE = symmetry_error_y(A%x) + symmetry_error_y(A%y) + symmetry_error_y(A%z)
        end function

        function symmetry_error_z_VF(A) result(SE)
          implicit none
          type(VF),intent(in) :: A
          real(cp) :: SE
          SE = symmetry_error_z(A%x) + symmetry_error_z(A%y) + symmetry_error_z(A%z)
        end function

        subroutine symmetry_local_x_VF(A)
          implicit none
          type(VF),intent(inout) :: A
          call symmetry_local_x(A%x)
          call symmetry_local_x(A%y)
          call symmetry_local_x(A%z)
        end subroutine

        subroutine symmetry_local_y_VF(A)
          implicit none
          type(VF),intent(inout) :: A
          call symmetry_local_y(A%x)
          call symmetry_local_y(A%y)
          call symmetry_local_y(A%z)
        end subroutine

        subroutine symmetry_local_z_VF(A)
          implicit none
          type(VF),intent(inout) :: A
          call symmetry_local_z(A%x)
          call symmetry_local_z(A%y)
          call symmetry_local_z(A%z)
        end subroutine

        function CFL_number_VF(A,m,dt) result(CFL)
          implicit none
          type(VF),intent(in) :: A
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: dt
          real(cp) :: CFL
          CFL = CFL_number(A%x,A%y,A%z,m,dt)
        end function

        function dt_given_CFL_number_VF(A,m,CFL) result(dt)
          implicit none
          type(VF),intent(in) :: A
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: CFL
          real(cp) :: dt
          dt = dt_given_CFL_number(A%x,A%y,A%z,m,CFL)
        end function

        subroutine assign_BC_vals_VF(A,B)
          implicit none
          type(VF),intent(inout) :: A
          type(VF),intent(in) :: B
          call assign_BC_vals(A%x,B%x)
          call assign_BC_vals(A%y,B%y)
          call assign_BC_vals(A%z,B%z)
        end subroutine

        subroutine update_BC_vals_VF(A)
          implicit none
          type(VF),intent(inout) :: A
          call update_BC_vals(A%x)
          call update_BC_vals(A%y)
          call update_BC_vals(A%z)
        end subroutine

        subroutine assign_BCs_VF(A,B)
          implicit none
          type(VF),intent(inout) :: A
          type(VF),intent(in) :: B
          call assign_BCs(A%x,B%x)
          call assign_BCs(A%y,B%y)
          call assign_BCs(A%z,B%z)
        end subroutine
        subroutine assign_Dirichlet_BCs_VF(A,B)
          implicit none
          type(VF),intent(inout) :: A
          type(VF),intent(in) :: B
          call assign_Dirichlet_BCs(A%x,B%x)
          call assign_Dirichlet_BCs(A%y,B%y)
          call assign_Dirichlet_BCs(A%z,B%z)
        end subroutine
        subroutine assign_Periodic_BCs_VF(A,B)
          implicit none
          type(VF),intent(inout) :: A
          type(VF),intent(in) :: B
          call assign_Periodic_BCs(A%x,B%x)
          call assign_Periodic_BCs(A%y,B%y)
          call assign_Periodic_BCs(A%z,B%z)
        end subroutine
        subroutine assign_Neumann_BCs_faces_VF(A,B)
          implicit none
          type(SF),intent(inout) :: A
          type(VF),intent(in) :: B
          call assign_Neumann_BCs(A,B%x,1)
          call assign_Neumann_BCs(A,B%y,2)
          call assign_Neumann_BCs(A,B%z,3)
        end subroutine
        subroutine assign_Neumann_BCs_wall_normal_VF(A,B)
          implicit none
          type(SF),intent(inout) :: A
          type(VF),intent(in) :: B
          call assign_Neumann_BCs_wall_normal(A,B%x,1)
          call assign_Neumann_BCs_wall_normal(A,B%y,2)
          call assign_Neumann_BCs_wall_normal(A,B%z,3)
        end subroutine
        subroutine multiply_Neumann_BCs_VF(A,scale)
          implicit none
          type(VF),intent(inout) :: A
          real(cp),intent(in) :: scale
          call multiply_Neumann_BCs(A%x,scale)
          call multiply_Neumann_BCs(A%y,scale)
          call multiply_Neumann_BCs(A%z,scale)
        end subroutine
        subroutine multiply_BCs_by_nhat_VF(A)
          implicit none
          type(VF),intent(inout) :: A
          call multiply_BCs_by_nhat(A%x)
          call multiply_BCs_by_nhat(A%y)
          call multiply_BCs_by_nhat(A%z)
        end subroutine
        subroutine assign_Robin_BCs_dir_VF(A,B)
          implicit none
          type(SF),intent(inout) :: A
          type(VF),intent(in) :: B
          call assign_Robin_BCs(A,B%x,1)
          call assign_Robin_BCs(A,B%y,2)
          call assign_Robin_BCs(A,B%z,3)
        end subroutine
        subroutine assign_Robin_BCs_faces_VF(A,B)
          implicit none
          type(VF),intent(inout) :: A
          type(VF),intent(in) :: B
          call assign_Robin_BCs(A%x,B%x)
          call assign_Robin_BCs(A%y,B%y)
          call assign_Robin_BCs(A%z,B%z)
        end subroutine
        subroutine multiply_Robin_coeff_VF(u)
          implicit none
          type(VF),intent(inout) :: u
          call multiply_Robin_coeff(u%x)
          call multiply_Robin_coeff(u%y)
          call multiply_Robin_coeff(u%z)
        end subroutine
        subroutine multiply_nhat_VF(u,u_with_BCs)
          implicit none
          type(VF),intent(inout) :: u
          type(VF),intent(in) :: u_with_BCs
          call multiply_nhat(u%x,u_with_BCs%x)
          call multiply_nhat(u%y,u_with_BCs%y)
          call multiply_nhat(u%z,u_with_BCs%z)
        end subroutine

        subroutine assign_ghost_XPeriodic_VF(A,val)
          implicit none
          type(VF),intent(inout) :: A
          real(cp),intent(in) :: val
          call assign_ghost_XPeriodic(A%x,val)
          call assign_ghost_XPeriodic(A%y,val)
          call assign_ghost_XPeriodic(A%z,val)
        end subroutine
        subroutine assign_ghost_XPeriodic_VF2(A,val,A_with_BCs)
          implicit none
          type(VF),intent(inout) :: A
          type(VF),intent(in) :: A_with_BCs
          real(cp),intent(in) :: val
          call assign_ghost_XPeriodic(A%x,val,A_with_BCs%x)
          call assign_ghost_XPeriodic(A%y,val,A_with_BCs%y)
          call assign_ghost_XPeriodic(A%z,val,A_with_BCs%z)
        end subroutine

        subroutine assign_ghost_N_XPeriodic_VF(A,val)
          implicit none
          type(VF),intent(inout) :: A
          real(cp),intent(in) :: val
          call assign_ghost_N_XPeriodic(A%x,val)
          call assign_ghost_N_XPeriodic(A%y,val)
          call assign_ghost_N_XPeriodic(A%z,val)
        end subroutine
        subroutine assign_ghost_N_XPeriodic_VF2(A,val,A_with_BCs)
          implicit none
          type(VF),intent(inout) :: A
          type(VF),intent(in) :: A_with_BCs
          real(cp),intent(in) :: val
          call assign_ghost_N_XPeriodic(A%x,val,A_with_BCs%x)
          call assign_ghost_N_XPeriodic(A%y,val,A_with_BCs%y)
          call assign_ghost_N_XPeriodic(A%z,val,A_with_BCs%z)
        end subroutine

        subroutine assign_wall_Dirichlet_VF(A,val)
          implicit none
          type(VF),intent(inout) :: A
          real(cp),intent(in) :: val
          call assign_wall_Dirichlet(A%x,val)
          call assign_wall_Dirichlet(A%y,val)
          call assign_wall_Dirichlet(A%z,val)
        end subroutine
        subroutine assign_wall_Dirichlet_VF2(A,val,A_with_BCs)
          implicit none
          type(VF),intent(inout) :: A
          type(VF),intent(in) :: A_with_BCs
          real(cp),intent(in) :: val
          call assign_wall_Dirichlet(A%x,val,A_with_BCs%x)
          call assign_wall_Dirichlet(A%y,val,A_with_BCs%y)
          call assign_wall_Dirichlet(A%z,val,A_with_BCs%z)
        end subroutine

        subroutine assign_wall_Periodic_single_VF(A,val)
          implicit none
          type(VF),intent(inout) :: A
          real(cp),intent(in) :: val
          call assign_wall_Periodic_single(A%x,val)
          call assign_wall_Periodic_single(A%y,val)
          call assign_wall_Periodic_single(A%z,val)
        end subroutine
        subroutine assign_wall_Periodic_single_VF2(A,val,A_with_BCs)
          implicit none
          type(VF),intent(inout) :: A
          type(VF),intent(in) :: A_with_BCs
          real(cp),intent(in) :: val
          call assign_wall_Periodic_single(A%x,val,A_with_BCs%x)
          call assign_wall_Periodic_single(A%y,val,A_with_BCs%y)
          call assign_wall_Periodic_single(A%z,val,A_with_BCs%z)
        end subroutine

        subroutine multiply_wall_Neumann_VF(A,val)
          implicit none
          type(VF),intent(inout) :: A
          real(cp),intent(in) :: val
          call multiply_wall_Neumann(A%x,val)
          call multiply_wall_Neumann(A%y,val)
          call multiply_wall_Neumann(A%z,val)
        end subroutine
        subroutine multiply_wall_Neumann_VF2(A,val,A_with_BCs)
          implicit none
          type(VF),intent(inout) :: A
          type(VF),intent(in) :: A_with_BCs
          real(cp),intent(in) :: val
          call multiply_wall_Neumann(A%x,val,A_with_BCs%x)
          call multiply_wall_Neumann(A%y,val,A_with_BCs%y)
          call multiply_wall_Neumann(A%z,val,A_with_BCs%z)
        end subroutine

        subroutine set_prescribed_BCs_VF(A)
          implicit none
          type(VF),intent(inout) :: A
          call set_prescribed_BCs(A%x)
          call set_prescribed_BCs(A%y)
          call set_prescribed_BCs(A%z)
        end subroutine

        subroutine set_BCs_homogeneous_VF(A)
          implicit none
          type(VF),intent(inout) :: A
          call set_BCs_homogeneous(A%x)
          call set_BCs_homogeneous(A%y)
          call set_BCs_homogeneous(A%z)
        end subroutine

      end module
       module momentum_stability_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod

       implicit none
       private

       public :: momentum_stability
       public :: init,delete

       type momentum_stability
         type(SF) :: Fo_grid
         type(SF) :: Co_grid
         type(SF) :: Re_grid
         type(SF) :: KE_adv
         type(SF) :: KE_diff
         type(SF) :: KE_pres
         type(SF) :: KE_transient
         type(SF) :: KE_jCrossB
       end type

       interface init;       module procedure init_MS;        end interface
       interface delete;     module procedure delete_MS;      end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_MS(MS,m)
         implicit none
         type(momentum_stability),intent(inout) :: MS
         type(mesh),intent(in) :: m
         call init_CC(MS%Fo_grid     ,m,0.0_cp)
         call init_CC(MS%Co_grid     ,m,0.0_cp)
         call init_CC(MS%Re_grid     ,m,0.0_cp)
         call init_CC(MS%KE_adv      ,m,0.0_cp)
         call init_CC(MS%KE_diff     ,m,0.0_cp)
         call init_CC(MS%KE_pres     ,m,0.0_cp)
         call init_CC(MS%KE_transient,m,0.0_cp)
         call init_CC(MS%KE_jCrossB  ,m,0.0_cp)
       end subroutine

       subroutine delete_MS(MS)
         implicit none
         type(momentum_stability),intent(inout) :: MS
         call delete(MS%Fo_grid)
         call delete(MS%Co_grid)
         call delete(MS%Re_grid)
         call delete(MS%KE_adv)
         call delete(MS%KE_diff)
         call delete(MS%KE_pres)
         call delete(MS%KE_transient)
         call delete(MS%KE_jCrossB)
       end subroutine

       end module
      module ops_del_mod
      ! Returns an n-derivative of the scalar field, f,
      ! along direction dir (1,2,3) which corresponds to (x,y,z).
      !
      ! Flags: (fopenmp,_DEBUG_DEL_)
      !
      ! Implementation:
      !      type(del) :: d
      !      type(SF) :: f,dfdh
      !      type(mesh) :: m
      !      integer :: n,dir,pad
      !      call d%assign  (dfdh,f,m,n,dir,pad) --> dfdh = d/dh (f), 0 if not defined.
      !      call d%add     (dfdh,f,m,n,dir,pad) --> dfdh = dfdh + d/dh (f)
      !      call d%subtract(dfdh,f,m,n,dir,pad) --> dfdh = dfdh - d/dh (f)
      !
      ! INPUT:
      !     f            = f(x,y,z)
      !     m            = mesh containing grids
      !     n            = nth derivative (n=1,2 supported)
      !     dir          = direction along which to take the derivative (1,2,3)
      !     pad          = (1,0) = (exclude,include) boundary calc along derivative direction
      !                    |0000000|     |-------|
      !                    |-------|  ,  |-------| Look at del for implementation details
      !                    |0000000|     |-------|
      !
      ! CharlieKawczynski@gmail.com
      ! 5/15/2014

      use current_precision_mod
      use grid_mod
      use face_edge_corner_indexing_mod
      use data_location_extend_mod
      use mesh_extend_mod
      use GF_mod
      use SF_extend_mod
      use sparse_mod
      use stencils_mod
      implicit none

      private
      public :: del

      type del
        contains
        generic,public :: assign => assignDel
        generic,public :: add => addDel
        generic,public :: subtract => subtractDel
        procedure,private,nopass :: assignDel
        procedure,private,nopass :: addDel
        procedure,private,nopass :: subtractDel
      end type

      contains

      ! *********************************************************
      ! *********************** LOW LEVEL ***********************
      ! *********************************************************

      subroutine diff_stag(operator,dfdh,f,T,dir,pad,gt)
        implicit none
        procedure(stencils_stag) :: operator
        type(grid_field),intent(inout) :: dfdh
        type(grid_field),intent(in) :: f
        type(sparse),intent(in) :: T
        integer,intent(in) :: dir,pad,gt
        integer :: i,j,k
        select case (dir)
        case (1)
#ifdef _PARALLELIZE_DEL_
        !$OMP PARALLEL DO SHARED(T,f,gt)

#endif
        do k=1+pad,f%s(3)-pad; do j=1+pad,f%s(2)-pad
          call operator(dfdh%f(:,j,k),f%f(:,j,k),T,f%s(dir),dfdh%s(dir),gt)
        enddo; enddo
#ifdef _PARALLELIZE_DEL_
        !$OMP END PARALLEL DO

#endif
        case (2)
#ifdef _PARALLELIZE_DEL_
        !$OMP PARALLEL DO SHARED(T,f,gt)

#endif
        do k=1+pad,f%s(3)-pad; do i=1+pad,f%s(1)-pad
          call operator(dfdh%f(i,:,k),f%f(i,:,k),T,f%s(dir),dfdh%s(dir),gt)
        enddo; enddo
#ifdef _PARALLELIZE_DEL_
        !$OMP END PARALLEL DO

#endif
        case (3)
#ifdef _PARALLELIZE_DEL_
        !$OMP PARALLEL DO SHARED(T,f,gt)

#endif
        do j=1+pad,f%s(2)-pad; do i=1+pad,f%s(1)-pad
          call operator(dfdh%f(i,j,:),f%f(i,j,:),T,f%s(dir),dfdh%s(dir),gt)
        enddo; enddo
#ifdef _PARALLELIZE_DEL_
        !$OMP END PARALLEL DO

#endif
        end select
      end subroutine

      subroutine diff_col(operator,dfdh,f,T,dir,pad,pad1,pad2)
        implicit none
        procedure(stencils_col) :: operator
        type(grid_field),intent(inout) :: dfdh
        type(grid_field),intent(in) :: f
        type(sparse),intent(in) :: T
        integer,intent(in) :: dir,pad,pad1,pad2
        integer :: i,j,k
        select case (dir)
        case (1)
#ifdef _PARALLELIZE_DEL_
        !$OMP PARALLEL DO SHARED(T,f,pad1,pad2)

#endif
        do k=1+pad,f%s(3)-pad; do j=1+pad,f%s(2)-pad
          call operator(dfdh%f(:,j,k),f%f(:,j,k),T,f%s(dir),pad1,pad2)
        enddo; enddo
#ifdef _PARALLELIZE_DEL_
        !$OMP END PARALLEL DO

#endif
        case (2)
#ifdef _PARALLELIZE_DEL_
        !$OMP PARALLEL DO SHARED(T,f,pad1,pad2)

#endif
        do k=1+pad,f%s(3)-pad; do i=1+pad,f%s(1)-pad
          call operator(dfdh%f(i,:,k),f%f(i,:,k),T,f%s(dir),pad1,pad2)
        enddo; enddo
#ifdef _PARALLELIZE_DEL_
        !$OMP END PARALLEL DO

#endif
        case (3)
#ifdef _PARALLELIZE_DEL_
        !$OMP PARALLEL DO SHARED(T,f,pad1,pad2)

#endif
        do j=1+pad,f%s(2)-pad; do i=1+pad,f%s(1)-pad
          call operator(dfdh%f(i,j,:),f%f(i,j,:),T,f%s(dir),pad1,pad2)
        enddo; enddo
#ifdef _PARALLELIZE_DEL_
        !$OMP END PARALLEL DO

#endif
        end select
      end subroutine


      ! *********************************************************
      ! *********************** MED LEVEL ***********************
      ! *********************************************************

      subroutine diff_tree_search(dfdh,f,g,n,dir,pad,genType,diffType,pad1,pad2)
        implicit none
        type(grid_field),intent(inout) :: dfdh
        type(grid_field),intent(in) :: f
        type(grid),intent(in) :: g
        integer,intent(in) :: n,dir,pad,genType,pad1,pad2
        integer,intent(in) :: diffType
#ifdef _DEBUG_DEL_
        call insist_shape_match(dfdh,f,dir,'diff_tree_search')
#endif
        select case (genType)
        case (1); select case (diffType)
                  case (3); call diff_stag(stag_assign ,dfdh,f,g%c(dir)%stagCC2N,dir,pad,1)
                  case (4); call diff_stag(stag_assign ,dfdh,f,g%c(dir)%stagN2CC,dir,pad,0)
                  case (1); call diff_col(col_CC_assign,dfdh,f,g%c(dir)%colCC(n),dir,pad,pad1,pad2)
                  case (2); call diff_col(col_N_assign ,dfdh,f,g%c(dir)%colN(n) ,dir,pad,pad1,pad2)
                  end select
        case (3); select case (diffType)
                  case (3); call diff_stag(stag_subtract ,dfdh,f,g%c(dir)%stagCC2N,dir,pad,1)
                  case (4); call diff_stag(stag_subtract ,dfdh,f,g%c(dir)%stagN2CC,dir,pad,0)
                  case (1); call diff_col(col_CC_subtract,dfdh,f,g%c(dir)%colCC(n),dir,pad,pad1,pad2)
                  case (2); call diff_col(col_N_subtract ,dfdh,f,g%c(dir)%colN(n) ,dir,pad,pad1,pad2)
                  end select
        case (2); select case (diffType)
                  case (3); call diff_stag(stag_add ,dfdh,f,g%c(dir)%stagCC2N,dir,pad,1)
                  case (4); call diff_stag(stag_add ,dfdh,f,g%c(dir)%stagN2CC,dir,pad,0)
                  case (1); call diff_col(col_CC_add,dfdh,f,g%c(dir)%colCC(n),dir,pad,pad1,pad2)
                  case (2); call diff_col(col_N_add ,dfdh,f,g%c(dir)%colN(n) ,dir,pad,pad1,pad2)
                  end select
        case default; stop 'Error: genType must = 1,2,3 in diff_tree_search in ops_del.f90'
        end select
      end subroutine

      subroutine diff(dfdh,f,m,n,dir,pad,genType)
        implicit none
        type(SF),intent(inout) :: dfdh
        type(SF),intent(in) :: f
        type(mesh),intent(in) :: m
        integer,intent(in) :: n,dir,pad,genType
        integer :: i,diffType
        ! integer :: pad1,pad2
        ! integer,dimension(2) :: faces
        ! d%assign(lapU,u,m,2,1,0)

        diffType = getDiffType(f,dfdh,dir)
        do i=1,m%s
          ! faces = normal_faces_given_dir(dir)
          ! if (m%B(i)%g%st_faces(faces(1))%TF) then; pad1 = 1; else; pad1 = 0; endif
          ! if (m%B(i)%g%st_faces(faces(2))%TF) then; pad2 = 1; else; pad2 = 0; endif

#ifdef _DEBUG_DEL_
          call check_diff_shape(f%BF(i)%GF,dfdh%BF(i)%GF,dir)
#endif

          call diff_tree_search(dfdh%BF(i)%GF,f%BF(i)%GF,m%B(i)%g,n,dir,pad,genType,diffType,0,0)
        enddo
        ! if (n.eq.2) then; call assign_ghost(dfdh,0.0_cp)
        ! elseif ((genType.eq.1).and.(pad.gt.0)) then
        if ((genType.eq.1).and.(pad.gt.0)) then
          if (n.eq.2) write(*,*) 'n,pad,dir,genType = ',n,pad,dir,genType
          select case (dir)
          case (1); call assign_ghost_ymin_ymax(dfdh,0.0_cp)
                    call assign_ghost_zmin_zmax(dfdh,0.0_cp)
          case (2); call assign_ghost_xmin_xmax(dfdh,0.0_cp)
                    call assign_ghost_zmin_zmax(dfdh,0.0_cp)
          case (3); call assign_ghost_xmin_xmax(dfdh,0.0_cp)
                    call assign_ghost_ymin_ymax(dfdh,0.0_cp)
          case default; stop 'Error: dir must = 1,2,3 in delGen_T in ops_del.f90.'
          end select
        endif
      end subroutine

      ! *********************************************************
      ! *********************** HIGH LEVEL **********************
      ! *********************************************************

      subroutine assignDel(dfdh,f,m,n,dir,pad)
        implicit none
        type(SF),intent(inout) :: dfdh
        type(SF),intent(in) :: f
        type(mesh),intent(in) :: m
        integer,intent(in) :: n,dir,pad
        call diff(dfdh,f,m,n,dir,pad,1)
      end subroutine

      subroutine addDel(dfdh,f,m,n,dir,pad)
        implicit none
        type(SF),intent(inout) :: dfdh
        type(SF),intent(in) :: f
        type(mesh),intent(in) :: m
        integer,intent(in) :: n,dir,pad
        call diff(dfdh,f,m,n,dir,pad,2)
      end subroutine

      subroutine subtractDel(dfdh,f,m,n,dir,pad)
        implicit none
        type(SF),intent(inout) :: dfdh
        type(SF),intent(in) :: f
        type(mesh),intent(in) :: m
        integer,intent(in) :: n,dir,pad
        call diff(dfdh,f,m,n,dir,pad,3)
      end subroutine

      ! *********************************************************
      ! *********************** AUX / DEBUG *********************
      ! *********************************************************

      function getDiffType(f,dfdh,dir) result(diffType)
        implicit none
        type(SF),intent(in) :: f,dfdh
        integer,intent(in) :: dir
        integer :: diffType
            if (CC_along(f%DL,dir).and.CC_along(dfdh%DL,dir)) then
          diffType = 1 ! Collocated derivative (CC)
        elseif (N_along(f%DL,dir).and.N_along(dfdh%DL,dir)) then
          diffType = 2 ! Collocated derivative (N)
        elseif (CC_along(f%DL,dir).and.N_along(dfdh%DL,dir)) then
          diffType = 3 ! Staggered derivative (CC->N)
        elseif (N_along(f%DL,dir).and.CC_along(dfdh%DL,dir)) then
          diffType = 4 ! Staggered derivative (N->CC)
        else
          write(*,*) 'dir = ',dir
          write(*,*) ' -------------------- f -------------------- '
          call print(f%DL)
          write(*,*) ' ------------------- dfdh -------------------- '
          call print(dfdh%DL)
          stop 'Error: diffType undetermined in ops_del.f90.'
        endif
      end function

#ifdef _DEBUG_DEL_
      subroutine check_diff_shape(f,dfdh,dir)
        implicit none
        type(grid_field),intent(in) :: f,dfdh
        integer,intent(in) :: dir
            if (f%s(dir).eq.dfdh%s(dir)) then ! Collocated derivative (CC)
        elseif (f%s(dir).eq.dfdh%s(dir)) then ! Collocated derivative (N)
        elseif (f%s(dir).eq.dfdh%s(dir)-1) then ! Staggered derivative (CC->N)
        elseif (f%s(dir).eq.dfdh%s(dir)+1) then ! Staggered derivative (N->CC)
        else
          write(*,*) 'dir = ',dir
          write(*,*) 'f%s(dir) = ',f%s(dir)
          write(*,*) 'dfdh%s(dir)+1 = ',dfdh%s(dir)+1
          stop 'Error: check_diff_shape undetermined in ops_del.f90.'
        endif
      end subroutine
#endif

      end module
       module AB2_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       implicit none

       private
       public :: AB2,AB2_overwrite
       interface AB2_overwrite;       module procedure AB2_overwrite_SF;       end interface
       interface AB2_overwrite;       module procedure AB2_overwrite_VF;       end interface
       interface AB2;                 module procedure AB2_SF;                 end interface
       interface AB2;                 module procedure AB2_VF;                 end interface

       contains

       subroutine AB2_overwrite_SF(Fn,Fnm1)
         ! Computes
         !
         !    Fn = 0.5 (3 Fn - Fnm1)
         !
         implicit none
         type(SF),intent(inout) :: Fn
         type(SF),intent(in) :: Fnm1
         call multiply(Fn,1.5_cp)
         call add_product(Fn,Fnm1,-0.5_cp)
       end subroutine

       subroutine AB2_overwrite_VF(Fn,Fnm1)
         ! Computes
         !
         !    Fn = 0.5 (3 Fn - Fnm1)
         !
         implicit none
         type(VF),intent(inout) :: Fn
         type(VF),intent(in) :: Fnm1
         call multiply(Fn,1.5_cp)
         call add_product(Fn,Fnm1,-0.5_cp)
       end subroutine

       subroutine AB2_SF(AB2,Fn,Fnm1)
         ! Computes
         !
         !    AB2 = 0.5 (3 Fn - Fnm1)
         !
         implicit none
         type(SF),intent(inout) :: AB2
         type(SF),intent(in) :: Fn,Fnm1
         call multiply(AB2,Fn,1.5_cp)
         call add_product(AB2,Fnm1,-0.5_cp)
       end subroutine

       subroutine AB2_VF(AB2,Fn,Fnm1)
         ! Computes
         !
         !    AB2 = 0.5 (3 Fn - Fnm1)
         !
         implicit none
         type(VF),intent(inout) :: AB2
         type(VF),intent(in) :: Fn,Fnm1
         call multiply(AB2,Fn,1.5_cp)
         call add_product(AB2,Fnm1,-0.5_cp)
       end subroutine

       end module
       module BC_funcs_mod
       use current_precision_mod
       use mesh_extend_mod
       use block_extend_mod
       use boundary_conditions_mod
       use boundary_conditions_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       implicit none

       private
       public :: Dirichlet_BCs
       public :: Neumann_BCs
       public :: make_periodic

       interface Dirichlet_BCs;   module procedure Dirichlet_BCs_SF;   end interface
       interface Dirichlet_BCs;   module procedure Dirichlet_BCs_VF;   end interface

       interface Neumann_BCs;     module procedure Neumann_BCs_SF;     end interface
       interface Neumann_BCs;     module procedure Neumann_BCs_VF;     end interface

       interface make_periodic;   module procedure make_periodic_SF;   end interface
       interface make_periodic;   module procedure make_periodic_VF;   end interface

       contains

       subroutine Dirichlet_BCs_SF(f,m)
         implicit none
         type(SF),intent(inout) :: f
         type(mesh),intent(in) :: m
         integer :: i
         do i=1,m%s
           call init_Dirichlet(f%BF(i)%BCs); call init(f%BF(i)%BCs,0.0_cp)
         enddo
       end subroutine

       subroutine Dirichlet_BCs_VF(f,m)
         implicit none
         type(VF),intent(inout) :: f
         type(mesh),intent(in) :: m
         integer :: i
         do i=1,m%s
           call init_Dirichlet(f%x%BF(i)%BCs); call init(f%x%BF(i)%BCs,0.0_cp)
           call init_Dirichlet(f%y%BF(i)%BCs); call init(f%y%BF(i)%BCs,0.0_cp)
           call init_Dirichlet(f%z%BF(i)%BCs); call init(f%z%BF(i)%BCs,0.0_cp)
         enddo
       end subroutine

       subroutine Neumann_BCs_SF(f,m)
         implicit none
         type(SF),intent(inout) :: f
         type(mesh),intent(in) :: m
         integer :: i
         do i=1,m%s
           call init_Neumann(f%BF(i)%BCs); call init(f%BF(i)%BCs,0.0_cp)
         enddo
       end subroutine

       subroutine Neumann_BCs_VF(f,m)
         implicit none
         type(VF),intent(inout) :: f
         type(mesh),intent(in) :: m
         integer :: i
         do i=1,m%s
           call init_Neumann(f%x%BF(i)%BCs); call init(f%x%BF(i)%BCs,0.0_cp)
           call init_Neumann(f%y%BF(i)%BCs); call init(f%y%BF(i)%BCs,0.0_cp)
           call init_Neumann(f%z%BF(i)%BCs); call init(f%z%BF(i)%BCs,0.0_cp)
         enddo
       end subroutine

       subroutine make_periodic_SF(f,m,periodic_dir)
         implicit none
         type(SF),intent(inout) :: f
         type(mesh),intent(in) :: m
         integer,dimension(3),intent(in) :: periodic_dir
         integer :: i,k
         do k=1,3
           if ((periodic_dir(k).ne.1).and.(periodic_dir(k).ne.0)) then
            stop 'Error: periodic_dir must = 1,0 in make_periodic_SF in BC_funcs.f90'
           endif
         enddo
         do i=1,m%s; do k=1,3
           if (periodic_dir(k).eq.1) call makePeriodic_SF(f%BF(i)%BCs,k)
         enddo; enddo
       end subroutine

       subroutine make_periodic_VF(f,m,periodic_dir)
         implicit none
         type(VF),intent(inout) :: f
         type(mesh),intent(in) :: m
         integer,dimension(3),intent(in) :: periodic_dir
         integer :: i,k
         do k=1,3
           if ((periodic_dir(k).ne.1).and.(periodic_dir(k).ne.0)) then
            stop 'Error: periodic_dir must = 1,0 in make_periodic_VF in BC_funcs.f90'
           endif
         enddo
         do i=1,m%s; do k=1,3
           if (periodic_dir(k).eq.1) then
            call makePeriodic_VF(f%x%BF(i)%BCs,f%y%BF(i)%BCs,f%z%BF(i)%BCs,k)
           endif
         enddo; enddo
       end subroutine

       subroutine makePeriodic_SF(f_bcs,dir)
         implicit none
         type(boundary_conditions),intent(inout) :: f_bcs
         integer,intent(in) :: dir
         select case (dir)
         case (1); call init_periodic(f_bcs,1)
                   call init_periodic(f_bcs,2)
         case (2); call init_periodic(f_bcs,3)
                   call init_periodic(f_bcs,4)
         case (3); call init_periodic(f_bcs,5)
                   call init_periodic(f_bcs,6)
         case default; stop 'Error: dir must = 1,2,3 in makePeriodic_SF in BC_funcs.f90'
         end select
       end subroutine

       subroutine makePeriodic_VF(fx_BCs,fy_BCs,fz_BCs,dir)
         implicit none
         type(boundary_conditions),intent(inout) :: fx_BCs,fy_BCs,fz_BCs
         integer,intent(in) :: dir
         select case (dir)
         case (1);call init_periodic(fx_BCs,1)
                  call init_periodic(fy_BCs,1)
                  call init_periodic(fz_BCs,1)
                  call init_periodic(fx_BCs,2)
                  call init_periodic(fy_BCs,2)
                  call init_periodic(fz_BCs,2)
         case (2);call init_periodic(fx_BCs,3)
                  call init_periodic(fy_BCs,3)
                  call init_periodic(fz_BCs,3)
                  call init_periodic(fx_BCs,4)
                  call init_periodic(fy_BCs,4)
                  call init_periodic(fz_BCs,4)
         case (3);call init_periodic(fx_BCs,5)
                  call init_periodic(fy_BCs,5)
                  call init_periodic(fz_BCs,5)
                  call init_periodic(fx_BCs,6)
                  call init_periodic(fy_BCs,6)
                  call init_periodic(fz_BCs,6)
         case default; stop 'Error: dir must = 1,2,3 in makePeriodic_VF in BC_funcs.f90'
         end select
       end subroutine

       end module
     module Mike_Ulrickson_data_mod
     use current_precision_mod
     use time_marching_params_mod
     use VF_extend_mod
     implicit none

     private
     public :: B_r_mean_normalized
     public :: B_p_mean_normalized
     public :: B_maxval
     public :: time_normalized

     integer,parameter :: n_points = 58
     real(cp),parameter :: micro_seconds_to_seconds = 10.0_cp**(-6.0_cp)
     ! real(cp) :: t_c = 0.00790207929237_cp
     real(cp) :: t_c = 0.0047_cp

     contains

     subroutine B_r_mean_normalized(B)
       implicit none
       real(cp),dimension(n_points),intent(inout) :: B
       call B_radial_mean(B); B = B/B_maxval()
     end subroutine

     subroutine B_p_mean_normalized(B)
       implicit none
       real(cp),dimension(n_points),intent(inout) :: B
       call B_poloidal_mean(B); B = B/B_maxval()
     end subroutine

     subroutine time_normalized(t)
       implicit none
       real(cp),dimension(n_points),intent(inout) :: t
       call time(t)
       t = t*micro_seconds_to_seconds/t_c
     end subroutine

     function B_maxval() result(B_max)
       implicit none
       real(cp),dimension(n_points) :: B_r,B_p
       real(cp) :: B_max
       call B_poloidal_mean(B_p)
       call B_radial_mean(B_r)
       B_max = maxval((/B_r,B_p/))
     end function

     subroutine B_poloidal_mean(B)
       implicit none
       real(cp),dimension(n_points),intent(inout) :: B
       B(1) = 1.20628735198_cp
       B(2) = 1.20626523805_cp
       B(3) = 1.20707869737_cp
       B(4) = 1.20723519238_cp
       B(5) = 1.20736376165_cp
       B(6) = 1.2074670058_cp
       B(7) = 1.20754408138_cp
       B(8) = 1.2076028386_cp
       B(9) = 1.2076045133_cp
       B(10) = 1.19906264524_cp
       B(11) = 1.18985071952_cp
       B(12) = 1.17935726652_cp
       B(13) = 1.16705135857_cp
       B(14) = 1.15640845773_cp
       B(15) = 1.14651285721_cp
       B(16) = 1.13614306957_cp
       B(17) = 1.12399623451_cp
       B(18) = 1.11301096412_cp
       B(19) = 1.09944287811_cp
       B(20) = 1.07422581796_cp
       B(21) = 1.07311875967_cp
       B(22) = 1.07258952018_cp
       B(23) = 1.0718700883_cp
       B(24) = 1.07111312563_cp
       B(25) = 1.07030253938_cp
       B(26) = 1.0692695161_cp
       B(27) = 1.06811719473_cp
       B(28) = 1.06717789214_cp
       B(29) = 1.06612563885_cp
       B(30) = 1.06515491405_cp
       B(31) = 1.06426265249_cp
       B(32) = 1.06346590308_cp
       B(33) = 1.06257444528_cp
       B(34) = 1.06163403839_cp
       B(35) = 1.06083846575_cp
       B(36) = 1.06013321546_cp
       B(37) = 1.05951893339_cp
       B(38) = 1.05891609945_cp
       B(39) = 1.05854588381_cp
       B(40) = 1.05797133085_cp
       B(41) = 1.05715785468_cp
       B(42) = 1.05456087396_cp
       B(43) = 1.0518653267_cp
       B(44) = 1.04924188454_cp
       B(45) = 1.04573744025_cp
       B(46) = 1.04377528768_cp
       B(47) = 1.04035437643_cp
       B(48) = 1.03769737041_cp
       B(49) = 1.01342337526_cp
       B(50) = 0.96027791034_cp
       B(51) = 0.903749303838_cp
       B(52) = 0.854222332346_cp
       B(53) = 0.80439838564_cp
       B(54) = 0.673229708095_cp
       B(55) = 0.503047974139_cp
       B(56) = 0.362047947922_cp
       B(57) = 0.230237554518_cp
       B(58) = 0.127946587997_cp
     end subroutine

     subroutine B_radial_mean(B)
       implicit none
       real(cp),dimension(n_points),intent(inout) :: B
       B(1) = 0.116585219499_cp
       B(2) = 0.116572322302_cp
       B(3) = 0.116736701655_cp
       B(4) = 0.11677028807_cp
       B(5) = 0.116795800294_cp
       B(6) = 0.116817120905_cp
       B(7) = 0.116833884333_cp
       B(8) = 0.11684726979_cp
       B(9) = 0.116847971432_cp
       B(10) = 0.115600851374_cp
       B(11) = 0.114294563194_cp
       B(12) = 0.112790630702_cp
       B(13) = 0.111106981748_cp
       B(14) = 0.109552630539_cp
       B(15) = 0.108160248647_cp
       B(16) = 0.106699436839_cp
       B(17) = 0.104906174502_cp
       B(18) = 0.103378249161_cp
       B(19) = 0.101465046887_cp
       B(20) = 0.0966570989539_cp
       B(21) = 0.0964572114459_cp
       B(22) = 0.0963437025154_cp
       B(23) = 0.0962067083936_cp
       B(24) = 0.0960670838805_cp
       B(25) = 0.0959205358582_cp
       B(26) = 0.0957396781373_cp
       B(27) = 0.0955433221811_cp
       B(28) = 0.095352934493_cp
       B(29) = 0.0951694209666_cp
       B(30) = 0.0950033539726_cp
       B(31) = 0.0948435984205_cp
       B(32) = 0.0947041741138_cp
       B(33) = 0.0945529594517_cp
       B(34) = 0.0943919245411_cp
       B(35) = 0.0942529815142_cp
       B(36) = 0.0941278611412_cp
       B(37) = 0.0940171375051_cp
       B(38) = 0.0939024314695_cp
       B(39) = 0.0938253818267_cp
       B(40) = 0.0937301136411_cp
       B(41) = 0.0935830965168_cp
       B(42) = 0.0932090553856_cp
       B(43) = 0.0927688818927_cp
       B(44) = 0.092369541128_cp
       B(45) = 0.0917603652518_cp
       B(46) = 0.0914503244176_cp
       B(47) = 0.09099925553_cp
       B(48) = 0.0905027020364_cp
       B(49) = 0.0867296506489_cp
       B(50) = 0.0785355000882_cp
       B(51) = 0.0698529355153_cp
       B(52) = 0.0624727982536_cp
       B(53) = 0.0550413661924_cp
       B(54) = 0.0378407725476_cp
       B(55) = 0.0224045648176_cp
       B(56) = -0.00233673927416_cp
       B(57) = 0.0300403947916_cp
       B(58) = 0.0425948541233_cp
     end subroutine

     subroutine time(t)
       implicit none
       real(cp),dimension(n_points),intent(inout) :: t
       t(1) = 0.0_cp
       t(2) = 1000.0_cp
       t(3) = 2000.0_cp
       t(4) = 3000.0_cp
       t(5) = 4000.0_cp
       t(6) = 5000.0_cp
       t(7) = 6000.0_cp
       t(8) = 7000.0_cp
       t(9) = 7100.0_cp
       t(10) = 7200.0_cp
       t(11) = 7300.0_cp
       t(12) = 7400.0_cp
       t(13) = 7500.0_cp
       t(14) = 7600.0_cp
       t(15) = 7700.0_cp
       t(16) = 7800.0_cp
       t(17) = 7900.0_cp
       t(18) = 8000.0_cp
       t(19) = 8100.0_cp
       t(20) = 8200.0_cp
       t(21) = 8300.0_cp
       t(22) = 8400.0_cp
       t(23) = 8500.0_cp
       t(24) = 8600.0_cp
       t(25) = 8700.0_cp
       t(26) = 8800.0_cp
       t(27) = 8900.0_cp
       t(28) = 9000.0_cp
       t(29) = 9100.0_cp
       t(30) = 9200.0_cp
       t(31) = 9300.0_cp
       t(32) = 9400.0_cp
       t(33) = 9500.0_cp
       t(34) = 9600.0_cp
       t(35) = 9700.0_cp
       t(36) = 9800.0_cp
       t(37) = 9900.0_cp
       t(38) = 10000.0_cp
       t(39) = 10100.0_cp
       t(40) = 10200.0_cp
       t(41) = 10300.0_cp
       t(42) = 10400.0_cp
       t(43) = 10500.0_cp
       t(44) = 10600.0_cp
       t(45) = 10700.0_cp
       t(46) = 10800.0_cp
       t(47) = 10900.0_cp
       t(48) = 11000.0_cp
       t(49) = 12000.0_cp
       t(50) = 14000.0_cp
       t(51) = 16000.0_cp
       t(52) = 18000.0_cp
       t(53) = 20000.0_cp
       t(54) = 25000.0_cp
       t(55) = 30000.0_cp
       t(56) = 35000.0_cp
       t(57) = 40000.0_cp
       t(58) = 45000.0_cp
     end subroutine

     end module
      module TF_extend_mod
      use TF_mod
      ! Tensor fields are a bit difficult to think about.. So here's
      ! a short description as to how they are constructed, used.
      !
      ! TF = [VF_x,VF_y,VF_z]
      !
      ! If TF is staggered, then realize that
      !
      ! call init_Face(TF,m)
      !
      ! Implies
      !
      ! TF = [ VF_x  , VF_y  , VF_z  ]
      !         ||      ||      ||
      !    x [(n,c,c),(n,c,c),(n,c,c)]
      !    y [(c,n,c),(c,n,c),(c,n,c)]
      !    z [(c,c,n),(c,c,n),(c,c,n)]
      !
      ! That is to say that each "component" of the TF is a
      ! staggered vector field depending on initialization.
      !
      !

        ! Rules:
        ! a = a + b => call add(a,b)
        ! a = a - b => call subtract(a,b)
        ! a = a * b => call multiply(a,b)
        ! a = a / b => call divide(a,b)
        ! a = b / a => call divide(b,a)
        ! OR
        ! c = a + b => call add(c,a,b)
        ! c = a - b => call subtract(c,a,b)
        ! c = a * b => call multiply(c,a,b)
        ! c = a / b => call divide(c,a,b)
        ! c = b / a => call divide(c,b,a)

        use IO_tools_mod
        use current_precision_mod
        use data_location_extend_mod
        use mesh_extend_mod
        use mesh_domain_extend_mod
        use SF_extend_mod
        use VF_extend_mod
        implicit none
        private

        ! Initialization / Deletion (allocate/deallocate)
        public :: TF
        public :: init,delete,export,import

        ! Grid initialization
        public :: init_CC
        public :: init_Face
        public :: init_Edge
        public :: init_Node

        public :: init_CC_Edge
        public :: init_Node_Face
        public :: init_Face_Transpose

        public :: assign_Neumann_BCs
        public :: assign_Neumann_BCs_wall_normal
        public :: multiply_Neumann_BCs

        ! Monitoring
        public :: print

        ! Operators
        public :: assign
        public :: add,add_product,subtract
        public :: multiply,divide
        public :: amax
        public :: square,square_root
        public :: cross_product
        public :: transpose

        public :: restrict
        public :: prolongate
        public :: get_DL
        public :: is_Face
        public :: is_Edge
        public :: is_CC
        public :: is_Node
        public :: is_CC_Edge
        public :: is_collocated
        ! public :: sum
        ! public :: assignX,assignY,assignZ

        interface init;                module procedure init_TF_copy_VF;           end interface
        interface init;                module procedure init_TF_copy_TF_mesh;      end interface

        interface init_CC;             module procedure init_CC_TF;                end interface
        interface init_Face;           module procedure init_Face_TF;              end interface
        interface init_Edge;           module procedure init_Edge_TF;              end interface
        interface init_Node;           module procedure init_Node_TF;              end interface

        interface init_CC;             module procedure init_CC_MD_TF;             end interface
        interface init_Face;           module procedure init_Face_MD_TF;           end interface
        interface init_Edge;           module procedure init_Edge_MD_TF;           end interface
        interface init_Node;           module procedure init_Node_MD_TF;           end interface

        interface init_Face_Transpose; module procedure init_Face_Transpose_TF;    end interface
        interface init_Face_Transpose; module procedure init_Face_Transpose_assign_TF;    end interface
        interface init_CC_Edge;        module procedure init_CC_Edge_TF;           end interface
        interface init_Node_Face;      module procedure init_Node_Face_TF;         end interface

        interface init_CC;             module procedure init_CC_assign_TF;         end interface
        interface init_Face;           module procedure init_Face_assign_TF;       end interface
        interface init_Edge;           module procedure init_Edge_assign_TF;       end interface
        interface init_Node;           module procedure init_Node_assign_TF;       end interface

        interface init_CC_Edge;module procedure init_CC_Edge_assign_TF; end interface

        interface assign_Neumann_BCs;  module procedure assign_Neumann_BCs_faces_TF;        end interface
        interface assign_Neumann_BCs_wall_normal;  module procedure assign_Neumann_BCs_wall_normal_TF;  end interface
        interface multiply_Neumann_BCs;module procedure multiply_Neumann_BCs_faces_TF; end interface

        interface assign;              module procedure assign_TF_S;               end interface
        interface assign;              module procedure assign_TF_VF;              end interface
        interface assign;              module procedure assign_TF_TF;              end interface

        interface add;                 module procedure add_TF_TF;                 end interface
        interface add;                 module procedure add_TF_TF_TF;              end interface
        interface add;                 module procedure add_TF_TF_VF;              end interface
        interface add;                 module procedure add_TF_VF;                 end interface
        interface add;                 module procedure add_VF_TF;                 end interface
        interface add;                 module procedure add_TF_S;                  end interface
        interface add;                 module procedure add_S_TF;                  end interface
        interface add;                 module procedure add_SF_TF;                 end interface
        interface add_product;         module procedure add_product_TF_TF_S;       end interface

        interface subtract;            module procedure subtract_TF_TF;            end interface
        interface subtract;            module procedure subtract_TF_VF;            end interface
        interface subtract;            module procedure subtract_TF_S;             end interface
        interface subtract;            module procedure subtract_S_TF;             end interface

        interface multiply;            module procedure multiply_TF_TF;            end interface
        interface multiply;            module procedure multiply_TF_VF;            end interface
        interface multiply;            module procedure multiply_VF_TF;            end interface
        interface multiply;            module procedure multiply_TF_S;             end interface
        interface multiply;            module procedure multiply_S_TF;             end interface

        interface divide;              module procedure divide_TF_TF;              end interface
        interface divide;              module procedure divide_TF_VF;              end interface
        interface divide;              module procedure divide_TF_S;               end interface
        interface divide;              module procedure divide_S_TF;               end interface

        interface amax;                module procedure amax_TF;                   end interface

        interface square;              module procedure square_TF;                 end interface
        interface square_root;         module procedure square_root_TF;            end interface
        interface cross_product;       module procedure cross_product_TF;          end interface

        interface restrict;            module procedure restrict_TF;               end interface
        interface restrict;            module procedure restrict_dir_TF;           end interface
        interface prolongate;          module procedure prolongate_TF;             end interface
        interface prolongate;          module procedure prolongate_dir_TF;         end interface

        interface get_DL;              module procedure get_DL_TF;                 end interface
        interface is_Face;             module procedure is_Face_VF_DL;             end interface
        interface is_Edge;             module procedure is_Edge_VF_DL;             end interface
        interface is_CC;               module procedure is_CC_VF_DL;               end interface
        interface is_Node;             module procedure is_Node_VF_DL;             end interface
        interface is_CC_Edge;          module procedure is_CC_Edge_VF_DL;          end interface
        interface is_collocated;       module procedure is_collocated_TF_DL;       end interface

        interface transpose;           module procedure transpose_TF_TF;           end interface
        interface transpose;           module procedure transpose_TF_SF;           end interface

        contains

        ! ----------------- ASSIGN ------------------

        subroutine assign_TF_TF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(TF),intent(in) :: g
          call assign(f%x,g%x); call assign(f%y,g%y); call assign(f%z,g%z)
        end subroutine

        subroutine assign_TF_VF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(VF),intent(in) :: g
          call assign(f%x,g); call assign(f%y,g); call assign(f%z,g)
        end subroutine

        subroutine assign_TF_S(f,g)
          implicit none
          type(TF),intent(inout) :: f
          real(cp),intent(in) :: g
          call assign(f%x,g); call assign(f%y,g); call assign(f%z,g)
        end subroutine

      ! ------------------- ADD ------------------------

        subroutine add_TF_TF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(TF),intent(in) :: g
          call add(f%x,g%x); call add(f%y,g%y); call add(f%z,g%z)
        end subroutine

        subroutine add_TF_TF_TF(f,g,r)
          implicit none
          type(TF),intent(inout) :: f
          type(TF),intent(in) :: g,r
          call add(f%x,g%x,r%x); call add(f%y,g%y,r%y); call add(f%z,g%z,r%z)
        end subroutine

        subroutine add_TF_TF_VF(f,g,r)
          implicit none
          type(TF),intent(inout) :: f
          type(TF),intent(in) :: g
          type(VF),intent(in) :: r
          call add(f%x,g%x,r); call add(f%y,g%y,r); call add(f%z,g%z,r)
        end subroutine

        subroutine add_TF_VF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(VF),intent(in) :: g
          call add(f%x,g); call add(f%y,g); call add(f%z,g)
        end subroutine

        subroutine add_VF_TF(g2,f)
          implicit none
          type(TF),intent(inout) :: f
          type(VF),intent(in) :: g2
          call add(f%x,g2); call add(f%y,g2); call add(f%z,g2)
        end subroutine

        subroutine add_TF_S(f,g)
          implicit none
          type(TF),intent(inout) :: f
          real(cp),intent(in) :: g
          call add(f%x,g); call add(f%y,g); call add(f%z,g)
        end subroutine

        subroutine add_S_TF(g2,f)
          implicit none
          type(TF),intent(inout) :: f
          real(cp),intent(in) :: g2
          call add(f%x,g2); call add(f%y,g2); call add(f%z,g2)
        end subroutine

        subroutine add_SF_TF(f,g)
          implicit none
          type(SF),intent(inout) :: f
          type(TF),intent(in) :: g
          call add(f,g%x%x,g%y%x,g%z%x,&
                     g%x%y,g%y%y,g%z%y,&
                     g%x%z,g%y%z,g%z%z)
        end subroutine

        subroutine add_product_TF_TF_S(f,g,c)
          implicit none
          type(TF),intent(inout) :: f
          type(TF),intent(in) :: g
          real(cp),intent(in) :: c
          call add_product(f%x,g%x,c)
          call add_product(f%y,g%y,c)
          call add_product(f%z,g%z,c)
        end subroutine

      ! ------------------- SUBTRACT ------------------------

        subroutine subtract_TF_TF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(TF),intent(in) :: g
          call subtract(f%x,g%x); call subtract(f%y,g%y); call subtract(f%z,g%z)
        end subroutine

        subroutine subtract_TF_VF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(VF),intent(in) :: g
          call subtract(f%x,g); call subtract(f%y,g); call subtract(f%z,g)
        end subroutine

        subroutine subtract_TF_S(f,g)
          implicit none
          type(TF),intent(inout) :: f
          real(cp),intent(in) :: g
          call subtract(f%x,g); call subtract(f%y,g); call subtract(f%z,g)
        end subroutine

        subroutine subtract_S_TF(g2,f)
          implicit none
          type(TF),intent(inout) :: f
          real(cp),intent(in) :: g2
          call subtract(g2,f%x); call subtract(g2,f%y); call subtract(g2,f%z)
        end subroutine

      ! ------------------- MULTIPLY ------------------------

        subroutine multiply_TF_TF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(TF),intent(in) :: g
          call multiply(f%x,g%x); call multiply(f%y,g%y); call multiply(f%z,g%z)
        end subroutine

        subroutine multiply_TF_VF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(VF),intent(in) :: g
          call multiply(f%x,g); call multiply(f%y,g); call multiply(f%z,g)
        end subroutine

        subroutine multiply_VF_TF(g2,f)
          implicit none
          type(TF),intent(inout) :: f
          type(VF),intent(in) :: g2
          call multiply(f%x,g2); call multiply(f%y,g2); call multiply(f%z,g2)
        end subroutine

        subroutine multiply_TF_S(f,g)
          implicit none
          type(TF),intent(inout) :: f
          real(cp),intent(in) :: g
          call multiply(f%x,g); call multiply(f%y,g); call multiply(f%z,g)
        end subroutine

        subroutine multiply_S_TF(g2,f)
          implicit none
          type(TF),intent(inout) :: f
          real(cp),intent(in) :: g2
          call multiply(f%x,g2); call multiply(f%y,g2); call multiply(f%z,g2)
        end subroutine

      ! ------------------- DIVIDE ------------------------

        subroutine divide_TF_TF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(TF),intent(in) :: g
          call divide(f%x,g%x); call divide(f%y,g%y); call divide(f%z,g%z)
        end subroutine

        subroutine divide_TF_VF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(VF),intent(in) :: g
          call divide(f%x,g); call divide(f%y,g); call divide(f%z,g)
        end subroutine

        subroutine divide_TF_S(f,g)
          implicit none
          type(TF),intent(inout) :: f
          real(cp),intent(in) :: g
          call divide(f%x,g); call divide(f%y,g); call divide(f%z,g)
        end subroutine

        subroutine divide_S_TF(g2,f)
          implicit none
          type(TF),intent(inout) :: f
          real(cp),intent(in) :: g2
          call divide(g2,f%x); call divide(g2,f%y); call divide(g2,f%z)
        end subroutine

      ! ------------------- OTHER ------------------------

        function amax_TF(f) result (m)
          implicit none
          type(TF),intent(in) :: f
          real(cp) :: m
          m = maxval((/amax(f%x),amax(f%y),amax(f%z)/))
        end function

        subroutine square_TF(f)
          implicit none
          type(TF),intent(inout) :: f
          call square(f%x); call square(f%y); call square(f%z)
        end subroutine

        subroutine square_root_TF(f)
          implicit none
          type(TF),intent(inout) :: f
          call square_root(f%x); call square_root(f%y); call square_root(f%z)
        end subroutine

        subroutine cross_product_TF(AcrossB,A,B)
          ! First index refers to vector direction.
          ! Second index refers to vector location.
          !      For example, in A%x%y, the direction of the vector
          !      will be in x, and it will be located on whatever
          !      location is defined by the y-component (y-face for face data
          !      or y-edge for edge data).
          ! Since this is a collocated operation, the second
          ! index should be the same (data should be collocated).
          ! NOTE: The diagonal, xx,yy,zz are not used.
          implicit none
          type(VF),intent(inout) :: AcrossB
          type(TF),intent(in) :: A,B
          call cross_product_x(AcrossB%x,A%y%x,A%z%x,B%y%x,B%z%x)
          call cross_product_y(AcrossB%y,A%x%y,A%z%y,B%x%y,B%z%y)
          call cross_product_z(AcrossB%z,A%x%z,A%y%z,B%x%z,B%y%z)
        end subroutine

        subroutine restrict_TF(A,m)
          implicit none
          type(TF),intent(inout) :: A
          type(mesh),intent(in) :: m
          call restrict(A%x,m)
          call restrict(A%y,m)
          call restrict(A%z,m)
        end subroutine

        subroutine restrict_dir_TF(A,m,dir)
          implicit none
          type(TF),intent(inout) :: A
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          call restrict(A%x,m,dir)
          call restrict(A%y,m,dir)
          call restrict(A%z,m,dir)
        end subroutine

        subroutine prolongate_TF(A,m)
          implicit none
          type(TF),intent(inout) :: A
          type(mesh),intent(in) :: m
          call prolongate(A%x,m)
          call prolongate(A%y,m)
          call prolongate(A%z,m)
        end subroutine

        subroutine prolongate_dir_TF(A,m,dir)
          implicit none
          type(TF),intent(inout) :: A
          type(mesh),intent(in) :: m
          integer,intent(in) :: dir
          call prolongate(A%x,m,dir)
          call prolongate(A%y,m,dir)
          call prolongate(A%z,m,dir)
        end subroutine

        function get_DL_TF(A) result(DL)
          implicit none
          type(TF),intent(in) :: A
          type(data_location),dimension(9) :: DL
          DL(1:3) = get_DL(A%x)
          DL(4:6) = get_DL(A%y)
          DL(7:9) = get_DL(A%z)
        end function

        function is_Face_VF_DL(f) result(L)
          implicit none
          type(TF),intent(in) :: f
          logical :: L
          L = is_Face_TF(get_DL(f))
        end function

        function is_Edge_VF_DL(f) result(L)
          implicit none
          type(TF),intent(in) :: f
          logical :: L
          L = is_Edge_TF(get_DL(f))
        end function

        function is_CC_VF_DL(f) result(L)
          implicit none
          type(TF),intent(in) :: f
          logical :: L
          L = is_CC_TF(get_DL(f))
        end function

        function is_Node_VF_DL(f) result(L)
          implicit none
          type(TF),intent(in) :: f
          logical :: L
          L = is_Node_TF(get_DL(f))
        end function

        function is_CC_Edge_VF_DL(f) result(L)
          implicit none
          type(TF),intent(in) :: f
          logical :: L
          L = is_CC_edge_TF(get_DL(f))
        end function

        function is_collocated_TF_DL(A) result(L)
          implicit none
          type(TF),intent(in) :: A
          type(data_location),dimension(9) :: DL
          logical :: L
          DL = get_DL(A)
          L = is_collocated_TF(DL)
        end function

        subroutine transpose_TF_SF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(SF),intent(inout) :: g
          call swap(f%x%y,f%y%x,g)
          call swap(f%y%x,f%x%y,g)
          call swap(f%x%z,f%z%x,g)
          call swap(f%z%x,f%x%z,g)
          call swap(f%y%z,f%z%y,g)
          call swap(f%z%y,f%y%z,g)
        end subroutine

        subroutine transpose_TF_TF(f,g)
          implicit none
          type(TF),intent(inout) :: f
          type(TF),intent(in) :: g
          call assign(f%x%x,g%x%x) ! Diagonal (remains the same)
          call assign(f%y%y,g%y%y) ! Diagonal (remains the same)
          call assign(f%z%z,g%z%z) ! Diagonal (remains the same)

          call assign(f%x%y,g%y%x) ! Off diag
          call assign(f%y%x,g%x%y) ! Off diag

          call assign(f%x%z,g%z%x) ! Off diag
          call assign(f%z%x,g%x%z) ! Off diag

          call assign(f%y%z,g%z%y) ! Off diag
          call assign(f%z%y,g%y%z) ! Off diag
        end subroutine

        ! subroutine vectorSum(f,g)
        !   implicit none
        !   type(VF),intent(inout) :: f
        !   type(TF),intent(in) :: g
        !   call sum(f%x,g%x); call sum(f%y,g%y); call sum(f%z,g%z)
        ! end subroutine

      ! ------------------- ALLOCATE / DEALLOCATE --------------------

        subroutine init_TF_copy_TF_mesh(f1,f2,m)
          implicit none
          type(TF),intent(inout) :: f1
          type(TF),intent(in) :: f2
          type(mesh),intent(in) :: m
          call init(f1%x,f2%x,m); call init(f1%y,f2%y,m); call init(f1%z,f2%z,m)
        end subroutine

        subroutine init_TF_copy_VF(f1,f2)
          implicit none
          type(TF),intent(inout) :: f1
          type(VF),intent(in) :: f2
          call init(f1%x,f2); call init(f1%y,f2); call init(f1%z,f2)
        end subroutine

        subroutine init_CC_TF(f,m)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_CC(f%x,m); call init_CC(f%y,m); call init_CC(f%z,m)
        end subroutine

        subroutine init_CC_MD_TF(f,m,MD)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(mesh_domain),intent(in) :: MD
          call init_CC(f%x,m,MD); call init_CC(f%y,m,MD); call init_CC(f%z,m,MD)
        end subroutine

        subroutine init_Edge_TF(f,m)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_Edge(f%x,m); call init_Edge(f%y,m); call init_Edge(f%z,m)
        end subroutine

        subroutine init_Edge_MD_TF(f,m,MD)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(mesh_domain),intent(in) :: MD
          call init_Edge(f%x,m,MD); call init_Edge(f%y,m,MD); call init_Edge(f%z,m,MD)
        end subroutine

        subroutine init_Node_Face_TF(f,m)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_Node(f%x%x,m)
          call init_Face(f%x%y,m,3)
          call init_Face(f%x%z,m,2)

          call init_Face(f%y%x,m,3)
          call init_Node(f%y%y,m)
          call init_Face(f%y%z,m,1)

          call init_Face(f%z%x,m,2)
          call init_Face(f%z%y,m,1)
          call init_Node(f%z%z,m)
        end subroutine

        subroutine init_Face_TF(f,m)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_Face(f%x,m); call init_Face(f%y,m); call init_Face(f%z,m)
        end subroutine

        subroutine init_Face_MD_TF(f,m,MD)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(mesh_domain),intent(in) :: MD
          call init_Face(f%x,m,MD); call init_Face(f%y,m,MD); call init_Face(f%z,m,MD)
        end subroutine

        subroutine init_Face_Transpose_TF(f,m)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_Face(f%x%x,m,1)
          call init_Face(f%x%y,m,1)
          call init_Face(f%x%z,m,1)
          call init_Face(f%y%x,m,2)
          call init_Face(f%y%y,m,2)
          call init_Face(f%y%z,m,2)
          call init_Face(f%z%x,m,3)
          call init_Face(f%z%y,m,3)
          call init_Face(f%z%z,m,3)
        end subroutine

        subroutine init_Face_Transpose_assign_TF(f,m,val)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_Face_Transpose(f,m)
          call assign(f,val)
        end subroutine

        subroutine init_CC_Edge_TF(f,m)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_CC  (f%x%x,m)
          call init_Edge(f%x%y,m,3)
          call init_Edge(f%x%z,m,2)

          call init_Edge(f%y%x,m,3)
          call init_CC  (f%y%y,m)
          call init_Edge(f%y%z,m,1)

          call init_Edge(f%z%x,m,2)
          call init_Edge(f%z%y,m,1)
          call init_CC  (f%z%z,m)
        end subroutine

        subroutine init_Node_TF(f,m)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          call init_Node(f%x,m); call init_Node(f%y,m); call init_Node(f%z,m)
        end subroutine

        subroutine init_Node_MD_TF(f,m,MD)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          type(mesh_domain),intent(in) :: MD
          call init_Node(f%x,m,MD); call init_Node(f%y,m,MD); call init_Node(f%z,m,MD)
        end subroutine

        subroutine init_CC_assign_TF(f,m,val)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_CC(f%x,m,val); call init_CC(f%y,m,val); call init_CC(f%z,m,val)
        end subroutine

        subroutine init_Edge_assign_TF(f,m,val)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_Edge(f%x,m,val); call init_Edge(f%y,m,val); call init_Edge(f%z,m,val)
        end subroutine

        subroutine init_Face_assign_TF(f,m,val)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_Face(f%x,m,val); call init_Face(f%y,m,val); call init_Face(f%z,m,val)
        end subroutine

        subroutine init_Node_assign_TF(f,m,val)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_Node(f%x,m,val); call init_Node(f%y,m,val); call init_Node(f%z,m,val)
        end subroutine

        subroutine init_CC_Edge_assign_TF(f,m,val)
          implicit none
          type(TF),intent(inout) :: f
          type(mesh),intent(in) :: m
          real(cp),intent(in) :: val
          call init_CC_Edge(f,m); call assign(f,val)
        end subroutine

        subroutine assign_Neumann_BCs_faces_TF(A,B)
          implicit none
          type(VF),intent(inout) :: A
          type(TF),intent(in) :: B
          call assign_Neumann_BCs(A%x,B%x)
          call assign_Neumann_BCs(A%y,B%y)
          call assign_Neumann_BCs(A%z,B%z)
        end subroutine

        subroutine assign_Neumann_BCs_wall_normal_TF(A,B)
          implicit none
          type(VF),intent(inout) :: A
          type(TF),intent(in) :: B
          call assign_Neumann_BCs_wall_normal(A%x,B%x)
          call assign_Neumann_BCs_wall_normal(A%y,B%y)
          call assign_Neumann_BCs_wall_normal(A%z,B%z)
        end subroutine

        subroutine multiply_Neumann_BCs_faces_TF(A,scale)
          implicit none
          type(TF),intent(inout) :: A
          real(cp),intent(in) :: scale
          call multiply_Neumann_BCs(A%x,scale)
          call multiply_Neumann_BCs(A%y,scale)
          call multiply_Neumann_BCs(A%z,scale)
        end subroutine

      end module
      module base_export_mod
      use current_precision_mod
      use mesh_extend_mod
      use data_location_extend_mod
      use SF_extend_mod
      use VF_extend_mod
      use GF_export_mod
      use exp_Tecplot_Header_mod
      implicit none

      private
      public :: exp_3D_3C ! exp_3D_3C(m,pad,un,name,U)
      public :: exp_2D_3C ! exp_2D_3C(m,pad,un,name,U,dir,plane)
      public :: exp_1D_3C ! exp_1D_3C(m,pad,un,name,U,dir,line)

      public :: exp_3D_2C ! exp_3D_2C(m,pad,un,name,U,dir)
      public :: exp_2D_2C ! exp_2D_2C(m,pad,un,name,U,dir,plane)
      public :: exp_1D_2C ! exp_1D_2C(m,pad,un,name,U,dir,line)

      public :: exp_3D_1C ! exp_3D_1C(m,pad,un,name,U)
      public :: exp_2D_1C ! exp_2D_1C(m,pad,un,name,U,dir,plane)
      public :: exp_1D_1C ! exp_1D_1C(m,pad,un,name,U,dir,line)

      public :: exp_mesh_SF ! exp_mesh_SF(m,pad,un,name)

      contains

      ! ***********************************************************************
      ! ************************* 3 COMPONENT FIELDS **************************
      ! ***********************************************************************

      subroutine exp_3D_3C(m,pad,un,name,U)
        implicit none
        type(VF),intent(in) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un
        character(len=*),intent(in) :: name
        integer :: i
        call exp_Header_3D_3C(un,name)
        do i=1,m%s
          call exp_3D_3C_GF(m%B(i)%g,U%x%DL,i,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF,U%z%BF(i)%GF)
        enddo
      end subroutine

      subroutine exp_2D_3C(m,pad,un,name,U,dir,plane)
        implicit none
        type(VF),intent(in) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir,plane
        character(len=*),intent(in) :: name
        integer :: i
        call exp_Header_2D_3C(un,dir,name)
        do i=1,m%s
        call exp_2D_3C_GF(m%B(i)%g,U%x%DL,i,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF,U%z%BF(i)%GF,dir,plane)
        enddo
      end subroutine

      subroutine exp_1D_3C(m,pad,un,name,U,dir,line)
        implicit none
        type(VF),intent(in) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir
        character(len=*),intent(in) :: name
        integer,dimension(2),intent(in) :: line
        integer :: i
        call exp_Header_1D_3C(un,dir,name)
        do i=1,m%s
        call exp_1D_3C_GF(m%B(i)%g,U%x%DL,i,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF,U%z%BF(i)%GF,dir,line)
        enddo
      end subroutine

      ! ***********************************************************************
      ! ************************* 2 COMPONENT FIELDS **************************
      ! ***********************************************************************

      subroutine exp_3D_2C(m,pad,un,name,U,dir)
        implicit none
        type(VF),intent(in) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir
        character(len=*),intent(in) :: name
        integer :: i
        call exp_Header_3D_2C(un,dir,name)
        select case (dir)
        case(1)
        do i=1,m%s;call exp_3D_2C_GF(m%B(i)%g,U%y%DL,i,pad,un,U%y%BF(i)%GF,U%z%BF(i)%GF);enddo
        case(2)
        do i=1,m%s;call exp_3D_2C_GF(m%B(i)%g,U%x%DL,i,pad,un,U%x%BF(i)%GF,U%z%BF(i)%GF);enddo
        case(3)
        do i=1,m%s;call exp_3D_2C_GF(m%B(i)%g,U%x%DL,i,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF);enddo
        case default; stop 'Error: dir must = 1:3 in exp_3D_2C in export_SF.f90'
        end select
      end subroutine

      subroutine exp_2D_2C(m,pad,un,name,U,dir,plane)
        implicit none
        type(VF),intent(in) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir,plane
        character(len=*),intent(in) :: name
        integer :: i
        call exp_Header_2D_2C(un,dir,name)
        select case (dir)
        case(1)
        do i=1,m%s
        call exp_2D_2C_GF(m%B(i)%g,U%y%DL,i,pad,un,U%y%BF(i)%GF,U%z%BF(i)%GF,dir,plane)
        enddo
        case(2)
        do i=1,m%s
        call exp_2D_2C_GF(m%B(i)%g,U%x%DL,i,pad,un,U%x%BF(i)%GF,U%z%BF(i)%GF,dir,plane)
        enddo
        case(3)
        do i=1,m%s
        call exp_2D_2C_GF(m%B(i)%g,U%x%DL,i,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF,dir,plane)
        enddo
        case default; stop 'Error: dir must = 1:3 in exp_2D_2C in export_SF.f90'
        end select
      end subroutine

      subroutine exp_1D_2C(m,pad,un,name,U,dir,line)
        implicit none
        type(VF),intent(in) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir
        character(len=*),intent(in) :: name
        integer,dimension(2),intent(in) :: line
        integer :: i
        call exp_Header_1D_2C(un,dir,name)
        select case (dir)
        case(1)
        do i=1,m%s
        call exp_1D_2C_GF(m%B(i)%g,U%y%DL,i,pad,un,U%y%BF(i)%GF,U%z%BF(i)%GF,dir,line)
        enddo
        case(2)
        do i=1,m%s
        call exp_1D_2C_GF(m%B(i)%g,U%x%DL,i,pad,un,U%x%BF(i)%GF,U%z%BF(i)%GF,dir,line)
        enddo
        case(3)
        do i=1,m%s
        call exp_1D_2C_GF(m%B(i)%g,U%x%DL,i,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF,dir,line)
        enddo
        case default; stop 'Error: dir must = 1:3 in exp_1D_2C in export_SF.f90'
        end select
      end subroutine

      ! ***********************************************************************
      ! ************************* 1 COMPONENT FIELDS **************************
      ! ***********************************************************************

      subroutine exp_3D_1C(m,pad,un,name,U)
        implicit none
        type(SF),intent(in) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un
        character(len=*),intent(in) :: name
        integer :: i
        call exp_Header_3D_1C(un,name)
        do i=1,m%s; call exp_3D_1C_GF(m%B(i)%g,U%DL,i,pad,un,U%BF(i)%GF); enddo
      end subroutine

      subroutine exp_2D_1C(m,pad,un,name,U,dir,plane)
        implicit none
        type(SF),intent(in) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir,plane
        character(len=*),intent(in) :: name
        integer :: i
        call exp_Header_2D_1C(un,dir,name)
        do i=1,m%s; call exp_2D_1C_GF(m%B(i)%g,U%DL,i,pad,un,U%BF(i)%GF,dir,plane); enddo
      end subroutine

      subroutine exp_1D_1C(m,pad,un,name,U,dir,line)
        implicit none
        type(SF),intent(in) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir
        integer,dimension(2),intent(in) :: line
        character(len=*),intent(in) :: name
        integer :: i
        call exp_Header_1D_1C(un,dir,name)
        do i=1,m%s; call exp_1D_1C_GF(m%B(i)%g,U%DL,i,pad,un,U%BF(i)%GF,dir,line); enddo
      end subroutine

      subroutine exp_mesh_SF(m,pad,un,name)
        implicit none
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un
        character(len=*),intent(in) :: name
        integer :: i
        call exp_Header_3D_1C(un,name)
        do i=1,m%s; call exp_3D_0C_GF(m%B(i)%g,DL_Node(),i,pad,un,1.0_cp); enddo
      end subroutine

      end module
      module base_import_mod
      use current_precision_mod
      use mesh_extend_mod
      use data_location_extend_mod
      use SF_extend_mod
      use VF_extend_mod
      use GF_import_mod
      use exp_Tecplot_Header_mod
      implicit none

      private
      public :: imp_3D_3C ! imp_3D_3C(m,pad,un,U)
      public :: imp_2D_3C ! imp_2D_3C(m,pad,un,U,dir,plane)
      public :: imp_1D_3C ! imp_1D_3C(m,pad,un,U,dir,line)

      public :: imp_3D_2C ! imp_3D_2C(m,pad,un,U,dir)
      public :: imp_2D_2C ! imp_2D_2C(m,pad,un,U,dir,plane)
      public :: imp_1D_2C ! imp_1D_2C(m,pad,un,U,dir,line)

      public :: imp_3D_1C ! imp_3D_1C(m,pad,un,U)
      public :: imp_2D_1C ! imp_2D_1C(m,pad,un,U,dir,plane)
      public :: imp_1D_1C ! imp_1D_1C(m,pad,un,U,dir,line)

      contains

      ! ***********************************************************************
      ! ************************* 3 COMPONENT FIELDS **************************
      ! ***********************************************************************

      subroutine imp_3D_3C(m,pad,un,U)
        implicit none
        type(VF),intent(inout) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un
        integer :: i
        read(un,*); read(un,*) ! tecplot header
        do i=1,m%s
          call imp_3D_3C_GF(m%B(i)%g,U%x%DL,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF,U%z%BF(i)%GF)
        enddo
      end subroutine

      subroutine imp_2D_3C(m,pad,un,U,dir,plane)
        implicit none
        type(VF),intent(inout) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir,plane
        integer :: i
        read(un,*); read(un,*) ! tecplot header
        do i=1,m%s
        call imp_2D_3C_GF(m%B(i)%g,U%x%DL,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF,U%z%BF(i)%GF,dir,plane)
        enddo
      end subroutine

      subroutine imp_1D_3C(m,pad,un,U,dir,line)
        implicit none
        type(VF),intent(inout) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir
        integer,dimension(2),intent(in) :: line
        integer :: i
        read(un,*); read(un,*) ! tecplot header
        do i=1,m%s
        call imp_1D_3C_GF(m%B(i)%g,U%x%DL,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF,U%z%BF(i)%GF,dir,line)
        enddo
      end subroutine

      ! ***********************************************************************
      ! ************************* 2 COMPONENT FIELDS **************************
      ! ***********************************************************************

      subroutine imp_3D_2C(m,pad,un,U,dir)
        implicit none
        type(VF),intent(inout) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir
        integer :: i
        read(un,*); read(un,*) ! tecplot header
        select case (dir)
        case(1)
        do i=1,m%s;call imp_3D_2C_GF(m%B(i)%g,U%y%DL,pad,un,U%y%BF(i)%GF,U%z%BF(i)%GF);enddo
        case(2)
        do i=1,m%s;call imp_3D_2C_GF(m%B(i)%g,U%x%DL,pad,un,U%x%BF(i)%GF,U%z%BF(i)%GF);enddo
        case(3)
        do i=1,m%s;call imp_3D_2C_GF(m%B(i)%g,U%x%DL,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF);enddo
        case default; stop 'Error: dir must = 1:3 in exp_3D_2C in export_SF.f90'
        end select
      end subroutine

      subroutine imp_2D_2C(m,pad,un,U,dir,plane)
        implicit none
        type(VF),intent(inout) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir,plane
        integer :: i
        read(un,*); read(un,*) ! tecplot header
        select case (dir)
        case(1)
        do i=1,m%s
        call imp_2D_2C_GF(m%B(i)%g,U%y%DL,pad,un,U%y%BF(i)%GF,U%z%BF(i)%GF,dir,plane)
        enddo
        case(2)
        do i=1,m%s
        call imp_2D_2C_GF(m%B(i)%g,U%x%DL,pad,un,U%x%BF(i)%GF,U%z%BF(i)%GF,dir,plane)
        enddo
        case(3)
        do i=1,m%s
        call imp_2D_2C_GF(m%B(i)%g,U%x%DL,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF,dir,plane)
        enddo
        case default; stop 'Error: dir must = 1:3 in exp_2D_2C in export_SF.f90'
        end select
      end subroutine

      subroutine imp_1D_2C(m,pad,un,U,dir,line)
        implicit none
        type(VF),intent(inout) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir
        integer,dimension(2),intent(in) :: line
        integer :: i
        read(un,*); read(un,*) ! tecplot header
        select case (dir)
        case(1)
        do i=1,m%s
        call imp_1D_2C_GF(m%B(i)%g,U%y%DL,pad,un,U%y%BF(i)%GF,U%z%BF(i)%GF,dir,line)
        enddo
        case(2)
        do i=1,m%s
        call imp_1D_2C_GF(m%B(i)%g,U%x%DL,pad,un,U%x%BF(i)%GF,U%z%BF(i)%GF,dir,line)
        enddo
        case(3)
        do i=1,m%s
        call imp_1D_2C_GF(m%B(i)%g,U%x%DL,pad,un,U%x%BF(i)%GF,U%y%BF(i)%GF,dir,line)
        enddo
        case default; stop 'Error: dir must = 1:3 in exp_1D_2C in export_SF.f90'
        end select
      end subroutine

      ! ***********************************************************************
      ! ************************* 1 COMPONENT FIELDS **************************
      ! ***********************************************************************

      subroutine imp_3D_1C(m,pad,un,U)
        implicit none
        type(SF),intent(inout) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un
        integer :: i
        read(un,*); read(un,*) ! tecplot header
        do i=1,m%s; call imp_3D_1C_GF(m%B(i)%g,U%DL,pad,un,U%BF(i)%GF); enddo
      end subroutine

      subroutine imp_2D_1C(m,pad,un,U,dir,plane)
        implicit none
        type(SF),intent(inout) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir,plane
        integer :: i
        read(un,*); read(un,*) ! tecplot header
        do i=1,m%s; call imp_2D_1C_GF(m%B(i)%g,U%DL,pad,un,U%BF(i)%GF,dir,plane); enddo
      end subroutine

      subroutine imp_1D_1C(m,pad,un,U,dir,line)
        implicit none
        type(SF),intent(inout) :: U
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,un,dir
        integer,dimension(2),intent(in) :: line
        integer :: i
        read(un,*); read(un,*) ! tecplot header
        do i=1,m%s; call imp_1D_1C_GF(m%B(i)%g,U%DL,pad,un,U%BF(i)%GF,dir,line); enddo
      end subroutine

      end module
       module check_BCs_mod
       use SF_extend_mod
       use VF_extend_mod
       implicit none

       private
       public :: check_defined

       contains

       subroutine check_defined(U)
         implicit none
         type(SF),intent(in) :: U
         integer :: i
         do i=1,U%s
         if (.not.U%BF(i)%BCs%BCL%defined) stop 'Error: bad bctype in check_BCs in check_BCs.f90'
         enddo
       end subroutine

       end module
      module index_mapping_mod
      use current_precision_mod
      use IO_tools_mod
      use mesh_extend_mod
      use SF_extend_mod
      use VF_extend_mod
      implicit none
      private

      ! Initialization / Deletion (allocate/deallocate)
      public :: get_3D_index
      public :: get_1D_index
      public :: get_val

      interface get_3D_index;        module procedure get_3D_index_SF;        end interface
      interface get_3D_index;        module procedure get_3D_index_VF;        end interface
      interface get_3D_index;        module procedure get_3D_index_m;         end interface
      interface get_1D_index;        module procedure get_1D_index_SF;        end interface

      interface get_val;             module procedure get_val_SF;             end interface
      interface get_val;             module procedure get_val_VF;             end interface

      contains

      ! ****************************************************************
      ! *************************** INDEXES ****************************
      ! ****************************************************************

      function get_1D_index_SF(i,j,k,t,U) result(index_1D)
        ! Notes:
        !     For i=1,j=1,k=1 we have
        !     m = 1 + im*(0 + 0) = 1
        !     For i=im,j=jm,k=km we have
        !     m = im + im*((jm-1) + jm*(km-1))
        !       = im + im*jm - im + im*jm*(km-1)
        !       =      im*jm      + im*jm*km-im*jm
        !       =                 + im*jm*km
        !     Which should equal
        !     m = im*jm*km
        implicit none
        type(SF),intent(in) :: U
        integer,intent(in) :: i,j,k,t
        integer :: im,jm,km
        real(cp) :: index_1D
        if (U%s.gt.1) stop 'Error: get_1D_index_SF not developed for U%s>1 in SF.f90'
        if (t.gt.1) stop 'Error: get_1D_index_SF not developed for t>1 in SF.f90'
        im = U%BF(1)%GF%s(1)
        jm = U%BF(1)%GF%s(2)
        km = U%BF(1)%GF%s(3)
        index_1D = i + im*( (j-1) + jm*(k-1) )
      end function

      subroutine get_3D_index_m(i_3D,j_3D,k_3D,t_3D,m,index_1D)
        implicit none
        integer,intent(inout) :: i_3D,j_3D,k_3D,t_3D
        type(mesh),intent(in) :: m
        integer,intent(in) :: index_1D
        integer :: im,jm,km
        if (m%s.gt.1) stop 'Error: get_3D_index_m not developed for U%s>1 in SF.f90'
        im = m%B(1)%g%c(1)%N
        jm = m%B(1)%g%c(2)%N
        km = m%B(1)%g%c(3)%N
        t_3D = 1
        k_3D = (index_1D-1)/(im*jm)+1
        j_3D = ((index_1D-1) - ((k_3D-1)*im*jm))/im+1
        i_3D = index_1D - (j_3D-1)*im - (k_3D-1)*im*jm
      end subroutine

      subroutine get_3D_index_SF(i_3D,j_3D,k_3D,t_3D,U,index_1D)
        implicit none
        integer,intent(inout) :: i_3D,j_3D,k_3D,t_3D
        type(SF),intent(in) :: U
        integer,intent(in) :: index_1D
        integer :: im,jm,km
        if (U%s.gt.1) stop 'Error: get_3D_index_SF not developed for U%s>1 in SF.f90'
        im = U%BF(1)%GF%s(1)
        jm = U%BF(1)%GF%s(2)
        km = U%BF(1)%GF%s(3)
        t_3D = 1
        k_3D = (index_1D-1)/(im*jm)+1
        j_3D = ((index_1D-1) - ((k_3D-1)*im*jm))/im+1
        i_3D = index_1D - (j_3D-1)*im - (k_3D-1)*im*jm
      end subroutine

      subroutine get_3D_index_VF(i_3D,j_3D,k_3D,t_3D,U,index_1D)
        implicit none
        integer,intent(inout) :: i_3D,j_3D,k_3D,t_3D
        type(VF),intent(in) :: U
        integer,intent(in) :: index_1D
        integer :: im,jm,km
        if (U%x%s.gt.1) stop 'Error: get_3D_index_VF not developed for U%s>1 in SF.f90'
        im = U%x%BF(1)%GF%s(1)
        jm = U%x%BF(1)%GF%s(2)
        km = U%x%BF(1)%GF%s(3)
        t_3D = 1
        k_3D = (index_1D-1)/(im*jm)+1
        j_3D = ((index_1D-1) - ((k_3D-1)*im*jm))/im+1
        i_3D = index_1D - (j_3D-1)*im - (k_3D-1)*im*jm
      end subroutine

      ! ****************************************************************
      ! **************************** VALUES ****************************
      ! ****************************************************************

      function get_val_SF(u,index_1D) result(val)
        implicit none
        type(SF),intent(in) :: u
        integer,intent(in) :: index_1D
        real(cp) :: val
        integer :: i_3D,j_3D,k_3D,t_3D
        call get_3D_index(i_3D,j_3D,k_3D,t_3D,u,index_1D); val = u%BF(t_3D)%GF%f(i_3D,j_3D,k_3D)
      end function

      function get_val_VF(u,index_1D) result(val)
        implicit none
        type(VF),intent(in) :: u
        integer,intent(in) :: index_1D
        real(cp),dimension(3) :: val
        val(1) = get_val(u%x,index_1D)
        val(2) = get_val(u%y,index_1D)
        val(3) = get_val(u%z,index_1D)
      end function

      end module
      module matrix_free_operators_interfaces_mod
      use current_precision_mod
      use mesh_mod
      use SF_mod
      use VF_mod
      use TF_mod
      use matrix_free_params_mod
      implicit none

      private
      public :: op_SF,op_SF_explicit
      public :: op_VF,op_VF_explicit

      abstract interface
      subroutine op_SF(Ax,x,k,m,MFP,tempk)
        import :: SF,TF,mesh,matrix_free_params
        implicit none
        type(SF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
      end subroutine
      end interface

      abstract interface
      subroutine op_SF_explicit(Ax,x,k,m,MFP,tempk)
        import :: SF,TF,mesh,matrix_free_params
        implicit none
        type(SF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
      end subroutine
      end interface

      abstract interface
      subroutine op_VF(Ax,x,k,m,MFP,tempk)
        import :: VF,TF,mesh,matrix_free_params
        implicit none
        type(VF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
      end subroutine
      end interface

      abstract interface
      subroutine op_VF_explicit(Ax,x,k,m,MFP,tempk)
        import :: VF,TF,mesh,matrix_free_params
        implicit none
        type(VF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
      end subroutine
      end interface

      end module
      module ops_embedExtract_mod
      ! Not all embed / extract routines are used for each method. For example,
      ! the CT method only uses embedEdge, and not embedCC or embedFace.
      !
      ! Pre-processor directives: (_PARALLELIZE_EMBEDEXTRACT_,_DEBUG_EMBEDEXTRACT_)

      use current_precision_mod
      use overlap_mod
      use data_location_extend_mod
      use face_edge_corner_indexing_mod
      use mesh_extend_mod
      use GF_embed_extract_mod
      use mesh_domain_extend_mod
      use GF_mod
      use SF_extend_mod
      use VF_extend_mod

      implicit none

      private
      public :: extract,extractCC,extractFace,extractEdge
      public :: embed,embedCC,embedFace,embedEdge

      interface extract;        module procedure extract_SF;        end interface
      interface extract;        module procedure extract_VF;        end interface
      interface extractCC;      module procedure extractCC_SF;      end interface
      interface extractCC;      module procedure extractCC_VF;      end interface
      interface extractFace;    module procedure extractFace_SF;    end interface
      interface extractFace;    module procedure extractFace_VF;    end interface
      interface extractEdge;    module procedure extractEdge_SF;    end interface
      interface extractEdge;    module procedure extractEdge_VF;    end interface

      interface embed;          module procedure embed_SF;          end interface
      interface embed;          module procedure embed_VF;          end interface
      interface embedCC;        module procedure embedCC_SF;        end interface
      interface embedCC;        module procedure embedCC_VF;        end interface
      interface embedFace;      module procedure embedFace_SF;      end interface
      interface embedFace;      module procedure embedFace_VF;      end interface
      interface embedEdge;      module procedure embedEdge_SF;      end interface
      interface embedEdge;      module procedure embedEdge_VF;      end interface

      contains

      ! *********************************************************************************
      ! ********************** CASE SPECIFIC EXTRACT ROUTINES ***************************
      ! *********************************************************************************

      subroutine extract_SF(interior,total,MD)
        implicit none
        type(SF),intent(inout) :: interior
        type(SF),intent(in) :: total
        type(mesh_domain),intent(in) :: MD
        if (is_CC(total%DL)) then;       call extractCC(interior,total,MD)
        elseif (is_Node(total%DL)) then; ! call extractNode(interior,total,MD)
        stop 'Error: N not supported in extract_SF in ops_embedExtract.f90'
        elseif (is_Face(total%DL)) then; call extractFace(interior,total,MD)
        elseif (is_Edge(total%DL)) then; call extractEdge(interior,total,MD)
        else; stop 'Error: bad data input to extract_F in embedExtract.f90'
        endif
      end subroutine
      subroutine extract_VF(interior,total,MD)
        implicit none
        type(VF),intent(inout) :: interior
        type(VF),intent(in) :: total
        type(mesh_domain),intent(in) :: MD
        call extract(interior%x,total%x,MD)
        call extract(interior%y,total%y,MD)
        call extract(interior%z,total%z,MD)
      end subroutine

      subroutine extractCC_SF(CC_i,CC_t,MD)
        implicit none
        type(SF),intent(inout) :: CC_i
        type(SF),intent(in) :: CC_t
        type(mesh_domain),intent(in) :: MD
        integer :: i
#ifdef _DEBUG_EMBEDEXTRACT_
        if (.not.is_CC(CC_i%DL)) stop 'Error: CC data not found (1) in extractCC_SF in ops_embedExtract.f90'
        if (.not.is_CC(CC_t%DL)) stop 'Error: CC data not found (2) in extractCC_SF in ops_embedExtract.f90'
#endif
        do i=1,MD%D%s
        call EX(CC_i%BF(MD%D%sd(i)%physical%g_R1_id)%GF,&
                CC_t%BF(MD%D%sd(i)%physical%g_R2_id)%GF,&
                EE_shape(CC_i,MD,i))
        enddo
      end subroutine
      subroutine extractCC_VF(CC_i,CC_t,MD)
        implicit none
        type(VF),intent(inout) :: CC_i
        type(VF),intent(in) :: CC_t
        type(mesh_domain),intent(in) :: MD
        call extractCC_SF(CC_i%x,CC_t%x,MD)
        call extractCC_SF(CC_i%y,CC_t%y,MD)
        call extractCC_SF(CC_i%z,CC_t%z,MD)
      end subroutine

      subroutine extractFace_SF(face_i,face_t,MD) ! Extracts Lorentz force from induction to momentum
        implicit none
        type(SF),intent(inout) :: face_i
        type(SF),intent(in) :: face_t
        type(mesh_domain),intent(in) :: MD
        integer :: i
#ifdef _DEBUG_EMBEDEXTRACT_
        if (.not.is_Face(face_t%DL)) stop 'Error: face data not found (1) in extractFace_SF in ops_embedExtract.f90'
        if (.not.is_Face(face_i%DL)) stop 'Error: face data not found (2) in extractFace_SF in ops_embedExtract.f90'
#endif
        do i=1,MD%D%s
        call EX(face_i%BF(MD%D%sd(i)%physical%g_R1_id)%GF,&
                face_t%BF(MD%D%sd(i)%physical%g_R2_id)%GF,&
                EE_shape(face_i,MD,i))
        enddo
      end subroutine
      subroutine extractFace_VF(face_i,face_t,MD) ! Extracts Lorentz force from induction to momentum
        implicit none
        type(VF),intent(inout) :: face_i
        type(VF),intent(in) :: face_t
        type(mesh_domain),intent(in) :: MD
        call extractFace_SF(face_i%x,face_t%x,MD)
        call extractFace_SF(face_i%y,face_t%y,MD)
        call extractFace_SF(face_i%z,face_t%z,MD)
      end subroutine

      subroutine extractEdge_SF(edge_i,edge_t,MD) ! Auxiliary (energy budget)
        implicit none
        type(SF),intent(inout) :: edge_i
        type(SF),intent(in) :: edge_t
        type(mesh_domain),intent(in) :: MD
        integer :: i
#ifdef _DEBUG_EMBEDEXTRACT_
        if (.not.is_Edge(edge_i%DL)) stop 'Error: edge data not found (1) in extractEdge_SF in ops_embedExtract.f90'
        if (.not.is_Edge(edge_t%DL)) stop 'Error: edge data not found (2) in extractEdge_SF in ops_embedExtract.f90'
#endif
        do i=1,MD%D%s
        call EX(edge_i%BF(MD%D%sd(i)%physical%g_R1_id)%GF,&
                edge_t%BF(MD%D%sd(i)%physical%g_R2_id)%GF,&
                EE_shape(edge_i,MD,i))
        enddo
      end subroutine
      subroutine extractEdge_VF(edge_i,edge_t,MD) ! Auxiliary (energy budget)
        implicit none
        type(VF),intent(inout) :: edge_i
        type(VF),intent(in) :: edge_t
        type(mesh_domain),intent(in) :: MD
        call extractEdge_SF(edge_i%x,edge_t%x,MD)
        call extractEdge_SF(edge_i%y,edge_t%y,MD)
        call extractEdge_SF(edge_i%z,edge_t%z,MD)
      end subroutine

      ! *********************************************************************************
      ! ************************ CASE SPECIFIC EMBED ROUTINES ***************************
      ! *********************************************************************************

      subroutine embed_SF(total,interior,MD)
        implicit none
        type(SF),intent(inout) :: total
        type(SF),intent(in) :: interior
        type(mesh_domain),intent(in) :: MD
              if (is_CC(total%DL)) then;  call embedCC(total,interior,MD)
        elseif (is_Node(total%DL)) then; ! call embedNode(total,interior,MD)
        stop 'Error: N not supported in embed_SF in ops_embedExtract.f90'
        elseif (is_Face(total%DL)) then; call embedFace(total,interior,MD)
        elseif (is_Edge(total%DL)) then; call embedEdge(total,interior,MD)
        else; stop 'Error: bad data input to extract_F in embedExtract.f90'
        endif
      end subroutine
      subroutine embed_VF(total,interior,MD)
        implicit none
        type(VF),intent(inout) :: total
        type(VF),intent(in) :: interior
        type(mesh_domain),intent(in) :: MD
        call embed(total%x,interior%x,MD)
        call embed(total%y,interior%y,MD)
        call embed(total%z,interior%z,MD)
      end subroutine

      subroutine embedCC_SF(CC_t,CC_i,MD) ! For material properties
        implicit none
        type(SF),intent(inout) :: CC_t
        type(SF),intent(in) :: CC_i
        type(mesh_domain),intent(in) :: MD
        integer :: i
#ifdef _DEBUG_EMBEDEXTRACT_
        if (.not.is_CC(CC_i%DL)) stop 'Error: CC data not found (1) in embedCC_SF in ops_embedExtract.f90'
        if (.not.is_CC(CC_t%DL)) stop 'Error: CC data not found (2) in embedCC_SF in ops_embedExtract.f90'
#endif
        do i=1,MD%D%s
        call EM(CC_t%BF(MD%D%sd(i)%physical%g_R2_id)%GF,&
                CC_i%BF(MD%D%sd(i)%physical%g_R1_id)%GF,&
                EE_shape(CC_t,MD,i))
        enddo
      end subroutine
      subroutine embedCC_VF(CC_t,CC_i,MD)
        implicit none
        type(VF),intent(inout) :: CC_t
        type(VF),intent(in) :: CC_i
        type(mesh_domain),intent(in) :: MD
        call embedCC_SF(CC_t%x,CC_i%x,MD)
        call embedCC_SF(CC_t%y,CC_i%y,MD)
        call embedCC_SF(CC_t%z,CC_i%z,MD)
      end subroutine

      subroutine embedFace_SF(Face_t,Face_i,MD)
        implicit none
        type(SF),intent(inout) :: Face_t
        type(SF),intent(in) :: Face_i
        type(mesh_domain),intent(in) :: MD
        integer :: i
#ifdef _DEBUG_EMBEDEXTRACT_
        if (.not.is_Face(Face_i%DL)) stop 'Error: Face data not found (1) in embedFace_SF in ops_embedExtract.f90'
        if (.not.is_Face(Face_t%DL)) stop 'Error: Face data not found (2) in embedFace_SF in ops_embedExtract.f90'
#endif
        do i=1,MD%D%s
        call EM(Face_t%BF(MD%D%sd(i)%physical%g_R2_id)%GF,&
                Face_i%BF(MD%D%sd(i)%physical%g_R1_id)%GF,&
                EE_shape(Face_t,MD,i))
        enddo
      end subroutine
      subroutine embedFace_VF(Face_t,Face_i,MD)
        implicit none
        type(VF),intent(inout) :: Face_t
        type(VF),intent(in) :: Face_i
        type(mesh_domain),intent(in) :: MD
        call embedFace_SF(face_t%x,face_i%x,MD)
        call embedFace_SF(face_t%y,face_i%y,MD)
        call embedFace_SF(face_t%z,face_i%z,MD)
      end subroutine

      subroutine embedEdge_SF(Edge_t,Edge_i,MD) ! Embeds velocity from momentum into induction
        implicit none
        type(SF),intent(inout) :: Edge_t
        type(SF),intent(in) :: Edge_i
        type(mesh_domain),intent(in) :: MD
        integer :: i
#ifdef _DEBUG_EMBEDEXTRACT_
        if (.not.is_Edge(edge_t%DL)) stop 'Error: edge data not found (1) in embedEdge_SF in ops_embedExtract.f90'
        if (.not.is_Edge(edge_i%DL)) stop 'Error: edge data not found (2) in embedEdge_SF in ops_embedExtract.f90'
#endif
        do i=1,MD%D%s
        call EM(Edge_t%BF(MD%D%sd(i)%physical%g_R2_id)%GF,&
                Edge_i%BF(MD%D%sd(i)%physical%g_R1_id)%GF,&
                EE_shape(Edge_t,MD,i))
        enddo
      end subroutine
      subroutine embedEdge_VF(Edge_t,Edge_i,MD) ! Embeds velocity from momentum into induction
        implicit none
        type(VF),intent(inout) :: Edge_t
        type(VF),intent(in) :: Edge_i
        type(mesh_domain),intent(in) :: MD
        call embedEdge_SF(Edge_t%x,Edge_i%x,MD)
        call embedEdge_SF(Edge_t%y,Edge_i%y,MD)
        call embedEdge_SF(Edge_t%z,Edge_i%z,MD)
      end subroutine

      ! *********************************************************************************
      ! ****************************** INDEX DETAILS ************************************
      ! *********************************************************************************

       ! type mesh_domain
       !   type(physical_domain) :: D
       !   type(mesh) :: m_R1,m_R2
       ! end type
       ! type physical_domain
       !   integer :: s ! Number of physical_sub_domains
       !   type(physical_sub_domain),dimension(:),allocatable :: sd
       !   logical :: defined = .false.
       ! end type
       ! type physical_sub_domain
       !   type(sub_domain) :: total
       !   type(sub_domain) :: physical
       !   logical :: defined = .false.
       ! end type
       ! type sub_domain
       !   type(overlap),dimension(3) :: C ! cell center
       !   type(overlap),dimension(3) :: N ! node
       !   type(overlap),dimension(3) :: M ! mixed
       !   logical :: defined = .false.
       !   integer :: g_R1_id = 0
       !   integer :: g_R2_id = 0
       ! end type

      function EE_shape(f,MD,i) result(s)
        ! mesh_domain doesn't use mixed for versatility
        implicit none
        type(SF),intent(in) :: f
        type(mesh_domain),intent(in) :: MD
        integer,intent(in) :: i
        type(overlap),dimension(3) :: s
        if (is_Face(f%DL)) then
          select case(get_Face(f%DL))
          case (1); call init(s(1),MD%D%sd(i)%physical%N(1))
                    call init(s(2),MD%D%sd(i)%physical%C(2))
                    call init(s(3),MD%D%sd(i)%physical%C(3))
          case (2); call init(s(1),MD%D%sd(i)%physical%C(1))
                    call init(s(2),MD%D%sd(i)%physical%N(2))
                    call init(s(3),MD%D%sd(i)%physical%C(3))
          case (3); call init(s(1),MD%D%sd(i)%physical%C(1))
                    call init(s(2),MD%D%sd(i)%physical%C(2))
                    call init(s(3),MD%D%sd(i)%physical%N(3))
          case default; stop 'Error: bad DL face in ops_embedExtract.f90'
          end select
        elseif (is_Edge(f%DL)) then
          select case(get_Edge(f%DL))
          case (1); call init(s(1),MD%D%sd(i)%physical%C(1))
                    call init(s(2),MD%D%sd(i)%physical%N(2))
                    call init(s(3),MD%D%sd(i)%physical%N(3))
          case (2); call init(s(1),MD%D%sd(i)%physical%N(1))
                    call init(s(2),MD%D%sd(i)%physical%C(2))
                    call init(s(3),MD%D%sd(i)%physical%N(3))
          case (3); call init(s(1),MD%D%sd(i)%physical%N(1))
                    call init(s(2),MD%D%sd(i)%physical%N(2))
                    call init(s(3),MD%D%sd(i)%physical%C(3))
          case default; stop 'Error: bad DL edge in ops_embedExtract.f90'
          end select
        elseif (is_CC(f%DL)) then
          call init(s(1),MD%D%sd(i)%physical%C(1))
          call init(s(2),MD%D%sd(i)%physical%C(2))
          call init(s(3),MD%D%sd(i)%physical%C(3))
        elseif (is_Node(f%DL)) then
          call init(s(1),MD%D%sd(i)%physical%N(1))
          call init(s(2),MD%D%sd(i)%physical%N(2))
          call init(s(3),MD%D%sd(i)%physical%N(3))
        else; stop 'Error: no type found in ops_embedExtract.f90'
        endif
      end function

      end module
       module ops_mirror_field_mod
       use current_precision_mod
       use mesh_extend_mod
       use face_edge_corner_indexing_mod
       use mirror_props_mod
       use SF_extend_mod
       use VF_extend_mod

       implicit none
       private
       public :: mirror_field
       interface mirror_field;      module procedure mirror_field_SF;      end interface
       interface mirror_field;      module procedure mirror_field_VF;      end interface

       public :: anti_mirror_field
       interface anti_mirror_field; module procedure anti_mirror_field_VF; end interface

       public :: mirror_mesh
       interface mirror_mesh;       module procedure mirror_mesh_MF;       end interface

       contains

       subroutine mirror_mesh_MF(m_mirror,m,MP)
         implicit none
         type(mesh),intent(inout) :: m_mirror
         type(mesh),intent(in) :: m
         type(mirror_props),intent(in) :: MP
         integer :: d
         call init(m_mirror,m)
         d = dir_given_face(MP%mirror_face)
         if (min_face(MP%mirror_face)) call mirror_about_hmin(m_mirror,d)
         if (max_face(MP%mirror_face)) call mirror_about_hmax(m_mirror,d)
         call init_props(m_mirror)
         call patch(m_mirror)
       end subroutine

       subroutine mirror_field_SF(m_mirror,x_mirror,m,x,MP)
         implicit none
         type(mesh),intent(inout) :: m_mirror
         type(SF),intent(inout) :: x_mirror
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         type(mirror_props),intent(in) :: MP
         integer :: d
         call mirror_mesh(m_mirror,m,MP)
         call init(x_mirror,x)
         call assign(x_mirror,x)
         d = dir_given_face(MP%mirror_face)
         if (min_face(MP%mirror_face)) call mirror_about_hmin(x_mirror,d,1.0_cp)
         if (max_face(MP%mirror_face)) call mirror_about_hmax(x_mirror,d,1.0_cp)
       end subroutine

       subroutine mirror_field_VF(m_mirror,x_mirror,m,x,MP)
         implicit none
         type(mesh),intent(inout) :: m_mirror
         type(VF),intent(inout) :: x_mirror
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         type(mirror_props),intent(in) :: MP
         integer :: d
         call mirror_mesh(m_mirror,m,MP)
         call init(x_mirror,x)
         call assign(x_mirror,x)
         d = dir_given_face(MP%mirror_face)
         if (min_face(MP%mirror_face)) then
          call mirror_about_hmin(x_mirror%x,d,MP%mirror_sign(1))
          call mirror_about_hmin(x_mirror%y,d,MP%mirror_sign(2))
          call mirror_about_hmin(x_mirror%z,d,MP%mirror_sign(3))
         endif
         if (max_face(MP%mirror_face)) then
          call mirror_about_hmax(x_mirror%x,d,MP%mirror_sign(1))
          call mirror_about_hmax(x_mirror%y,d,MP%mirror_sign(2))
          call mirror_about_hmax(x_mirror%z,d,MP%mirror_sign(3))
         endif
       end subroutine

       subroutine anti_mirror_field_VF(m_mirror,x_mirror,m,x,MP)
         implicit none
         type(mesh),intent(inout) :: m_mirror
         type(VF),intent(inout) :: x_mirror
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         type(mirror_props),intent(in) :: MP
         integer :: d
         call mirror_mesh(m_mirror,m,MP)
         call init(x_mirror,x)
         call assign(x_mirror,x)
         d = dir_given_face(MP%mirror_face)
         if (min_face(MP%mirror_face)) then
          call mirror_about_hmin(x_mirror%x,d,MP%mirror_sign_a(1))
          call mirror_about_hmin(x_mirror%y,d,MP%mirror_sign_a(2))
          call mirror_about_hmin(x_mirror%z,d,MP%mirror_sign_a(3))
         endif
         if (max_face(MP%mirror_face)) then
          call mirror_about_hmax(x_mirror%x,d,MP%mirror_sign_a(1))
          call mirror_about_hmax(x_mirror%y,d,MP%mirror_sign_a(2))
          call mirror_about_hmax(x_mirror%z,d,MP%mirror_sign_a(3))
         endif
       end subroutine

       end module
      module preconditioner_interfaces_mod
      use current_precision_mod
      use mesh_mod
      use SF_mod
      use VF_mod
      use TF_mod
      implicit none

      private
      public :: preconditioner_SF
      public :: preconditioner_VF

      abstract interface
      subroutine preconditioner_SF(Minv,m,sig,c,temp_Minv)
        import mesh,SF,TF,cp
        implicit none
        type(SF),intent(inout) :: Minv,temp_Minv
        type(mesh),intent(in) :: m
        type(TF),intent(in) :: sig
        real(cp),intent(in) :: c
      end subroutine
      end interface

      abstract interface
      subroutine preconditioner_VF(Minv,m,sig,c,temp_Minv)
        import mesh,VF,TF,cp
        implicit none
        type(VF),intent(inout) :: Minv,temp_Minv
        type(mesh),intent(in) :: m
        type(TF),intent(in) :: sig
        real(cp),intent(in) :: c
      end subroutine
      end interface

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module time_statistics_VF_mod
       use probe_mod
       use time_statistics_params_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use VF_mod
       use TF_mod
       use string_mod
       use dir_manip_mod
       implicit none

       private
       public :: time_statistics_VF
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_time_statistics_VF;              end interface
       interface delete;                 module procedure delete_time_statistics_VF;                 end interface
       interface display;                module procedure display_time_statistics_VF;                end interface
       interface display_short;          module procedure display_short_time_statistics_VF;          end interface
       interface display;                module procedure display_wrap_time_statistics_VF;           end interface
       interface print;                  module procedure print_time_statistics_VF;                  end interface
       interface print_short;            module procedure print_short_time_statistics_VF;            end interface
       interface export;                 module procedure export_time_statistics_VF;                 end interface
       interface export_primitives;      module procedure export_primitives_time_statistics_VF;      end interface
       interface import;                 module procedure import_time_statistics_VF;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_time_statistics_VF;end interface
       interface export_structured;      module procedure export_structured_D_time_statistics_VF;    end interface
       interface import_structured;      module procedure import_structured_D_time_statistics_VF;    end interface
       interface import_primitives;      module procedure import_primitives_time_statistics_VF;      end interface
       interface export;                 module procedure export_wrap_time_statistics_VF;            end interface
       interface import;                 module procedure import_wrap_time_statistics_VF;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_time_statistics_VF;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_time_statistics_VF;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_time_statistics_VF;      end interface
       interface export;                 module procedure export_DN_time_statistics_VF;              end interface
       interface import;                 module procedure import_DN_time_statistics_VF;              end interface
       interface export_structured;      module procedure export_structured_DN_time_statistics_VF;   end interface
       interface import_structured;      module procedure import_structured_DN_time_statistics_VF;   end interface

       type time_statistics_VF
         type(string) :: dir
         type(string) :: name
         type(VF) :: U_sum
         type(VF) :: U_ave
         type(probe) :: mean_energy
         type(VF) :: RMS
         type(TF) :: stresses
         type(TF) :: stresses_sum
         type(probe) :: L2_stresses
         type(time_statistics_params) :: TSP
       end type

       contains

       subroutine init_copy_time_statistics_VF(this,that)
         implicit none
         type(time_statistics_VF),intent(inout) :: this
         type(time_statistics_VF),intent(in) :: that
         call delete(this)
         call init(this%dir,that%dir)
         call init(this%name,that%name)
         call init(this%U_sum,that%U_sum)
         call init(this%U_ave,that%U_ave)
         call init(this%mean_energy,that%mean_energy)
         call init(this%RMS,that%RMS)
         call init(this%stresses,that%stresses)
         call init(this%stresses_sum,that%stresses_sum)
         call init(this%L2_stresses,that%L2_stresses)
         call init(this%TSP,that%TSP)
       end subroutine

       subroutine delete_time_statistics_VF(this)
         implicit none
         type(time_statistics_VF),intent(inout) :: this
         call delete(this%dir)
         call delete(this%name)
         call delete(this%U_sum)
         call delete(this%U_ave)
         call delete(this%mean_energy)
         call delete(this%RMS)
         call delete(this%stresses)
         call delete(this%stresses_sum)
         call delete(this%L2_stresses)
         call delete(this%TSP)
       end subroutine

       subroutine display_time_statistics_VF(this,un)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         integer,intent(in) :: un
         call display(this%dir,un)
         call display(this%name,un)
         call display(this%U_sum,un)
         call display(this%U_ave,un)
         call display(this%mean_energy,un)
         call display(this%RMS,un)
         call display(this%stresses,un)
         call display(this%stresses_sum,un)
         call display(this%L2_stresses,un)
         call display(this%TSP,un)
       end subroutine

       subroutine display_short_time_statistics_VF(this,un)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         integer,intent(in) :: un
         call display(this%dir,un)
         call display(this%name,un)
         call display(this%U_sum,un)
         call display(this%U_ave,un)
         call display(this%mean_energy,un)
         call display(this%RMS,un)
         call display(this%stresses,un)
         call display(this%stresses_sum,un)
         call display(this%L2_stresses,un)
         call display(this%TSP,un)
       end subroutine

       subroutine display_wrap_time_statistics_VF(this,dir,name)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_time_statistics_VF(this)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_time_statistics_VF(this)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_time_statistics_VF(this,un)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         integer,intent(in) :: un
         call export(this%dir,un)
         call export(this%name,un)
         call export(this%U_sum,un)
         call export(this%U_ave,un)
         call export(this%mean_energy,un)
         call export(this%RMS,un)
         call export(this%stresses,un)
         call export(this%stresses_sum,un)
         call export(this%L2_stresses,un)
         call export(this%TSP,un)
       end subroutine

       subroutine import_time_statistics_VF(this,un)
         implicit none
         type(time_statistics_VF),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%dir,un)
         call import(this%name,un)
         call import(this%U_sum,un)
         call import(this%U_ave,un)
         call import(this%mean_energy,un)
         call import(this%RMS,un)
         call import(this%stresses,un)
         call import(this%stresses_sum,un)
         call import(this%L2_stresses,un)
         call import(this%TSP,un)
       end subroutine

       subroutine export_primitives_time_statistics_VF(this,un)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_time_statistics_VF(this,un)
         implicit none
         type(time_statistics_VF),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_time_statistics_VF(this,dir,name)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_time_statistics_VF(this,dir,name)
         implicit none
         type(time_statistics_VF),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_time_statistics_VF(this)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_time_statistics_VF(this)
         implicit none
         type(time_statistics_VF),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_time_statistics_VF(this)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         call export_structured(this%U_sum,&
         str(this%dir)//'U_sum'//fortran_PS)
         call export_structured(this%U_ave,&
         str(this%dir)//'U_ave'//fortran_PS)
         call export_structured(this%mean_energy,&
         str(this%dir)//'mean_energy'//fortran_PS)
         call export_structured(this%RMS,str(this%dir)//'RMS'//fortran_PS)
         call export_structured(this%L2_stresses,&
         str(this%dir)//'L2_stresses'//fortran_PS)
         call export_structured(this%TSP,str(this%dir)//'TSP'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_time_statistics_VF(this)
         implicit none
         type(time_statistics_VF),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         call import_structured(this%U_sum,&
         str(this%dir)//'U_sum'//fortran_PS)
         call import_structured(this%U_ave,&
         str(this%dir)//'U_ave'//fortran_PS)
         call import_structured(this%mean_energy,&
         str(this%dir)//'mean_energy'//fortran_PS)
         call import_structured(this%RMS,str(this%dir)//'RMS'//fortran_PS)
         call import_structured(this%L2_stresses,&
         str(this%dir)//'L2_stresses'//fortran_PS)
         call import_structured(this%TSP,str(this%dir)//'TSP'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_time_statistics_VF(this,dir)
         implicit none
         type(time_statistics_VF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
         call set_IO_dir(this%U_sum,dir//'U_sum'//fortran_PS)
         call set_IO_dir(this%U_ave,dir//'U_ave'//fortran_PS)
         call set_IO_dir(this%mean_energy,dir//'mean_energy'//fortran_PS)
         call set_IO_dir(this%RMS,dir//'RMS'//fortran_PS)
         call set_IO_dir(this%L2_stresses,dir//'L2_stresses'//fortran_PS)
         call set_IO_dir(this%TSP,dir//'TSP'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_time_statistics_VF(this,dir)
         implicit none
         type(time_statistics_VF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
         if (get_necessary_for_restart(this%U_sum)) then
           call make_IO_dir(this%U_sum,dir//'U_sum'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_ave)) then
           call make_IO_dir(this%U_ave,dir//'U_ave'//fortran_PS)
         endif
         call make_IO_dir(this%mean_energy,dir//'mean_energy'//fortran_PS)
         if (get_necessary_for_restart(this%RMS)) then
           call make_IO_dir(this%RMS,dir//'RMS'//fortran_PS)
         endif
         call make_IO_dir(this%L2_stresses,dir//'L2_stresses'//fortran_PS)
         call make_IO_dir(this%TSP,dir//'TSP'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_time_statistics_VF(this,dir)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         if (get_necessary_for_restart(this%U_sum)) then
           call export_structured(this%U_sum,dir//'U_sum'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_ave)) then
           call export_structured(this%U_ave,dir//'U_ave'//fortran_PS)
         endif
         call export_structured(this%mean_energy,&
         dir//'mean_energy'//fortran_PS)
         if (get_necessary_for_restart(this%RMS)) then
           call export_structured(this%RMS,dir//'RMS'//fortran_PS)
         endif
         call export_structured(this%L2_stresses,&
         dir//'L2_stresses'//fortran_PS)
         call export_structured(this%TSP,dir//'TSP'//fortran_PS)
       end subroutine

       subroutine export_structured_D_time_statistics_VF(this,dir)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         if (get_necessary_for_restart(this%U_sum)) then
           call export_structured(this%U_sum,dir//'U_sum'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_ave)) then
           call export_structured(this%U_ave,dir//'U_ave'//fortran_PS)
         endif
         call export_structured(this%mean_energy,&
         dir//'mean_energy'//fortran_PS)
         if (get_necessary_for_restart(this%RMS)) then
           call export_structured(this%RMS,dir//'RMS'//fortran_PS)
         endif
         call export_structured(this%L2_stresses,&
         dir//'L2_stresses'//fortran_PS)
         call export_structured(this%TSP,dir//'TSP'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_time_statistics_VF(this,dir)
         implicit none
         type(time_statistics_VF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         if (get_necessary_for_restart(this%U_sum)) then
           call import_structured(this%U_sum,dir//'U_sum'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_ave)) then
           call import_structured(this%U_ave,dir//'U_ave'//fortran_PS)
         endif
         call import_structured(this%mean_energy,&
         dir//'mean_energy'//fortran_PS)
         if (get_necessary_for_restart(this%RMS)) then
           call import_structured(this%RMS,dir//'RMS'//fortran_PS)
         endif
         call import_structured(this%L2_stresses,&
         dir//'L2_stresses'//fortran_PS)
         call import_structured(this%TSP,dir//'TSP'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_time_statistics_VF(this)
         implicit none
         type(time_statistics_VF),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
      module IO_export_mod
      use current_precision_mod
      use mesh_extend_mod
      use string_mod
      use data_location_extend_mod
      use SF_extend_mod
      use VF_extend_mod
      use base_export_mod
      use IO_tools_mod
      use time_marching_params_mod
      use face_edge_corner_indexing_mod
      use datatype_conversion_mod
      use construct_suffix_mod
      implicit none

      private

      interface export_3D_3C;   module procedure export_3D_3C_steady;     end interface
      interface export_3D_3C;   module procedure export_3D_3C_unsteady;   end interface
      public :: export_3D_3C ! call export_3D_3C(m,U,dir,name,pad,TMP)
                             ! call export_3D_3C(m,U,dir,name,pad)

      interface export_2D_3C;   module procedure export_2D_3C_steady;     end interface
      interface export_2D_3C;   module procedure export_2D_3C_unsteady;   end interface
      public :: export_2D_3C ! call export_2D_3C(m,U,dir,name,pad,direction,plane,TMP)
                             ! call export_2D_3C(m,U,dir,name,pad,direction,plane)

      interface export_1D_3C;   module procedure export_1D_3C_steady;     end interface
      interface export_1D_3C;   module procedure export_1D_3C_unsteady;   end interface
      public :: export_1D_3C ! call export_1D_3C(m,U,dir,name,pad,direction,line,TMP)
                             ! call export_1D_3C(m,U,dir,name,pad,direction,line)


      interface export_3D_2C;   module procedure export_3D_2C_steady;     end interface
      interface export_3D_2C;   module procedure export_3D_2C_unsteady;   end interface
      public :: export_3D_2C ! call export_3D_2C(m,U,dir,name,pad,TMP,direction)
                             ! call export_3D_2C(m,U,dir,name,pad,direction)

      interface export_2D_2C;   module procedure export_2D_2C_steady;     end interface
      interface export_2D_2C;   module procedure export_2D_2C_unsteady;   end interface
      public :: export_2D_2C ! call export_2D_2C(m,U,dir,name,pad,TMP,direction,plane)
                             ! call export_2D_2C(m,U,dir,name,pad,direction,plane)

      interface export_1D_2C;   module procedure export_1D_2C_steady;     end interface
      interface export_1D_2C;   module procedure export_1D_2C_unsteady;   end interface
      public :: export_1D_2C ! call export_1D_2C(m,U,dir,name,pad,TMP,direction,line)
                             ! call export_1D_2C(m,U,dir,name,pad,direction,line)


      interface export_3D_1C;   module procedure export_3D_1C_steady;     end interface
      interface export_3D_1C;   module procedure export_3D_1C_unsteady;   end interface
      public :: export_3D_1C ! call export_3D_1C(m,U,dir,name,pad,TMP)
                             ! call export_3D_1C(m,U,dir,name,pad)

      interface export_2D_1C;   module procedure export_2D_1C_steady;     end interface
      interface export_2D_1C;   module procedure export_2D_1C_unsteady;   end interface
      public :: export_2D_1C ! call export_2D_1C(m,U,dir,name,pad,TMP,direction,plane)
                             ! call export_2D_1C(m,U,dir,name,pad,direction,plane)

      interface export_1D_1C;   module procedure export_1D_1C_steady;     end interface
      interface export_1D_1C;   module procedure export_1D_1C_unsteady;   end interface
      public :: export_1D_1C ! call export_1D_1C(m,U,dir,name,pad,TMP,direction,line)
                             ! call export_1D_1C(m,U,dir,name,pad,direction,line)

      public :: export_mesh

      contains

      ! **********************************************************************
      ! **************************** 3 COMPONENTS ****************************
      ! **********************************************************************

      subroutine export_3D_3C_steady(m,U,dir,name,pad)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad
        type(VF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s))
        call exp_3D_3C(m,pad,un,str(s),U)
        call close_and_message(un,dir,str(s))
        call delete(s)
      end subroutine
      subroutine export_3D_3C_unsteady(m,U,dir,name,pad,TMP)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad
        type(VF),intent(in) :: U
        type(time_marching_params),intent(in) :: TMP
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s)//'_t='//str(cp2str(TMP%t)))
        call exp_3D_3C(m,pad,un,str(s),U)
        call close_and_message(un,dir,str(s)//'_t='//str(cp2str(TMP%t)))
        call delete(s)
      end subroutine

      subroutine export_2D_3C_steady(m,U,dir,name,pad,direction,plane)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction,plane
        type(VF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s))
        call exp_2D_3C(m,pad,un,str(s),U,direction,plane)
        call close_and_message(un,dir,str(s))
        call delete(s)
      end subroutine
      subroutine export_2D_3C_unsteady(m,U,dir,name,pad,TMP,direction,plane)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction,plane
        type(time_marching_params),intent(in) :: TMP
        type(VF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s)//'_plane_t='//str(cp2str(TMP%t)))
        call exp_2D_3C(m,pad,un,str(s),U,direction,plane)
        call close_and_message(un,dir,str(s)//'_plane_t='//str(cp2str(TMP%t)))
        call delete(s)
      end subroutine

      subroutine export_1D_3C_steady(m,U,dir,name,pad,direction,line)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction
        type(VF),intent(in) :: U
        integer,dimension(2),intent(in) :: line
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s))
        call exp_1D_3C(m,pad,un,str(s),U,direction,line)
        call close_and_message(un,dir,str(s))
        call delete(s)
      end subroutine
      subroutine export_1D_3C_unsteady(m,U,dir,name,pad,TMP,direction,line)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction
        type(time_marching_params),intent(in) :: TMP
        type(VF),intent(in) :: U
        integer,dimension(2),intent(in) :: line
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s)//'_line_t='//str(cp2str(TMP%t)))
        call exp_1D_3C(m,pad,un,str(s),U,direction,line)
        call close_and_message(un,dir,str(s)//'_line_t='//str(cp2str(TMP%t)))
        call delete(s)
      end subroutine

      ! **********************************************************************
      ! **************************** 2 COMPONENTS ****************************
      ! **********************************************************************

      subroutine export_3D_2C_steady(m,U,dir,name,pad,direction)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction
        type(VF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s))
        call exp_3D_2C(m,pad,un,str(s),U,direction)
        call close_and_message(un,dir,str(s))
        call delete(s)
      end subroutine
      subroutine export_3D_2C_unsteady(m,U,dir,name,pad,TMP,direction)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction
        type(time_marching_params),intent(in) :: TMP
        type(VF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s)//'_t='//str(cp2str(TMP%t)))
        call exp_3D_2C(m,pad,un,str(s),U,direction)
        call close_and_message(un,dir,str(s)//'_t='//str(cp2str(TMP%t)))
        call delete(s)
      end subroutine

      subroutine export_2D_2C_steady(m,U,dir,name,pad,direction,plane)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction,plane
        type(VF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s))
        call exp_2D_2C(m,pad,un,str(s),U,direction,plane)
        call close_and_message(un,dir,str(s))
        call delete(s)
      end subroutine
      subroutine export_2D_2C_unsteady(m,U,dir,name,pad,TMP,direction,plane)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction,plane
        type(time_marching_params),intent(in) :: TMP
        type(VF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s)//'_plane_t='//str(cp2str(TMP%t)))
        call exp_2D_2C(m,pad,un,str(s),U,direction,plane)
        call close_and_message(un,dir,str(s)//'_plane_t='//str(cp2str(TMP%t)))
        call delete(s)
      end subroutine

      subroutine export_1D_2C_steady(m,U,dir,name,pad,direction,line)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,dimension(2),intent(in) :: line
        integer,intent(in) :: pad,direction
        type(VF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s))
        call exp_1D_2C(m,pad,un,str(s),U,direction,line)
        call close_and_message(un,dir,str(s))
        call delete(s)
      end subroutine
      subroutine export_1D_2C_unsteady(m,U,dir,name,pad,TMP,direction,line)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction
        integer,dimension(2),intent(in) :: line
        type(time_marching_params),intent(in) :: TMP
        type(VF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s)//'_line_t='//str(cp2str(TMP%t)))
        call exp_1D_2C(m,pad,un,str(s),U,direction,line)
        call close_and_message(un,dir,str(s)//'_line_t='//str(cp2str(TMP%t)))
        call delete(s)
      end subroutine

      ! **********************************************************************
      ! **************************** 1 COMPONENTS ****************************
      ! **********************************************************************

      subroutine export_3D_1C_steady(m,U,dir,name,pad)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad
        type(SF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,U%DL)
        un = new_and_open(dir,str(s))
        call exp_3D_1C(m,pad,un,str(s),U)
        call close_and_message(un,dir,str(s))
        call delete(s)
      end subroutine
      subroutine export_3D_1C_unsteady(m,U,dir,name,pad,TMP)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad
        type(SF),intent(in) :: U
        type(time_marching_params),intent(in) :: TMP
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,U%DL)
        un = new_and_open(dir,str(s)//'_t='//str(cp2str(TMP%t)))
        call exp_3D_1C(m,pad,un,str(s),U)
        call close_and_message(un,dir,str(s)//'_t='//str(cp2str(TMP%t)))
        call delete(s)
      end subroutine

      subroutine export_2D_1C_steady(m,U,dir,name,pad,direction,plane)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction,plane
        type(SF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,U%DL)
        un = new_and_open(dir,str(s))
        call exp_2D_1C(m,pad,un,str(s),U,direction,plane)
        call close_and_message(un,dir,str(s))
        call delete(s)
      end subroutine
      subroutine export_2D_1C_unsteady(m,U,dir,name,pad,TMP,direction,plane)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction,plane
        type(time_marching_params),intent(in) :: TMP
        type(SF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,U%DL)
        un = new_and_open(dir,str(s)//'_plane_t='//str(cp2str(TMP%t)))
        call exp_2D_1C(m,pad,un,str(s),U,direction,plane)
        call close_and_message(un,dir,str(s)//'_plane_t='//str(cp2str(TMP%t)))
        call delete(s)
      end subroutine

      subroutine export_1D_1C_steady(m,U,dir,name,pad,direction,line)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction
        integer,dimension(2),intent(in) :: line
        type(SF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,U%DL)
        un = new_and_open(dir,str(s))
        call exp_1D_1C(m,pad,un,str(s),U,direction,line)
        call close_and_message(un,dir,str(s))
        call delete(s)
      end subroutine
      subroutine export_1D_1C_unsteady(m,U,dir,name,pad,TMP,direction,line)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad,direction
        integer,dimension(2),intent(in) :: line
        type(time_marching_params),intent(in) :: TMP
        type(SF),intent(in) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,U%DL)
        un = new_and_open(dir,str(s)//'_line_t='//str(cp2str(TMP%t)))
        call exp_1D_1C(m,pad,un,str(s),U,direction,line)
        call close_and_message(un,dir,str(s)//'_line_t='//str(cp2str(TMP%t)))
        call delete(s)
      end subroutine

      ! **********************************************************************
      ! **************************** 0 COMPONENTS ****************************
      ! **********************************************************************

      subroutine export_mesh(m,dir,name,pad)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad
        integer :: un
        un = new_and_open(dir,name)
        call exp_mesh_SF(m,pad,un,name)
        call close_and_message(un,dir,name)
      end subroutine

      end module
      module IO_import_mod
      use current_precision_mod
      use mesh_extend_mod
      use SF_extend_mod
      use VF_extend_mod
      use base_import_mod
      use IO_tools_mod
      use string_mod
      use time_marching_params_mod
      use datatype_conversion_mod
      use construct_suffix_mod
      implicit none

      private
      public :: import_3D_1C
      public :: import_3D_3C

      contains

      subroutine import_3D_1C(m,U,dir,name,pad)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad
        type(SF),intent(inout) :: U
        type(string) :: s
        integer :: un
        call construct_suffix(s,name,get_DL(U))
        un = new_and_open(dir,str(s))
        call imp_3D_1C(m,pad,un,U)
        call close_and_message(un,dir,str(s))
        call delete(s)
      end subroutine

      subroutine import_3D_3C(m,U,dir,name,pad)
        implicit none
        character(len=*),intent(in) :: dir,name
        type(mesh),intent(in) :: m
        integer,intent(in) :: pad
        type(VF),intent(inout) :: U
        call import_3D_1C(m,U%x,dir,name,pad)
        call import_3D_1C(m,U%y,dir,name,pad)
        call import_3D_1C(m,U%z,dir,name,pad)
      end subroutine

      end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module PCG_solver_SF_mod
       use string_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use matrix_free_operators_interfaces_mod
       use preconditioner_interfaces_mod
       use norms_mod
       use TF_mod
       use matrix_free_params_mod
       use iter_solver_params_mod
       use SF_mod
       use dir_manip_mod
       implicit none

       private
       public :: PCG_solver_SF
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_PCG_solver_SF;              end interface
       interface delete;                 module procedure delete_PCG_solver_SF;                 end interface
       interface display;                module procedure display_PCG_solver_SF;                end interface
       interface display_short;          module procedure display_short_PCG_solver_SF;          end interface
       interface display;                module procedure display_wrap_PCG_solver_SF;           end interface
       interface print;                  module procedure print_PCG_solver_SF;                  end interface
       interface print_short;            module procedure print_short_PCG_solver_SF;            end interface
       interface export;                 module procedure export_PCG_solver_SF;                 end interface
       interface export_primitives;      module procedure export_primitives_PCG_solver_SF;      end interface
       interface import;                 module procedure import_PCG_solver_SF;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_PCG_solver_SF;end interface
       interface export_structured;      module procedure export_structured_D_PCG_solver_SF;    end interface
       interface import_structured;      module procedure import_structured_D_PCG_solver_SF;    end interface
       interface import_primitives;      module procedure import_primitives_PCG_solver_SF;      end interface
       interface export;                 module procedure export_wrap_PCG_solver_SF;            end interface
       interface import;                 module procedure import_wrap_PCG_solver_SF;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_PCG_solver_SF;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_PCG_solver_SF;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_PCG_solver_SF;      end interface
       interface export;                 module procedure export_DN_PCG_solver_SF;              end interface
       interface import;                 module procedure import_DN_PCG_solver_SF;              end interface
       interface export_structured;      module procedure export_structured_DN_PCG_solver_SF;   end interface
       interface import_structured;      module procedure import_structured_DN_PCG_solver_SF;   end interface

       type PCG_solver_SF
         integer :: un = 0
         integer :: un_convergence = 0
         type(matrix_free_params) :: MFP
         type(TF) :: tempk
         type(TF) :: k
         type(SF) :: r
         type(SF) :: p
         type(SF) :: tempx
         type(SF) :: Ax
         type(SF) :: x_BC
         type(SF) :: vol
         type(SF) :: z
         type(SF) :: Minv
         type(norms) :: norm
         type(iter_solver_params) :: ISP
         type(string) :: dir
         type(string) :: name
         type(string) :: var_dir
         type(string) :: var_name
         procedure(preconditioner_SF),pointer,nopass :: prec
         procedure(op_SF),pointer,nopass :: operator
         procedure(op_SF_explicit),pointer,nopass :: operator_explicit
       end type

       contains

       subroutine init_copy_PCG_solver_SF(this,that)
         implicit none
         type(PCG_solver_SF),intent(inout) :: this
         type(PCG_solver_SF),intent(in) :: that
         call delete(this)
         this%un = that%un
         this%un_convergence = that%un_convergence
         call init(this%MFP,that%MFP)
         call init(this%tempk,that%tempk)
         call init(this%k,that%k)
         call init(this%r,that%r)
         call init(this%p,that%p)
         call init(this%tempx,that%tempx)
         call init(this%Ax,that%Ax)
         call init(this%x_BC,that%x_BC)
         call init(this%vol,that%vol)
         call init(this%z,that%z)
         call init(this%Minv,that%Minv)
         call init(this%norm,that%norm)
         call init(this%ISP,that%ISP)
         call init(this%dir,that%dir)
         call init(this%name,that%name)
         call init(this%var_dir,that%var_dir)
         call init(this%var_name,that%var_name)
         this%prec => that%prec
         this%operator => that%operator
         this%operator_explicit => that%operator_explicit
       end subroutine

       subroutine delete_PCG_solver_SF(this)
         implicit none
         type(PCG_solver_SF),intent(inout) :: this
         this%un = 0
         this%un_convergence = 0
         call delete(this%MFP)
         call delete(this%tempk)
         call delete(this%k)
         call delete(this%r)
         call delete(this%p)
         call delete(this%tempx)
         call delete(this%Ax)
         call delete(this%x_BC)
         call delete(this%vol)
         call delete(this%z)
         call delete(this%Minv)
         call delete(this%norm)
         call delete(this%ISP)
         call delete(this%dir)
         call delete(this%name)
         call delete(this%var_dir)
         call delete(this%var_name)
         nullify(this%prec)
         nullify(this%operator)
         nullify(this%operator_explicit)
       end subroutine

       subroutine display_PCG_solver_SF(this,un)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'un                = ',this%un
         write(un,*) 'un_convergence    = ',this%un_convergence
         call display(this%MFP,un)
         call display(this%tempk,un)
         call display(this%k,un)
         call display(this%r,un)
         call display(this%p,un)
         call display(this%tempx,un)
         call display(this%Ax,un)
         call display(this%x_BC,un)
         call display(this%vol,un)
         call display(this%z,un)
         call display(this%Minv,un)
         call display(this%norm,un)
         call display(this%ISP,un)
         call display(this%dir,un)
         call display(this%name,un)
         call display(this%var_dir,un)
         call display(this%var_name,un)
       end subroutine

       subroutine display_short_PCG_solver_SF(this,un)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'un                = ',this%un
         write(un,*) 'un_convergence    = ',this%un_convergence
         call display(this%MFP,un)
         call display(this%tempk,un)
         call display(this%k,un)
         call display(this%r,un)
         call display(this%p,un)
         call display(this%tempx,un)
         call display(this%Ax,un)
         call display(this%x_BC,un)
         call display(this%vol,un)
         call display(this%z,un)
         call display(this%Minv,un)
         call display(this%norm,un)
         call display(this%ISP,un)
         call display(this%dir,un)
         call display(this%name,un)
         call display(this%var_dir,un)
         call display(this%var_name,un)
       end subroutine

       subroutine display_wrap_PCG_solver_SF(this,dir,name)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_PCG_solver_SF(this)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_PCG_solver_SF(this)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_PCG_solver_SF(this,un)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%MFP,un)
         call export(this%tempk,un)
         call export(this%k,un)
         call export(this%r,un)
         call export(this%p,un)
         call export(this%tempx,un)
         call export(this%Ax,un)
         call export(this%x_BC,un)
         call export(this%vol,un)
         call export(this%z,un)
         call export(this%Minv,un)
         call export(this%norm,un)
         call export(this%ISP,un)
         call export(this%dir,un)
         call export(this%name,un)
         call export(this%var_dir,un)
         call export(this%var_name,un)
       end subroutine

       subroutine import_PCG_solver_SF(this,un)
         implicit none
         type(PCG_solver_SF),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%MFP,un)
         call import(this%tempk,un)
         call import(this%k,un)
         call import(this%r,un)
         call import(this%p,un)
         call import(this%tempx,un)
         call import(this%Ax,un)
         call import(this%x_BC,un)
         call import(this%vol,un)
         call import(this%z,un)
         call import(this%Minv,un)
         call import(this%norm,un)
         call import(this%ISP,un)
         call import(this%dir,un)
         call import(this%name,un)
         call import(this%var_dir,un)
         call import(this%var_name,un)
       end subroutine

       subroutine export_primitives_PCG_solver_SF(this,un)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'un                 = ';write(un,*) this%un
         write(un,*) 'un_convergence     = ';write(un,*) this%un_convergence
       end subroutine

       subroutine import_primitives_PCG_solver_SF(this,un)
         implicit none
         type(PCG_solver_SF),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%un
         read(un,*); read(un,*) this%un_convergence
       end subroutine

       subroutine export_wrap_PCG_solver_SF(this,dir,name)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_PCG_solver_SF(this,dir,name)
         implicit none
         type(PCG_solver_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_PCG_solver_SF(this)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_PCG_solver_SF(this)
         implicit none
         type(PCG_solver_SF),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_PCG_solver_SF(this)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%MFP,str(this%dir)//'MFP'//fortran_PS)
         call export_structured(this%r,str(this%dir)//'r'//fortran_PS)
         call export_structured(this%p,str(this%dir)//'p'//fortran_PS)
         call export_structured(this%tempx,&
         str(this%dir)//'tempx'//fortran_PS)
         call export_structured(this%Ax,str(this%dir)//'Ax'//fortran_PS)
         call export_structured(this%x_BC,str(this%dir)//'x_BC'//fortran_PS)
         call export_structured(this%vol,str(this%dir)//'vol'//fortran_PS)
         call export_structured(this%z,str(this%dir)//'z'//fortran_PS)
         call export_structured(this%Minv,str(this%dir)//'Minv'//fortran_PS)
         call export_structured(this%norm,str(this%dir)//'norm'//fortran_PS)
         call export_structured(this%ISP,str(this%dir)//'ISP'//fortran_PS)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         call export_structured(this%var_dir,&
         str(this%dir)//'var_dir'//fortran_PS)
         call export_structured(this%var_name,&
         str(this%dir)//'var_name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_PCG_solver_SF(this)
         implicit none
         type(PCG_solver_SF),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%MFP,str(this%dir)//'MFP'//fortran_PS)
         call import_structured(this%r,str(this%dir)//'r'//fortran_PS)
         call import_structured(this%p,str(this%dir)//'p'//fortran_PS)
         call import_structured(this%tempx,&
         str(this%dir)//'tempx'//fortran_PS)
         call import_structured(this%Ax,str(this%dir)//'Ax'//fortran_PS)
         call import_structured(this%x_BC,str(this%dir)//'x_BC'//fortran_PS)
         call import_structured(this%vol,str(this%dir)//'vol'//fortran_PS)
         call import_structured(this%z,str(this%dir)//'z'//fortran_PS)
         call import_structured(this%Minv,str(this%dir)//'Minv'//fortran_PS)
         call import_structured(this%norm,str(this%dir)//'norm'//fortran_PS)
         call import_structured(this%ISP,str(this%dir)//'ISP'//fortran_PS)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         call import_structured(this%var_dir,&
         str(this%dir)//'var_dir'//fortran_PS)
         call import_structured(this%var_name,&
         str(this%dir)//'var_name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_PCG_solver_SF(this,dir)
         implicit none
         type(PCG_solver_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%MFP,dir//'MFP'//fortran_PS)
         call set_IO_dir(this%r,dir//'r'//fortran_PS)
         call set_IO_dir(this%p,dir//'p'//fortran_PS)
         call set_IO_dir(this%tempx,dir//'tempx'//fortran_PS)
         call set_IO_dir(this%Ax,dir//'Ax'//fortran_PS)
         call set_IO_dir(this%x_BC,dir//'x_BC'//fortran_PS)
         call set_IO_dir(this%vol,dir//'vol'//fortran_PS)
         call set_IO_dir(this%z,dir//'z'//fortran_PS)
         call set_IO_dir(this%Minv,dir//'Minv'//fortran_PS)
         call set_IO_dir(this%norm,dir//'norm'//fortran_PS)
         call set_IO_dir(this%ISP,dir//'ISP'//fortran_PS)
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
         call set_IO_dir(this%var_dir,dir//'var_dir'//fortran_PS)
         call set_IO_dir(this%var_name,dir//'var_name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_PCG_solver_SF(this,dir)
         implicit none
         type(PCG_solver_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%MFP,dir//'MFP'//fortran_PS)
         if (get_necessary_for_restart(this%r)) then
           call make_IO_dir(this%r,dir//'r'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%p)) then
           call make_IO_dir(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%tempx)) then
           call make_IO_dir(this%tempx,dir//'tempx'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ax)) then
           call make_IO_dir(this%Ax,dir//'Ax'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%x_BC)) then
           call make_IO_dir(this%x_BC,dir//'x_BC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call make_IO_dir(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call make_IO_dir(this%z,dir//'z'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Minv)) then
           call make_IO_dir(this%Minv,dir//'Minv'//fortran_PS)
         endif
         call make_IO_dir(this%norm,dir//'norm'//fortran_PS)
         call make_IO_dir(this%ISP,dir//'ISP'//fortran_PS)
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
         call make_IO_dir(this%var_dir,dir//'var_dir'//fortran_PS)
         call make_IO_dir(this%var_name,dir//'var_name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_PCG_solver_SF(this,dir)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%MFP,dir//'MFP'//fortran_PS)
         if (get_necessary_for_restart(this%r)) then
           call export_structured(this%r,dir//'r'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%p)) then
           call export_structured(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%tempx)) then
           call export_structured(this%tempx,dir//'tempx'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ax)) then
           call export_structured(this%Ax,dir//'Ax'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%x_BC)) then
           call export_structured(this%x_BC,dir//'x_BC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call export_structured(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call export_structured(this%z,dir//'z'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Minv)) then
           call export_structured(this%Minv,dir//'Minv'//fortran_PS)
         endif
         call export_structured(this%norm,dir//'norm'//fortran_PS)
         call export_structured(this%ISP,dir//'ISP'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         call export_structured(this%var_dir,dir//'var_dir'//fortran_PS)
         call export_structured(this%var_name,dir//'var_name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_PCG_solver_SF(this,dir)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%MFP,dir//'MFP'//fortran_PS)
         if (get_necessary_for_restart(this%r)) then
           call export_structured(this%r,dir//'r'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%p)) then
           call export_structured(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%tempx)) then
           call export_structured(this%tempx,dir//'tempx'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ax)) then
           call export_structured(this%Ax,dir//'Ax'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%x_BC)) then
           call export_structured(this%x_BC,dir//'x_BC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call export_structured(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call export_structured(this%z,dir//'z'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Minv)) then
           call export_structured(this%Minv,dir//'Minv'//fortran_PS)
         endif
         call export_structured(this%norm,dir//'norm'//fortran_PS)
         call export_structured(this%ISP,dir//'ISP'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         call export_structured(this%var_dir,dir//'var_dir'//fortran_PS)
         call export_structured(this%var_name,dir//'var_name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_PCG_solver_SF(this,dir)
         implicit none
         type(PCG_solver_SF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%MFP,dir//'MFP'//fortran_PS)
         if (get_necessary_for_restart(this%r)) then
           call import_structured(this%r,dir//'r'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%p)) then
           call import_structured(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%tempx)) then
           call import_structured(this%tempx,dir//'tempx'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ax)) then
           call import_structured(this%Ax,dir//'Ax'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%x_BC)) then
           call import_structured(this%x_BC,dir//'x_BC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call import_structured(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call import_structured(this%z,dir//'z'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Minv)) then
           call import_structured(this%Minv,dir//'Minv'//fortran_PS)
         endif
         call import_structured(this%norm,dir//'norm'//fortran_PS)
         call import_structured(this%ISP,dir//'ISP'//fortran_PS)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         call import_structured(this%var_dir,dir//'var_dir'//fortran_PS)
         call import_structured(this%var_name,dir//'var_name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_PCG_solver_SF(this)
         implicit none
         type(PCG_solver_SF),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module PCG_solver_VF_mod
       use string_mod
       use datatype_conversion_mod
       use VF_mod
       use IO_tools_mod
       use matrix_free_operators_interfaces_mod
       use preconditioner_interfaces_mod
       use norms_mod
       use TF_mod
       use matrix_free_params_mod
       use iter_solver_params_mod
       use dir_manip_mod
       implicit none

       private
       public :: PCG_solver_VF
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_PCG_solver_VF;              end interface
       interface delete;                 module procedure delete_PCG_solver_VF;                 end interface
       interface display;                module procedure display_PCG_solver_VF;                end interface
       interface display_short;          module procedure display_short_PCG_solver_VF;          end interface
       interface display;                module procedure display_wrap_PCG_solver_VF;           end interface
       interface print;                  module procedure print_PCG_solver_VF;                  end interface
       interface print_short;            module procedure print_short_PCG_solver_VF;            end interface
       interface export;                 module procedure export_PCG_solver_VF;                 end interface
       interface export_primitives;      module procedure export_primitives_PCG_solver_VF;      end interface
       interface import;                 module procedure import_PCG_solver_VF;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_PCG_solver_VF;end interface
       interface export_structured;      module procedure export_structured_D_PCG_solver_VF;    end interface
       interface import_structured;      module procedure import_structured_D_PCG_solver_VF;    end interface
       interface import_primitives;      module procedure import_primitives_PCG_solver_VF;      end interface
       interface export;                 module procedure export_wrap_PCG_solver_VF;            end interface
       interface import;                 module procedure import_wrap_PCG_solver_VF;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_PCG_solver_VF;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_PCG_solver_VF;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_PCG_solver_VF;      end interface
       interface export;                 module procedure export_DN_PCG_solver_VF;              end interface
       interface import;                 module procedure import_DN_PCG_solver_VF;              end interface
       interface export_structured;      module procedure export_structured_DN_PCG_solver_VF;   end interface
       interface import_structured;      module procedure import_structured_DN_PCG_solver_VF;   end interface

       type PCG_solver_VF
         integer :: un = 0
         integer :: un_convergence = 0
         type(matrix_free_params) :: MFP
         type(TF) :: tempk
         type(TF) :: k
         type(VF) :: r
         type(VF) :: p
         type(VF) :: tempx
         type(VF) :: Ax
         type(VF) :: x_BC
         type(VF) :: vol
         type(VF) :: z
         type(VF) :: Minv
         type(norms) :: norm
         type(iter_solver_params) :: ISP
         type(string) :: dir
         type(string) :: name
         type(string) :: var_dir
         type(string) :: var_name
         procedure(preconditioner_VF),pointer,nopass :: prec
         procedure(op_VF),pointer,nopass :: operator
         procedure(op_VF_explicit),pointer,nopass :: operator_explicit
       end type

       contains

       subroutine init_copy_PCG_solver_VF(this,that)
         implicit none
         type(PCG_solver_VF),intent(inout) :: this
         type(PCG_solver_VF),intent(in) :: that
         call delete(this)
         this%un = that%un
         this%un_convergence = that%un_convergence
         call init(this%MFP,that%MFP)
         call init(this%tempk,that%tempk)
         call init(this%k,that%k)
         call init(this%r,that%r)
         call init(this%p,that%p)
         call init(this%tempx,that%tempx)
         call init(this%Ax,that%Ax)
         call init(this%x_BC,that%x_BC)
         call init(this%vol,that%vol)
         call init(this%z,that%z)
         call init(this%Minv,that%Minv)
         call init(this%norm,that%norm)
         call init(this%ISP,that%ISP)
         call init(this%dir,that%dir)
         call init(this%name,that%name)
         call init(this%var_dir,that%var_dir)
         call init(this%var_name,that%var_name)
         this%prec => that%prec
         this%operator => that%operator
         this%operator_explicit => that%operator_explicit
       end subroutine

       subroutine delete_PCG_solver_VF(this)
         implicit none
         type(PCG_solver_VF),intent(inout) :: this
         this%un = 0
         this%un_convergence = 0
         call delete(this%MFP)
         call delete(this%tempk)
         call delete(this%k)
         call delete(this%r)
         call delete(this%p)
         call delete(this%tempx)
         call delete(this%Ax)
         call delete(this%x_BC)
         call delete(this%vol)
         call delete(this%z)
         call delete(this%Minv)
         call delete(this%norm)
         call delete(this%ISP)
         call delete(this%dir)
         call delete(this%name)
         call delete(this%var_dir)
         call delete(this%var_name)
         nullify(this%prec)
         nullify(this%operator)
         nullify(this%operator_explicit)
       end subroutine

       subroutine display_PCG_solver_VF(this,un)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'un                = ',this%un
         write(un,*) 'un_convergence    = ',this%un_convergence
         call display(this%MFP,un)
         call display(this%tempk,un)
         call display(this%k,un)
         call display(this%r,un)
         call display(this%p,un)
         call display(this%tempx,un)
         call display(this%Ax,un)
         call display(this%x_BC,un)
         call display(this%vol,un)
         call display(this%z,un)
         call display(this%Minv,un)
         call display(this%norm,un)
         call display(this%ISP,un)
         call display(this%dir,un)
         call display(this%name,un)
         call display(this%var_dir,un)
         call display(this%var_name,un)
       end subroutine

       subroutine display_short_PCG_solver_VF(this,un)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'un                = ',this%un
         write(un,*) 'un_convergence    = ',this%un_convergence
         call display(this%MFP,un)
         call display(this%tempk,un)
         call display(this%k,un)
         call display(this%r,un)
         call display(this%p,un)
         call display(this%tempx,un)
         call display(this%Ax,un)
         call display(this%x_BC,un)
         call display(this%vol,un)
         call display(this%z,un)
         call display(this%Minv,un)
         call display(this%norm,un)
         call display(this%ISP,un)
         call display(this%dir,un)
         call display(this%name,un)
         call display(this%var_dir,un)
         call display(this%var_name,un)
       end subroutine

       subroutine display_wrap_PCG_solver_VF(this,dir,name)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_PCG_solver_VF(this)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_PCG_solver_VF(this)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_PCG_solver_VF(this,un)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%MFP,un)
         call export(this%tempk,un)
         call export(this%k,un)
         call export(this%r,un)
         call export(this%p,un)
         call export(this%tempx,un)
         call export(this%Ax,un)
         call export(this%x_BC,un)
         call export(this%vol,un)
         call export(this%z,un)
         call export(this%Minv,un)
         call export(this%norm,un)
         call export(this%ISP,un)
         call export(this%dir,un)
         call export(this%name,un)
         call export(this%var_dir,un)
         call export(this%var_name,un)
       end subroutine

       subroutine import_PCG_solver_VF(this,un)
         implicit none
         type(PCG_solver_VF),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%MFP,un)
         call import(this%tempk,un)
         call import(this%k,un)
         call import(this%r,un)
         call import(this%p,un)
         call import(this%tempx,un)
         call import(this%Ax,un)
         call import(this%x_BC,un)
         call import(this%vol,un)
         call import(this%z,un)
         call import(this%Minv,un)
         call import(this%norm,un)
         call import(this%ISP,un)
         call import(this%dir,un)
         call import(this%name,un)
         call import(this%var_dir,un)
         call import(this%var_name,un)
       end subroutine

       subroutine export_primitives_PCG_solver_VF(this,un)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'un                 = ';write(un,*) this%un
         write(un,*) 'un_convergence     = ';write(un,*) this%un_convergence
       end subroutine

       subroutine import_primitives_PCG_solver_VF(this,un)
         implicit none
         type(PCG_solver_VF),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%un
         read(un,*); read(un,*) this%un_convergence
       end subroutine

       subroutine export_wrap_PCG_solver_VF(this,dir,name)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_PCG_solver_VF(this,dir,name)
         implicit none
         type(PCG_solver_VF),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_PCG_solver_VF(this)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_PCG_solver_VF(this)
         implicit none
         type(PCG_solver_VF),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_PCG_solver_VF(this)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%MFP,str(this%dir)//'MFP'//fortran_PS)
         call export_structured(this%r,str(this%dir)//'r'//fortran_PS)
         call export_structured(this%p,str(this%dir)//'p'//fortran_PS)
         call export_structured(this%tempx,&
         str(this%dir)//'tempx'//fortran_PS)
         call export_structured(this%Ax,str(this%dir)//'Ax'//fortran_PS)
         call export_structured(this%x_BC,str(this%dir)//'x_BC'//fortran_PS)
         call export_structured(this%vol,str(this%dir)//'vol'//fortran_PS)
         call export_structured(this%z,str(this%dir)//'z'//fortran_PS)
         call export_structured(this%Minv,str(this%dir)//'Minv'//fortran_PS)
         call export_structured(this%norm,str(this%dir)//'norm'//fortran_PS)
         call export_structured(this%ISP,str(this%dir)//'ISP'//fortran_PS)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         call export_structured(this%var_dir,&
         str(this%dir)//'var_dir'//fortran_PS)
         call export_structured(this%var_name,&
         str(this%dir)//'var_name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_PCG_solver_VF(this)
         implicit none
         type(PCG_solver_VF),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%MFP,str(this%dir)//'MFP'//fortran_PS)
         call import_structured(this%r,str(this%dir)//'r'//fortran_PS)
         call import_structured(this%p,str(this%dir)//'p'//fortran_PS)
         call import_structured(this%tempx,&
         str(this%dir)//'tempx'//fortran_PS)
         call import_structured(this%Ax,str(this%dir)//'Ax'//fortran_PS)
         call import_structured(this%x_BC,str(this%dir)//'x_BC'//fortran_PS)
         call import_structured(this%vol,str(this%dir)//'vol'//fortran_PS)
         call import_structured(this%z,str(this%dir)//'z'//fortran_PS)
         call import_structured(this%Minv,str(this%dir)//'Minv'//fortran_PS)
         call import_structured(this%norm,str(this%dir)//'norm'//fortran_PS)
         call import_structured(this%ISP,str(this%dir)//'ISP'//fortran_PS)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         call import_structured(this%var_dir,&
         str(this%dir)//'var_dir'//fortran_PS)
         call import_structured(this%var_name,&
         str(this%dir)//'var_name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_PCG_solver_VF(this,dir)
         implicit none
         type(PCG_solver_VF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%MFP,dir//'MFP'//fortran_PS)
         call set_IO_dir(this%r,dir//'r'//fortran_PS)
         call set_IO_dir(this%p,dir//'p'//fortran_PS)
         call set_IO_dir(this%tempx,dir//'tempx'//fortran_PS)
         call set_IO_dir(this%Ax,dir//'Ax'//fortran_PS)
         call set_IO_dir(this%x_BC,dir//'x_BC'//fortran_PS)
         call set_IO_dir(this%vol,dir//'vol'//fortran_PS)
         call set_IO_dir(this%z,dir//'z'//fortran_PS)
         call set_IO_dir(this%Minv,dir//'Minv'//fortran_PS)
         call set_IO_dir(this%norm,dir//'norm'//fortran_PS)
         call set_IO_dir(this%ISP,dir//'ISP'//fortran_PS)
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
         call set_IO_dir(this%var_dir,dir//'var_dir'//fortran_PS)
         call set_IO_dir(this%var_name,dir//'var_name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_PCG_solver_VF(this,dir)
         implicit none
         type(PCG_solver_VF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%MFP,dir//'MFP'//fortran_PS)
         if (get_necessary_for_restart(this%r)) then
           call make_IO_dir(this%r,dir//'r'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%p)) then
           call make_IO_dir(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%tempx)) then
           call make_IO_dir(this%tempx,dir//'tempx'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ax)) then
           call make_IO_dir(this%Ax,dir//'Ax'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%x_BC)) then
           call make_IO_dir(this%x_BC,dir//'x_BC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call make_IO_dir(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call make_IO_dir(this%z,dir//'z'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Minv)) then
           call make_IO_dir(this%Minv,dir//'Minv'//fortran_PS)
         endif
         call make_IO_dir(this%norm,dir//'norm'//fortran_PS)
         call make_IO_dir(this%ISP,dir//'ISP'//fortran_PS)
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
         call make_IO_dir(this%var_dir,dir//'var_dir'//fortran_PS)
         call make_IO_dir(this%var_name,dir//'var_name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_PCG_solver_VF(this,dir)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%MFP,dir//'MFP'//fortran_PS)
         if (get_necessary_for_restart(this%r)) then
           call export_structured(this%r,dir//'r'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%p)) then
           call export_structured(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%tempx)) then
           call export_structured(this%tempx,dir//'tempx'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ax)) then
           call export_structured(this%Ax,dir//'Ax'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%x_BC)) then
           call export_structured(this%x_BC,dir//'x_BC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call export_structured(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call export_structured(this%z,dir//'z'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Minv)) then
           call export_structured(this%Minv,dir//'Minv'//fortran_PS)
         endif
         call export_structured(this%norm,dir//'norm'//fortran_PS)
         call export_structured(this%ISP,dir//'ISP'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         call export_structured(this%var_dir,dir//'var_dir'//fortran_PS)
         call export_structured(this%var_name,dir//'var_name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_PCG_solver_VF(this,dir)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%MFP,dir//'MFP'//fortran_PS)
         if (get_necessary_for_restart(this%r)) then
           call export_structured(this%r,dir//'r'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%p)) then
           call export_structured(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%tempx)) then
           call export_structured(this%tempx,dir//'tempx'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ax)) then
           call export_structured(this%Ax,dir//'Ax'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%x_BC)) then
           call export_structured(this%x_BC,dir//'x_BC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call export_structured(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call export_structured(this%z,dir//'z'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Minv)) then
           call export_structured(this%Minv,dir//'Minv'//fortran_PS)
         endif
         call export_structured(this%norm,dir//'norm'//fortran_PS)
         call export_structured(this%ISP,dir//'ISP'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         call export_structured(this%var_dir,dir//'var_dir'//fortran_PS)
         call export_structured(this%var_name,dir//'var_name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_PCG_solver_VF(this,dir)
         implicit none
         type(PCG_solver_VF),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%MFP,dir//'MFP'//fortran_PS)
         if (get_necessary_for_restart(this%r)) then
           call import_structured(this%r,dir//'r'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%p)) then
           call import_structured(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%tempx)) then
           call import_structured(this%tempx,dir//'tempx'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ax)) then
           call import_structured(this%Ax,dir//'Ax'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%x_BC)) then
           call import_structured(this%x_BC,dir//'x_BC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%vol)) then
           call import_structured(this%vol,dir//'vol'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%z)) then
           call import_structured(this%z,dir//'z'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Minv)) then
           call import_structured(this%Minv,dir//'Minv'//fortran_PS)
         endif
         call import_structured(this%norm,dir//'norm'//fortran_PS)
         call import_structured(this%ISP,dir//'ISP'//fortran_PS)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         call import_structured(this%var_dir,dir//'var_dir'//fortran_PS)
         call import_structured(this%var_name,dir//'var_name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_PCG_solver_VF(this)
         implicit none
         type(PCG_solver_VF),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module apply_BCs_mod
       use current_precision_mod
       use datatype_conversion_mod
       use check_BCs_mod
       use data_location_extend_mod
       use bctype_extend_mod
       use apply_BCs_faces_bridge_mod
       ! use apply_BCs_edges_bridge_mod
       ! use apply_BCs_corners_bridge_mod
       use face_edge_corner_indexing_mod
       use SF_extend_mod
       use VF_extend_mod

       implicit none

       private
       public :: apply_BCs
       interface apply_BCs;     module procedure apply_BCs_SF;    end interface
       interface apply_BCs;     module procedure apply_BCs_VF;    end interface

       contains

       subroutine apply_BCs_VF(U)
         implicit none
         type(VF),intent(inout) :: U
         call apply_BCs(U%x)
         call apply_BCs(U%y)
         call apply_BCs(U%z)
       end subroutine

       subroutine apply_BCs_SF(U)
         implicit none
         type(SF),intent(inout) :: U
#ifdef _DEBUG_APPLY_BCS_FACES_
         call check_defined(U)
#endif
         call apply_BCs_faces(U)
         ! call apply_BCs_edges(U)
         ! call apply_BCs_corners(U)
       end subroutine

       subroutine apply_BCs_faces(U)
         implicit none
         type(SF),intent(inout) :: U
         integer :: t,i
         do t=1,U%s
#ifdef _PARALLELIZE_APPLY_BCS_FACES_
         !$OMP PARALLEL DO

#endif
         do i=1,U%BF(t)%BCs%PA_face_BCs%N
         call U%BF(t)%BCs%PA_face_BCs%SP(i)%P(&
         U%BF(t)%GF,&
         U%BF(t)%BCs%face%SB(U%BF(t)%BCs%PA_face_BCs%SP(i)%ID)%b_total,&
         U%BF(t)%BCs%f_BCs,&
         U%BF(t)%BCs%PA_face_BCs%SP(i)%ID)
         enddo

#ifdef _PARALLELIZE_APPLY_BCS_FACES_
        !$OMP END PARALLEL DO

#endif
         enddo
       end subroutine

       ! subroutine apply_BCs_edges(U)
       !   implicit none
       !   type(SF),intent(inout) :: U
       !   integer :: t,i
       !   do t=1,U%s
       !   do i=1,U%BF(t)%BCs%PA_edge_BCs%N
       !   call U%BF(t)%BCs%PA_edge_BCs%SP(i)%P(&
       !   U%BF(t)%GF,&
       !   U%BF(t)%BCs%edge%b(U%BF(t)%BCs%PA_edge_BCs%SP(i)%ID),&
       !   U%BF(t)%BCs%e_BCs,&
       !   U%BF(t)%BCs%PA_edge_BCs%SP(i)%ID)
       !   enddo
       !   enddo
       ! end subroutine

       ! subroutine apply_BCs_corners(U)
       !   implicit none
       !   type(SF),intent(inout) :: U
       !   integer :: t,i
       !   do t=1,U%s
       !   do i=1,U%BF(t)%BCs%PA_corner_BCs%N
       !   call U%BF(t)%BCs%PA_corner_BCs%SP(i)%P(&
       !   U%BF(t)%GF,&
       !   U%BF(t)%BCs%corner%b(U%BF(t)%BCs%PA_corner_BCs%SP(i)%ID),&
       !   U%BF(t)%BCs%c_BCs,&
       !   U%BF(t)%BCs%PA_corner_BCs%SP(i)%ID)
       !   enddo
       !   enddo
       ! end subroutine

       end module
       module apply_BCs_implicit_mod
       use current_precision_mod
       use datatype_conversion_mod
       use check_BCs_mod
       use data_location_extend_mod
       use bctype_extend_mod
       use apply_BCs_faces_bridge_implicit_mod
       ! use apply_BCs_edges_bridge_implicit_mod
       ! use apply_BCs_corners_bridge_implicit_mod
       use face_edge_corner_indexing_mod
       use SF_extend_mod
       use VF_extend_mod

       implicit none

       private
       public :: apply_BCs_implicit
       interface apply_BCs_implicit; module procedure apply_BCs_imp_SF; end interface
       interface apply_BCs_implicit; module procedure apply_BCs_imp_VF; end interface

       contains

       subroutine apply_BCs_imp_VF(U)
         implicit none
         type(VF),intent(inout) :: U
         call apply_BCs_implicit(U%x)
         call apply_BCs_implicit(U%y)
         call apply_BCs_implicit(U%z)
       end subroutine

       subroutine apply_BCs_imp_SF(U)
         implicit none
         type(SF),intent(inout) :: U
#ifdef _DEBUG_APPLY_BCS_
         call check_defined(U)
#endif
         call apply_BCs_faces_imp(U)
         ! call apply_BCs_edges_imp(U)
         ! call apply_BCs_corners_imp(U)
       end subroutine

       subroutine apply_BCs_faces_imp(U)
         implicit none
         type(SF),intent(inout) :: U
         integer :: t,i
         do t=1,U%s
#ifdef _PARALLELIZE_APPLY_BCS_FACES_
         !$OMP PARALLEL DO

#endif
         do i=1,U%BF(t)%BCs%PA_face_implicit_BCs%N
         call U%BF(t)%BCs%PA_face_implicit_BCs%SP(i)%P(&
         U%BF(t)%GF,&
         U%BF(t)%BCs%face%SB(U%BF(t)%BCs%PA_face_implicit_BCs%SP(i)%ID)%b_total,&
         U%BF(t)%BCs%f_BCs,&
         U%BF(t)%BCs%PA_face_implicit_BCs%SP(i)%ID)
         enddo

#ifdef _PARALLELIZE_APPLY_BCS_FACES_
        !$OMP END PARALLEL DO

#endif
         enddo
       end subroutine

       ! subroutine apply_BCs_edges_imp_SF(U)
       !   implicit none
       !   type(SF),intent(inout) :: U
       !   integer :: t,i
       !   do t=1,U%s
       !   do i=1,U%BF(t)%BCs%PA_edge_implicit_BCs%N
       !   call U%BF(t)%BCs%PA_edge_implicit_BCs%SP(i)%P(&
       !   U%BF(t)%GF,&
       !   U%BF(t)%BCs%edge%b(U%BF(t)%BCs%PA_edge_implicit_BCs%SP(i)%ID),&
       !   U%BF(t)%BCs%e_BCs,&
       !   U%BF(t)%BCs%PA_edge_implicit_BCs%SP(i)%ID)
       !   enddo
       !   enddo
       ! end subroutine

       ! subroutine apply_BCs_corners_imp_SF(U)
       !   implicit none
       !   type(SF),intent(inout) :: U
       !   integer :: t,i
       !   do t=1,U%s
       !   do i=1,U%BF(t)%BCs%PA_corner_implicit_BCs%N
       !   call U%BF(t)%BCs%PA_corner_implicit_BCs%SP(i)%P(&
       !   U%BF(t)%GF,&
       !   U%BF(t)%BCs%corner%b(U%BF(t)%BCs%PA_corner_implicit_BCs%SP(i)%ID),&
       !   U%BF(t)%BCs%c_BCs,&
       !   U%BF(t)%BCs%PA_corner_implicit_BCs%SP(i)%ID)
       !   enddo
       !   enddo
       ! end subroutine

       end module
       module assign_B0_vs_t_mod
       use current_precision_mod
       use time_marching_params_mod
       use Mike_Ulrickson_data_mod
       use VF_extend_mod
       implicit none

       private
       public :: assign_B0_vs_t
       public :: assign_dB0_dt_vs_t
       integer,parameter :: n_data_points = 58
       ! integer :: i_start = 7 ! B_poloidal does not drop until about t(7)
       integer :: i_start = 8 ! B_poloidal does not drop until about t(7)

       contains

       subroutine assign_B0_vs_t(B0,TMP)
         implicit none
         type(VF),intent(inout) :: B0
         type(time_marching_params),intent(in) :: TMP
         real(cp),dimension(n_data_points) :: B_p_all,B_r_all,t_all
         real(cp) :: time
         ! Non-dimensionalize
         call time_normalized(t_all)
         time = TMP%t+t_all(i_start)
         call B_r_mean_normalized(B_r_all)
         call B_p_mean_normalized(B_p_all)

         ! ! Old coordinate system
         ! call assign(B0%x,5.0_cp)
         ! ! call assign(B0%y,get_B_from_t(t_all,B_r_all,time))
         ! call assign(B0%y,0.0_cp)
         ! call assign(B0%z,get_B_from_t(t_all,B_p_all,time))

         ! New coordinate system
         call assign(B0%z,5.0_cp)
         call assign(B0%y,0.0_cp)
         ! call assign(B0%y,get_B_from_t(t_all,B_r_all,time))
         call assign(B0%x,get_B_from_t(t_all,B_p_all,time))
       end subroutine

       subroutine assign_dB0_dt_vs_t(dB0_dt,TMP)
         implicit none
         type(VF),intent(inout) :: dB0_dt
         type(time_marching_params),intent(in) :: TMP
         real(cp),dimension(n_data_points) :: B_p_all,B_r_all,t_all
         real(cp) :: time
         call time_normalized(t_all)
         time = TMP%t+t_all(i_start)
         call B_r_mean_normalized(B_r_all)
         call B_p_mean_normalized(B_p_all)

         ! ! Old coordinate system
         ! call assign(dB0_dt%x,0.0_cp)
         ! ! call assign(dB0_dt%y,get_dB0_dt_from_t(t_all,B_r_all,time))
         ! call assign(dB0_dt%y,0.0_cp)
         ! call assign(dB0_dt%z,get_dB0_dt_from_t(t_all,B_p_all,time))

         ! New coordinate system
         call assign(dB0_dt%z,0.0_cp)
         call assign(dB0_dt%y,0.0_cp)
         ! call assign(dB0_dt%y,get_dB0_dt_from_t(t_all,B_r_all,time))
         call assign(dB0_dt%x,get_dB0_dt_from_t(t_all,B_p_all,time))
       end subroutine

       function get_dB0_dt_from_t(t_all,B_all,t) result(dB0_dt)
         implicit none
         real(cp),dimension(n_data_points),intent(in) :: t_all,B_all
         real(cp),intent(in) :: t
         real(cp) :: dB0_dt
         integer :: i,n
         n = n_data_points
         dB0_dt = (B_all(2)-B_all(1))/(t_all(2)-t_all(1))
         do i=1,n-1
          if ((t.ge.t_all(i)).and.(t.le.t_all(i+1))) then
           dB0_dt = (B_all(i+1)-B_all(i))/(t_all(i+1)-t_all(i))
          endif
         enddo
         if (t.gt.t_all(n)) then
          dB0_dt = 0.0_cp
         endif
       end function

       function get_B_from_t(t_all,B_all,t) result(B)
         implicit none
         real(cp),dimension(n_data_points),intent(in) :: t_all,B_all
         real(cp),intent(in) :: t
         real(cp) :: B
         integer :: i,n
         n = n_data_points
         B = B_all(1)
         do i=1,n-1
          if ((t.ge.t_all(i)).and.(t.le.t_all(i+1))) then
           B = interp_simple(B_all(i),t_all(i),B_all(i+1),t_all(i+1),t)
          endif
         enddo
         if (t.ge.t_all(n)) B = B_all(n)
       end function

       function interp_simple(B1,t1,B2,t2,t) result(B)
         implicit none
         real(cp),intent(in) :: B1,t1,B2,t2,t
         real(cp) :: B
         B = B1 + (B2-B1)*(t-t1)/(t2-t1)
       end function

       end module
      module diagonals_mod
      use current_precision_mod
      use GF_diagonals_mod
      use mesh_extend_mod
      use SF_extend_mod
      use VF_extend_mod
      use TF_extend_mod
      implicit none

      private
      public :: diag_Lap
      public :: diag_curl_curl
      interface diag_Lap;         module procedure diag_Lap_SF;          end interface
      interface diag_Lap;         module procedure diag_Lap_VF;          end interface
      interface diag_curl_curl;   module procedure diag_curl_curl_VF;    end interface

      contains

      subroutine diag_Lap_SF(diag,m)
        ! Computes Laplacian diagonal: diag = diag( ∇•(∇) )
        implicit none
        type(SF),intent(inout) :: diag
        type(mesh),intent(in) :: m
        integer :: t
        do t=1,m%s
          call laplacian_diagonal(diag%BF(t)%GF,m%B(t)%g,diag%DL)
        enddo
      end subroutine

      subroutine diag_Lap_VF(diag,m)
        implicit none
        type(VF),intent(inout) :: diag
        type(mesh),intent(in) :: m
        call diag_Lap(diag%x,m)
        call diag_Lap(diag%y,m)
        call diag_Lap(diag%z,m)
      end subroutine

      subroutine diag_curl_curl_VF(diag,m,sig) ! Verified 1/3/2016
        ! Computes curl-curl diagonal: diag = diag(∇x(σ∇x))
        implicit none
        type(VF),intent(inout) :: diag
        type(mesh),intent(in) :: m
        type(TF),intent(in) :: sig
        integer :: t
        call assign(diag,0.0_cp)
        do t=1,m%s
          call curl_curl_diagonal(diag%x%BF(t)%GF,&
                                  diag%y%BF(t)%GF,&
                                  diag%z%BF(t)%GF,&
                                  m%B(t)%g,&
                                  sig%x%x%BF(t)%GF,&
                                  sig%x%y%BF(t)%GF,&
                                  sig%x%z%BF(t)%GF)
        enddo
      end subroutine

      end module
       module init_B_BCs_mod
       use current_precision_mod
       use BC_funcs_mod
       use grid_mod
       use mesh_extend_mod
       use boundary_conditions_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use sim_params_mod
       implicit none

       private
       public :: init_B_BCs

       contains

       subroutine init_B_BCs(B,m,SP)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         type(sim_params),intent(in) :: SP
         integer,dimension(3) :: periodic_dir
         integer :: preset_ID

         call init_BC_mesh(B%x,m) ! MUST COME BEFORE BVAL ASSIGNMENT
         call init_BC_mesh(B%y,m) ! MUST COME BEFORE BVAL ASSIGNMENT
         call init_BC_mesh(B%z,m) ! MUST COME BEFORE BVAL ASSIGNMENT

         call Dirichlet_BCs(B,m)

         preset_ID = SP%VS%B%BC
         periodic_dir = SP%GP%periodic_dir
         ! preset_ID = 0 ! manual override

         select case (preset_ID)
         case (0);
         case (1);  call pseudo_vacuum(B,m)
         case (2);  call init_Bandaru(B)
         case (3);  call periodic_duct_flow(B,m)
         case (4);  call periodic_duct_flow_pseudo_vacuum(B,m)
         case (5);  call periodic_duct_thin_wall(B,m)
         case (6);  call thin_wall(B,m)
         case (7);  call thin_wall_LDC(B,m)
         case (8);  call thin_wall_Hunt(B,m)
         case (9);  call RV_symmetric_zmax(B,m)
         case (10); call PV_symmetric_zmax(B,m)
         case default; stop 'Error: bad preset_ID in init_UBCs.f90'
         end select

         call make_periodic(B,m,periodic_dir)
         call init_BC_props(B,SP%DP%c_w,SP%DP%Robin_coeff)
       end subroutine

       subroutine RV_symmetric_zmax(B,m)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         integer :: i
         do i=1,m%s
           ! call init_AntiSymmetric(B%x%BF(i)%BCs,6)
           ! call init_AntiSymmetric(B%y%BF(i)%BCs,6)
           call init_Dirichlet(B%x%BF(i)%BCs,6) ! effectively same as antisymmetric
           call init_Dirichlet(B%y%BF(i)%BCs,6) ! effectively same as antisymmetric
           call init_Neumann(B%z%BF(i)%BCs,6)
         enddo
       end subroutine

       subroutine PV_symmetric_zmax(B,m)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         integer :: i
         call pseudo_vacuum(B,m)
         do i=1,m%s
           ! call init_AntiSymmetric(B%x%BF(i)%BCs,6)
           ! call init_AntiSymmetric(B%y%BF(i)%BCs,6)
           call init_Dirichlet(B%x%BF(i)%BCs,6) ! effectively same as antisymmetric
           call init_Dirichlet(B%y%BF(i)%BCs,6) ! effectively same as antisymmetric
           call init_Neumann(B%z%BF(i)%BCs,6)
         enddo
       end subroutine

       subroutine pseudo_vacuum(B,m)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         integer :: i
         call Dirichlet_BCs(B,m)
         do i=1,m%s
           call init_Neumann(B%x%BF(i)%BCs,1); call init(B%x%BF(i)%BCs,0.0_cp,1)
           call init_Neumann(B%x%BF(i)%BCs,2); call init(B%x%BF(i)%BCs,0.0_cp,2)
           call init_Neumann(B%y%BF(i)%BCs,3); call init(B%y%BF(i)%BCs,0.0_cp,3)
           call init_Neumann(B%y%BF(i)%BCs,4); call init(B%y%BF(i)%BCs,0.0_cp,4)
           call init_Neumann(B%z%BF(i)%BCs,5); call init(B%z%BF(i)%BCs,0.0_cp,5)
           call init_Neumann(B%z%BF(i)%BCs,6); call init(B%z%BF(i)%BCs,0.0_cp,6)
         enddo
       end subroutine

       subroutine periodic_duct_flow(B,m)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         integer :: i,k
         do i=1,m%s
           do k=1,2; call init_periodic(B%x%BF(i)%BCs,k); enddo
           do k=1,2; call init_periodic(B%y%BF(i)%BCs,k); enddo
           do k=1,2; call init_periodic(B%z%BF(i)%BCs,k); enddo
         enddo
       end subroutine

       subroutine periodic_duct_flow_pseudo_vacuum(B,m)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         integer :: i,k
         call pseudo_vacuum(B,m)
         do i=1,m%s
           do k=1,2; call init_periodic(B%x%BF(i)%BCs,k); enddo
           do k=1,2; call init_periodic(B%y%BF(i)%BCs,k); enddo
           do k=1,2; call init_periodic(B%z%BF(i)%BCs,k); enddo
         enddo
       end subroutine

       subroutine periodic_duct_thin_wall(B,m)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         integer :: i,k
         call thin_wall(B,m)
         do i=1,m%s
           do k=1,2; call init_periodic(B%x%BF(i)%BCs,k); enddo
           do k=1,2; call init_periodic(B%y%BF(i)%BCs,k); enddo
           do k=1,2; call init_periodic(B%z%BF(i)%BCs,k); enddo
         enddo
       end subroutine

       subroutine init_Bandaru(B)
         implicit none
         type(VF),intent(inout) :: B
         integer :: i
         do i=1,B%x%s
         call init_periodic(B%x%BF(i)%BCs,1)
         call init_periodic(B%y%BF(i)%BCs,1)
         call init_periodic(B%z%BF(i)%BCs,1)
         call init_periodic(B%x%BF(i)%BCs,2)
         call init_periodic(B%y%BF(i)%BCs,2)
         call init_periodic(B%z%BF(i)%BCs,2)
         call init_Neumann(B%x%BF(i)%BCs,5)
         call init_Neumann(B%x%BF(i)%BCs,6)
         enddo
       end subroutine

       subroutine thin_wall(B,m)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         integer :: i,j
         call pseudo_vacuum(B,m)
         do i=1,m%s
           j=3;call init_Robin(B%x%BF(i)%BCs,j); call init(B%x%BF(i)%BCs,0.0_cp,j)
           j=4;call init_Robin(B%x%BF(i)%BCs,j); call init(B%x%BF(i)%BCs,0.0_cp,j)
           j=5;call init_Robin(B%x%BF(i)%BCs,j); call init(B%x%BF(i)%BCs,0.0_cp,j)
           j=6;call init_Robin(B%x%BF(i)%BCs,j); call init(B%x%BF(i)%BCs,0.0_cp,j)

           j=1;call init_Robin(B%y%BF(i)%BCs,j); call init(B%y%BF(i)%BCs,0.0_cp,j)
           j=2;call init_Robin(B%y%BF(i)%BCs,j); call init(B%y%BF(i)%BCs,0.0_cp,j)
           j=5;call init_Robin(B%y%BF(i)%BCs,j); call init(B%y%BF(i)%BCs,0.0_cp,j)
           j=6;call init_Robin(B%y%BF(i)%BCs,j); call init(B%y%BF(i)%BCs,0.0_cp,j)

           j=1;call init_Robin(B%z%BF(i)%BCs,j); call init(B%z%BF(i)%BCs,0.0_cp,j)
           j=2;call init_Robin(B%z%BF(i)%BCs,j); call init(B%z%BF(i)%BCs,0.0_cp,j)
           j=3;call init_Robin(B%z%BF(i)%BCs,j); call init(B%z%BF(i)%BCs,0.0_cp,j)
           j=4;call init_Robin(B%z%BF(i)%BCs,j); call init(B%z%BF(i)%BCs,0.0_cp,j)
         enddo
       end subroutine

       subroutine thin_wall_face(B,m,face)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         integer,intent(in) :: face
         integer :: i
         do i=1,m%s
           select case (face)
           case (1); call init_Robin(B%y%BF(i)%BCs,face); call init(B%y%BF(i)%BCs,0.0_cp,face)
                     call init_Robin(B%z%BF(i)%BCs,face); call init(B%z%BF(i)%BCs,0.0_cp,face)
           case (2); call init_Robin(B%y%BF(i)%BCs,face); call init(B%y%BF(i)%BCs,0.0_cp,face)
                     call init_Robin(B%z%BF(i)%BCs,face); call init(B%z%BF(i)%BCs,0.0_cp,face)
           case (3); call init_Robin(B%x%BF(i)%BCs,face); call init(B%x%BF(i)%BCs,0.0_cp,face)
                     call init_Robin(B%z%BF(i)%BCs,face); call init(B%z%BF(i)%BCs,0.0_cp,face)
           case (4); call init_Robin(B%x%BF(i)%BCs,face); call init(B%x%BF(i)%BCs,0.0_cp,face)
                     call init_Robin(B%z%BF(i)%BCs,face); call init(B%z%BF(i)%BCs,0.0_cp,face)
           case (5); call init_Robin(B%y%BF(i)%BCs,face); call init(B%y%BF(i)%BCs,0.0_cp,face)
                     call init_Robin(B%x%BF(i)%BCs,face); call init(B%x%BF(i)%BCs,0.0_cp,face)
           case (6); call init_Robin(B%x%BF(i)%BCs,face); call init(B%x%BF(i)%BCs,0.0_cp,face)
                     call init_Robin(B%y%BF(i)%BCs,face); call init(B%y%BF(i)%BCs,0.0_cp,face)
           case default; stop 'Error: face must = 1:6 in thin_wall_face in init_BBCs.f90'
           end select
         enddo
       end subroutine

       subroutine thin_wall_Hunt(B,m)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         call pseudo_vacuum(B,m)
         call thin_wall_face(B,m,5)
         call thin_wall_face(B,m,6)
       end subroutine

       subroutine thin_wall_LDC(B,m)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         call pseudo_vacuum(B,m)
         call thin_wall_face(B,m,4)
       end subroutine

       end module
       module init_K_mod
       use current_precision_mod
       use mesh_extend_mod
       use ops_embedExtract_mod
       use mesh_domain_extend_mod
       use SF_extend_mod
       implicit none

       private
       public :: initK

       integer :: preDefined_K = 1 ! k* = k_wall/k_l
       !                                  0 : User-defined case (no override)
       !                                  1 : k* = kStar
       real(cp) :: kStarWall = 1.0_cp ! k* = k_wall/k_l

       contains

       subroutine initK(k,m,MD)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: k
         type(mesh_domain),intent(in) :: MD
         if (preDefined_K.ne.0) then
           call initPredefinedK(k,m,MD)
         else
           call initUserK(k,m,MD)
         endif
       end subroutine

       subroutine initPredefinedK(k,m,MD)
         implicit none
         type(SF),intent(inout) :: k
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         type(SF) :: k_l
         call init_CC(k_l,m,MD)
         call assign(k_l,1.0_cp)
         call assign(k,kStarWall)
         call embedCC(k,k_l,MD)
         call delete(k_l)
       end subroutine

       subroutine initUserK(k,m,MD)
         implicit none
         type(SF),intent(inout) :: k
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         type(SF) :: k_l
         call init_CC(k_l,m,MD)
         call assign(k_l,1.0_cp)
         call assign(k,kStarWall)
         call embedCC(k,k_l,MD)
         call delete(k_l)
       end subroutine

       end module
       module init_P_BCs_mod
       use current_precision_mod
       use BC_funcs_mod
       use grid_mod
       use mesh_extend_mod
       use boundary_conditions_extend_mod
       use SF_extend_mod
       use sim_params_mod
       implicit none

       private
       public :: init_P_BCs

       contains

       subroutine init_P_BCs(p,m,SP)
         implicit none
         type(SF),intent(inout) :: p
         type(mesh),intent(in) :: m
         type(sim_params),intent(in) :: SP
         integer,dimension(3) :: periodic_dir
         integer :: preset_ID
         call init_BC_mesh(p,m) ! MUST COME BEFORE BVAL ASSIGNMENT

         call Neumann_BCs(p,m) ! Default
         p%all_Neumann = .true. ! Needs to be adjusted manually

         preset_ID = SP%VS%P%BC
         periodic_dir = SP%GP%periodic_dir
         ! preset_ID = 0 ! manual override

         select case (preset_ID)
         case (0) ! Pure Neumann default
         case (1); call duct_flow_P0_at_xmax(p)
         case (2); call duct_flow_periodic_IO(p)
         case (3); call duct_flow_2domains(p)
         case (4); call flow_past_2D_square(p)
         case default; stop 'Error: bad preset_ID in init_PBCs.f90.'
         end select
         call make_periodic(p,m,periodic_dir)
         call init_BC_props(p,SP%DP%c_w,SP%DP%Robin_coeff)
       end subroutine

       subroutine flow_past_2D_square(p)
         implicit none
         type(SF),intent(inout) :: p
         integer :: i
         p%all_Neumann = .false.
         do i=1,p%s
         call init_Dirichlet(p%BF(i)%BCs,2)
         enddo
         ! call init_Dirichlet(p%BF(5)%BCs%e(8+3)%BCs)
         ! call init_Dirichlet(p%BF(8)%BCs%e(8+3)%BCs)
         ! call init_Dirichlet(p%BF(8)%BCs%e(8+4)%BCs)
         ! call init_Dirichlet(p%BF(7)%BCs%e(8+4)%BCs)
       end subroutine

       subroutine duct_flow_P0_at_xmax(p)
         implicit none
         type(SF),intent(inout) :: p
         integer :: i
         p%all_Neumann = .false.
         do i=1,p%s
         call init_Dirichlet(p%BF(i)%BCs,2)
         enddo
       end subroutine

       subroutine duct_flow_periodic_IO(p)
         implicit none
         type(SF),intent(inout) :: p
         integer :: i
         p%all_Neumann = .true.
         do i=1,p%s
         call init_periodic(p%BF(i)%BCs,1)
         call init_periodic(p%BF(i)%BCs,2)
         enddo
       end subroutine

       subroutine duct_flow_2domains(p)
         implicit none
         type(SF),intent(inout) :: p
         integer :: i
         p%all_Neumann = .false.
         do i=1,p%s
         call init_Dirichlet(p%BF(i)%BCs,2)
         enddo
         ! call init_Dirichlet(p%BF(1)%BCs%e(8+4)%BCs)
         ! call init_Dirichlet(p%BF(2)%BCs%e(8+3)%BCs)
       end subroutine

       end module
       module init_Sigma_mod
       use current_precision_mod
       use grid_mod
       use mesh_extend_mod
       use mesh_domain_extend_mod
       use ops_embedExtract_mod
       use SF_extend_mod
       implicit none

       private
       public :: initSigma

       integer :: preDefined_Sigma = 1 ! sigma* = sigma_wall/sigma_l
       !                                          0 : Uniform
       !                                          1 : Subdomain dependent
       !                                          2 : Cylinder (2D)
       !                                          3 : single cell sheet

       contains

       subroutine initSigma(sigma,m,MD,sig_local_over_sig_f)
         implicit none
         type(SF),intent(inout) :: sigma
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         real(cp),intent(in) :: sig_local_over_sig_f
         if (preDefined_Sigma.ne.0) then
           call initPredefinedSigma(sigma,m,MD,sig_local_over_sig_f)
         else
           call initUserSigma(sigma,m,MD,sig_local_over_sig_f)
         endif
       end subroutine

       subroutine initPredefinedSigma(sigma,m,MD,sig_local_over_sig_f)
         implicit none
         type(SF),intent(inout) :: sigma
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         real(cp),intent(in) :: sig_local_over_sig_f
         call assign(sigma,1.0_cp)
         select case (preDefined_Sigma)
         case (0);
         case (1); call initSubdomain(sigma,m,MD,sig_local_over_sig_f)
         case (2); call initCylinder2D(sigma,m,MD,3,sig_local_over_sig_f) ! Only for single mesh_domain
         case (3); call single_cell_sheet(sigma,m,MD,sig_local_over_sig_f)
         case default
         stop 'Error: preDefined_Sigma not found in initPredefinedSigma in initializeSigma.f90'
         end select
       end subroutine

       subroutine initSubdomain(sigma,m,MD,sig_local_over_sig_f)
         implicit none
         type(SF),intent(inout) :: sigma
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         real(cp),intent(in) :: sig_local_over_sig_f
         type(SF) :: sigma_l
         call init_CC(sigma_l,m,MD)
         call assign(sigma_l,1.0_cp)
         call assign(sigma,sig_local_over_sig_f)
         call embedCC(sigma,sigma_l,MD)
         call delete(sigma_l)
       end subroutine

       subroutine single_cell_sheet(sigma,m,MD,sig_local_over_sig_f)
         implicit none
         type(SF),intent(inout) :: sigma
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         real(cp),intent(in) :: sig_local_over_sig_f
         type(SF) :: sigma_l
         call init_CC(sigma_l,m,MD)
         call assign(sigma_l,sig_local_over_sig_f)
         sigma_l%BF(1)%GF%f(:,sigma_l%BF(1)%GF%s(2)-1,:) = 1.0_cp
         call assign(sigma,sig_local_over_sig_f)
         call embedCC(sigma,sigma_l,MD)
         call delete(sigma_l)
       end subroutine

       subroutine initCylinder2D(sigma,m,MD,dir,sig_local_over_sig_f)
         implicit none
         type(SF),intent(inout) :: sigma
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         integer,intent(in) :: dir
         real(cp),intent(in) :: sig_local_over_sig_f
         type(SF) :: sigma_l
         real(cp),dimension(3) :: hc
         integer,dimension(3) :: s
         integer :: i,j,k
         real(cp) :: r0,r,two
         two = 2.0_cp
         r0 = 1.0_cp
         call init_CC(sigma_l,m,MD)
         call assign(sigma_l,1.0_cp)
         call assign(sigma,sig_local_over_sig_f)
         s = sigmA%BF(1)%GF%s
         hc = (/((m%B(1)%g%c(i)%hmax+m%B(1)%g%c(i)%hmin)/2.0_cp,i=1,3)/)
         select case (dir)
         case (1)
           do k=1,s(3);do j=1,s(2);do i=1,s(1)
                r = sqrt((m%B(1)%g%c(2)%hc%f(j)-hc(2))**two + (m%B(1)%g%c(3)%hc%f(k)-hc(3))**two)
                if (r.lt.r0) sigmA%BF(1)%GF%f(i,j,k) = 1.0_cp
           enddo;enddo;enddo
         case (2)
           do k=1,s(3);do j=1,s(2);do i=1,s(1)
                r = sqrt((m%B(1)%g%c(1)%hc%f(i)-hc(1))**two + (m%B(1)%g%c(3)%hc%f(k)-hc(3))**two)
                if (r.lt.r0) sigmA%BF(1)%GF%f(i,j,k) = 1.0_cp
           enddo;enddo;enddo
         case (3)
           do k=1,s(3);do j=1,s(2);do i=1,s(1)
                r = sqrt((m%B(1)%g%c(1)%hc%f(i)-hc(1))**two + (m%B(1)%g%c(2)%hc%f(j)-hc(2))**two)
                if (r.lt.r0) sigmA%BF(1)%GF%f(i,j,k) = 1.0_cp
           enddo;enddo;enddo
         case default
         stop 'Error: dir must = 1,2,3 in initCylinder2D in initializeSigma.f90'
         end select
         call delete(sigma_l)
       end subroutine

       subroutine initUserSigma(sigma,m,MD,sig_local_over_sig_f)
         implicit none
         type(SF),intent(inout) :: sigma
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         real(cp),intent(in) :: sig_local_over_sig_f
         type(SF) :: sigma_l
         call init_CC(sigma_l,m,MD)
         call assign(sigma_l,1.0_cp)
         call assign(sigma,sig_local_over_sig_f)
         call embedCC(sigma,sigma_l,MD)
         call delete(sigma_l)
       end subroutine

       end module
       module init_T_BCs_mod
       use current_precision_mod
       use grid_mod
       use mesh_extend_mod
       use boundary_conditions_extend_mod
       use BC_funcs_mod
       use SF_extend_mod
       use sim_params_mod
       implicit none

       private
       public :: init_T_BCs

       contains

       subroutine init_T_BCs(T,m,SP)
         implicit none
         type(SF),intent(inout) :: T
         type(mesh),intent(in) :: m
         type(sim_params),intent(in) :: SP
         integer,dimension(3) :: periodic_dir
         integer :: preset_ID
         call init_BC_mesh(T,m) ! MUST COME BEFORE BVAL ASSIGNMENT

         call Neumann_BCs(T,m)
         T%all_Neumann = .false. ! Needs to be adjusted manually

         preset_ID = SP%VS%T%BC
         periodic_dir = SP%GP%periodic_dir
         ! preset_ID = 1 ! manual override

         select case (preset_ID)
         case (0) ! Default insulating
         case (1); call initFixedBCs(T); call hotFaceBC(T,2)
         case (2); call hotFaceBC(T,1);  call coldFaceBC(T,2)
         case default; stop 'Error: bad preset_ID in init_TBCs.f90.'
         end select
         call make_periodic(T,m,periodic_dir)
       end subroutine

       subroutine hotFaceBC(T,face)
         implicit none
         type(SF),intent(inout) :: T
         integer,intent(in) :: face
         call init_Dirichlet(T%BF(1)%BCs,face)
         call init(T%BF(1)%BCs,1.0_cp,face)
       end subroutine

       subroutine coldFaceBC(T,face)
         implicit none
         type(SF),intent(inout) :: T
         integer,intent(in) :: face
         call init_Dirichlet(T%BF(1)%BCs,face)
         call init(T%BF(1)%BCs,0.0_cp,face)
       end subroutine

       subroutine initFixedBCs(T)
         implicit none
         type(SF),intent(inout) :: T
         call init_Dirichlet(T%BF(1)%BCs)
         call init(T%BF(1)%BCs,0.0_cp)
       end subroutine

       end module
       module init_U_BCs_mod
       use current_precision_mod
       use BC_funcs_mod
       use block_mod
       use block_extend_mod
       use grid_mod
       use block_extend_mod
       use mesh_extend_mod
       use boundary_conditions_extend_mod
       use GF_mod
       use block_field_mod
       use block_field_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use profile_funcs_mod
       use face_edge_corner_indexing_mod
       use sim_params_mod
       implicit none

       private
       public :: init_U_BCs

       contains

       subroutine init_U_BCs(U,m,SP)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         type(sim_params),intent(in) :: SP
         integer,dimension(3) :: periodic_dir
         integer :: preset_ID
         call init_BC_mesh(U%x,m) ! MUST COME BEFORE BVAL ASSIGNMENT
         call init_BC_mesh(U%y,m) ! MUST COME BEFORE BVAL ASSIGNMENT
         call init_BC_mesh(U%z,m) ! MUST COME BEFORE BVAL ASSIGNMENT

         call Dirichlet_BCs(U,m)

         preset_ID = SP%VS%U%BC
         periodic_dir = SP%GP%periodic_dir
         ! preset_ID = 1 ! manual override

         select case (preset_ID)
         case (0);
         case (1);  call LDC_at_ymax(U)
         case (2);  call LDC_at_ymax_symmetric_zmax(U)
         case (3);  call LDC_at_ymax_smooth(U,m)
         case (4);  call duct_flow_uniform_in_axial_out(U)
         case (5);  call duct_flow_uniform_in_FD_out(U)
         case (6);  call duct_flow_periodic_IO(U)
         case (7);  call duct_flow_FD_in_FD_out(U,m,1)
         case (8);  call channel_flow_uniform_in_FD_out(U)
         case (9);  call channel_flow_parabolic_in_FD_out(U,m,2)
         case (10); call cylinder_driven_cavity(U,m,1)
         case (11); call Tylers_geometry(U)
         case (12); call flow_over_2D_square(U)
         case (13); call LDC_4_domains(U)
         case (14); call duct_flow_2D_2domains(U)
         case (15); call LDC_9_domains(U)
         case (16); call LDC_at_ymax_symmetric_zmax(U)
                    call LDC_at_ymax_Shatrov_smooth(U,m)
         case (17); call LDC_at_ymax_symmetric_zmax(U)
                    call LDC_at_ymax_Leriche_smooth(U,m)
         case (18); call Taylor_Green_Vortex(U)
         case default; stop 'Error: bad preset_ID in init_UBCs.f90'
         end select
         call make_periodic(U,m,periodic_dir)
         call init_BC_props(U,SP%DP%c_w,SP%DP%Robin_coeff)
       end subroutine

       subroutine LDC_at_ymax(U)
         implicit none
         type(VF),intent(inout) :: U
         call init(U%x%BF(1)%BCs,1.0_cp,4)
       end subroutine

       subroutine LDC_at_ymax_smooth(U,m)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         real(cp) :: n
         call init(U%x%BF(1)%BCs,1.0_cp,4)
         n = 18.0_cp
         ! smooth_lid_GF(U,g,DL,plane,n)
         call smooth_lid(U%x%BF(1)%BCs%face%SB(4)%b,m%B(1)%fb(4),U%x%DL,2,n)
       end subroutine

       subroutine LDC_at_ymax_Shatrov_smooth(U,m)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         real(cp) :: k_lid
         call init(U%x%BF(1)%BCs,1.0_cp,4)
         k_lid = 80.0_cp
         call smooth_lid_Shatrov(U%x%BF(1)%BCs%face%SB(4)%b,m%B(1)%fb(4),U%x%DL,2,k_lid)
       end subroutine

       subroutine LDC_at_ymax_Leriche_smooth(U,m)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         real(cp) :: n_lid
         call init(U%x%BF(1)%BCs,1.0_cp,4)
         n_lid = 18.0_cp
         call smooth_lid_Leriche(U%x%BF(1)%BCs%face%SB(4)%b,m%B(1)%fb(4),U%x%DL,2,n_lid,3)
       end subroutine

       subroutine Taylor_Green_Vortex(U)
         implicit none
         type(VF),intent(inout) :: U
         integer :: i,j
         do i=1,U%x%s
         do j=1,6
         call init_periodic(U%z%BF(i)%BCs,j)
         enddo
         enddo
         do i=1,U%x%s
         call init_Neumann(U%x%BF(i)%BCs,1)
         call init_Neumann(U%x%BF(i)%BCs,2)
         call init_Dirichlet(U%x%BF(i)%BCs,3)
         call init_Dirichlet(U%x%BF(i)%BCs,4)
         call init_Neumann(U%y%BF(i)%BCs,3)
         call init_Neumann(U%y%BF(i)%BCs,4)
         call init_Dirichlet(U%y%BF(i)%BCs,1)
         call init_Dirichlet(U%y%BF(i)%BCs,2)
         enddo
       end subroutine

       subroutine LDC_at_ymax_symmetric_zmax(U)
         implicit none
         type(VF),intent(inout) :: U
         integer :: i
         do i=1,U%x%s
         call init(U%x%BF(i)%BCs,1.0_cp,4)
         call init_Neumann(U%x%BF(i)%BCs,6)
         call init_Neumann(U%y%BF(i)%BCs,6)
         ! call init_Neumann(U%z%BF(i)%BCs,6) ! Results in small flow through
         call init_Dirichlet(U%z%BF(i)%BCs,6)
         enddo
       end subroutine

       subroutine LDC_4_domains(U)
         implicit none
         type(VF),intent(inout) :: U
         integer :: i
         do i=1,U%x%s
         call init(U%x%BF(3)%BCs,1.0_cp,4) ! periodic in z, driven at ymax
         call init(U%x%BF(4)%BCs,1.0_cp,4) ! periodic in z, driven at ymax
         enddo
       end subroutine

       subroutine LDC_9_domains(U)
         implicit none
         type(VF),intent(inout) :: U
         integer :: i
         do i=1,U%x%s
         call init(U%x%BF(5)%BCs,1.0_cp,4) ! periodic in z, driven at ymax
         call init(U%x%BF(8)%BCs,1.0_cp,4) ! periodic in z, driven at ymax
         call init(U%x%BF(9)%BCs,1.0_cp,4) ! periodic in z, driven at ymax
         ! call init(U%x%BF(5)%BCs%e(8+4),1.0_cp)
         ! call init(U%x%BF(8)%BCs%e(8+2),1.0_cp)
         ! call init(U%x%BF(8)%BCs%e(8+4),1.0_cp)
         ! call init(U%x%BF(9)%BCs%e(8+2),1.0_cp)
         enddo
       end subroutine

       subroutine duct_flow_uniform_in_FD_out(U)
         implicit none
         type(VF),intent(inout) :: U
         integer :: i
         do i=1,U%x%s
         call init(U%x%BF(i)%BCs,1.0_cp,1)  ! Inlet (uniform)
         call init_Neumann(U%x%BF(i)%BCs,2) ! Outlet (fully developed)
         call init_Neumann(U%y%BF(i)%BCs,2) ! Outlet (fully developed)
         call init_Neumann(U%z%BF(i)%BCs,2) ! Outlet (fully developed)
         enddo
       end subroutine

       subroutine duct_flow_uniform_in_axial_out(U)
         implicit none
         type(VF),intent(inout) :: U
         integer :: i
         do i=1,U%x%s
         call init(U%x%BF(i)%BCs,1.0_cp,1)  ! Inlet (uniform)
         call init_Neumann(U%x%BF(i)%BCs,2) ! Outlet (fully developed)
         enddo
       end subroutine

       subroutine duct_flow_periodic_IO(U)
         implicit none
         type(VF),intent(inout) :: U
         integer :: i
         do i=1,U%x%s
         call init_periodic(U%x%BF(i)%BCs,1) ! Inlet (periodic)
         call init_periodic(U%x%BF(i)%BCs,2) ! Outlet (periodic)
         call init_periodic(U%y%BF(i)%BCs,1) ! Inlet (periodic)
         call init_periodic(U%y%BF(i)%BCs,2) ! Outlet (periodic)
         call init_periodic(U%z%BF(i)%BCs,1) ! Inlet (periodic)
         call init_periodic(U%z%BF(i)%BCs,2) ! Outlet (periodic)
         enddo
       end subroutine

       subroutine duct_flow_2D_2domains(U)
         implicit none
         type(VF),intent(inout) :: U
         ! Inlet (uniform)
         call init(U%x%BF(1)%BCs,1.0_cp,1)
         call init(U%x%BF(2)%BCs,1.0_cp,1)
         ! call init(U%x%BF(1)%BCs%e(8+2),1.0_cp)
         ! call init(U%x%BF(2)%BCs%e(8+1),1.0_cp)
         call init_Neumann(U%x%BF(1)%BCs,2) ! Outlet (fully developed)
         call init_Neumann(U%x%BF(2)%BCs,2) ! Outlet (fully developed)

       end subroutine

       subroutine channel_flow_uniform_in_FD_out(U)
         implicit none
         type(VF),intent(inout) :: U
         integer :: i
         do i=1,U%x%s
         call init(U%x%BF(i)%BCs,1.0_cp,1)  ! Inlet (uniform)
         call init_Neumann(U%x%BF(i)%BCs,2) ! Outlet (fully developed)
         enddo
       end subroutine

       subroutine channel_flow_parabolic_in_FD_out(U,m,dir)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir
         integer :: i
         do i=1,U%x%s
         call parabolic_1D(U%x%BF(i)%BCs%face%SB(1)%b,m%B(1)%g,U%x%DL,dir) ! Inlet (parabolic)
         call init_Neumann(U%x%BF(i)%BCs,2) ! Outlet (fully developed)
         enddo
       end subroutine

       subroutine flow_over_2D_square(U)
         implicit none
         type(VF),intent(inout) :: U
         ! 16 edges total must be defined here with velocity of 1
         ! Inlet (uniform)
         call init(U%x%BF(1)%BCs,1.0_cp,1)
         call init(U%x%BF(2)%BCs,1.0_cp,1)
         call init(U%x%BF(3)%BCs,1.0_cp,1)
              ! Edges
              ! call init(U%x%BF(1)%BCs%e(8+1),1.0_cp); call init(U%x%BF(1)%BCs%e(8+2),1.0_cp)
              ! call init(U%x%BF(2)%BCs%e(8+1),1.0_cp); call init(U%x%BF(2)%BCs%e(8+2),1.0_cp)
              ! call init(U%x%BF(3)%BCs%e(8+1),1.0_cp); call init(U%x%BF(3)%BCs%e(8+2),1.0_cp)
         ! Sides (free-stream)
         call init(U%x%BF(2)%BCs,1.0_cp,4); call init(U%x%BF(3)%BCs,1.0_cp,3)
         call init(U%x%BF(4)%BCs,1.0_cp,4); call init(U%x%BF(6)%BCs,1.0_cp,3)
         call init(U%x%BF(5)%BCs,1.0_cp,4); call init(U%x%BF(7)%BCs,1.0_cp,3)
              ! Edges
              ! call init(U%x%BF(2)%BCs%e(8+4),1.0_cp); call init(U%x%BF(3)%BCs%e(8+3),1.0_cp)
              ! call init(U%x%BF(4)%BCs%e(8+2),1.0_cp); call init(U%x%BF(6)%BCs%e(8+1),1.0_cp)
              ! call init(U%x%BF(4)%BCs%e(8+4),1.0_cp); call init(U%x%BF(6)%BCs%e(8+3),1.0_cp)
              ! call init(U%x%BF(5)%BCs%e(8+2),1.0_cp); call init(U%x%BF(7)%BCs%e(8+1),1.0_cp)
              ! call init(U%x%BF(5)%BCs%e(8+4),1.0_cp); call init(U%x%BF(7)%BCs%e(8+3),1.0_cp)
         ! Outlet (fully developed and v=0)
         call init_Neumann(U%x%BF(5)%BCs,2)
         call init_Neumann(U%x%BF(7)%BCs,2)
         call init_Neumann(U%x%BF(8)%BCs,2)
       end subroutine

       subroutine Tylers_geometry(U)
         implicit none
         type(VF),intent(inout) :: U
         integer :: i
         ! THIS NEEDS TO BE FIXED
         do i=4,6
           call init_Neumann(U%x%BF(i)%BCs,2)
           call init_Neumann(U%y%BF(i)%BCs,2)
           call init_Neumann(U%z%BF(i)%BCs,2)
         enddo
         call init_Neumann(U%x%BF(10)%BCs,2); call init_Neumann(U%x%BF(14)%BCs,2)
         call init_Neumann(U%y%BF(10)%BCs,2); call init_Neumann(U%y%BF(14)%BCs,2)
         call init_Neumann(U%z%BF(10)%BCs,2); call init_Neumann(U%z%BF(14)%BCs,2)
         call init(U%x%BF(1)%BCs,1.0_cp,1)

         call init_Neumann(U%x%BF(1)%BCs,6)
         call init_Neumann(U%y%BF(1)%BCs,6)
         call init_Neumann(U%z%BF(1)%BCs,6)

         call init(U%x%BF(1)%BCs,1.0_cp,1)
         call init_Neumann(U%x%BF(14)%BCs,1)
         call init_Neumann(U%y%BF(14)%BCs,1)
         call init_Neumann(U%z%BF(14)%BCs,1)
       end subroutine

       subroutine cylinder_driven_cavity(U,m,face)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         integer,intent(in) :: face
         integer :: dir
         dir = dir_given_face(face)
         select case (dir)
         case(1); call cylinderDrivenBCs(U%y%BF(1),m%B(1),face,2)
                  call cylinderDrivenBCs(U%z%BF(1),m%B(1),face,3)
         case(2); call cylinderDrivenBCs(U%x%BF(1),m%B(1),face,1)
                  call cylinderDrivenBCs(U%z%BF(1),m%B(1),face,3)
         case(3); call cylinderDrivenBCs(U%x%BF(1),m%B(1),face,1)
                  call cylinderDrivenBCs(U%y%BF(1),m%B(1),face,2)
         end select
       end subroutine

       subroutine duct_flow_FD_in_FD_out(U,m,face)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         integer,intent(in) :: face
         integer :: dir
         dir = dir_given_face(face)
         select case (dir)
         case(1); call ductFlow_FD_Profile(U%x%BF(1),m%B(1),face)
         case(2); call ductFlow_FD_Profile(U%y%BF(1),m%B(1),face)
         case(3); call ductFlow_FD_Profile(U%z%BF(1),m%B(1),face)
         end select
       end subroutine

       subroutine cylinderDrivenBCs(BF,B,face,comp)
         implicit none
         type(block_field),intent(inout) :: BF
         type(block),intent(in) :: B
         integer,intent(in) :: face,comp
         integer,dimension(3) :: s
         integer,dimension(2) :: s_2D,a
         type(grid_field) :: temp
         real(cp) :: nhat
         integer :: dir
         dir = dir_given_face(face)
         nhat = nhat_given_face(face)
         a = adj_dir_given_dir(dir)
         s = BF%GF%s
         s(dir) = 1
         s_2D = (/s(a(1)),s(a(2))/)
         call init(temp,BF%GF)
         call assign(temp,reshape(rotatingCylinder(B%g%c(a(1)),&
                                                   B%g%c(a(2)),&
                                                   s(a(1)),&
                                                   s(a(2)),&
                                                   0.1_cp,1.0_cp,comp),s))
         call init(BF%BCs,temp,face)
         call multiply(temp,nhat)
         call delete(temp)
       end subroutine

       subroutine ductFlow_FD_Profile(BF,B,face)
         implicit none
         type(block_field),intent(inout) :: BF
         type(block),intent(in) :: B
         integer,intent(in) :: face
         integer,dimension(3) :: s
         integer,dimension(2) :: s_2D,a
         type(grid_field) :: temp
         real(cp) :: nhat
         integer :: dir
         dir = dir_given_face(face)
         nhat = nhat_given_face(face)
         a = adj_dir_given_dir(dir)
         s = BF%GF%s
         s(dir) = 1
         s_2D = (/s(a(1)),s(a(2))/)
         call init(temp,BF%GF)
         call assign(temp,reshape(init_FD_DuctFlow(B%g%c(a(1)),&
                                                   B%g%c(a(2)),&
                                                   s(a(1)),&
                                                   s(a(2))),s))
         call multiply(temp,nhat)
         call init(BF%BCs,temp,face)
         call delete(temp)
       end subroutine

       end module
       module init_phi_BCs_mod
       use current_precision_mod
       use BC_funcs_mod
       use grid_mod
       use mesh_extend_mod
       use boundary_conditions_extend_mod
       use SF_extend_mod
       use sim_params_mod
       implicit none

       private
       public :: init_phi_BCs

       contains

       subroutine init_phi_BCs(phi,m,SP)
         implicit none
         type(SF),intent(inout) :: phi
         type(mesh),intent(in) :: m
         type(sim_params),intent(in) :: SP
         integer,dimension(3) :: periodic_dir
         integer :: preset_ID
         call init_BC_mesh(phi,m) ! MUST COME BEFORE BVAL ASSIGNMENT

         call Dirichlet_BCs(phi,m)

         preset_ID = SP%VS%phi%BC
         periodic_dir = SP%GP%periodic_dir
         ! preset_ID = 0 ! manual override

         phi%all_Neumann = .false. ! Needs to be adjusted manually

         select case (preset_ID)
         case (0)
         case (1); call periodic_duct_flow(phi)
         case default; stop 'Error: bad preset_ID in init_phi_BCs.f90.'
         end select
         call make_periodic(phi,m,periodic_dir)
         call init_BC_props(phi,SP%DP%c_w,SP%DP%Robin_coeff)
       end subroutine

       subroutine periodic_duct_flow(phi)
         implicit none
         type(SF),intent(inout) :: phi
         call init_periodic(phi%BF(1)%BCs,1)
         call init_periodic(phi%BF(1)%BCs,2)
       end subroutine

       end module
       module ops_norms_mod
       use current_precision_mod
       use mesh_extend_mod
       use mesh_domain_extend_mod
       use data_location_extend_mod
       use GF_norms_mod
       use GF_norms_weights_mod
       use GF_norms_weights_light_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       implicit none

       private
       public :: compute_Ln
       public :: compute_Linf

       ! Interfaces:
       ! Ln(e,u,n,mesh) = L(n) = ∫∫∫ u(i,j,k)ⁿ dx dy dz   ! Only for CC data
       ! Ln(e,u,n,vol)  = L(n) = ∫∫∫ u(i,j,k)ⁿ dx dy dz
       ! Ln(e,u,n)      = L(n) = ΣΣΣ u(i,j,k)ⁿ
       ! Linf(e,u)      = L(∞) = max(abs(u))

       interface compute_Ln;    module procedure Ln_vol_SF;            end interface
       interface compute_Ln;    module procedure Ln_vol_VF;            end interface
       interface compute_Ln;    module procedure Ln_vol_VF_collocated; end interface

       interface compute_Ln;    module procedure Ln_mesh_SF;           end interface
       interface compute_Ln;    module procedure Ln_mesh_VF;           end interface
       interface compute_Ln;    module procedure Ln_mesh_TF;           end interface

       interface compute_Ln;    module procedure Ln_mesh_SF_D;         end interface
       interface compute_Ln;    module procedure Ln_mesh_VF_D;         end interface
       interface compute_Ln;    module procedure Ln_mesh_TF_D;         end interface

       interface compute_Ln;    module procedure Ln_no_vol_SF;         end interface
       interface compute_Ln;    module procedure Ln_no_vol_VF;         end interface

       interface compute_Linf;  module procedure Linf_SF;              end interface
       interface compute_Linf;  module procedure Linf_VF;              end interface

       contains

       subroutine Ln_mesh_SF(e,u,n,m)
         implicit none
         real(cp),intent(inout) :: e
         type(SF),intent(in) :: u
         real(cp),intent(in) :: n
         type(mesh),intent(in) :: m
         real(cp) :: temp
         integer :: t
         e = 0.0_cp
         ! write(*,*) 'vol_ID(u%DL) = ',vol_ID(u%DL)
         do t=1,m%s
          call compute_Ln_norm(temp,u%BF(t)%GF,n,m%B(t)%g,u%DL)
          e = e + temp
         enddo
       end subroutine

       subroutine Ln_mesh_VF(e,u,n,m)
         implicit none
         real(cp),intent(inout) :: e
         type(VF),intent(in) :: u
         real(cp),intent(in) :: n
         type(mesh),intent(in) :: m
         real(cp) :: temp
         integer :: t
         e = 0.0_cp
         if (is_collocated(u)) then
           ! write(*,*) 'vol_ID(u%x%DL) = ',vol_ID(u%x%DL)
           do t=1,m%s;
             call compute_Ln_norm(temp,u%x%BF(t)%GF,&
                          u%y%BF(t)%GF,&
                          u%z%BF(t)%GF,&
                          n,&
                          m%B(t)%g,u%x%DL)
             e = e + temp
           enddo
         else
           ! write(*,*) 'vol_ID(u%x%DL) = ',vol_ID(u%x%DL)
           ! write(*,*) 'vol_ID(u%y%DL) = ',vol_ID(u%y%DL)
           ! write(*,*) 'vol_ID(u%z%DL) = ',vol_ID(u%z%DL)
           do t=1,m%s;
             call compute_Ln_norm(temp,u%x%BF(t)%GF,n,m%B(t)%g,u%x%DL); e = e + temp
             call compute_Ln_norm(temp,u%y%BF(t)%GF,n,m%B(t)%g,u%y%DL); e = e + temp
             call compute_Ln_norm(temp,u%z%BF(t)%GF,n,m%B(t)%g,u%z%DL); e = e + temp
           enddo
         endif
       end subroutine

       subroutine Ln_mesh_TF(e,u,n,m)
         implicit none
         real(cp),intent(inout) :: e
         type(TF),intent(in) :: u
         real(cp),intent(in) :: n
         type(mesh),intent(in) :: m
         real(cp) :: temp
         integer :: t
         e = 0.0_cp
#ifdef _DEBUG_OPS_NORMS_
         if (is_collocated(u)) then
           stop 'Error: must use collocated data in Ln_mesh_TF in ops_norms.f90.f90'
         endif
#endif
         do t=1,m%s
           call compute_Ln_norm(temp,u%x%x%BF(t)%GF,&
                        u%x%y%BF(t)%GF,&
                        u%x%z%BF(t)%GF,&
                        u%y%x%BF(t)%GF,&
                        u%y%y%BF(t)%GF,&
                        u%y%z%BF(t)%GF,&
                        u%z%x%BF(t)%GF,&
                        u%z%y%BF(t)%GF,&
                        u%z%z%BF(t)%GF,&
                        n,m%B(t)%g,u%x%y%DL)
           e = e + temp
         enddo
       end subroutine

       subroutine Ln_mesh_SF_D(e,u,n,m,MD)
         implicit none
         real(cp),intent(inout) :: e
         type(SF),intent(in) :: u
         real(cp),intent(in) :: n
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
            if (compare(m,MD%m_R1)) then; call compute_Ln(e,u,n,MD%m_R2)
         elseif(compare(m,MD%m_R2)) then; call compute_Ln(e,u,n,MD%m_R1)
         else; stop 'Error: missed case in Ln_mesh_SF_D in ops_norms.f90'
         endif
       end subroutine
       subroutine Ln_mesh_VF_D(e,u,n,m,MD)
         implicit none
         real(cp),intent(inout) :: e
         type(VF),intent(in) :: u
         real(cp),intent(in) :: n
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
            if (compare(m,MD%m_R1)) then; call compute_Ln(e,u,n,MD%m_R2)
         elseif(compare(m,MD%m_R2)) then; call compute_Ln(e,u,n,MD%m_R1)
         else; stop 'Error: missed case in Ln_mesh_VF_D in ops_norms.f90'
         endif
       end subroutine
       subroutine Ln_mesh_TF_D(e,u,n,m,MD)
         implicit none
         real(cp),intent(inout) :: e
         type(TF),intent(in) :: u
         real(cp),intent(in) :: n
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
            if (compare(m,MD%m_R1)) then; call compute_Ln(e,u,n,MD%m_R2)
         elseif(compare(m,MD%m_R2)) then; call compute_Ln(e,u,n,MD%m_R1)
         else; stop 'Error: missed case in Ln_mesh_TF_D in ops_norms.f90'
         endif
       end subroutine

       subroutine Ln_vol_SF(e,u,n,vol)
         implicit none
         real(cp),intent(inout) :: e
         type(SF),intent(in) :: u,vol
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: t
         e = 0.0_cp
         do t=1,u%s
           call compute_Ln_norm(temp,u%BF(t)%GF,n,vol%BF(t)%GF)
           e = e + temp
         enddo
       end subroutine

       subroutine Ln_vol_VF_collocated(e,u,n,vol)
         implicit none
         real(cp),intent(inout) :: e
         type(VF),intent(in) :: u
         type(SF),intent(in) :: vol
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: t
         e = 0.0_cp
         do t=1,vol%s
           call compute_Ln_norm(temp,u%x%BF(t)%GF,&
                                     u%y%BF(t)%GF,&
                                     u%z%BF(t)%GF,&
                                     n,vol%BF(t)%GF)
           e = e + temp
         enddo
       end subroutine

       subroutine Ln_vol_VF(e,u,n,vol)
         implicit none
         real(cp),intent(inout) :: e
         type(VF),intent(in) :: u,vol
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: t
         e = 0.0_cp
         if (is_collocated(u)) then; call compute_Ln(e,u,n,vol%x)
         else
           do t=1,u%x%s
             call compute_Ln_norm(temp,u%x%BF(t)%GF,n,vol%x%BF(t)%GF); e = e + temp
             call compute_Ln_norm(temp,u%y%BF(t)%GF,n,vol%y%BF(t)%GF); e = e + temp
             call compute_Ln_norm(temp,u%z%BF(t)%GF,n,vol%z%BF(t)%GF); e = e + temp
           enddo
         endif
       end subroutine

       subroutine Ln_no_vol_SF(e,u,n)
         implicit none
         real(cp),intent(inout) :: e
         type(SF),intent(in) :: u
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: t
         e = 0.0_cp
         do t=1,u%s
           call compute_Ln_norm(temp,u%BF(t)%GF,n)
           e = e + temp
         enddo
       end subroutine

       subroutine Ln_no_vol_VF(e,u,n)
         implicit none
         real(cp),intent(inout) :: e
         type(VF),intent(in) :: u
         real(cp),intent(in) :: n
         real(cp) :: temp
         integer :: t
         e = 0.0_cp
         if (is_collocated(u)) then
           do t=1,u%x%s
             call compute_Ln_norm(temp,u%x%BF(t)%GF,&
                                       u%y%BF(t)%GF,&
                                       u%z%BF(t)%GF,n); e = e + temp
           enddo
         else
           do t=1,u%x%s
             call compute_Ln_norm(temp,u%x%BF(t)%GF,n); e = e + temp
             call compute_Ln_norm(temp,u%y%BF(t)%GF,n); e = e + temp
             call compute_Ln_norm(temp,u%z%BF(t)%GF,n); e = e + temp
           enddo
         endif
       end subroutine

       subroutine Linf_SF(e,u)
         implicit none
         real(cp),intent(inout) :: e
         type(SF),intent(in) :: u
         e = amax(u)
       end subroutine

       subroutine Linf_VF(e,u)
         implicit none
         real(cp),intent(inout) :: e
         type(VF),intent(in) :: u
         e = amax(u)
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module energy_mod
       use PCG_solver_SF_mod
       use string_mod
       use datatype_conversion_mod
       use mesh_domain_mod
       use IO_tools_mod
       use VF_mod
       use TF_mod
       use mesh_mod
       use SF_mod
       use dir_manip_mod
       implicit none

       private
       public :: energy
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_energy;              end interface
       interface delete;                 module procedure delete_energy;                 end interface
       interface display;                module procedure display_energy;                end interface
       interface display_short;          module procedure display_short_energy;          end interface
       interface display;                module procedure display_wrap_energy;           end interface
       interface print;                  module procedure print_energy;                  end interface
       interface print_short;            module procedure print_short_energy;            end interface
       interface export;                 module procedure export_energy;                 end interface
       interface export_primitives;      module procedure export_primitives_energy;      end interface
       interface import;                 module procedure import_energy;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_energy;end interface
       interface export_structured;      module procedure export_structured_D_energy;    end interface
       interface import_structured;      module procedure import_structured_D_energy;    end interface
       interface import_primitives;      module procedure import_primitives_energy;      end interface
       interface export;                 module procedure export_wrap_energy;            end interface
       interface import;                 module procedure import_wrap_energy;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_energy;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_energy;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_energy;      end interface

       type energy
         logical :: suppress_warning = .false.
         type(mesh) :: m
         type(PCG_Solver_SF) :: PCG_T
         type(SF) :: T
         type(SF) :: Tnm1
         type(SF) :: temp_CC1
         type(SF) :: temp_CC2
         type(SF) :: F
         type(SF) :: Fnm1
         type(SF) :: L
         type(SF) :: divQ
         type(SF) :: Q_source
         type(VF) :: temp_F
         type(VF) :: k
         type(VF) :: U_F
         type(VF) :: U_CC
         type(VF) :: gravity
         type(VF) :: temp_CC1_VF
         type(VF) :: temp_CC2_VF
         type(TF) :: temp_CC_TF
         type(TF) :: temp_F_TF
         type(mesh_domain) :: MD
       end type

       contains

       subroutine init_copy_energy(this,that)
         implicit none
         type(energy),intent(inout) :: this
         type(energy),intent(in) :: that
         call delete(this)
         this%suppress_warning = that%suppress_warning
         call init(this%m,that%m)
         call init(this%PCG_T,that%PCG_T)
         call init(this%T,that%T)
         call init(this%Tnm1,that%Tnm1)
         call init(this%temp_CC1,that%temp_CC1)
         call init(this%temp_CC2,that%temp_CC2)
         call init(this%F,that%F)
         call init(this%Fnm1,that%Fnm1)
         call init(this%L,that%L)
         call init(this%divQ,that%divQ)
         call init(this%Q_source,that%Q_source)
         call init(this%temp_F,that%temp_F)
         call init(this%k,that%k)
         call init(this%U_F,that%U_F)
         call init(this%U_CC,that%U_CC)
         call init(this%gravity,that%gravity)
         call init(this%temp_CC1_VF,that%temp_CC1_VF)
         call init(this%temp_CC2_VF,that%temp_CC2_VF)
         call init(this%temp_CC_TF,that%temp_CC_TF)
         call init(this%temp_F_TF,that%temp_F_TF)
         call init(this%MD,that%MD)
       end subroutine

       subroutine delete_energy(this)
         implicit none
         type(energy),intent(inout) :: this
         this%suppress_warning = .false.
         call delete(this%m)
         call delete(this%PCG_T)
         call delete(this%T)
         call delete(this%Tnm1)
         call delete(this%temp_CC1)
         call delete(this%temp_CC2)
         call delete(this%F)
         call delete(this%Fnm1)
         call delete(this%L)
         call delete(this%divQ)
         call delete(this%Q_source)
         call delete(this%temp_F)
         call delete(this%k)
         call delete(this%U_F)
         call delete(this%U_CC)
         call delete(this%gravity)
         call delete(this%temp_CC1_VF)
         call delete(this%temp_CC2_VF)
         call delete(this%temp_CC_TF)
         call delete(this%temp_F_TF)
         call delete(this%MD)
       end subroutine

       subroutine display_energy(this,un)
         implicit none
         type(energy),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning = ',this%suppress_warning
         call display(this%m,un)
         call display(this%PCG_T,un)
         call display(this%T,un)
         call display(this%Tnm1,un)
         call display(this%temp_CC1,un)
         call display(this%temp_CC2,un)
         call display(this%F,un)
         call display(this%Fnm1,un)
         call display(this%L,un)
         call display(this%divQ,un)
         call display(this%Q_source,un)
         call display(this%temp_F,un)
         call display(this%k,un)
         call display(this%U_F,un)
         call display(this%U_CC,un)
         call display(this%gravity,un)
         call display(this%temp_CC1_VF,un)
         call display(this%temp_CC2_VF,un)
         call display(this%temp_CC_TF,un)
         call display(this%temp_F_TF,un)
         call display(this%MD,un)
       end subroutine

       subroutine display_short_energy(this,un)
         implicit none
         type(energy),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning = ',this%suppress_warning
         call display(this%m,un)
         call display(this%PCG_T,un)
         call display(this%T,un)
         call display(this%Tnm1,un)
         call display(this%temp_CC1,un)
         call display(this%temp_CC2,un)
         call display(this%F,un)
         call display(this%Fnm1,un)
         call display(this%L,un)
         call display(this%divQ,un)
         call display(this%Q_source,un)
         call display(this%temp_F,un)
         call display(this%k,un)
         call display(this%U_F,un)
         call display(this%U_CC,un)
         call display(this%gravity,un)
         call display(this%temp_CC1_VF,un)
         call display(this%temp_CC2_VF,un)
         call display(this%temp_CC_TF,un)
         call display(this%temp_F_TF,un)
         call display(this%MD,un)
       end subroutine

       subroutine display_wrap_energy(this,dir,name)
         implicit none
         type(energy),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_energy(this)
         implicit none
         type(energy),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_energy(this)
         implicit none
         type(energy),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_energy(this,un)
         implicit none
         type(energy),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%m,un)
         call export(this%PCG_T,un)
         call export(this%T,un)
         call export(this%Tnm1,un)
         call export(this%temp_CC1,un)
         call export(this%temp_CC2,un)
         call export(this%F,un)
         call export(this%Fnm1,un)
         call export(this%L,un)
         call export(this%divQ,un)
         call export(this%Q_source,un)
         call export(this%temp_F,un)
         call export(this%k,un)
         call export(this%U_F,un)
         call export(this%U_CC,un)
         call export(this%gravity,un)
         call export(this%temp_CC1_VF,un)
         call export(this%temp_CC2_VF,un)
         call export(this%temp_CC_TF,un)
         call export(this%temp_F_TF,un)
         call export(this%MD,un)
       end subroutine

       subroutine import_energy(this,un)
         implicit none
         type(energy),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%m,un)
         call import(this%PCG_T,un)
         call import(this%T,un)
         call import(this%Tnm1,un)
         call import(this%temp_CC1,un)
         call import(this%temp_CC2,un)
         call import(this%F,un)
         call import(this%Fnm1,un)
         call import(this%L,un)
         call import(this%divQ,un)
         call import(this%Q_source,un)
         call import(this%temp_F,un)
         call import(this%k,un)
         call import(this%U_F,un)
         call import(this%U_CC,un)
         call import(this%gravity,un)
         call import(this%temp_CC1_VF,un)
         call import(this%temp_CC2_VF,un)
         call import(this%temp_CC_TF,un)
         call import(this%temp_F_TF,un)
         call import(this%MD,un)
       end subroutine

       subroutine export_primitives_energy(this,un)
         implicit none
         type(energy),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning  = ';write(un,*) this%suppress_warning
       end subroutine

       subroutine import_primitives_energy(this,un)
         implicit none
         type(energy),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%suppress_warning
       end subroutine

       subroutine export_wrap_energy(this,dir,name)
         implicit none
         type(energy),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_energy(this,dir,name)
         implicit none
         type(energy),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_energy(this,dir)
         implicit none
         type(energy),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%PCG_T,dir//'PCG_T'//fortran_PS)
         call set_IO_dir(this%T,dir//'T'//fortran_PS)
         call set_IO_dir(this%Tnm1,dir//'Tnm1'//fortran_PS)
         call set_IO_dir(this%temp_CC1,dir//'temp_CC1'//fortran_PS)
         call set_IO_dir(this%temp_CC2,dir//'temp_CC2'//fortran_PS)
         call set_IO_dir(this%F,dir//'F'//fortran_PS)
         call set_IO_dir(this%Fnm1,dir//'Fnm1'//fortran_PS)
         call set_IO_dir(this%L,dir//'L'//fortran_PS)
         call set_IO_dir(this%divQ,dir//'divQ'//fortran_PS)
         call set_IO_dir(this%Q_source,dir//'Q_source'//fortran_PS)
         call set_IO_dir(this%temp_F,dir//'temp_F'//fortran_PS)
         call set_IO_dir(this%k,dir//'k'//fortran_PS)
         call set_IO_dir(this%U_F,dir//'U_F'//fortran_PS)
         call set_IO_dir(this%U_CC,dir//'U_CC'//fortran_PS)
         call set_IO_dir(this%gravity,dir//'gravity'//fortran_PS)
         call set_IO_dir(this%temp_CC1_VF,dir//'temp_CC1_VF'//fortran_PS)
         call set_IO_dir(this%temp_CC2_VF,dir//'temp_CC2_VF'//fortran_PS)
         call set_IO_dir(this%MD,dir//'MD'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_energy(this,dir)
         implicit none
         type(energy),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%PCG_T,dir//'PCG_T'//fortran_PS)
         if (get_necessary_for_restart(this%T)) then
           call make_IO_dir(this%T,dir//'T'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Tnm1)) then
           call make_IO_dir(this%Tnm1,dir//'Tnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC1)) then
           call make_IO_dir(this%temp_CC1,dir//'temp_CC1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC2)) then
           call make_IO_dir(this%temp_CC2,dir//'temp_CC2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call make_IO_dir(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call make_IO_dir(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call make_IO_dir(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divQ)) then
           call make_IO_dir(this%divQ,dir//'divQ'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Q_source)) then
           call make_IO_dir(this%Q_source,dir//'Q_source'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F)) then
           call make_IO_dir(this%temp_F,dir//'temp_F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%k)) then
           call make_IO_dir(this%k,dir//'k'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_F)) then
           call make_IO_dir(this%U_F,dir//'U_F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_CC)) then
           call make_IO_dir(this%U_CC,dir//'U_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%gravity)) then
           call make_IO_dir(this%gravity,dir//'gravity'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC1_VF)) then
           call make_IO_dir(this%temp_CC1_VF,dir//'temp_CC1_VF'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC2_VF)) then
           call make_IO_dir(this%temp_CC2_VF,dir//'temp_CC2_VF'//fortran_PS)
         endif
         call make_IO_dir(this%MD,dir//'MD'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_energy(this,dir)
         implicit none
         type(energy),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%PCG_T,dir//'PCG_T'//fortran_PS)
         if (get_necessary_for_restart(this%T)) then
           call export_structured(this%T,dir//'T'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Tnm1)) then
           call export_structured(this%Tnm1,dir//'Tnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC1)) then
           call export_structured(this%temp_CC1,dir//'temp_CC1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC2)) then
           call export_structured(this%temp_CC2,dir//'temp_CC2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call export_structured(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call export_structured(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call export_structured(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divQ)) then
           call export_structured(this%divQ,dir//'divQ'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Q_source)) then
           call export_structured(this%Q_source,dir//'Q_source'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F)) then
           call export_structured(this%temp_F,dir//'temp_F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%k)) then
           call export_structured(this%k,dir//'k'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_F)) then
           call export_structured(this%U_F,dir//'U_F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_CC)) then
           call export_structured(this%U_CC,dir//'U_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%gravity)) then
           call export_structured(this%gravity,dir//'gravity'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC1_VF)) then
           call export_structured(this%temp_CC1_VF,&
           dir//'temp_CC1_VF'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC2_VF)) then
           call export_structured(this%temp_CC2_VF,&
           dir//'temp_CC2_VF'//fortran_PS)
         endif
         call export_structured(this%MD,dir//'MD'//fortran_PS)
       end subroutine

       subroutine export_structured_D_energy(this,dir)
         implicit none
         type(energy),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%PCG_T,dir//'PCG_T'//fortran_PS)
         if (get_necessary_for_restart(this%T)) then
           call export_structured(this%T,dir//'T'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Tnm1)) then
           call export_structured(this%Tnm1,dir//'Tnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC1)) then
           call export_structured(this%temp_CC1,dir//'temp_CC1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC2)) then
           call export_structured(this%temp_CC2,dir//'temp_CC2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call export_structured(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call export_structured(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call export_structured(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divQ)) then
           call export_structured(this%divQ,dir//'divQ'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Q_source)) then
           call export_structured(this%Q_source,dir//'Q_source'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F)) then
           call export_structured(this%temp_F,dir//'temp_F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%k)) then
           call export_structured(this%k,dir//'k'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_F)) then
           call export_structured(this%U_F,dir//'U_F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_CC)) then
           call export_structured(this%U_CC,dir//'U_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%gravity)) then
           call export_structured(this%gravity,dir//'gravity'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC1_VF)) then
           call export_structured(this%temp_CC1_VF,&
           dir//'temp_CC1_VF'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC2_VF)) then
           call export_structured(this%temp_CC2_VF,&
           dir//'temp_CC2_VF'//fortran_PS)
         endif
         call export_structured(this%MD,dir//'MD'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_energy(this,dir)
         implicit none
         type(energy),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%PCG_T,dir//'PCG_T'//fortran_PS)
         if (get_necessary_for_restart(this%T)) then
           call import_structured(this%T,dir//'T'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Tnm1)) then
           call import_structured(this%Tnm1,dir//'Tnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC1)) then
           call import_structured(this%temp_CC1,dir//'temp_CC1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC2)) then
           call import_structured(this%temp_CC2,dir//'temp_CC2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call import_structured(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call import_structured(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call import_structured(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divQ)) then
           call import_structured(this%divQ,dir//'divQ'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Q_source)) then
           call import_structured(this%Q_source,dir//'Q_source'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F)) then
           call import_structured(this%temp_F,dir//'temp_F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%k)) then
           call import_structured(this%k,dir//'k'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_F)) then
           call import_structured(this%U_F,dir//'U_F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_CC)) then
           call import_structured(this%U_CC,dir//'U_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%gravity)) then
           call import_structured(this%gravity,dir//'gravity'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC1_VF)) then
           call import_structured(this%temp_CC1_VF,&
           dir//'temp_CC1_VF'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC2_VF)) then
           call import_structured(this%temp_CC2_VF,&
           dir//'temp_CC2_VF'//fortran_PS)
         endif
         call import_structured(this%MD,dir//'MD'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_energy(this)
         implicit none
         type(energy),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module import_raw_mod
       use current_precision_mod
       use mesh_extend_mod
       use string_mod
       use SF_extend_mod
       use VF_extend_mod
       use data_location_extend_mod
       use IO_tools_mod
       use IO_import_mod

       implicit none
       private

       public :: import_raw
       interface import_raw; module procedure ir_steady_SF; end interface
       interface import_raw; module procedure ir_steady_VF; end interface

       contains

       ! **********************************************************************
       ! ***************************** IMPORT RAW *****************************
       ! **********************************************************************

       subroutine ir_steady_SF(m,x,dir,name,pad)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         call import_3D_1C(m,x,dir,name,pad)
       end subroutine

       subroutine ir_steady_VF(m,x,dir,name,pad)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(inout) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         if (is_collocated(x)) then; call import_3D_3C(m,x,dir,name,pad)
         else;                       call import_3D_1C(m,x%x,dir,name,pad)
                                     call import_3D_1C(m,x%y,dir,name,pad)
                                     call import_3D_1C(m,x%z,dir,name,pad)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module induction_mod
       use PCG_solver_SF_mod
       use string_mod
       use datatype_conversion_mod
       use mesh_domain_mod
       use IO_tools_mod
       use VF_mod
       use PCG_solver_VF_mod
       use TF_mod
       use mesh_mod
       use FFT_Solver_SF_mod
       use SF_mod
       use dir_manip_mod
       implicit none

       private
       public :: induction
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_induction;              end interface
       interface delete;                 module procedure delete_induction;                 end interface
       interface display;                module procedure display_induction;                end interface
       interface display_short;          module procedure display_short_induction;          end interface
       interface display;                module procedure display_wrap_induction;           end interface
       interface print;                  module procedure print_induction;                  end interface
       interface print_short;            module procedure print_short_induction;            end interface
       interface export;                 module procedure export_induction;                 end interface
       interface export_primitives;      module procedure export_primitives_induction;      end interface
       interface import;                 module procedure import_induction;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_induction;end interface
       interface export_structured;      module procedure export_structured_D_induction;    end interface
       interface import_structured;      module procedure import_structured_D_induction;    end interface
       interface import_primitives;      module procedure import_primitives_induction;      end interface
       interface export;                 module procedure export_wrap_induction;            end interface
       interface import;                 module procedure import_wrap_induction;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_induction;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_induction;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_induction;      end interface

       type induction
         logical :: suppress_warning = .false.
         type(mesh) :: m
         type(mesh) :: m_sigma
         type(PCG_Solver_VF) :: PCG_B
         type(PCG_Solver_SF) :: PCG_cleanB
         type(FFT_Solver_SF) :: FFT_cleanB
         type(TF) :: U_E
         type(TF) :: temp_E_TF
         type(TF) :: temp_F1_TF
         type(TF) :: temp_F2_TF
         type(TF) :: stresses
         type(TF) :: temp_CC_TF
         type(SF) :: sigmaInv_CC
         type(SF) :: cell_volume
         type(SF) :: divB
         type(SF) :: divJ
         type(SF) :: phi
         type(SF) :: temp_CC
         type(VF) :: F
         type(VF) :: Fnm1
         type(VF) :: L
         type(VF) :: J
         type(VF) :: temp_E
         type(VF) :: B
         type(VF) :: Bnm1
         type(VF) :: B0
         type(VF) :: Btot
         type(VF) :: B_interior
         type(VF) :: temp_F1
         type(VF) :: temp_F2
         type(VF) :: jCrossB
         type(VF) :: Bstar
         type(VF) :: dB0dt
         type(VF) :: sigmaInv_edge
         type(VF) :: J_interior
         type(VF) :: curlUCrossB
         type(VF) :: cell_inverse_area
         type(VF) :: CC_VF_fluid
         type(VF) :: CC_VF_sigma
         type(VF) :: temp_CC_VF
         type(mesh_domain) :: MD_fluid
         type(mesh_domain) :: MD_sigma
       end type

       contains

       subroutine init_copy_induction(this,that)
         implicit none
         type(induction),intent(inout) :: this
         type(induction),intent(in) :: that
         call delete(this)
         this%suppress_warning = that%suppress_warning
         call init(this%m,that%m)
         call init(this%m_sigma,that%m_sigma)
         call init(this%PCG_B,that%PCG_B)
         call init(this%PCG_cleanB,that%PCG_cleanB)
         call init(this%FFT_cleanB,that%FFT_cleanB)
         call init(this%U_E,that%U_E)
         call init(this%temp_E_TF,that%temp_E_TF)
         call init(this%temp_F1_TF,that%temp_F1_TF)
         call init(this%temp_F2_TF,that%temp_F2_TF)
         call init(this%stresses,that%stresses)
         call init(this%temp_CC_TF,that%temp_CC_TF)
         call init(this%sigmaInv_CC,that%sigmaInv_CC)
         call init(this%cell_volume,that%cell_volume)
         call init(this%divB,that%divB)
         call init(this%divJ,that%divJ)
         call init(this%phi,that%phi)
         call init(this%temp_CC,that%temp_CC)
         call init(this%F,that%F)
         call init(this%Fnm1,that%Fnm1)
         call init(this%L,that%L)
         call init(this%J,that%J)
         call init(this%temp_E,that%temp_E)
         call init(this%B,that%B)
         call init(this%Bnm1,that%Bnm1)
         call init(this%B0,that%B0)
         call init(this%Btot,that%Btot)
         call init(this%B_interior,that%B_interior)
         call init(this%temp_F1,that%temp_F1)
         call init(this%temp_F2,that%temp_F2)
         call init(this%jCrossB,that%jCrossB)
         call init(this%Bstar,that%Bstar)
         call init(this%dB0dt,that%dB0dt)
         call init(this%sigmaInv_edge,that%sigmaInv_edge)
         call init(this%J_interior,that%J_interior)
         call init(this%curlUCrossB,that%curlUCrossB)
         call init(this%cell_inverse_area,that%cell_inverse_area)
         call init(this%CC_VF_fluid,that%CC_VF_fluid)
         call init(this%CC_VF_sigma,that%CC_VF_sigma)
         call init(this%temp_CC_VF,that%temp_CC_VF)
         call init(this%MD_fluid,that%MD_fluid)
         call init(this%MD_sigma,that%MD_sigma)
       end subroutine

       subroutine delete_induction(this)
         implicit none
         type(induction),intent(inout) :: this
         this%suppress_warning = .false.
         call delete(this%m)
         call delete(this%m_sigma)
         call delete(this%PCG_B)
         call delete(this%PCG_cleanB)
         call delete(this%FFT_cleanB)
         call delete(this%U_E)
         call delete(this%temp_E_TF)
         call delete(this%temp_F1_TF)
         call delete(this%temp_F2_TF)
         call delete(this%stresses)
         call delete(this%temp_CC_TF)
         call delete(this%sigmaInv_CC)
         call delete(this%cell_volume)
         call delete(this%divB)
         call delete(this%divJ)
         call delete(this%phi)
         call delete(this%temp_CC)
         call delete(this%F)
         call delete(this%Fnm1)
         call delete(this%L)
         call delete(this%J)
         call delete(this%temp_E)
         call delete(this%B)
         call delete(this%Bnm1)
         call delete(this%B0)
         call delete(this%Btot)
         call delete(this%B_interior)
         call delete(this%temp_F1)
         call delete(this%temp_F2)
         call delete(this%jCrossB)
         call delete(this%Bstar)
         call delete(this%dB0dt)
         call delete(this%sigmaInv_edge)
         call delete(this%J_interior)
         call delete(this%curlUCrossB)
         call delete(this%cell_inverse_area)
         call delete(this%CC_VF_fluid)
         call delete(this%CC_VF_sigma)
         call delete(this%temp_CC_VF)
         call delete(this%MD_fluid)
         call delete(this%MD_sigma)
       end subroutine

       subroutine display_induction(this,un)
         implicit none
         type(induction),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning  = ',this%suppress_warning
         call display(this%m,un)
         call display(this%m_sigma,un)
         call display(this%PCG_B,un)
         call display(this%PCG_cleanB,un)
         call display(this%FFT_cleanB,un)
         call display(this%U_E,un)
         call display(this%temp_E_TF,un)
         call display(this%temp_F1_TF,un)
         call display(this%temp_F2_TF,un)
         call display(this%stresses,un)
         call display(this%temp_CC_TF,un)
         call display(this%sigmaInv_CC,un)
         call display(this%cell_volume,un)
         call display(this%divB,un)
         call display(this%divJ,un)
         call display(this%phi,un)
         call display(this%temp_CC,un)
         call display(this%F,un)
         call display(this%Fnm1,un)
         call display(this%L,un)
         call display(this%J,un)
         call display(this%temp_E,un)
         call display(this%B,un)
         call display(this%Bnm1,un)
         call display(this%B0,un)
         call display(this%Btot,un)
         call display(this%B_interior,un)
         call display(this%temp_F1,un)
         call display(this%temp_F2,un)
         call display(this%jCrossB,un)
         call display(this%Bstar,un)
         call display(this%dB0dt,un)
         call display(this%sigmaInv_edge,un)
         call display(this%J_interior,un)
         call display(this%curlUCrossB,un)
         call display(this%cell_inverse_area,un)
         call display(this%CC_VF_fluid,un)
         call display(this%CC_VF_sigma,un)
         call display(this%temp_CC_VF,un)
         call display(this%MD_fluid,un)
         call display(this%MD_sigma,un)
       end subroutine

       subroutine display_short_induction(this,un)
         implicit none
         type(induction),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning  = ',this%suppress_warning
         call display(this%m,un)
         call display(this%m_sigma,un)
         call display(this%PCG_B,un)
         call display(this%PCG_cleanB,un)
         call display(this%FFT_cleanB,un)
         call display(this%U_E,un)
         call display(this%temp_E_TF,un)
         call display(this%temp_F1_TF,un)
         call display(this%temp_F2_TF,un)
         call display(this%stresses,un)
         call display(this%temp_CC_TF,un)
         call display(this%sigmaInv_CC,un)
         call display(this%cell_volume,un)
         call display(this%divB,un)
         call display(this%divJ,un)
         call display(this%phi,un)
         call display(this%temp_CC,un)
         call display(this%F,un)
         call display(this%Fnm1,un)
         call display(this%L,un)
         call display(this%J,un)
         call display(this%temp_E,un)
         call display(this%B,un)
         call display(this%Bnm1,un)
         call display(this%B0,un)
         call display(this%Btot,un)
         call display(this%B_interior,un)
         call display(this%temp_F1,un)
         call display(this%temp_F2,un)
         call display(this%jCrossB,un)
         call display(this%Bstar,un)
         call display(this%dB0dt,un)
         call display(this%sigmaInv_edge,un)
         call display(this%J_interior,un)
         call display(this%curlUCrossB,un)
         call display(this%cell_inverse_area,un)
         call display(this%CC_VF_fluid,un)
         call display(this%CC_VF_sigma,un)
         call display(this%temp_CC_VF,un)
         call display(this%MD_fluid,un)
         call display(this%MD_sigma,un)
       end subroutine

       subroutine display_wrap_induction(this,dir,name)
         implicit none
         type(induction),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_induction(this)
         implicit none
         type(induction),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_induction(this)
         implicit none
         type(induction),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_induction(this,un)
         implicit none
         type(induction),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%m,un)
         call export(this%m_sigma,un)
         call export(this%PCG_B,un)
         call export(this%PCG_cleanB,un)
         call export(this%FFT_cleanB,un)
         call export(this%U_E,un)
         call export(this%temp_E_TF,un)
         call export(this%temp_F1_TF,un)
         call export(this%temp_F2_TF,un)
         call export(this%stresses,un)
         call export(this%temp_CC_TF,un)
         call export(this%sigmaInv_CC,un)
         call export(this%cell_volume,un)
         call export(this%divB,un)
         call export(this%divJ,un)
         call export(this%phi,un)
         call export(this%temp_CC,un)
         call export(this%F,un)
         call export(this%Fnm1,un)
         call export(this%L,un)
         call export(this%J,un)
         call export(this%temp_E,un)
         call export(this%B,un)
         call export(this%Bnm1,un)
         call export(this%B0,un)
         call export(this%Btot,un)
         call export(this%B_interior,un)
         call export(this%temp_F1,un)
         call export(this%temp_F2,un)
         call export(this%jCrossB,un)
         call export(this%Bstar,un)
         call export(this%dB0dt,un)
         call export(this%sigmaInv_edge,un)
         call export(this%J_interior,un)
         call export(this%curlUCrossB,un)
         call export(this%cell_inverse_area,un)
         call export(this%CC_VF_fluid,un)
         call export(this%CC_VF_sigma,un)
         call export(this%temp_CC_VF,un)
         call export(this%MD_fluid,un)
         call export(this%MD_sigma,un)
       end subroutine

       subroutine import_induction(this,un)
         implicit none
         type(induction),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%m,un)
         call import(this%m_sigma,un)
         call import(this%PCG_B,un)
         call import(this%PCG_cleanB,un)
         call import(this%FFT_cleanB,un)
         call import(this%U_E,un)
         call import(this%temp_E_TF,un)
         call import(this%temp_F1_TF,un)
         call import(this%temp_F2_TF,un)
         call import(this%stresses,un)
         call import(this%temp_CC_TF,un)
         call import(this%sigmaInv_CC,un)
         call import(this%cell_volume,un)
         call import(this%divB,un)
         call import(this%divJ,un)
         call import(this%phi,un)
         call import(this%temp_CC,un)
         call import(this%F,un)
         call import(this%Fnm1,un)
         call import(this%L,un)
         call import(this%J,un)
         call import(this%temp_E,un)
         call import(this%B,un)
         call import(this%Bnm1,un)
         call import(this%B0,un)
         call import(this%Btot,un)
         call import(this%B_interior,un)
         call import(this%temp_F1,un)
         call import(this%temp_F2,un)
         call import(this%jCrossB,un)
         call import(this%Bstar,un)
         call import(this%dB0dt,un)
         call import(this%sigmaInv_edge,un)
         call import(this%J_interior,un)
         call import(this%curlUCrossB,un)
         call import(this%cell_inverse_area,un)
         call import(this%CC_VF_fluid,un)
         call import(this%CC_VF_sigma,un)
         call import(this%temp_CC_VF,un)
         call import(this%MD_fluid,un)
         call import(this%MD_sigma,un)
       end subroutine

       subroutine export_primitives_induction(this,un)
         implicit none
         type(induction),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning   = ';write(un,*) this%suppress_warning
       end subroutine

       subroutine import_primitives_induction(this,un)
         implicit none
         type(induction),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%suppress_warning
       end subroutine

       subroutine export_wrap_induction(this,dir,name)
         implicit none
         type(induction),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_induction(this,dir,name)
         implicit none
         type(induction),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_induction(this,dir)
         implicit none
         type(induction),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%PCG_B,dir//'PCG_B'//fortran_PS)
         call set_IO_dir(this%PCG_cleanB,dir//'PCG_cleanB'//fortran_PS)
         call set_IO_dir(this%FFT_cleanB,dir//'FFT_cleanB'//fortran_PS)
         call set_IO_dir(this%sigmaInv_CC,dir//'sigmaInv_CC'//fortran_PS)
         call set_IO_dir(this%cell_volume,dir//'cell_volume'//fortran_PS)
         call set_IO_dir(this%divB,dir//'divB'//fortran_PS)
         call set_IO_dir(this%divJ,dir//'divJ'//fortran_PS)
         call set_IO_dir(this%phi,dir//'phi'//fortran_PS)
         call set_IO_dir(this%temp_CC,dir//'temp_CC'//fortran_PS)
         call set_IO_dir(this%F,dir//'F'//fortran_PS)
         call set_IO_dir(this%Fnm1,dir//'Fnm1'//fortran_PS)
         call set_IO_dir(this%L,dir//'L'//fortran_PS)
         call set_IO_dir(this%J,dir//'J'//fortran_PS)
         call set_IO_dir(this%temp_E,dir//'temp_E'//fortran_PS)
         call set_IO_dir(this%B,dir//'B'//fortran_PS)
         call set_IO_dir(this%Bnm1,dir//'Bnm1'//fortran_PS)
         call set_IO_dir(this%B0,dir//'B0'//fortran_PS)
         call set_IO_dir(this%Btot,dir//'Btot'//fortran_PS)
         call set_IO_dir(this%B_interior,dir//'B_interior'//fortran_PS)
         call set_IO_dir(this%temp_F1,dir//'temp_F1'//fortran_PS)
         call set_IO_dir(this%temp_F2,dir//'temp_F2'//fortran_PS)
         call set_IO_dir(this%jCrossB,dir//'jCrossB'//fortran_PS)
         call set_IO_dir(this%Bstar,dir//'Bstar'//fortran_PS)
         call set_IO_dir(this%dB0dt,dir//'dB0dt'//fortran_PS)
         call set_IO_dir(this%sigmaInv_edge,&
         dir//'sigmaInv_edge'//fortran_PS)
         call set_IO_dir(this%J_interior,dir//'J_interior'//fortran_PS)
         call set_IO_dir(this%curlUCrossB,dir//'curlUCrossB'//fortran_PS)
         call set_IO_dir(this%cell_inverse_area,&
         dir//'cell_inverse_area'//fortran_PS)
         call set_IO_dir(this%CC_VF_fluid,dir//'CC_VF_fluid'//fortran_PS)
         call set_IO_dir(this%CC_VF_sigma,dir//'CC_VF_sigma'//fortran_PS)
         call set_IO_dir(this%temp_CC_VF,dir//'temp_CC_VF'//fortran_PS)
         call set_IO_dir(this%MD_fluid,dir//'MD_fluid'//fortran_PS)
         call set_IO_dir(this%MD_sigma,dir//'MD_sigma'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_induction(this,dir)
         implicit none
         type(induction),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%PCG_B,dir//'PCG_B'//fortran_PS)
         call make_IO_dir(this%PCG_cleanB,dir//'PCG_cleanB'//fortran_PS)
         call make_IO_dir(this%FFT_cleanB,dir//'FFT_cleanB'//fortran_PS)
         if (get_necessary_for_restart(this%sigmaInv_CC)) then
           call make_IO_dir(this%sigmaInv_CC,dir//'sigmaInv_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%cell_volume)) then
           call make_IO_dir(this%cell_volume,dir//'cell_volume'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divB)) then
           call make_IO_dir(this%divB,dir//'divB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divJ)) then
           call make_IO_dir(this%divJ,dir//'divJ'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%phi)) then
           call make_IO_dir(this%phi,dir//'phi'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC)) then
           call make_IO_dir(this%temp_CC,dir//'temp_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call make_IO_dir(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call make_IO_dir(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call make_IO_dir(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%J)) then
           call make_IO_dir(this%J,dir//'J'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_E)) then
           call make_IO_dir(this%temp_E,dir//'temp_E'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B)) then
           call make_IO_dir(this%B,dir//'B'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Bnm1)) then
           call make_IO_dir(this%Bnm1,dir//'Bnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B0)) then
           call make_IO_dir(this%B0,dir//'B0'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Btot)) then
           call make_IO_dir(this%Btot,dir//'Btot'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B_interior)) then
           call make_IO_dir(this%B_interior,dir//'B_interior'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F1)) then
           call make_IO_dir(this%temp_F1,dir//'temp_F1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F2)) then
           call make_IO_dir(this%temp_F2,dir//'temp_F2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%jCrossB)) then
           call make_IO_dir(this%jCrossB,dir//'jCrossB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Bstar)) then
           call make_IO_dir(this%Bstar,dir//'Bstar'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%dB0dt)) then
           call make_IO_dir(this%dB0dt,dir//'dB0dt'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%sigmaInv_edge)) then
           call make_IO_dir(this%sigmaInv_edge,&
           dir//'sigmaInv_edge'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%J_interior)) then
           call make_IO_dir(this%J_interior,dir//'J_interior'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%curlUCrossB)) then
           call make_IO_dir(this%curlUCrossB,dir//'curlUCrossB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%cell_inverse_area)) then
           call make_IO_dir(this%cell_inverse_area,&
           dir//'cell_inverse_area'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%CC_VF_fluid)) then
           call make_IO_dir(this%CC_VF_fluid,dir//'CC_VF_fluid'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%CC_VF_sigma)) then
           call make_IO_dir(this%CC_VF_sigma,dir//'CC_VF_sigma'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC_VF)) then
           call make_IO_dir(this%temp_CC_VF,dir//'temp_CC_VF'//fortran_PS)
         endif
         call make_IO_dir(this%MD_fluid,dir//'MD_fluid'//fortran_PS)
         call make_IO_dir(this%MD_sigma,dir//'MD_sigma'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_induction(this,dir)
         implicit none
         type(induction),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%PCG_B,dir//'PCG_B'//fortran_PS)
         call export_structured(this%PCG_cleanB,&
         dir//'PCG_cleanB'//fortran_PS)
         call export_structured(this%FFT_cleanB,&
         dir//'FFT_cleanB'//fortran_PS)
         if (get_necessary_for_restart(this%sigmaInv_CC)) then
           call export_structured(this%sigmaInv_CC,&
           dir//'sigmaInv_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%cell_volume)) then
           call export_structured(this%cell_volume,&
           dir//'cell_volume'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divB)) then
           call export_structured(this%divB,dir//'divB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divJ)) then
           call export_structured(this%divJ,dir//'divJ'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%phi)) then
           call export_structured(this%phi,dir//'phi'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC)) then
           call export_structured(this%temp_CC,dir//'temp_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call export_structured(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call export_structured(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call export_structured(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%J)) then
           call export_structured(this%J,dir//'J'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_E)) then
           call export_structured(this%temp_E,dir//'temp_E'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B)) then
           call export_structured(this%B,dir//'B'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Bnm1)) then
           call export_structured(this%Bnm1,dir//'Bnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B0)) then
           call export_structured(this%B0,dir//'B0'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Btot)) then
           call export_structured(this%Btot,dir//'Btot'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B_interior)) then
           call export_structured(this%B_interior,&
           dir//'B_interior'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F1)) then
           call export_structured(this%temp_F1,dir//'temp_F1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F2)) then
           call export_structured(this%temp_F2,dir//'temp_F2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%jCrossB)) then
           call export_structured(this%jCrossB,dir//'jCrossB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Bstar)) then
           call export_structured(this%Bstar,dir//'Bstar'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%dB0dt)) then
           call export_structured(this%dB0dt,dir//'dB0dt'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%sigmaInv_edge)) then
           call export_structured(this%sigmaInv_edge,&
           dir//'sigmaInv_edge'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%J_interior)) then
           call export_structured(this%J_interior,&
           dir//'J_interior'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%curlUCrossB)) then
           call export_structured(this%curlUCrossB,&
           dir//'curlUCrossB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%cell_inverse_area)) then
           call export_structured(this%cell_inverse_area,&
           dir//'cell_inverse_area'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%CC_VF_fluid)) then
           call export_structured(this%CC_VF_fluid,&
           dir//'CC_VF_fluid'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%CC_VF_sigma)) then
           call export_structured(this%CC_VF_sigma,&
           dir//'CC_VF_sigma'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC_VF)) then
           call export_structured(this%temp_CC_VF,&
           dir//'temp_CC_VF'//fortran_PS)
         endif
         call export_structured(this%MD_fluid,dir//'MD_fluid'//fortran_PS)
         call export_structured(this%MD_sigma,dir//'MD_sigma'//fortran_PS)
       end subroutine

       subroutine export_structured_D_induction(this,dir)
         implicit none
         type(induction),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%PCG_B,dir//'PCG_B'//fortran_PS)
         call export_structured(this%PCG_cleanB,&
         dir//'PCG_cleanB'//fortran_PS)
         call export_structured(this%FFT_cleanB,&
         dir//'FFT_cleanB'//fortran_PS)
         if (get_necessary_for_restart(this%sigmaInv_CC)) then
           call export_structured(this%sigmaInv_CC,&
           dir//'sigmaInv_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%cell_volume)) then
           call export_structured(this%cell_volume,&
           dir//'cell_volume'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divB)) then
           call export_structured(this%divB,dir//'divB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divJ)) then
           call export_structured(this%divJ,dir//'divJ'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%phi)) then
           call export_structured(this%phi,dir//'phi'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC)) then
           call export_structured(this%temp_CC,dir//'temp_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call export_structured(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call export_structured(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call export_structured(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%J)) then
           call export_structured(this%J,dir//'J'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_E)) then
           call export_structured(this%temp_E,dir//'temp_E'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B)) then
           call export_structured(this%B,dir//'B'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Bnm1)) then
           call export_structured(this%Bnm1,dir//'Bnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B0)) then
           call export_structured(this%B0,dir//'B0'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Btot)) then
           call export_structured(this%Btot,dir//'Btot'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B_interior)) then
           call export_structured(this%B_interior,&
           dir//'B_interior'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F1)) then
           call export_structured(this%temp_F1,dir//'temp_F1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F2)) then
           call export_structured(this%temp_F2,dir//'temp_F2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%jCrossB)) then
           call export_structured(this%jCrossB,dir//'jCrossB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Bstar)) then
           call export_structured(this%Bstar,dir//'Bstar'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%dB0dt)) then
           call export_structured(this%dB0dt,dir//'dB0dt'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%sigmaInv_edge)) then
           call export_structured(this%sigmaInv_edge,&
           dir//'sigmaInv_edge'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%J_interior)) then
           call export_structured(this%J_interior,&
           dir//'J_interior'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%curlUCrossB)) then
           call export_structured(this%curlUCrossB,&
           dir//'curlUCrossB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%cell_inverse_area)) then
           call export_structured(this%cell_inverse_area,&
           dir//'cell_inverse_area'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%CC_VF_fluid)) then
           call export_structured(this%CC_VF_fluid,&
           dir//'CC_VF_fluid'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%CC_VF_sigma)) then
           call export_structured(this%CC_VF_sigma,&
           dir//'CC_VF_sigma'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC_VF)) then
           call export_structured(this%temp_CC_VF,&
           dir//'temp_CC_VF'//fortran_PS)
         endif
         call export_structured(this%MD_fluid,dir//'MD_fluid'//fortran_PS)
         call export_structured(this%MD_sigma,dir//'MD_sigma'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_induction(this,dir)
         implicit none
         type(induction),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%PCG_B,dir//'PCG_B'//fortran_PS)
         call import_structured(this%PCG_cleanB,&
         dir//'PCG_cleanB'//fortran_PS)
         call import_structured(this%FFT_cleanB,&
         dir//'FFT_cleanB'//fortran_PS)
         if (get_necessary_for_restart(this%sigmaInv_CC)) then
           call import_structured(this%sigmaInv_CC,&
           dir//'sigmaInv_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%cell_volume)) then
           call import_structured(this%cell_volume,&
           dir//'cell_volume'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divB)) then
           call import_structured(this%divB,dir//'divB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divJ)) then
           call import_structured(this%divJ,dir//'divJ'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%phi)) then
           call import_structured(this%phi,dir//'phi'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC)) then
           call import_structured(this%temp_CC,dir//'temp_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call import_structured(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call import_structured(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call import_structured(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%J)) then
           call import_structured(this%J,dir//'J'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_E)) then
           call import_structured(this%temp_E,dir//'temp_E'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B)) then
           call import_structured(this%B,dir//'B'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Bnm1)) then
           call import_structured(this%Bnm1,dir//'Bnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B0)) then
           call import_structured(this%B0,dir//'B0'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Btot)) then
           call import_structured(this%Btot,dir//'Btot'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%B_interior)) then
           call import_structured(this%B_interior,&
           dir//'B_interior'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F1)) then
           call import_structured(this%temp_F1,dir//'temp_F1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F2)) then
           call import_structured(this%temp_F2,dir//'temp_F2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%jCrossB)) then
           call import_structured(this%jCrossB,dir//'jCrossB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Bstar)) then
           call import_structured(this%Bstar,dir//'Bstar'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%dB0dt)) then
           call import_structured(this%dB0dt,dir//'dB0dt'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%sigmaInv_edge)) then
           call import_structured(this%sigmaInv_edge,&
           dir//'sigmaInv_edge'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%J_interior)) then
           call import_structured(this%J_interior,&
           dir//'J_interior'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%curlUCrossB)) then
           call import_structured(this%curlUCrossB,&
           dir//'curlUCrossB'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%cell_inverse_area)) then
           call import_structured(this%cell_inverse_area,&
           dir//'cell_inverse_area'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%CC_VF_fluid)) then
           call import_structured(this%CC_VF_fluid,&
           dir//'CC_VF_fluid'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%CC_VF_sigma)) then
           call import_structured(this%CC_VF_sigma,&
           dir//'CC_VF_sigma'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC_VF)) then
           call import_structured(this%temp_CC_VF,&
           dir//'temp_CC_VF'//fortran_PS)
         endif
         call import_structured(this%MD_fluid,dir//'MD_fluid'//fortran_PS)
         call import_structured(this%MD_sigma,dir//'MD_sigma'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_induction(this)
         implicit none
         type(induction),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module init_B0_field_mod
       use current_precision_mod
       use grid_mod
       use GF_mod
       use mesh_extend_mod
       use VF_extend_mod
       use IO_import_mod
       use sim_params_mod
       implicit none

       private
       public :: init_B0_field

       contains

       subroutine init_B0_field(B0,m,SP)
         implicit none
         type(VF),intent(inout) :: B0
         type(mesh),intent(in) :: m
         type(sim_params),intent(in) :: SP
         integer :: preset_ID

         call assign(B0,0.0_cp)
         preset_ID = SP%VS%B0%IC
         ! preset_ID = 0 ! manual override

         select case(preset_ID)
         case (0)
         case (1); call uniform_B_field(B0,SP%SCP%uniform_B0_dir)
         case (2); call initFringingField_Sergey(B0,m,3,1)
         case (3); call initFringingField_ALEX(B0,m,3,1)
         case (4); call init_Field_Bandaru(B0,m,2)
         case default; stop 'Error: bad preset_ID in init_B0_field.f90'
         end select
       end subroutine

       subroutine uniform_B_field(B,dir)
         implicit none
         type(VF),intent(inout) :: B
         integer,intent(in) :: dir
         call assign(B,0.0_cp)
         select case (dir)
         case (0)
         case (1); call assign(B%x,1.0_cp)
         case (2); call assign(B%y,1.0_cp)
         case (3); call assign(B%z,1.0_cp)
         case (4); call assign(B,1.0_cp)
         case default
         stop 'Error: dir must = 1,2,3 in uniform_B_field.'
         end select
       end subroutine

       subroutine initFringingField_Sergey(B,m,applied_dir,fringeDir)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(inout) :: B
         integer,intent(in) :: applied_dir,fringeDir
         select case (applied_dir)
         case (1); call init_Fringe_Sergey(B%x%BF(1)%GF,m%B(1)%g,fringeDir)
         case (2); call init_Fringe_Sergey(B%y%BF(1)%GF,m%B(1)%g,fringeDir)
         case (3); call init_Fringe_Sergey(B%z%BF(1)%GF,m%B(1)%g,fringeDir)
         case default
         stop 'Error: applied_dir must = 1,2,3 in initFringingField_Sergey.'
         end select
       end subroutine

       subroutine init_Fringe_Sergey(B,g,dir)
         implicit none
         type(grid),intent(in) :: g
         type(grid_field),intent(inout) :: B
         integer,intent(in) :: dir
         type(grid_field) :: Btemp
         integer :: i2,i
         real(cp) :: d,Bstretch,Bshift,temp
         call init(Btemp,B)
         Bstretch = 0.2_cp; Bshift = 10.0_cp
         do i=1,B%s(dir)
           d = dble((g%c(dir)%hc%f(i)-Bshift)/Bstretch)
           temp = (1.0_cp+tanh(d))/2.0_cp
           call assign_plane(Btemp,temp,i,dir)
         enddo; i2 = 0
         call assign(B,Btemp)
         do i=1+(B%s(dir)-1)/2,B%s(dir)
          call assign_plane(B,Btemp,i,1+(B%s(dir)+1)/2-i2,dir); i2 = i2+1
         enddo
         call delete(Btemp)
       end subroutine

       subroutine init_Field_Bandaru(B,m,currentDir)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(inout) :: B
         integer,intent(in) :: currentDir
         call init_Field_Bandaru_GF(B%x%BF(1)%GF,&
                                    B%y%BF(1)%GF,&
                                    B%z%BF(1)%GF,m%B(1)%g,currentDir)
       end subroutine

       subroutine init_Field_Bandaru_GF(Bx,By,Bz,g,currentDir)
         implicit none
         type(grid_field),intent(inout) :: Bx,By,Bz
         type(grid),intent(in) :: g
         integer,intent(in) :: currentDir
         integer :: i,j,k
         real(cp) :: ka,cosh_ka ! kappa
         ka = 1.0_cp
         cosh_ka = cosh(ka)
         select case (currentDir)
         case (1);
           do i=1,By%s(1);do j=1,By%s(2);do k=1,By%s(3)
             By%f(i,j,k) = cos( ka*g%c(3)%hc%f(k)) * &
                           cosh(ka*g%c(2)%hn%f(j))/cosh_ka
           enddo;enddo;enddo
           do i=1,Bz%s(1);do j=1,Bz%s(2);do k=1,Bz%s(3)
             Bz%f(i,j,k) =-sin( ka*g%c(3)%hn%f(k)) * &
                           sinh(ka*g%c(2)%hc%f(j))/cosh_ka
           enddo;enddo;enddo
         case (2);
           do i=1,Bx%s(1);do j=1,Bx%s(2);do k=1,Bx%s(3)
             Bx%f(i,j,k) =-sin( ka*g%c(1)%hn%f(i)) * &
                           sinh(ka*g%c(3)%hc%f(k))/cosh_ka
           enddo;enddo;enddo
           do i=1,Bz%s(1);do j=1,Bz%s(2);do k=1,Bz%s(3)
             Bz%f(i,j,k) = cos( ka*g%c(1)%hc%f(i)) * &
                           cosh(ka*g%c(3)%hn%f(k))/cosh_ka
           enddo;enddo;enddo
         case (3);
           do i=1,Bx%s(1);do j=1,Bx%s(2);do k=1,Bx%s(3)
             Bx%f(i,j,k) = cos( ka*g%c(2)%hc%f(j)) * &
                           cosh(ka*g%c(1)%hn%f(i))/cosh_ka
           enddo;enddo;enddo
           do i=1,By%s(1);do j=1,By%s(2);do k=1,By%s(3)
             By%f(i,j,k) =-sin( ka*g%c(2)%hn%f(j)) * &
                           sinh(ka*g%c(1)%hc%f(i))/cosh_ka
           enddo;enddo;enddo
         case default
         stop 'Error: currentDir must = 1,2,3 in init_Field_Bandaru_GF in init_B0_field.'
         end select
       end subroutine

       subroutine initFringingField_ALEX(B,m,dir,fringeDir)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(inout) :: B
         integer,intent(in) :: dir,fringeDir
         select case (dir)
         case (1); call init_ALEX_Fringe(B%x%BF(1)%GF,m%B(1)%g,fringeDir)
         case (2); call init_ALEX_Fringe(B%y%BF(1)%GF,m%B(1)%g,fringeDir)
         case (3); call init_ALEX_Fringe(B%z%BF(1)%GF,m%B(1)%g,fringeDir)
         case default
         stop 'Error: dir must = 1,2,3 in initFringingField_ALEX.'
         end select
       end subroutine

       subroutine init_ALEX_Fringe(B0,g,dir)
         implicit none
         type(grid),intent(in) :: g
         type(grid_field),intent(inout) :: B0
         integer,intent(in) :: dir
         real(cp) :: d,temp,Bstretch,Bshift
         integer :: i
         Bstretch = 0.45_cp; Bshift = 12.5_cp
         do i=1,B0%s(dir)
           d = dble(g%c(dir)%hc%f(i)-Bshift*Bstretch)
           temp = 0.5_cp*(1.0_cp-tanh(d))
           call assign_plane(B0,temp,i,dir)
         enddo
       end subroutine

       end module
       module init_B_field_mod
       use current_precision_mod
       use grid_mod
       use mesh_extend_mod
       use VF_extend_mod
       use IO_import_mod
       use sim_params_mod
       implicit none

       private
       public :: init_B_field

       contains

       subroutine init_B_field(B,SP)
         implicit none
         type(VF),intent(inout) :: B
         type(sim_params),intent(in) :: SP
         integer :: preset_ID

         call initZeroField(B)

         preset_ID = SP%VS%B%IC
         ! preset_ID = 0 ! manual override

         select case(preset_ID)
         case (0)
         case default; stop 'Error: bad preset_ID in init_B_field.f90'
         end select
       end subroutine

       subroutine initZeroField(B)
         implicit none
         type(VF),intent(inout) :: B
         call assign(B,0.0_cp)
       end subroutine

       end module
       module init_B_interior_mod
       use current_precision_mod
       use mesh_extend_mod
       use mesh_domain_extend_mod
       use VF_extend_mod
       use IO_import_mod
       implicit none

       private
       public :: initB_interior

       contains

       subroutine initB_interior(B,m,MD,dir)
         implicit none
         type(VF),intent(inout) :: B
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         character(len=*),intent(in) :: dir
         type(mesh) :: temp
         call init_other(temp,m,MD)
         call import_3D_1C(temp,B%x,dir,'B_interior_f_x',0)
         call import_3D_1C(temp,B%y,dir,'B_interior_f_y',0)
         call import_3D_1C(temp,B%z,dir,'B_interior_f_z',0)
         call delete(temp)
       end subroutine

       end module
       module init_Bstar_field_mod
       use current_precision_mod
       use grid_mod
       use mesh_extend_mod
       use VF_extend_mod
       use IO_import_mod
       use sim_params_mod
       implicit none

       private
       public :: init_Bstar_field

       contains

       subroutine init_Bstar_field(Bstar,B)
         implicit none
         type(VF),intent(inout) :: Bstar
         type(VF),intent(in) :: B
         call assign(Bstar,B)
       end subroutine

       end module
       module init_J_interior_mod
       use current_precision_mod
       use mesh_extend_mod
       use mesh_domain_extend_mod
       use VF_extend_mod
       use IO_import_mod
       implicit none

       private
       public :: initJ_interior

       contains

       subroutine initJ_interior(J,m,MD,dir)
         implicit none
         type(VF),intent(inout) :: J
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         character(len=*),intent(in) :: dir
         type(mesh) :: temp
         call init_other(temp,m,MD)
         call import_3D_1C(temp,J%x,dir,'J_interior_e_x',0)
         call import_3D_1C(temp,J%y,dir,'J_interior_e_y',0)
         call import_3D_1C(temp,J%z,dir,'J_interior_e_z',0)
         call delete(temp)
       end subroutine

       end module
       module init_T_field_mod
       use current_precision_mod
       use SF_extend_mod
       use IO_import_mod
       use mesh_extend_mod
       use sim_params_mod
       implicit none

       private
       public :: init_T_field

       contains

       subroutine init_T_field(T,m,SP,dir)
         implicit none
         type(SF),intent(inout) :: T
         type(mesh),intent(in) :: m
         character(len=*),intent(in) :: dir
         type(sim_params),intent(in) :: SP
         integer :: preset_ID

         call assign(T,0.0_cp)

         preset_ID = SP%VS%T%IC
         if (SP%VS%T%SS%restart) then
               call restart_T(T,m,dir)
         else
           select case(preset_ID)
           case (0); call uniformTfield(T)
           case (1); call initUserTfield(T)
           case default; stop 'Error: bad preset_ID in init_T_field.f90'
           end select
         endif
       end subroutine

       subroutine restart_T(T,m,dir)
         implicit none
         character(len=*),intent(in) :: dir
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: T
         call import_3D_1C(m,T,dir,'Tc',0)
       end subroutine

       subroutine uniformTfield(T)
         implicit none
         type(SF),intent(inout) :: T
         call assign(T,0.0_cp)
       end subroutine

       subroutine initUserTfield(T)
         implicit none
         type(SF),intent(inout) :: T
         call uniformTfield(T)
       end subroutine

       end module
       module init_Ustar_field_mod
       use current_precision_mod
       use grid_mod
       use mesh_extend_mod
       use VF_extend_mod
       use IO_import_mod
       use sim_params_mod
       implicit none

       private
       public :: init_Ustar_field

       contains

       subroutine init_Ustar_field(Ustar,U)
         implicit none
         type(VF),intent(inout) :: Ustar
         type(VF),intent(in) :: U
         call assign(Ustar,U)
       end subroutine

       end module
       module init_gravity_field_mod
       use current_precision_mod
       use VF_extend_mod
       use IO_import_mod
       use mesh_extend_mod
       use sim_params_mod
       implicit none

       private
       public :: init_gravity_field

       contains

       subroutine init_gravity_field(gravity,m,SP,dir)
         implicit none
         type(VF),intent(inout) :: gravity
         type(mesh),intent(in) :: m
         character(len=*),intent(in) :: dir
         type(sim_params),intent(in) :: SP

         call assign(gravity,0.0_cp)

         if (SP%VS%T%SS%restart) then
           call restart_gravity(gravity,m,dir)
         else
           call uniform_gravity_field(gravity,SP%SCP%uniform_gravity_dir)
         endif
       end subroutine

       subroutine restart_gravity(gravity,m,dir)
         implicit none
         character(len=*),intent(in) :: dir
         type(mesh),intent(in) :: m
         type(VF),intent(inout) :: gravity
         call import_3D_1C(m,gravity%x,dir,'gravityf_x',0)
         call import_3D_1C(m,gravity%y,dir,'gravityf_y',0)
         call import_3D_1C(m,gravity%z,dir,'gravityf_z',0)
       end subroutine

       subroutine uniform_gravity_field(gravity,dir)
         implicit none
         type(VF),intent(inout) :: gravity
         integer,intent(in) :: dir
         select case(dir)
         case (1); call assign(gravity%x,1.0_cp)
         case (2); call assign(gravity%y,1.0_cp)
         case (3); call assign(gravity%z,1.0_cp)
         case default; stop 'Error: bad dir in uniform_gravity_field.f90'
         end select
       end subroutine

       end module
       module init_phi_field_mod
       use current_precision_mod
       use grid_mod
       use mesh_extend_mod
       use SF_extend_mod
       use IO_import_mod
       use sim_params_mod
       implicit none

       private
       public :: init_phi_field

       contains

       subroutine init_phi_field(phi,SP)
         implicit none
         type(SF),intent(inout) :: phi
         type(sim_params),intent(in) :: SP
         integer :: preset_ID

         call initZeroField(phi)

         preset_ID = SP%VS%phi%IC
         ! preset_ID = 0 ! manual override

         select case(preset_ID)
         case (0)
         case default; stop 'Error: bad preset_ID in init_phi_field.f90'
         end select
       end subroutine

       subroutine initZeroField(phi)
         implicit none
         type(SF),intent(inout) :: phi
         call assign(phi,0.0_cp)
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module momentum_mod
       use PCG_solver_SF_mod
       use string_mod
       use datatype_conversion_mod
       use time_statistics_VF_mod
       use IO_tools_mod
       use VF_mod
       use PCG_solver_VF_mod
       use TF_mod
       use mesh_mod
       use FFT_Solver_SF_mod
       use SF_mod
       use dir_manip_mod
       implicit none

       private
       public :: momentum
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings

       interface init;                   module procedure init_copy_momentum;              end interface
       interface delete;                 module procedure delete_momentum;                 end interface
       interface display;                module procedure display_momentum;                end interface
       interface display_short;          module procedure display_short_momentum;          end interface
       interface display;                module procedure display_wrap_momentum;           end interface
       interface print;                  module procedure print_momentum;                  end interface
       interface print_short;            module procedure print_short_momentum;            end interface
       interface export;                 module procedure export_momentum;                 end interface
       interface export_primitives;      module procedure export_primitives_momentum;      end interface
       interface import;                 module procedure import_momentum;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_momentum;end interface
       interface export_structured;      module procedure export_structured_D_momentum;    end interface
       interface import_structured;      module procedure import_structured_D_momentum;    end interface
       interface import_primitives;      module procedure import_primitives_momentum;      end interface
       interface export;                 module procedure export_wrap_momentum;            end interface
       interface import;                 module procedure import_wrap_momentum;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_momentum;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_momentum;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_momentum;      end interface

       type momentum
         logical :: suppress_warning = .false.
         type(mesh) :: m
         type(PCG_Solver_SF) :: PCG_P
         type(PCG_Solver_VF) :: PCG_U
         type(FFT_Solver_SF) :: FFT_P
         type(time_statistics_VF) :: TS
         type(SF) :: p
         type(SF) :: divU
         type(SF) :: temp_CC
         type(VF) :: U
         type(VF) :: Ustar
         type(VF) :: Unm1
         type(VF) :: U_CC
         type(VF) :: F
         type(VF) :: Fnm1
         type(VF) :: L
         type(VF) :: temp_F1
         type(VF) :: temp_F2
         type(VF) :: temp_F3
         type(VF) :: temp_E
         type(VF) :: temp_CC_VF
         type(TF) :: U_E
         type(TF) :: TF_CC
         type(TF) :: TF_CC_edge
       end type

       contains

       subroutine init_copy_momentum(this,that)
         implicit none
         type(momentum),intent(inout) :: this
         type(momentum),intent(in) :: that
         call delete(this)
         this%suppress_warning = that%suppress_warning
         call init(this%m,that%m)
         call init(this%PCG_P,that%PCG_P)
         call init(this%PCG_U,that%PCG_U)
         call init(this%FFT_P,that%FFT_P)
         call init(this%TS,that%TS)
         call init(this%p,that%p)
         call init(this%divU,that%divU)
         call init(this%temp_CC,that%temp_CC)
         call init(this%U,that%U)
         call init(this%Ustar,that%Ustar)
         call init(this%Unm1,that%Unm1)
         call init(this%U_CC,that%U_CC)
         call init(this%F,that%F)
         call init(this%Fnm1,that%Fnm1)
         call init(this%L,that%L)
         call init(this%temp_F1,that%temp_F1)
         call init(this%temp_F2,that%temp_F2)
         call init(this%temp_F3,that%temp_F3)
         call init(this%temp_E,that%temp_E)
         call init(this%temp_CC_VF,that%temp_CC_VF)
         call init(this%U_E,that%U_E)
         call init(this%TF_CC,that%TF_CC)
         call init(this%TF_CC_edge,that%TF_CC_edge)
       end subroutine

       subroutine delete_momentum(this)
         implicit none
         type(momentum),intent(inout) :: this
         this%suppress_warning = .false.
         call delete(this%m)
         call delete(this%PCG_P)
         call delete(this%PCG_U)
         call delete(this%FFT_P)
         call delete(this%TS)
         call delete(this%p)
         call delete(this%divU)
         call delete(this%temp_CC)
         call delete(this%U)
         call delete(this%Ustar)
         call delete(this%Unm1)
         call delete(this%U_CC)
         call delete(this%F)
         call delete(this%Fnm1)
         call delete(this%L)
         call delete(this%temp_F1)
         call delete(this%temp_F2)
         call delete(this%temp_F3)
         call delete(this%temp_E)
         call delete(this%temp_CC_VF)
         call delete(this%U_E)
         call delete(this%TF_CC)
         call delete(this%TF_CC_edge)
       end subroutine

       subroutine display_momentum(this,un)
         implicit none
         type(momentum),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning = ',this%suppress_warning
         call display(this%m,un)
         call display(this%PCG_P,un)
         call display(this%PCG_U,un)
         call display(this%FFT_P,un)
         call display(this%TS,un)
         call display(this%p,un)
         call display(this%divU,un)
         call display(this%temp_CC,un)
         call display(this%U,un)
         call display(this%Ustar,un)
         call display(this%Unm1,un)
         call display(this%U_CC,un)
         call display(this%F,un)
         call display(this%Fnm1,un)
         call display(this%L,un)
         call display(this%temp_F1,un)
         call display(this%temp_F2,un)
         call display(this%temp_F3,un)
         call display(this%temp_E,un)
         call display(this%temp_CC_VF,un)
         call display(this%U_E,un)
         call display(this%TF_CC,un)
         call display(this%TF_CC_edge,un)
       end subroutine

       subroutine display_short_momentum(this,un)
         implicit none
         type(momentum),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning = ',this%suppress_warning
         call display(this%m,un)
         call display(this%PCG_P,un)
         call display(this%PCG_U,un)
         call display(this%FFT_P,un)
         call display(this%TS,un)
         call display(this%p,un)
         call display(this%divU,un)
         call display(this%temp_CC,un)
         call display(this%U,un)
         call display(this%Ustar,un)
         call display(this%Unm1,un)
         call display(this%U_CC,un)
         call display(this%F,un)
         call display(this%Fnm1,un)
         call display(this%L,un)
         call display(this%temp_F1,un)
         call display(this%temp_F2,un)
         call display(this%temp_F3,un)
         call display(this%temp_E,un)
         call display(this%temp_CC_VF,un)
         call display(this%U_E,un)
         call display(this%TF_CC,un)
         call display(this%TF_CC_edge,un)
       end subroutine

       subroutine display_wrap_momentum(this,dir,name)
         implicit none
         type(momentum),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_momentum(this)
         implicit none
         type(momentum),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_momentum(this)
         implicit none
         type(momentum),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_momentum(this,un)
         implicit none
         type(momentum),intent(in) :: this
         integer,intent(in) :: un
         call export_primitives(this,un)
         call export(this%m,un)
         call export(this%PCG_P,un)
         call export(this%PCG_U,un)
         call export(this%FFT_P,un)
         call export(this%TS,un)
         call export(this%p,un)
         call export(this%divU,un)
         call export(this%temp_CC,un)
         call export(this%U,un)
         call export(this%Ustar,un)
         call export(this%Unm1,un)
         call export(this%U_CC,un)
         call export(this%F,un)
         call export(this%Fnm1,un)
         call export(this%L,un)
         call export(this%temp_F1,un)
         call export(this%temp_F2,un)
         call export(this%temp_F3,un)
         call export(this%temp_E,un)
         call export(this%temp_CC_VF,un)
         call export(this%U_E,un)
         call export(this%TF_CC,un)
         call export(this%TF_CC_edge,un)
       end subroutine

       subroutine import_momentum(this,un)
         implicit none
         type(momentum),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import_primitives(this,un)
         call import(this%m,un)
         call import(this%PCG_P,un)
         call import(this%PCG_U,un)
         call import(this%FFT_P,un)
         call import(this%TS,un)
         call import(this%p,un)
         call import(this%divU,un)
         call import(this%temp_CC,un)
         call import(this%U,un)
         call import(this%Ustar,un)
         call import(this%Unm1,un)
         call import(this%U_CC,un)
         call import(this%F,un)
         call import(this%Fnm1,un)
         call import(this%L,un)
         call import(this%temp_F1,un)
         call import(this%temp_F2,un)
         call import(this%temp_F3,un)
         call import(this%temp_E,un)
         call import(this%temp_CC_VF,un)
         call import(this%U_E,un)
         call import(this%TF_CC,un)
         call import(this%TF_CC_edge,un)
       end subroutine

       subroutine export_primitives_momentum(this,un)
         implicit none
         type(momentum),intent(in) :: this
         integer,intent(in) :: un
         write(un,*) 'suppress_warning  = ';write(un,*) this%suppress_warning
       end subroutine

       subroutine import_primitives_momentum(this,un)
         implicit none
         type(momentum),intent(inout) :: this
         integer,intent(in) :: un
         read(un,*); read(un,*) this%suppress_warning
       end subroutine

       subroutine export_wrap_momentum(this,dir,name)
         implicit none
         type(momentum),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_momentum(this,dir,name)
         implicit none
         type(momentum),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine set_IO_dir_momentum(this,dir)
         implicit none
         type(momentum),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call set_IO_dir(this%PCG_P,dir//'PCG_P'//fortran_PS)
         call set_IO_dir(this%PCG_U,dir//'PCG_U'//fortran_PS)
         call set_IO_dir(this%FFT_P,dir//'FFT_P'//fortran_PS)
         call set_IO_dir(this%TS,dir//'TS'//fortran_PS)
         call set_IO_dir(this%p,dir//'p'//fortran_PS)
         call set_IO_dir(this%divU,dir//'divU'//fortran_PS)
         call set_IO_dir(this%temp_CC,dir//'temp_CC'//fortran_PS)
         call set_IO_dir(this%U,dir//'U'//fortran_PS)
         call set_IO_dir(this%Ustar,dir//'Ustar'//fortran_PS)
         call set_IO_dir(this%Unm1,dir//'Unm1'//fortran_PS)
         call set_IO_dir(this%U_CC,dir//'U_CC'//fortran_PS)
         call set_IO_dir(this%F,dir//'F'//fortran_PS)
         call set_IO_dir(this%Fnm1,dir//'Fnm1'//fortran_PS)
         call set_IO_dir(this%L,dir//'L'//fortran_PS)
         call set_IO_dir(this%temp_F1,dir//'temp_F1'//fortran_PS)
         call set_IO_dir(this%temp_F2,dir//'temp_F2'//fortran_PS)
         call set_IO_dir(this%temp_F3,dir//'temp_F3'//fortran_PS)
         call set_IO_dir(this%temp_E,dir//'temp_E'//fortran_PS)
         call set_IO_dir(this%temp_CC_VF,dir//'temp_CC_VF'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_momentum(this,dir)
         implicit none
         type(momentum),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call make_IO_dir(this%PCG_P,dir//'PCG_P'//fortran_PS)
         call make_IO_dir(this%PCG_U,dir//'PCG_U'//fortran_PS)
         call make_IO_dir(this%FFT_P,dir//'FFT_P'//fortran_PS)
         call make_IO_dir(this%TS,dir//'TS'//fortran_PS)
         if (get_necessary_for_restart(this%p)) then
           call make_IO_dir(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divU)) then
           call make_IO_dir(this%divU,dir//'divU'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC)) then
           call make_IO_dir(this%temp_CC,dir//'temp_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U)) then
           call make_IO_dir(this%U,dir//'U'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ustar)) then
           call make_IO_dir(this%Ustar,dir//'Ustar'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Unm1)) then
           call make_IO_dir(this%Unm1,dir//'Unm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_CC)) then
           call make_IO_dir(this%U_CC,dir//'U_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call make_IO_dir(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call make_IO_dir(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call make_IO_dir(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F1)) then
           call make_IO_dir(this%temp_F1,dir//'temp_F1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F2)) then
           call make_IO_dir(this%temp_F2,dir//'temp_F2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F3)) then
           call make_IO_dir(this%temp_F3,dir//'temp_F3'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_E)) then
           call make_IO_dir(this%temp_E,dir//'temp_E'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC_VF)) then
           call make_IO_dir(this%temp_CC_VF,dir//'temp_CC_VF'//fortran_PS)
         endif
       end subroutine

       subroutine export_folder_structure_momentum(this,dir)
         implicit none
         type(momentum),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%PCG_P,dir//'PCG_P'//fortran_PS)
         call export_structured(this%PCG_U,dir//'PCG_U'//fortran_PS)
         call export_structured(this%FFT_P,dir//'FFT_P'//fortran_PS)
         call export_structured(this%TS,dir//'TS'//fortran_PS)
         if (get_necessary_for_restart(this%p)) then
           call export_structured(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divU)) then
           call export_structured(this%divU,dir//'divU'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC)) then
           call export_structured(this%temp_CC,dir//'temp_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U)) then
           call export_structured(this%U,dir//'U'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ustar)) then
           call export_structured(this%Ustar,dir//'Ustar'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Unm1)) then
           call export_structured(this%Unm1,dir//'Unm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_CC)) then
           call export_structured(this%U_CC,dir//'U_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call export_structured(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call export_structured(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call export_structured(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F1)) then
           call export_structured(this%temp_F1,dir//'temp_F1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F2)) then
           call export_structured(this%temp_F2,dir//'temp_F2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F3)) then
           call export_structured(this%temp_F3,dir//'temp_F3'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_E)) then
           call export_structured(this%temp_E,dir//'temp_E'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC_VF)) then
           call export_structured(this%temp_CC_VF,&
           dir//'temp_CC_VF'//fortran_PS)
         endif
       end subroutine

       subroutine export_structured_D_momentum(this,dir)
         implicit none
         type(momentum),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%PCG_P,dir//'PCG_P'//fortran_PS)
         call export_structured(this%PCG_U,dir//'PCG_U'//fortran_PS)
         call export_structured(this%FFT_P,dir//'FFT_P'//fortran_PS)
         call export_structured(this%TS,dir//'TS'//fortran_PS)
         if (get_necessary_for_restart(this%p)) then
           call export_structured(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divU)) then
           call export_structured(this%divU,dir//'divU'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC)) then
           call export_structured(this%temp_CC,dir//'temp_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U)) then
           call export_structured(this%U,dir//'U'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ustar)) then
           call export_structured(this%Ustar,dir//'Ustar'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Unm1)) then
           call export_structured(this%Unm1,dir//'Unm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_CC)) then
           call export_structured(this%U_CC,dir//'U_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call export_structured(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call export_structured(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call export_structured(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F1)) then
           call export_structured(this%temp_F1,dir//'temp_F1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F2)) then
           call export_structured(this%temp_F2,dir//'temp_F2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F3)) then
           call export_structured(this%temp_F3,dir//'temp_F3'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_E)) then
           call export_structured(this%temp_E,dir//'temp_E'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC_VF)) then
           call export_structured(this%temp_CC_VF,&
           dir//'temp_CC_VF'//fortran_PS)
         endif
         close(un)
       end subroutine

       subroutine import_structured_D_momentum(this,dir)
         implicit none
         type(momentum),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%PCG_P,dir//'PCG_P'//fortran_PS)
         call import_structured(this%PCG_U,dir//'PCG_U'//fortran_PS)
         call import_structured(this%FFT_P,dir//'FFT_P'//fortran_PS)
         call import_structured(this%TS,dir//'TS'//fortran_PS)
         if (get_necessary_for_restart(this%p)) then
           call import_structured(this%p,dir//'p'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%divU)) then
           call import_structured(this%divU,dir//'divU'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC)) then
           call import_structured(this%temp_CC,dir//'temp_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U)) then
           call import_structured(this%U,dir//'U'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Ustar)) then
           call import_structured(this%Ustar,dir//'Ustar'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Unm1)) then
           call import_structured(this%Unm1,dir//'Unm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%U_CC)) then
           call import_structured(this%U_CC,dir//'U_CC'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%F)) then
           call import_structured(this%F,dir//'F'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%Fnm1)) then
           call import_structured(this%Fnm1,dir//'Fnm1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%L)) then
           call import_structured(this%L,dir//'L'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F1)) then
           call import_structured(this%temp_F1,dir//'temp_F1'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F2)) then
           call import_structured(this%temp_F2,dir//'temp_F2'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_F3)) then
           call import_structured(this%temp_F3,dir//'temp_F3'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_E)) then
           call import_structured(this%temp_E,dir//'temp_E'//fortran_PS)
         endif
         if (get_necessary_for_restart(this%temp_CC_VF)) then
           call import_structured(this%temp_CC_VF,&
           dir//'temp_CC_VF'//fortran_PS)
         endif
         close(un)
       end subroutine

       subroutine suppress_warnings_momentum(this)
         implicit none
         type(momentum),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module norms_extend_mod
       use norms_mod
       ! Computes norms
       !     L(1)
       !     L(2)
       !     L(∞)
       !
       ! Interfaces:
       ! compute(e,u,vol)  = L(n) = volume⁻¹ ( ∫∫∫ | u(i,j,k)ⁿ | dx dy dz )ᵝ, β=1/n
       ! compute(e,u)      = L(n) = ( ΣΣΣ | u(i,j,k)ⁿ | )ᵝ, β=1/n
       ! compute(e,u)      = L(∞) = max(abs(u))
       use current_precision_mod
       use IO_tools_mod
       use grid_mod
       use mesh_extend_mod
       use ops_norms_mod
       use GF_mod
       use SF_extend_mod
       use VF_extend_mod
       implicit none

       private
       public :: norms
       public :: init,delete,display,print,export,import ! Essentials
       public :: compute

       interface init;            module procedure init_norms;             end interface
       interface display;         module procedure display_norms2;         end interface
       interface display;         module procedure display_norms1_name;    end interface
       interface display;         module procedure display_norms2_name;    end interface
       interface print;           module procedure print_norms2;           end interface
       interface print;           module procedure print_norms1_name;      end interface
       interface print;           module procedure print_norms2_name;      end interface

       interface compute;         module procedure compute_norms_vol_SF;   end interface
       interface compute;         module procedure compute_norms_SF;       end interface
       interface compute;         module procedure compute_norms_vol_VF;   end interface
       interface compute;         module procedure compute_norms_VF;       end interface

       contains

       ! **************************************************************
       ! ************************** ESSENTIALS ************************
       ! **************************************************************

       subroutine init_norms(e)
         implicit none
         type(norms),intent(inout) :: e
         e%L1 = 0.0_cp
         e%L2 = 0.0_cp
         e%Linf = 0.0_cp
       end subroutine

       subroutine display_norms1_name(norm,un,name)
         implicit none
         type(norms),intent(in) :: norm
         integer,intent(in) :: un
         character(len=*),intent(in) :: name
         write(un,*) ' -------------- '//name//' -------------- '
         write(un,*) 'L1 = ',norm%L1
         write(un,*) 'L2 = ',norm%L2
         write(un,*) 'Linf = ',norm%Linf
       end subroutine

       subroutine display_norms2_name(n1,n2,un,name)
         implicit none
         type(norms),intent(in) :: n1,n2
         integer,intent(in) :: un
         character(len=*),intent(in) :: name
         write(un,*) ' -------------- '//name//' -------------- '
         write(un,*) 'L1 = ',n1%L1,n2%L1
         write(un,*) 'L2 = ',n1%L2,n2%L2
         write(un,*) 'Linf = ',n1%Linf,n2%Linf
       end subroutine

       subroutine display_norms2(n1,n2,un)
         implicit none
         type(norms),intent(in) :: n1,n2
         integer,intent(in) :: un
         write(un,*) 'L1 = ',n1%L1,n2%L1
         write(un,*) 'L2 = ',n1%L2,n2%L2
         write(un,*) 'Linf = ',n1%Linf,n2%Linf
       end subroutine

       subroutine print_norms1_name(norm,name)
         implicit none
         type(norms),intent(in) :: norm
         character(len=*),intent(in) :: name
         call display(norm,6,name)
       end subroutine

       subroutine print_norms2_name(n1,n2,name)
         implicit none
         type(norms),intent(in) :: n1,n2
         character(len=*),intent(in) :: name
         call display(n1,n2,6,name)
       end subroutine

       subroutine print_norms2(n1,n2)
         implicit none
         type(norms),intent(in) :: n1,n2
         call display(n1,n2,6)
       end subroutine

       ! **************************************************************
       ! ************************ COMPUTATIONS ************************
       ! **************************************************************

       subroutine compute_norms_vol_SF(e,u,vol,tot_vol)
         implicit none
         type(norms),intent(inout) :: e
         type(SF),intent(in) :: u,vol
         real(cp),intent(in) :: tot_vol
         call compute_Ln(e%L1,u,1.0_cp,vol); e%L1 = e%L1/tot_vol
         call compute_Ln(e%L2,u,2.0_cp,vol); e%L2 = (e%L2**0.5_cp)/tot_vol
         e%Linf = amax(u)
       end subroutine

       subroutine compute_norms_vol_VF(e,u,vol,tot_vol)
         implicit none
         type(norms),intent(inout) :: e
         type(VF),intent(in) :: u,vol
         real(cp),intent(in) :: tot_vol
         call compute_Ln(e%L1,u,1.0_cp,vol)
         call compute_Ln(e%L2,u,2.0_cp,vol)
         e%L1 = e%L1/tot_vol
         e%L2 = (e%L2**0.5_cp)/tot_vol
         e%Linf = amax(u)
       end subroutine

       subroutine compute_norms_SF(e,u)
         implicit none
         type(norms),intent(inout) :: e
         type(SF),intent(in) :: u
         call compute_Ln(e%L1,u,1.0_cp)
         call compute_Ln(e%L2,u,2.0_cp)
         e%L2 = e%L2**0.5_cp
         e%Linf = amax(u)
       end subroutine

       subroutine compute_norms_VF(e,u)
         implicit none
         type(norms),intent(inout) :: e
         type(VF),intent(in) :: u
         call compute_Ln(e%L1,u,1.0_cp)
         call compute_Ln(e%L2,u,2.0_cp)
         e%L2 = e%L2**0.5_cp
         e%Linf = amax(u)
       end subroutine

       end module
       module ops_interp_mod
       ! Compiler flags: ( fopenmp, _DEBUG_INTERP_ )
       !
       ! Directions are frequently used in MOONS.
       ! For clarity, some diagrams here show how the
       ! directions are defined.
       !
       ! faceDir = 1 (x)
       !
       !                       z
       !                y      |
       !                 \   __|____
       !                  \ |\ |     \
       !                   \| \|______\
       !      faceDir --->  \  |      |
       !                     \ |      |
       !                      \|______|_____ x
       !
       !
       !
       ! edgeDir = 1 (x)
       !
       !                       z
       !                y      |
       !                 \   __|____
       !                  \ |\ |     \
       !                   \| \|______\
       !                    \  |      |
       !                     \ |      |
       !                      \|______|_____ x
       !                        -------> edgeDir
       !
       use current_precision_mod
       use GF_interp_mod
       use GF_extrap_mod
       use face_edge_corner_indexing_mod
       use grid_mod
       use mesh_extend_mod
       use data_location_extend_mod
       use apply_BCs_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       implicit none


       ! VECTOR INTEGFACES:
       !        face2Face_VF(faceX,faceY,faceZ,face,m,tempCC)
       !        face2CellCenter_VF(cellCenter,face,m)
       !        face2Node_VF(node,face,m,tempE)
       !        cellCenter2Face_VF(face,cellCenter,m)
       !        cellCenter2Face2_VF(face,cellCenter,m)
       !        cellCenter2Node_VF(node,cellCenter,m,tempF,tempE)
       !        cellCenter2Edge_VF_VF(edge,cellCenter,m,tempF)
       !        cellCenter2Edge_VF_SF(edge,cellCenter,m,tempF)
       !        node2Edge_VF(edge,node,m)
       !        node2Edge2_VF(edge,node,m)
       !        node2Face_VF_VF(face,node,m,tempE)
       !        node2Face_VF_SF(face,node,m,tempE)
       !        edge2Node_VF(node,edge,m)
       !        edge2CellCenter_VF(cellCenter,edge,m,tempF)

       private

       ! ------------------------------- POSSIBLE ALIASES ---------------------------------
       ! public :: F2F,F2N,F2CC,F2E,CC2F,CC2E,CC2N,E2F,E2N,E2CC,N2F,N2E

       ! ------------------------------- INTERPOLATION ROUTINES ---------------------------------
       ! Base interpolation
       public :: interp               ! call interp(f,m,gd,dir)
       public :: extrap               ! call extrap(f,m,gd,dir)

       ! Derived interpolations (* = has vector interface)
       public :: face2Face            ! call face2Face(faceAve,f,m,dir,aveLoc)
       public :: face2Face_no_diag
       public :: face2Node            ! call face2Node(nodeAverage,face,m,dir)           *
       public :: face2CellCenter      ! call face2CellCenter(cellCenter,face,m,faceDir)  *
       public :: face2Edge            ! call face2Edge(edge,m,face,edgeDir)
       public :: face2Edge_no_diag

       public :: cellCenter2Face      ! call cellCenter2Face(face,cellCenter,m,faceDir)  *
       public :: cellCenter2Edge      ! call cellCenter2Edge(edge,cellCenter,m,edgeDir)  *
       public :: cellCenter2Node      ! call cellCenter2Node(nodeAverage,cellCenter,m)   *

       public :: edge2Face            ! call edge2Face(face,edge,m,edgeDir,faceDir)
       public :: edge2Face_no_diag
       public :: edge2Node            ! call edge2Node(node,edge,m,edgeDir)              *
       public :: edge2CellCenter      ! call edge2CellCenter(cellCenter,edge,m,edgeDir)

       public :: node2Face            ! call node2Face(face,node,m,faceDir)              *
       public :: node2Edge            ! call node2Edge(edge,node,m,edgeDir)              *
       public :: node2CellCenter      ! call node2CellCenter(CC,node,m,E_x,F_y)          *

       public :: any_to_node

       ! ****************** Raw interpolation / extrapolation routines ******************

       interface interp;              module procedure interpO2_SF;          end interface
       interface extrap;              module procedure extrapO2_SF;          end interface
       interface extrap;              module procedure extrapO2_VF;          end interface
       interface extrap;              module procedure extrapO2_TF;          end interface

       ! ********************************** SF routines **********************************

       interface face2CellCenter;     module procedure face2CellCenter_SF;    end interface
       interface face2Node;           module procedure face2Node_SF;          end interface
       interface face2Face;           module procedure face2Face_SF;          end interface
       interface face2Face;           module procedure face2Face_TF;          end interface
       interface face2Face_no_diag;   module procedure face2Face_no_diag_TF;  end interface
       interface face2Edge;           module procedure face2Edge_SF_3;        end interface
       interface face2Edge;           module procedure face2Edge_SF_1;        end interface
       interface face2Edge;           module procedure face2Edge_TF;          end interface
       interface face2Edge_no_diag;   module procedure face2Edge_TF_no_diag;  end interface

       interface cellCenter2Face;     module procedure cellCenter2Face_SF;    end interface
       interface cellCenter2Node;     module procedure cellCenter2Node_SF;    end interface
       interface cellCenter2Edge;     module procedure cellCenter2Edge_SF;    end interface

       interface node2Edge;           module procedure node2Edge_SF;          end interface
       interface node2Face;           module procedure node2Face_SF;          end interface
       interface node2CellCenter;     module procedure node2CellCenter_SF;    end interface

       interface edge2Face;           module procedure edge2Face_SF;          end interface
       interface edge2CellCenter;     module procedure edge2CellCenter_SF;    end interface
       interface edge2Node;           module procedure edge2Node_SF;          end interface
       interface edge2Face_no_diag;   module procedure edge2Face_no_diag_TF;  end interface

       interface any_to_node;         module procedure any_to_node_SF;        end interface

       ! ********************************** VF routines **********************************

       interface face2Face;           module procedure face2Face_VF;          end interface
       interface face2CellCenter;     module procedure face2CellCenter_VF;    end interface
       interface face2Node;           module procedure face2Node_VF;          end interface

       interface cellCenter2Face;     module procedure cellCenter2Face_VF_VF; end interface
       interface cellCenter2Face;     module procedure cellCenter2Face_VF_SF; end interface
       interface cellCenter2Face;     module procedure cellCenter2Face_TF_VF; end interface
       interface cellCenter2Node;     module procedure cellCenter2Node_VF;    end interface
       interface cellCenter2Edge;     module procedure cellCenter2Edge_VF_VF; end interface
       interface cellCenter2Edge;     module procedure cellCenter2Edge_VF_SF; end interface

       interface edge2Node;           module procedure edge2Node_VF;          end interface
       interface edge2CellCenter;     module procedure edge2CellCenter_VF;    end interface

       interface node2Face;           module procedure node2Face_VF_VF;       end interface
       interface node2Face;           module procedure node2Face_VF_SF;       end interface

       interface node2Edge;           module procedure node2Edge_VF;          end interface
       interface node2Edge;           module procedure node2Edge2_VF;         end interface

       interface any_to_node;         module procedure any_to_node_VF;        end interface

       contains

       ! ****************************************************************************************
       ! ****************************************************************************************
       ! ********************************* BASE INTERPOLATION ***********************************
       ! ****************************************************************************************
       ! ****************************************************************************************

       subroutine extrapO2_VF(f,m)
         implicit none
         type(VF),intent(inout) :: f
         type(mesh),intent(in) :: m
         call extrap(f%x,m)
         call extrap(f%y,m)
         call extrap(f%z,m)
       end subroutine

       subroutine extrapO2_TF(f,m)
         implicit none
         type(TF),intent(inout) :: f
         type(mesh),intent(in) :: m
         call extrap(f%x,m)
         call extrap(f%y,m)
         call extrap(f%z,m)
       end subroutine

       subroutine extrapO2_SF(f,m)
         implicit none
         type(SF),intent(inout) :: f
         type(mesh),intent(in) :: m
         integer :: i,k
         do k=1,3; do i=1,m%s
           call extrap(f%BF(i)%GF,k) ! self-extrapolation
         enddo; enddo
       end subroutine

       subroutine interpO2_SF(f,g,m,dir)
         implicit none
         type(SF),intent(inout) :: f
         type(SF),intent(in) :: g
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir
         integer :: i
         if (N_along(f%DL,dir).and.CC_along(g%DL,dir)) then
           do i=1,m%s
             call interp_C2N(f%BF(i)%GF,&
                             g%BF(i)%GF,&
                             m%B(i)%g,&
                             dir,&
                             m%MP%int_tensor(dir)%eye(1),&
                             m%MP%int_tensor(dir)%eye(2),&
                             m%MP%int_tensor(dir)%eye(3))
           enddo
         elseif (CC_along(f%DL,dir).and.N_along(g%DL,dir)) then
           do i=1,m%s
             call interp_N2C(f%BF(i)%GF,&
                             g%BF(i)%GF,&
                             m%MP%int_tensor(dir)%eye(1),&
                             m%MP%int_tensor(dir)%eye(2),&
                             m%MP%int_tensor(dir)%eye(3))
           enddo
         else
           write(*,*) ' ---------------- f ---------------- '; call print(f%DL)
           write(*,*) ' ---------------- g ---------------- '; call print(g%DL)
           stop 'Error: bad DLs in interpO2_SF in ops_interp.f90'
         endif
       end subroutine

       ! ****************************************************************************************
       ! ****************************************************************************************
       ! ****************************** SCALAR-FIELD INTERPOLATIONS *****************************
       ! ****************************************************************************************
       ! ****************************************************************************************

       ! ****************************************************************************************
       ! ********************************* FACE INTERPOLATIONS **********************************
       ! ****************************************************************************************

       subroutine face2CellCenter_SF(cellCenter,face,m,faceDir)
         ! 1 interpolation routine (no allocation required)
         implicit none
         type(SF),intent(inout) :: cellCenter
         type(SF),intent(in)    :: face
         type(mesh),intent(in) :: m
         integer,intent(in) :: faceDir
         call interp(cellCenter,face,m,faceDir)
       end subroutine

       subroutine face2Edge_SF_1(edge,face,m,faceDir,edgeDir)
         ! Case dependent multiple-interpolation routine (requires 1 or 3 interpolations)
         !
         ! This routine moves
         !       face data along direction faceDir
         !    to edge data along direction edgeDir
         !
         ! edgeDir is defined as the direction along which the dimension is of size N+2
         ! faceDir is defined as the direction along which the dimension is of size N+1
         !
         ! Where N is the number of cells.
         !
         ! This means that there are 2 possible cases:
         !    edgeDir == faceDir       (requires 3 interpolations, 1 to cell center, 2 to edge)
         !    edgeDir ≠ faceDir        (requires 1 interpolation)
         !
         implicit none
         type(SF),intent(inout) :: edge
         type(SF),intent(in)    :: face
         type(mesh),intent(in) :: m
         integer,intent(in) :: edgeDir,faceDir
         integer :: orthDir
         if (edgeDir.ne.faceDir) then ! Requires 1 interpolation (no allocations)
           orthDir = orth_dir((/edgeDir,faceDir/))
           call interp(edge,face,m,orthDir)
         else ! Requires 3 interpolations ()
           stop 'Error: use face2Edge_SF_3 for edgeDir = faceDir in face2Edge_SF_1 in ops_interp.f90'
         endif
       end subroutine

       subroutine face2Edge_SF_3(edge,face,m,tempCC,tempF,faceDir,edgeDir)
         ! Requires 3 interpolations
         ! NOTE: tempF = (y,x,x) for edgeDir = (1,2,3)
         implicit none
         type(SF),intent(inout) :: edge,tempF,tempCC
         type(SF),intent(in)    :: face
         type(mesh),intent(in) :: m
         integer,intent(in) :: edgeDir,faceDir
         if (edgeDir.eq.faceDir) then ! requires 1 interpolation (no allocations)
           call face2CellCenter(tempCC,face,m,faceDir)
           call cellCenter2Edge(edge,tempCC,m,tempF,edgeDir)
         else; stop 'Error: edgeDir must = faceDir in this face2Edge_SF_3'
         endif
       end subroutine

       subroutine face2Face_SF(faceAve,face,m,tempCC,faceDir,aveLoc)
         implicit none
         type(SF),intent(inout) :: faceAve,tempCC
         type(SF),intent(in) :: face
         type(mesh),intent(in) :: m
         integer,intent(in) :: faceDir,aveLoc
         call face2CellCenter(tempCC,face,m,faceDir)
         call cellCenter2Face(faceAve,tempCC,m,aveLoc)
       end subroutine

       subroutine face2Node_SF(node,face,m,faceDir,tempE)
         implicit none
         type(SF),intent(inout) :: node
         type(SF),intent(in) :: face
         type(mesh),intent(in) :: m
         integer,intent(in) :: faceDir
         type(SF),intent(inout) :: tempE
         integer :: edgeDir
         select case (faceDir)
         case (1); edgeDir = 2
         case (2); edgeDir = 1
         case (3); edgeDir = 1
         case default; stop 'Error: faceDir must = 1,2,3 in face2Node_SF in ops_interp.f90'
         end select
         call face2Edge(tempE,face,m,faceDir,edgeDir)
         call edge2Node(node,tempE,m,edgeDir)
       end subroutine

       ! ****************************************************************************************
       ! *********************************** CC INTERPOLATIONS **********************************
       ! ****************************************************************************************

       subroutine cellCenter2Face_SF(face,cellCenter,m,faceDir)
         implicit none
         type(SF),intent(inout) :: face
         type(SF),intent(in) :: cellCenter
         type(mesh),intent(in) :: m
         integer,intent(in) :: faceDir
         call interp(face,cellCenter,m,faceDir)
       end subroutine

       subroutine cellCenter2Node_SF(node,cellCenter,m,tempFx,tempEz)
         implicit none
         type(SF),intent(inout) :: node
         type(SF),intent(in) :: cellCenter
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: tempFx,tempEz
         call cellCenter2Face(tempFx,cellCenter,m,1)
         call face2Edge(tempEz,tempFx,m,1,3)
         call edge2Node(node,tempEz,m,3)
       end subroutine

       subroutine cellCenter2Edge_SF(edge,cellCenter,m,tempF,edgeDir)
         implicit none
         type(SF),intent(inout) :: edge,tempF
         type(SF),intent(in) :: cellCenter
         type(mesh),intent(in) :: m
         integer,intent(in) :: edgeDir
         integer :: d_F2E,d_C2F
         select case (edgeDir)
         case(1); d_F2E = 2; d_C2F = 2
         case(2); d_F2E = 1; d_C2F = 1
         case(3); d_F2E = 1; d_C2F = 1
         case default; stop 'Error: edgeDir must = 1,2,3 in cellCenter2Edge_SF in ops_interp.f90'
         end select
         call cellCenter2Face(tempF,cellCenter,m,d_C2F)
         call face2Edge(edge,tempF,m,d_F2E,edgeDir)
       end subroutine

       ! ****************************************************************************************
       ! ********************************* NODE INTERPOLATIONS **********************************
       ! ****************************************************************************************

       subroutine node2Face_SF(face,node,m,tempEyxx,faceDir)
         implicit none
         type(SF),intent(inout) :: face,tempEyxx
         type(SF),intent(in) :: node
         type(mesh),intent(in) :: m
         integer,intent(in) :: faceDir
         integer :: d
         select case (faceDir)
         case (1); d = 2
         case (2); d = 1
         case (3); d = 1
         case default; stop 'Error: faceDir must = 1,2,3 in node2Face_SF in ops_interp.f90'
         end select
         call node2Edge(tempEyxx,node,m,d)
         call edge2Face(face,tempEyxx,m,d,faceDir)
       end subroutine

       subroutine node2CellCenter_SF(CC,node,m,E_x,F_y)
         implicit none
         type(SF),intent(inout) :: CC,E_x,F_y
         type(SF),intent(in) :: node
         type(mesh),intent(in) :: m
         call node2Edge(E_x,node,m,1)
         call edge2Face(F_y,E_x,m,1,2)
         call face2CellCenter(CC,F_y,m,2)
       end subroutine

       subroutine node2Edge_SF(edge,node,m,edgeDir)
         implicit none
         type(SF),intent(inout) :: edge
         type(SF),intent(in) :: node
         type(mesh),intent(in) :: m
         integer,intent(in) :: edgeDir
         call interp(edge,node,m,edgeDir)
       end subroutine

       ! ****************************************************************************************
       ! ********************************* EDGE INTERPOLATIONS **********************************
       ! ****************************************************************************************

       subroutine edge2Face_SF(face,edge,m,edgeDir,faceDir)
         implicit none
         type(SF),intent(inout) :: face
         type(SF),intent(in) :: edge
         type(mesh),intent(in) :: m
         integer,intent(in) :: faceDir,edgeDir
         integer :: orthDir
         if (edgeDir.ne.faceDir) then ! Requires 1 interpolation (no allocations)
           orthDir = orth_dir((/edgeDir,faceDir/))
           call interp(face,edge,m,orthDir)
         else ! Requires 3 interpolations ()
           stop 'Error: edgeDir=faceDir, need more temps for this interp in edge2Face_SF in ops_interp.f90'
         endif
       end subroutine

       subroutine edge2CellCenter_SF(cellCenter,edge,m,tempF,edgeDir)
         implicit none
         type(SF),intent(inout) :: cellCenter
         type(SF),intent(in) :: edge
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: tempF
         integer,intent(in) :: edgeDir
         integer :: faceDir
         select case (edgeDir)
         case (1); faceDir = 2
         case (2); faceDir = 3
         case (3); faceDir = 1
         case default; stop 'Error: edgeDir must = 1,2,3 in edge2CellCenter_GF in interpOps.f90'
         end select
         call edge2Face(tempF,edge,m,edgeDir,faceDir)
         call face2CellCenter(cellCenter,tempF,m,faceDir)
       end subroutine

       subroutine edge2Node_SF(node,edge,m,edgeDir)
         implicit none
         type(SF),intent(inout) :: node
         type(SF),intent(in) :: edge
         type(mesh),intent(in) :: m
         integer,intent(in) :: edgeDir
         call interp(node,edge,m,edgeDir)
       end subroutine


       ! ****************************************************************************************
       ! ****************************************************************************************
       ! ****************************** VECTOR-FIELD INTERPOLATIONS *****************************
       ! ****************************************************************************************
       ! ****************************************************************************************


       ! ****************************************************************************************
       ! ********************************* FACE INTERPOLATIONS **********************************
       ! ****************************************************************************************

       subroutine face2Face_VF(faceX,faceY,faceZ,face,m,tempCC)
         ! [U_ave,V_ave,W_ave] = interp(U)
         implicit none
         type(VF),intent(inout) :: faceX,faceY,faceZ
         type(VF),intent(in)    :: face
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: tempCC

         call assign(faceX%x,face%x)
         call assign(faceY%y,face%y)
         call assign(faceZ%z,face%z)

         call face2Face(faceX%y,face%x,m,tempCC,1,2)
         call face2Face(faceX%z,face%x,m,tempCC,1,3)

         call face2Face(faceY%x,face%y,m,tempCC,2,1)
         call face2Face(faceY%z,face%y,m,tempCC,2,3)

         call face2Face(faceZ%x,face%z,m,tempCC,3,1)
         call face2Face(faceZ%y,face%z,m,tempCC,3,2)
       end subroutine

       subroutine face2Face_TF(face_TF,face_VF,m,tempCC)
         ! [U_ave,V_ave,W_ave] = interp(U)
         implicit none
         type(TF),intent(inout) :: face_TF
         type(VF),intent(in)    :: face_VF
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: tempCC
         call assign(face_TF%x%x,face_VF%x)
         call face2Face(face_TF%x%y,face_VF%x,m,tempCC,1,2)
         call face2Face(face_TF%x%z,face_VF%x,m,tempCC,1,3)

         call assign(face_TF%y%y,face_VF%y)
         call face2Face(face_TF%y%x,face_VF%y,m,tempCC,2,1)
         call face2Face(face_TF%y%z,face_VF%y,m,tempCC,2,3)

         call assign(face_TF%z%z,face_VF%z)
         call face2Face(face_TF%z%x,face_VF%z,m,tempCC,3,1)
         call face2Face(face_TF%z%y,face_VF%z,m,tempCC,3,2)
       end subroutine

       subroutine face2Face_no_diag_TF(face_TF,face_VF,m,tempCC)
         ! [U_ave,V_ave,W_ave] = interp(U)
         implicit none
         type(TF),intent(inout) :: face_TF
         type(VF),intent(in)    :: face_VF
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: tempCC
         call face2Face(face_TF%x%y,face_VF%x,m,tempCC,1,2)
         call face2Face(face_TF%x%z,face_VF%x,m,tempCC,1,3)
         call face2Face(face_TF%y%x,face_VF%y,m,tempCC,2,1)
         call face2Face(face_TF%y%z,face_VF%y,m,tempCC,2,3)
         call face2Face(face_TF%z%x,face_VF%z,m,tempCC,3,1)
         call face2Face(face_TF%z%y,face_VF%z,m,tempCC,3,2)
       end subroutine

       subroutine face2Edge_TF(edge,face,m,tempCC,tempF)
         ! [U_ave,V_ave,W_ave] = interp(U)
         implicit none
         type(TF),intent(inout) :: edge
         type(VF),intent(in) :: face
         type(VF),intent(inout) :: tempF
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: tempCC
         ! tempF = (y,x,x) for edgeDir = (1,2,3) tempCC,tempF
         call face2Edge(edge%x%x,face%x,m,tempCC,tempF%y,1,1)
         call face2Edge(edge%x%y,face%x,m,1,2)
         call face2Edge(edge%x%z,face%x,m,1,3)
         call face2Edge(edge%y%x,face%y,m,2,1)
         call face2Edge(edge%y%y,face%y,m,tempCC,tempF%x,2,2)
         call face2Edge(edge%y%z,face%y,m,2,3)
         call face2Edge(edge%z%x,face%z,m,3,1)
         call face2Edge(edge%z%y,face%z,m,3,2)
         call face2Edge(edge%z%z,face%z,m,tempCC,tempF%x,3,3)
       end subroutine

       subroutine face2Edge_TF_no_diag(edge,face,m)
         ! [U_ave,V_ave,W_ave] = interp(U)
         implicit none
         type(TF),intent(inout) :: edge
         type(VF),intent(in) :: face
         type(mesh),intent(in) :: m
         ! tempF = (y,x,x) for edgeDir = (1,2,3) tempCC,tempF
         call face2Edge(edge%x%y,face%x,m,1,2)
         call face2Edge(edge%x%z,face%x,m,1,3)
         call face2Edge(edge%y%x,face%y,m,2,1)
         call face2Edge(edge%y%z,face%y,m,2,3)
         call face2Edge(edge%z%x,face%z,m,3,1)
         call face2Edge(edge%z%y,face%z,m,3,2)
       end subroutine

       subroutine face2CellCenter_VF(cellCenter,face,m)
         implicit none
         type(VF),intent(inout) :: cellCenter
         type(VF),intent(in)    :: face
         type(mesh),intent(in) :: m
         call face2CellCenter(cellCenter%x,face%x,m,1)
         call face2CellCenter(cellCenter%y,face%y,m,2)
         call face2CellCenter(cellCenter%z,face%z,m,3)
       end subroutine

       subroutine face2Node_VF(node,face,m,tempE)
         implicit none
         type(VF),intent(inout) :: node,tempE
         type(VF),intent(in) :: face
         type(mesh),intent(in) :: m
         call face2Node(node%x,face%x,m,1,tempE%y)
         call face2Node(node%y,face%y,m,2,tempE%x)
         call face2Node(node%z,face%z,m,3,tempE%x)
       end subroutine

       ! ****************************************************************************************
       ! *********************************** CC INTERPOLATIONS **********************************
       ! ****************************************************************************************

       subroutine cellCenter2Face_VF_VF(face,cellCenter,m)
         implicit none
         type(VF),intent(inout) :: face
         type(VF),intent(in) :: cellCenter
         type(mesh),intent(in) :: m
         call cellCenter2Face(face%x,cellCenter%x,m,1)
         call cellCenter2Face(face%y,cellCenter%y,m,2)
         call cellCenter2Face(face%z,cellCenter%z,m,3)
       end subroutine

       subroutine cellCenter2Face_VF_SF(face,cellCenter,m)
         implicit none
         type(VF),intent(inout) :: face
         type(SF),intent(in) :: cellCenter
         type(mesh),intent(in) :: m
         call cellCenter2Face(face%x,cellCenter,m,1)
         call cellCenter2Face(face%y,cellCenter,m,2)
         call cellCenter2Face(face%z,cellCenter,m,3)
       end subroutine

       subroutine cellCenter2Face_TF_VF(face,cellCenter,m)
         implicit none
         type(TF),intent(inout) :: face
         type(VF),intent(in) :: cellCenter
         type(mesh),intent(in) :: m
         call cellCenter2Face(face%x,cellCenter%x,m) ! Interp SF to VF
         call cellCenter2Face(face%y,cellCenter%y,m) ! Interp SF to VF
         call cellCenter2Face(face%z,cellCenter%z,m) ! Interp SF to VF
       end subroutine

       subroutine cellCenter2Node_VF(node,cellCenter,m,tempF,tempE)
         implicit none
         type(VF),intent(inout) :: node,tempF,tempE
         type(VF),intent(in) :: cellCenter
         type(mesh),intent(in) :: m
         call cellCenter2Node(node%x,cellCenter%x,m,tempF%x,tempE%z)
         call cellCenter2Node(node%y,cellCenter%y,m,tempF%x,tempE%z)
         call cellCenter2Node(node%z,cellCenter%z,m,tempF%x,tempE%z)
       end subroutine

       subroutine cellCenter2Edge_VF_VF(edge,cellCenter,m,tempF)
         implicit none
         type(VF),intent(inout) :: edge,tempF
         type(VF),intent(in) :: cellCenter
         type(mesh),intent(in) :: m
         call cellCenter2Edge(edge%x,cellCenter%x,m,tempF%y,1)
         call cellCenter2Edge(edge%y,cellCenter%y,m,tempF%x,2)
         call cellCenter2Edge(edge%z,cellCenter%z,m,tempF%x,3)
       end subroutine

       subroutine cellCenter2Edge_VF_SF(edge,cellCenter,m,tempF)
         implicit none
         type(VF),intent(inout) :: edge,tempF
         type(SF),intent(in) :: cellCenter
         type(mesh),intent(in) :: m
         call cellCenter2Edge(edge%x,cellCenter,m,tempF%y,1)
         call cellCenter2Edge(edge%y,cellCenter,m,tempF%x,2)
         call cellCenter2Edge(edge%z,cellCenter,m,tempF%x,3)
       end subroutine

       ! ****************************************************************************************
       ! ********************************* NODE INTERPOLATIONS **********************************
       ! ****************************************************************************************

       subroutine node2Edge_VF(edge,node,m)
         implicit none
         type(VF),intent(inout) :: edge
         type(VF),intent(in) :: node
         type(mesh),intent(in) :: m
         call node2Edge(edge%x,node%x,m,1)
         call node2Edge(edge%y,node%y,m,2)
         call node2Edge(edge%z,node%z,m,3)
       end subroutine

       subroutine node2Edge2_VF(edge,node,m)
         implicit none
         type(VF),intent(inout) :: edge
         type(SF),intent(in) :: node
         type(mesh),intent(in) :: m
         call node2Edge(edge%x,node,m,1)
         call node2Edge(edge%y,node,m,2)
         call node2Edge(edge%z,node,m,3)
       end subroutine

       subroutine node2Face_VF_VF(face,node,m,tempE)
         implicit none
         type(VF),intent(inout) :: face,tempE
         type(VF),intent(in) :: node
         type(mesh),intent(in) :: m
         call node2Face(face%x,node%x,m,tempE%y,1)
         call node2Face(face%y,node%y,m,tempE%x,2)
         call node2Face(face%z,node%z,m,tempE%x,3)
       end subroutine

       subroutine node2Face_VF_SF(face,node,m,tempE)
         implicit none
         type(VF),intent(inout) :: face,tempE
         type(SF),intent(in) :: node
         type(mesh),intent(in) :: m
         call node2Face(face%x,node,m,tempE%y,1)
         call node2Face(face%y,node,m,tempE%x,2)
         call node2Face(face%z,node,m,tempE%x,3)
       end subroutine

       ! ****************************************************************************************
       ! ********************************* EDGE INTERPOLATIONS **********************************
       ! ****************************************************************************************

       subroutine edge2Node_VF(node,edge,m)
         implicit none
         type(VF),intent(inout) :: node
         type(VF),intent(in) :: edge
         type(mesh),intent(in) :: m
         call edge2Node(node%x,edge%x,m,1)
         call edge2Node(node%y,edge%y,m,2)
         call edge2Node(node%z,edge%z,m,3)
       end subroutine

       subroutine edge2CellCenter_VF(cellCenter,edge,m,tempF)
         implicit none
         type(VF),intent(inout) :: cellCenter,tempF
         type(VF),intent(in) :: edge
         type(mesh),intent(in) :: m
         call edge2CellCenter(cellCenter%x,edge%x,m,tempF%y,1) ! temp%F is correct. Refer to edge2CellCenter
         call edge2CellCenter(cellCenter%y,edge%y,m,tempF%z,2) ! temp%F is correct. Refer to edge2CellCenter
         call edge2CellCenter(cellCenter%z,edge%z,m,tempF%x,3) ! temp%F is correct. Refer to edge2CellCenter
       end subroutine

       subroutine edge2Face_no_diag_TF(face,edge,m)
         implicit none
         type(TF),intent(inout) :: face
         type(VF),intent(in) :: edge
         type(mesh),intent(in) :: m
         call edge2Face(face%x%y,edge%x,m,1,2)
         call edge2Face(face%x%z,edge%x,m,1,3)
         call edge2Face(face%y%x,edge%y,m,2,1)
         call edge2Face(face%y%z,edge%y,m,2,3)
         call edge2Face(face%z%x,edge%z,m,3,1)
         call edge2Face(face%z%y,edge%z,m,3,2)
       end subroutine

       subroutine any_to_node_SF(m,node,x,edge,face)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         type(SF),intent(inout) :: node,edge,face
         integer,dimension(3) :: i
         integer :: i_f,i_e
         if (is_CC(x%DL)) then
           call init_Face(face,m,1)
           call init_Edge(edge,m,3)
           call init_Node(node,m)
           call cellcenter2Node(node,x,m,face,edge)
           call delete(face)
           call delete(edge)
         elseif (is_Node(x%DL)) then
         call init_Node(node,m)
         call assign(node,x)
         elseif (is_Face(x%DL)) then
           i = (/2,1,1/)
           i_f = get_Face(x%DL)
           call init_Edge(edge,m,i(i_f))
           call init_Node(node,m)
           call face2Node(node,x,m,i_f,edge)
           call delete(edge)
         elseif (is_Edge(x%DL)) then
           i_e = get_Edge(x%DL)
           call init_Node(node,m)
           call edge2Node(node,x,m,i_e)
         else; stop 'Error: bad DL to any_to_node_SF in ops_interp.f90'
         endif
       end subroutine

       subroutine any_to_node_VF(m,node,x,edge,face)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         type(VF),intent(inout) :: node,edge,face
         if (is_CC(x)) then
#ifdef _DEBUG_INTERP_
           call insist_collocated(x,'any_to_node_VF')
#endif
           call init_Face(face,m)
           call init_Edge(edge,m)
           call init_Node(node,m)
           call cellcenter2Node(node,x,m,face,edge)
           call delete(face)
           call delete(edge)
         elseif (is_Node(x)) then
#ifdef _DEBUG_INTERP_
           call insist_collocated(x,'any_to_node_VF')
#endif
         call init_Node(node,m)
         call assign(node,x)
         elseif (is_Face(x)) then
           call init_Edge(edge,m)
           call init_Node(node,m)
           call face2Node(node,x,m,edge)
           call delete(edge)
         elseif (is_Edge(x)) then
           call init_Node(node,m)
           call edge2Node(node,x,m)
         else; stop 'Error: bad DL to any_to_node_VF in ops_interp.f90'
         endif
       end subroutine

       end module
       module compute_energy_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use ops_interp_mod
       use ops_norms_mod
       implicit none

       private
       public :: compute_energy

       contains

       subroutine compute_energy(e,A_F,B_F,m,temp_F,temp_CC,compute_norms)
         ! Computes  ∫∫∫ A_F•B_F dV
         implicit none
         real(cp),intent(inout) :: e
         type(VF),intent(in) :: A_F,B_F
         type(VF),intent(inout) :: temp_F
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: temp_CC
         logical,intent(in) :: compute_norms
         real(cp) :: temp
         if (compute_norms) then
           call multiply(temp_F,A_F,B_F)
           e = 0.0_cp
           call face2CellCenter(temp_CC,temp_F%x,m,1)
           call assign_ghost_XPeriodic(temp_CC,0.0_cp)
           call compute_Ln(temp,temp_CC,1.0_cp,m); e = temp
           call face2CellCenter(temp_CC,temp_F%y,m,2)
           call assign_ghost_XPeriodic(temp_CC,0.0_cp)
           call compute_Ln(temp,temp_CC,1.0_cp,m); e = e + temp
           call face2CellCenter(temp_CC,temp_F%z,m,3)
           call assign_ghost_XPeriodic(temp_CC,0.0_cp)
           call compute_Ln(temp,temp_CC,1.0_cp,m); e = e + temp
         endif
       end subroutine

       end module
       module export_raw_processed_mod
       use current_precision_mod
       use mesh_extend_mod
       use string_mod
       use SF_extend_mod
       use VF_extend_mod
       use data_location_extend_mod
       use IO_tools_mod
       use IO_export_mod
       use ops_interp_mod
       use time_marching_params_mod

       implicit none
       private

       public :: export_raw
       interface export_raw;        module procedure er_steady_SF;           end interface
       interface export_raw;        module procedure er_unsteady_SF;         end interface
       interface export_raw;        module procedure er_steady_VF;           end interface
       interface export_raw;        module procedure er_unsteady_VF;         end interface

       public :: export_processed
       interface export_processed;  module procedure ep_3D_1C_steady_SF;     end interface
       interface export_processed;  module procedure ep_3D_1C_unsteady_SF;   end interface
       interface export_processed;  module procedure ep_3D_3C_steady_VF;     end interface
       interface export_processed;  module procedure ep_3D_3C_unsteady_VF;   end interface

       interface export_processed;  module procedure ep_2D_3C_steady_VF;     end interface
       interface export_processed;  module procedure ep_2D_3C_unsteady_VF;   end interface
       interface export_processed;  module procedure ep_2D_1C_steady_SF;     end interface
       interface export_processed;  module procedure ep_2D_1C_unsteady_SF;   end interface

       interface export_processed;  module procedure ep_1D_1C_steady_SF;     end interface
       interface export_processed;  module procedure ep_1D_1C_unsteady_SF;   end interface
       interface export_processed;  module procedure ep_1D_3C_steady_VF;     end interface
       interface export_processed;  module procedure ep_1D_3C_unsteady_VF;   end interface

       contains

       ! **********************************************************************
       ! ***************************** EXPORT RAW *****************************
       ! **********************************************************************

       subroutine er_steady_SF(m,x,dir,name,pad)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         call export_3D_1C(m,x,dir,name,pad)
       end subroutine
       subroutine er_unsteady_SF(m,x,dir,name,pad,TMP)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(time_marching_params),intent(in) :: TMP
         call export_3D_1C(m,x,dir,name,pad,TMP)
       end subroutine

       subroutine er_steady_VF(m,x,dir,name,pad)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         if (is_collocated(x)) then; call export_3D_3C(m,x,dir,name,pad)
         else;                       call export_3D_1C(m,x%x,dir,name,pad)
                                     call export_3D_1C(m,x%y,dir,name,pad)
                                     call export_3D_1C(m,x%z,dir,name,pad)
         endif
       end subroutine
       subroutine er_unsteady_VF(m,x,dir,name,pad,TMP)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(time_marching_params),intent(in) :: TMP
         if (is_collocated(x)) then; call export_3D_3C(m,x,dir,name,pad,TMP)
         else;                       call export_3D_1C(m,x%x,dir,name,pad,TMP)
                                     call export_3D_1C(m,x%y,dir,name,pad,TMP)
                                     call export_3D_1C(m,x%z,dir,name,pad,TMP)
         endif
       end subroutine

       ! **********************************************************************
       ! ************************* EXPORT 3D PROCESSED ************************
       ! **********************************************************************

       subroutine ep_3D_1C_steady_SF(m,x,dir,name,pad)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(SF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_3D_1C(m,temp_N,dir,name//'p',pad)
         call delete(temp_N)
       end subroutine
       subroutine ep_3D_1C_unsteady_SF(m,x,dir,name,pad,TMP)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(time_marching_params),intent(in) :: TMP
         type(SF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_3D_1C(m,temp_N,dir,name//'p',pad,TMP)
         call delete(temp_N)
       end subroutine

       subroutine ep_3D_3C_steady_VF(m,x,dir,name,pad)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(VF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_3D_3C(m,temp_N,dir,name//'p',pad)
         call delete(temp_N)
       end subroutine
       subroutine ep_3D_3C_unsteady_VF(m,x,dir,name,pad,TMP)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(time_marching_params),intent(in) :: TMP
         type(VF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_3D_3C(m,temp_N,dir,name//'p',pad,TMP)
         call delete(temp_N)
       end subroutine


       ! **********************************************************************
       ! ************************* EXPORT 2D PROCESSED ************************
       ! **********************************************************************

       subroutine ep_2D_3C_steady_VF(m,x,dir,name,pad,direction,plane)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad,direction,plane
         type(VF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_2D_3C(m,temp_N,dir,name//'p',pad,direction,plane)
         call delete(temp_N)
       end subroutine
       subroutine ep_2D_3C_unsteady_VF(m,x,dir,name,pad,TMP,direction,plane)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad,direction,plane
         type(time_marching_params),intent(in) :: TMP
         type(VF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_2D_3C(m,temp_N,dir,name//'p',pad,TMP,direction,plane)
         call delete(temp_N)
       end subroutine

       subroutine ep_2D_1C_steady_SF(m,x,dir,name,pad,direction,plane)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad,direction,plane
         type(SF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_2D_1C(m,temp_N,dir,name//'p',pad,direction,plane)
         call delete(temp_N)
       end subroutine
       subroutine ep_2D_1C_unsteady_SF(m,x,dir,name,pad,TMP,direction,plane)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad,direction,plane
         type(time_marching_params),intent(in) :: TMP
         type(SF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_2D_1C(m,temp_N,dir,name//'p',pad,TMP,direction,plane)
         call delete(temp_N)
       end subroutine


       ! **********************************************************************
       ! ************************* EXPORT 1D PROCESSED ************************
       ! **********************************************************************

       subroutine ep_1D_1C_steady_SF(m,x,dir,name,pad,direction,line)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad,direction
         integer,dimension(2),intent(in) :: line
         type(SF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_1D_1C(m,temp_N,dir,name//'p',pad,direction,line)
         call delete(temp_N)
       end subroutine
       subroutine ep_1D_1C_unsteady_SF(m,x,dir,name,pad,TMP,direction,line)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad,direction
         integer,dimension(2),intent(in) :: line
         type(time_marching_params),intent(in) :: TMP
         type(SF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_1D_1C(m,temp_N,dir,name//'p',pad,TMP,direction,line)
         call delete(temp_N)
       end subroutine

       subroutine ep_1D_3C_steady_VF(m,x,dir,name,pad,direction,line)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad,direction
         integer,dimension(2),intent(in) :: line
         type(VF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_1D_3C(m,temp_N,dir,name//'p',pad,direction,line)
         call delete(temp_N)
       end subroutine
       subroutine ep_1D_3C_unsteady_VF(m,x,dir,name,pad,TMP,direction,line)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad,direction
         integer,dimension(2),intent(in) :: line
         type(time_marching_params),intent(in) :: TMP
         type(VF) :: temp_1,temp_2,temp_N
         call any_to_node(m,temp_N,x,temp_1,temp_2)
         call export_1D_3C(m,temp_N,dir,name//'p',pad,TMP,direction,line)
         call delete(temp_N)
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module governing_equations_mod
       use datatype_conversion_mod
       use energy_mod
       use IO_tools_mod
       use momentum_mod
       use string_mod
       use induction_mod
       use dir_manip_mod
       implicit none

       private
       public :: governing_equations
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_governing_equations;              end interface
       interface delete;                 module procedure delete_governing_equations;                 end interface
       interface display;                module procedure display_governing_equations;                end interface
       interface display_short;          module procedure display_short_governing_equations;          end interface
       interface display;                module procedure display_wrap_governing_equations;           end interface
       interface print;                  module procedure print_governing_equations;                  end interface
       interface print_short;            module procedure print_short_governing_equations;            end interface
       interface export;                 module procedure export_governing_equations;                 end interface
       interface export_primitives;      module procedure export_primitives_governing_equations;      end interface
       interface import;                 module procedure import_governing_equations;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_governing_equations;end interface
       interface export_structured;      module procedure export_structured_D_governing_equations;    end interface
       interface import_structured;      module procedure import_structured_D_governing_equations;    end interface
       interface import_primitives;      module procedure import_primitives_governing_equations;      end interface
       interface export;                 module procedure export_wrap_governing_equations;            end interface
       interface import;                 module procedure import_wrap_governing_equations;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_governing_equations;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_governing_equations;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_governing_equations;      end interface
       interface export;                 module procedure export_DN_governing_equations;              end interface
       interface import;                 module procedure import_DN_governing_equations;              end interface
       interface export_structured;      module procedure export_structured_DN_governing_equations;   end interface
       interface import_structured;      module procedure import_structured_DN_governing_equations;   end interface

       type governing_equations
         type(momentum) :: mom
         type(induction) :: ind
         type(energy) :: nrg
         type(string) :: dir
         type(string) :: name
       end type

       contains

       subroutine init_copy_governing_equations(this,that)
         implicit none
         type(governing_equations),intent(inout) :: this
         type(governing_equations),intent(in) :: that
         call delete(this)
         call init(this%mom,that%mom)
         call init(this%ind,that%ind)
         call init(this%nrg,that%nrg)
         call init(this%dir,that%dir)
         call init(this%name,that%name)
       end subroutine

       subroutine delete_governing_equations(this)
         implicit none
         type(governing_equations),intent(inout) :: this
         call delete(this%mom)
         call delete(this%ind)
         call delete(this%nrg)
         call delete(this%dir)
         call delete(this%name)
       end subroutine

       subroutine display_governing_equations(this,un)
         implicit none
         type(governing_equations),intent(in) :: this
         integer,intent(in) :: un
         call display(this%mom,un)
         call display(this%ind,un)
         call display(this%nrg,un)
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_short_governing_equations(this,un)
         implicit none
         type(governing_equations),intent(in) :: this
         integer,intent(in) :: un
         call display(this%mom,un)
         call display(this%ind,un)
         call display(this%nrg,un)
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_wrap_governing_equations(this,dir,name)
         implicit none
         type(governing_equations),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_governing_equations(this)
         implicit none
         type(governing_equations),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_governing_equations(this)
         implicit none
         type(governing_equations),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_governing_equations(this,un)
         implicit none
         type(governing_equations),intent(in) :: this
         integer,intent(in) :: un
         call export(this%mom,un)
         call export(this%ind,un)
         call export(this%nrg,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_governing_equations(this,un)
         implicit none
         type(governing_equations),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%mom,un)
         call import(this%ind,un)
         call import(this%nrg,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_governing_equations(this,un)
         implicit none
         type(governing_equations),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_governing_equations(this,un)
         implicit none
         type(governing_equations),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_governing_equations(this,dir,name)
         implicit none
         type(governing_equations),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_governing_equations(this,dir,name)
         implicit none
         type(governing_equations),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_governing_equations(this)
         implicit none
         type(governing_equations),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_governing_equations(this)
         implicit none
         type(governing_equations),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_governing_equations(this)
         implicit none
         type(governing_equations),intent(in) :: this
         integer :: un
         integer :: un_indicate
         un_indicate = new_and_open(str(this%dir),&
         'delete_primitives_to_bypass_restart')
         close(un_indicate)
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%mom,str(this%dir)//'mom'//fortran_PS)
         call export_structured(this%ind,str(this%dir)//'ind'//fortran_PS)
         call export_structured(this%nrg,str(this%dir)//'nrg'//fortran_PS)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_governing_equations(this)
         implicit none
         type(governing_equations),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%mom,str(this%dir)//'mom'//fortran_PS)
         call import_structured(this%ind,str(this%dir)//'ind'//fortran_PS)
         call import_structured(this%nrg,str(this%dir)//'nrg'//fortran_PS)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_governing_equations(this,dir)
         implicit none
         type(governing_equations),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%mom,dir//'mom'//fortran_PS)
         call set_IO_dir(this%ind,dir//'ind'//fortran_PS)
         call set_IO_dir(this%nrg,dir//'nrg'//fortran_PS)
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_governing_equations(this,dir)
         implicit none
         type(governing_equations),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%mom,dir//'mom'//fortran_PS)
         call make_IO_dir(this%ind,dir//'ind'//fortran_PS)
         call make_IO_dir(this%nrg,dir//'nrg'//fortran_PS)
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_governing_equations(this,dir)
         implicit none
         type(governing_equations),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         integer :: un_indicate
         un_indicate = new_and_open(dir,&
         'delete_primitives_to_bypass_restart')
         close(un_indicate)
         call export_structured(this%mom,dir//'mom'//fortran_PS)
         call export_structured(this%ind,dir//'ind'//fortran_PS)
         call export_structured(this%nrg,dir//'nrg'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_governing_equations(this,dir)
         implicit none
         type(governing_equations),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         integer :: un_indicate
         un_indicate = new_and_open(dir,&
         'delete_primitives_to_bypass_restart')
         close(un_indicate)
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%mom,dir//'mom'//fortran_PS)
         call export_structured(this%ind,dir//'ind'//fortran_PS)
         call export_structured(this%nrg,dir//'nrg'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_governing_equations(this,dir)
         implicit none
         type(governing_equations),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%mom,dir//'mom'//fortran_PS)
         call import_structured(this%ind,dir//'ind'//fortran_PS)
         call import_structured(this%nrg,dir//'nrg'//fortran_PS)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_governing_equations(this)
         implicit none
         type(governing_equations),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       ! ***************************************************
       ! ******* THIS CODE IS GENERATED. DO NOT EDIT *******
       ! ***************************************************
       module MOONS_mod
       use config_mod
       use string_mod
       use governing_equations_mod
       use datatype_conversion_mod
       use IO_tools_mod
       use mesh_mod
       use dir_manip_mod
       implicit none

       private
       public :: MOONS
       public :: init,delete,display,display_short,display,print,print_short,&
       export,export_primitives,import,export_folder_structure,&
       export_structured,import_structured,import_primitives,export,import,&
       set_IO_dir,make_IO_dir,suppress_warnings,export,import,&
       export_structured,import_structured

       interface init;                   module procedure init_copy_MOONS;              end interface
       interface delete;                 module procedure delete_MOONS;                 end interface
       interface display;                module procedure display_MOONS;                end interface
       interface display_short;          module procedure display_short_MOONS;          end interface
       interface display;                module procedure display_wrap_MOONS;           end interface
       interface print;                  module procedure print_MOONS;                  end interface
       interface print_short;            module procedure print_short_MOONS;            end interface
       interface export;                 module procedure export_MOONS;                 end interface
       interface export_primitives;      module procedure export_primitives_MOONS;      end interface
       interface import;                 module procedure import_MOONS;                 end interface
       interface export_folder_structure;module procedure export_folder_structure_MOONS;end interface
       interface export_structured;      module procedure export_structured_D_MOONS;    end interface
       interface import_structured;      module procedure import_structured_D_MOONS;    end interface
       interface import_primitives;      module procedure import_primitives_MOONS;      end interface
       interface export;                 module procedure export_wrap_MOONS;            end interface
       interface import;                 module procedure import_wrap_MOONS;            end interface
       interface set_IO_dir;             module procedure set_IO_dir_MOONS;             end interface
       interface make_IO_dir;            module procedure make_IO_dir_MOONS;            end interface
       interface suppress_warnings;      module procedure suppress_warnings_MOONS;      end interface
       interface export;                 module procedure export_DN_MOONS;              end interface
       interface import;                 module procedure import_DN_MOONS;              end interface
       interface export_structured;      module procedure export_structured_DN_MOONS;   end interface
       interface import_structured;      module procedure import_structured_DN_MOONS;   end interface

       type MOONS
         type(config) :: C
         type(governing_equations) :: GE
         type(mesh) :: m_temp
         type(string) :: dir
         type(string) :: name
       end type

       contains

       subroutine init_copy_MOONS(this,that)
         implicit none
         type(MOONS),intent(inout) :: this
         type(MOONS),intent(in) :: that
         call delete(this)
         call init(this%C,that%C)
         call init(this%GE,that%GE)
         call init(this%m_temp,that%m_temp)
         call init(this%dir,that%dir)
         call init(this%name,that%name)
       end subroutine

       subroutine delete_MOONS(this)
         implicit none
         type(MOONS),intent(inout) :: this
         call delete(this%C)
         call delete(this%GE)
         call delete(this%m_temp)
         call delete(this%dir)
         call delete(this%name)
       end subroutine

       subroutine display_MOONS(this,un)
         implicit none
         type(MOONS),intent(in) :: this
         integer,intent(in) :: un
         call display(this%C,un)
         call display(this%GE,un)
         call display(this%m_temp,un)
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_short_MOONS(this,un)
         implicit none
         type(MOONS),intent(in) :: this
         integer,intent(in) :: un
         call display(this%C,un)
         call display(this%GE,un)
         call display(this%m_temp,un)
         call display(this%dir,un)
         call display(this%name,un)
       end subroutine

       subroutine display_wrap_MOONS(this,dir,name)
         implicit none
         type(MOONS),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call display(this,un)
         close(un)
       end subroutine

       subroutine print_MOONS(this)
         implicit none
         type(MOONS),intent(in) :: this
         call display(this,6)
       end subroutine

       subroutine print_short_MOONS(this)
         implicit none
         type(MOONS),intent(in) :: this
         call display_short(this,6)
       end subroutine

       subroutine export_MOONS(this,un)
         implicit none
         type(MOONS),intent(in) :: this
         integer,intent(in) :: un
         call export(this%C,un)
         call export(this%GE,un)
         call export(this%m_temp,un)
         call export(this%dir,un)
         call export(this%name,un)
       end subroutine

       subroutine import_MOONS(this,un)
         implicit none
         type(MOONS),intent(inout) :: this
         integer,intent(in) :: un
         call delete(this)
         call import(this%C,un)
         call import(this%GE,un)
         call import(this%m_temp,un)
         call import(this%dir,un)
         call import(this%name,un)
       end subroutine

       subroutine export_primitives_MOONS(this,un)
         implicit none
         type(MOONS),intent(in) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine import_primitives_MOONS(this,un)
         implicit none
         type(MOONS),intent(inout) :: this
         integer,intent(in) :: un
         integer :: un_suppress_warning
         un_suppress_warning = un
         call suppress_warnings(this)
       end subroutine

       subroutine export_wrap_MOONS(this,dir,name)
         implicit none
         type(MOONS),intent(in) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = new_and_open(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine import_wrap_MOONS(this,dir,name)
         implicit none
         type(MOONS),intent(inout) :: this
         character(len=*),intent(in) :: dir,name
         integer :: un
         un = open_to_read(dir,name)
         call export(this,un)
         close(un)
       end subroutine

       subroutine export_DN_MOONS(this)
         implicit none
         type(MOONS),intent(in) :: this
         call export(this,str(this%dir),str(this%name))
       end subroutine

       subroutine import_DN_MOONS(this)
         implicit none
         type(MOONS),intent(inout) :: this
         type(string) :: dir,name
         integer :: un
         call init(dir,this%dir)
         call init(name,this%name)
         un = open_to_read(str(dir),str(name))
         call import(this,un)
         call delete(dir)
         call delete(name)
         close(un)
       end subroutine

       subroutine export_structured_DN_MOONS(this)
         implicit none
         type(MOONS),intent(in) :: this
         integer :: un
         un = new_and_open(str(this%dir),'primitives')
         call export_primitives(this,un)
         call export_structured(this%C,str(this%dir)//'C'//fortran_PS)
         call export_structured(this%GE,str(this%dir)//'GE'//fortran_PS)
         call export_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call export_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_DN_MOONS(this)
         implicit none
         type(MOONS),intent(inout) :: this
         integer :: un
         un = open_to_read(str(this%dir),'primitives')
         call import_primitives(this,un)
         call import_structured(this%C,str(this%dir)//'C'//fortran_PS)
         call import_structured(this%GE,str(this%dir)//'GE'//fortran_PS)
         call import_structured(this%dir,str(this%dir)//'dir'//fortran_PS)
         call import_structured(this%name,str(this%dir)//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine set_IO_dir_MOONS(this,dir)
         implicit none
         type(MOONS),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call set_IO_dir(this%C,dir//'C'//fortran_PS)
         call set_IO_dir(this%GE,dir//'GE'//fortran_PS)
         call set_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call set_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine make_IO_dir_MOONS(this,dir)
         implicit none
         type(MOONS),intent(inout) :: this
         character(len=*),intent(in) :: dir
         call suppress_warnings(this)
         call make_dir_quiet(dir)
         call init(this%dir,dir)
         call init(this%name,'primitives')
         call make_IO_dir(this%C,dir//'C'//fortran_PS)
         call make_IO_dir(this%GE,dir//'GE'//fortran_PS)
         call make_IO_dir(this%dir,dir//'dir'//fortran_PS)
         call make_IO_dir(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_folder_structure_MOONS(this,dir)
         implicit none
         type(MOONS),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         call export_structured(this%C,dir//'C'//fortran_PS)
         call export_structured(this%GE,dir//'GE'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
       end subroutine

       subroutine export_structured_D_MOONS(this,dir)
         implicit none
         type(MOONS),intent(in) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = new_and_open(dir,'primitives')
         call export_primitives(this,un)
         call export_structured(this%C,dir//'C'//fortran_PS)
         call export_structured(this%GE,dir//'GE'//fortran_PS)
         call export_structured(this%dir,dir//'dir'//fortran_PS)
         call export_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine import_structured_D_MOONS(this,dir)
         implicit none
         type(MOONS),intent(inout) :: this
         character(len=*),intent(in) :: dir
         integer :: un
         un = open_to_read(dir,'primitives')
         call import_primitives(this,un)
         call import_structured(this%C,dir//'C'//fortran_PS)
         call import_structured(this%GE,dir//'GE'//fortran_PS)
         call import_structured(this%dir,dir//'dir'//fortran_PS)
         call import_structured(this%name,dir//'name'//fortran_PS)
         close(un)
       end subroutine

       subroutine suppress_warnings_MOONS(this)
         implicit none
         type(MOONS),intent(in) :: this
         if (.false.) then
           call print(this)
         endif
       end subroutine

       end module
       module export_analytic_mod
       use current_precision_mod
       use SF_extend_mod
       use VF_extend_mod
       use IO_tools_mod
       use mesh_extend_mod
       use profile_funcs_mod
       use export_raw_processed_mod
       use dir_tree_mod
       use string_mod
       use path_extend_mod
       use path_extend_mod
       implicit none

       private
       public :: export_Shercliff
       public :: export_Hunt
       public :: export_Shercliff_Hunt_analytic_sol
       public :: export_numerical_flow_rate

       contains

       subroutine export_Shercliff(m,u_numerical,Ha,dpdh,dir,DT)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: u_numerical
         real(cp),intent(in) :: Ha,dpdh
         integer,intent(in) :: dir
         type(dir_tree),intent(in) :: DT
         type(SF) :: temp
         real(cp) :: mu
         integer :: i
         mu = 1.0_cp
         if (m%s.gt.1) stop 'Error: attempting export_Shercliff with m%s>1 in export_analytic.f90'
         call init_Face(temp,m,dir)
         select case (dir)
         case (1); do i=1,m%B(1)%g%c(dir)%sn
         temp%BF(1)%GF%f(i,:,:) = Shercliff_profile(m%B(1)%g%c(2),m%B(1)%g%c(3),m%B(1)%g%c(2)%sc,m%B(1)%g%c(3)%sc,Ha,mu,dpdh)
         enddo
         case (2); do i=1,m%B(1)%g%c(dir)%sn
         temp%BF(1)%GF%f(:,i,:) = Shercliff_profile(m%B(1)%g%c(1),m%B(1)%g%c(3),m%B(1)%g%c(1)%sc,m%B(1)%g%c(3)%sc,Ha,mu,dpdh)
         enddo
         case (3); do i=1,m%B(1)%g%c(dir)%sn
         temp%BF(1)%GF%f(:,:,i) = Shercliff_profile(m%B(1)%g%c(1),m%B(1)%g%c(2),m%B(1)%g%c(1)%sc,m%B(1)%g%c(2)%sc,Ha,mu,dpdh)
         enddo
         case default; stop 'Error: dir must = 1,2,3 in export_Shercliff in export_analytic.f90'
         end select
         call export_raw(m,temp,str(DT%U%field),'Shercliff_analytic',0)
         call export_raw(m,u_numerical,str(DT%U%field),'Shercliff_numerical',0)
         call export_processed(m,temp,str(DT%U%field),'Shercliff_analytic',1)
         call export_processed(m,u_numerical,str(DT%U%field),'Shercliff_numerical',1)
         call delete(temp)
       end subroutine


       subroutine export_Hunt(m,u_numerical,Ha,dpdh,dir,DT)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: u_numerical
         real(cp),intent(in) :: Ha,dpdh
         integer,intent(in) :: dir
         type(dir_tree),intent(in) :: DT
         type(SF) :: temp
         real(cp) :: mu
         integer :: i
         mu = 1.0_cp
         if (m%s.gt.1) stop 'Error: attempting export_Hunt with m%s>1 in export_analytic.f90'
         call init_Face(temp,m,dir)
         select case (dir)
         case (1); do i=1,m%B(1)%g%c(dir)%sn
         temp%BF(1)%GF%f(i,:,:) = Hunt_profile(m%B(1)%g%c(2),m%B(1)%g%c(3),m%B(1)%g%c(2)%sc,m%B(1)%g%c(3)%sc,Ha,mu,dpdh)
         enddo
         case (2); do i=1,m%B(1)%g%c(dir)%sn
         temp%BF(1)%GF%f(:,i,:) = Hunt_profile(m%B(1)%g%c(1),m%B(1)%g%c(3),m%B(1)%g%c(1)%sc,m%B(1)%g%c(3)%sc,Ha,mu,dpdh)
         enddo
         case (3); do i=1,m%B(1)%g%c(dir)%sn
         temp%BF(1)%GF%f(:,:,i) = Hunt_profile(m%B(1)%g%c(1),m%B(1)%g%c(2),m%B(1)%g%c(1)%sc,m%B(1)%g%c(2)%sc,Ha,mu,dpdh)
         enddo
         case default; stop 'Error: dir must = 1,2,3 in export_Hunt in export_analytic.f90'
         end select
         call export_raw(m,temp,str(DT%U%field),'Hunt_analytic',0)
         call export_raw(m,u_numerical,str(DT%U%field),'Hunt_numerical',0)
         call export_processed(m,temp,str(DT%U%field),'Hunt_analytic',1)
         call export_processed(m,u_numerical,str(DT%U%field),'Hunt_numerical',1)
         call delete(temp)
       end subroutine

       subroutine export_Shercliff_Hunt_analytic_sol(m,u_numerical,Ha,d_B,dpdh,dir,DT)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: u_numerical
         real(cp),intent(in) :: Ha,d_B,dpdh
         integer,intent(in) :: dir
         type(dir_tree),intent(in) :: DT
         type(SF) :: temp
         real(cp) :: mu
         integer :: i
         mu = 1.0_cp
         if (m%s.gt.1) stop 'Error: attempting export_Shercliff_Hunt_analytic_sol with m%s>1 in export_analytic.f90'
         call init_Face(temp,m,dir)
         select case (dir)
         case (1); do i=1,m%B(1)%g%c(dir)%sn
         temp%BF(1)%GF%f(i,:,:) = SH_profile(m%B(1)%g%c(2),m%B(1)%g%c(3),m%B(1)%g%c(2)%sc,m%B(1)%g%c(3)%sc,d_B,Ha,mu,dpdh)
         enddo
         case (2); do i=1,m%B(1)%g%c(dir)%sn
         temp%BF(1)%GF%f(:,i,:) = SH_profile(m%B(1)%g%c(1),m%B(1)%g%c(3),m%B(1)%g%c(1)%sc,m%B(1)%g%c(3)%sc,d_B,Ha,mu,dpdh)
         enddo
         case (3); do i=1,m%B(1)%g%c(dir)%sn
         temp%BF(1)%GF%f(:,:,i) = SH_profile(m%B(1)%g%c(1),m%B(1)%g%c(2),m%B(1)%g%c(1)%sc,m%B(1)%g%c(2)%sc,d_B,Ha,mu,dpdh)
         enddo
         case default; stop 'Error: dir must = 1,2,3 in export_Shercliff_Hunt_analytic_sol in export_analytic.f90'
         end select
         call export_raw(m,temp,str(DT%U%field),'SH_analytic',0)
         call export_raw(m,u_numerical,str(DT%U%field),'SH_numerical',0)
         call export_processed(m,temp,str(DT%U%field),'SH_analytic',1)
         call export_processed(m,u_numerical,str(DT%U%field),'SH_numerical',1)
         call delete(temp)
       end subroutine

       subroutine export_numerical_flow_rate(m,u_numerical,Re,DT)
         implicit none
         type(SF),intent(in) :: u_numerical
         real(cp),intent(in) :: Re
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         real(cp) :: Q
         integer :: un
         un = new_and_open(str(DT%LDC),'numerical_flow_rate')
         ! call boundary_flux(Q,u_numerical,m,u_temp) ! Cancels in and output!
         ! Just need outflux, not net flux
         Q = plane_sum_x(u_numerical%BF(1)%GF,m%B(1)%g,2,1.0_cp)/Re
         write(*,*) 'Numerical flow rate = ',Q
         write(un,*) 'Numerical flow rate = ',Q
         call close_and_message(un,str(DT%LDC),'numerical_flow_rate')
       end subroutine

       end module
       module export_processed_FPL_mod
       use export_field_mod
       use export_planes_mod
       use export_lines_mod
       use export_raw_processed_mod
       use datatype_conversion_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use time_marching_params_mod

       implicit none
       private

       public :: export_processed
       interface export_processed;  module procedure export_unsteady_field_SF; end interface
       interface export_processed;  module procedure export_unsteady_field_VF; end interface
       interface export_processed;  module procedure export_unsteady_plane_SF; end interface
       interface export_processed;  module procedure export_unsteady_plane_VF; end interface
       interface export_processed;  module procedure export_unsteady_line_SF;  end interface
       interface export_processed;  module procedure export_unsteady_line_VF;  end interface

       contains

       subroutine export_unsteady_field_SF(m,x,dir,name,pad,TMP,unsteady_field)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(time_marching_params),intent(in) :: TMP
         type(export_field),intent(in) :: unsteady_field
         if (unsteady_field%export_ever) then
           call export_processed(m,x,dir,name,pad,TMP)
         endif
       end subroutine
       subroutine export_unsteady_field_VF(m,x,dir,name,pad,TMP,unsteady_field)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(time_marching_params),intent(in) :: TMP
         type(export_field),intent(in) :: unsteady_field
         if (unsteady_field%export_ever) then
           call export_processed(m,x,dir,name,pad,TMP)
         endif
       end subroutine

       subroutine export_unsteady_plane_SF(m,x,dir,name,pad,TMP,unsteady_planes)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(time_marching_params),intent(in) :: TMP
         type(export_planes),intent(in) :: unsteady_planes
         integer :: i
         do i=1,unsteady_planes%N
         if (unsteady_planes%EP(i)%export_ever) then
           call export_processed(m,x,dir,name//unsteady_planes%EP(i)%suffix,&
           pad,TMP,unsteady_planes%EP(i)%dir,unsteady_planes%EP(i)%plane)
         endif
         enddo
       end subroutine
       subroutine export_unsteady_plane_VF(m,x,dir,name,pad,TMP,unsteady_planes)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(time_marching_params),intent(in) :: TMP
         type(export_planes),intent(in) :: unsteady_planes
         integer :: i
         do i=1,unsteady_planes%N
         if (unsteady_planes%EP(i)%export_ever) then
           call export_processed(m,x,dir,name//unsteady_planes%EP(i)%suffix,&
            pad,TMP,unsteady_planes%EP(i)%dir,unsteady_planes%EP(i)%plane)
         endif
         enddo
       end subroutine

       subroutine export_unsteady_line_SF(m,x,dir,name,pad,TMP,unsteady_lines)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(time_marching_params),intent(in) :: TMP
         type(export_lines),intent(in) :: unsteady_lines
         integer :: i
         do i=1,unsteady_lines%N
         if (unsteady_lines%EL(i)%export_ever) then
           call export_processed(m,x,dir,name//unsteady_lines%EL(i)%suffix,&
           pad,TMP,unsteady_lines%EL(i)%dir,unsteady_lines%EL(i)%line)
         endif
         enddo
       end subroutine
       subroutine export_unsteady_line_VF(m,x,dir,name,pad,TMP,unsteady_lines)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(time_marching_params),intent(in) :: TMP
         type(export_lines),intent(in) :: unsteady_lines
         integer :: i
         do i=1,unsteady_lines%N
         if (unsteady_lines%EL(i)%export_ever) then
           call export_processed(m,x,dir,name//unsteady_lines%EL(i)%suffix,&
           pad,TMP,unsteady_lines%EL(i)%dir,unsteady_lines%EL(i)%line)
         endif
         enddo
       end subroutine

       end module
       module export_raw_processed_symmetry_mod
       use current_precision_mod
       use mesh_extend_mod
       use export_raw_processed_mod
       use face_edge_corner_indexing_mod
       use string_mod
       use string_aux_mod
       use SF_extend_mod
       use VF_extend_mod
       use datatype_conversion_mod
       use IO_export_mod
       use ops_mirror_field_mod
       use mirror_props_mod

       implicit none

       public :: export_raw
       public :: export_processed

       private
       interface export_raw;       module procedure export_raw_symmetry_SF;       end interface
       interface export_raw;       module procedure export_raw_symmetry_VF;       end interface
       interface export_processed; module procedure export_processed_symmetry_SF; end interface
       interface export_processed; module procedure export_processed_symmetry_VF; end interface

       contains

       ! ************************************* RAW ******************************************

       subroutine export_raw_symmetry_SF(m,x,dir,name,pad,MP)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(mirror_props),intent(in) :: MP
         integer :: d
         type(mesh) :: m_temp
         type(SF) :: x_temp
         type(string) :: s
         d = dir_given_face(MP%mirror_face)
         call mirror_field(m_temp,x_temp,m,x,MP)
         call init(s,int2str(d))
         call remove_leading_zeros(s)
         call export_raw(m_temp,x_temp,dir,name//'_mirror_'//str(s),pad)
         call delete(s)
         call delete(m_temp)
         call delete(x_temp)
       end subroutine

       subroutine export_raw_symmetry_VF(m,x,dir,name,pad,MP)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(mirror_props),intent(in) :: MP
         integer :: d
         type(mesh) :: m_temp
         type(VF) :: x_temp
         type(string) :: s
         d = dir_given_face(MP%mirror_face)
         call mirror_field(m_temp,x_temp,m,x,MP)
         call init(s,int2str(d))
         call remove_leading_zeros(s)
         call export_raw(m_temp,x_temp,dir,name//'_mirror_'//str(s),pad)
         call delete(s)
         call delete(m_temp)
         call delete(x_temp)
       end subroutine

       ! *********************************** PROCESSED **************************************

       subroutine export_processed_symmetry_SF(m,x,dir,name,pad,MP)
         implicit none
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(mirror_props),intent(in) :: MP
         integer :: d
         type(mesh) :: m_temp
         type(SF) :: x_temp
         type(string) :: s
         d = dir_given_face(MP%mirror_face)
         call mirror_field(m_temp,x_temp,m,x,MP)
         call init(s,int2str(d))
         call remove_leading_zeros(s)
         call export_processed(m_temp,x_temp,dir,name//'_mirror_'//str(s),pad)
         call delete(s)
         call delete(m_temp)
         call delete(x_temp)
       end subroutine

       subroutine export_processed_symmetry_VF(m,x,dir,name,pad,MP)
         implicit none
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: x
         character(len=*),intent(in) :: dir,name
         integer,intent(in) :: pad
         type(mirror_props),intent(in) :: MP
         integer :: d
         type(mesh) :: m_temp
         type(VF) :: x_temp
         type(string) :: s
         d = dir_given_face(MP%mirror_face)
         call mirror_field(m_temp,x_temp,m,x,MP)
         call init(s,int2str(d))
         call remove_leading_zeros(s)
         call export_processed(m_temp,x_temp,dir,name//'_mirror_'//str(s),pad)
         call delete(s)
         call delete(m_temp)
         call delete(x_temp)
       end subroutine

       end module
       module ops_aux_mod
       !
       ! Directions are frequently used in this code.
       ! For clarity, some diagrams here show how the
       ! directions are defined.
       !
       ! faceDir = 1 (x)
       !
       !                       z
       !                y      |
       !                 \   __|____
       !                  \ |\ |     \
       !                   \| \|______\
       !      faceDir --->  \  |      |
       !                     \ |      |
       !                      \|______|_____ x
       !
       !
       !
       ! edgeDir = 1 (x)
       !
       !                       z
       !                y      |
       !                 \   __|____
       !                  \ |\ |     \
       !                   \| \|______\
       !                    \  |      |
       !                     \ |      |
       !                      \|______|_____ x
       !                        -------> edgeDir
       !
       !
       use current_precision_mod
       use bctype_extend_mod
       use face_edge_corner_indexing_mod
       use ops_del_mod
       use ops_interp_mod
       use grid_mod
       use mesh_extend_mod
       use mesh_domain_extend_mod
       use ops_embedExtract_mod
       use export_raw_processed_mod
       use GF_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use index_mapping_mod

       implicit none

       private

       ! ----------------------------------- OTHER ROUTINES ------------------------------------

       public :: dot_product
       interface dot_product;             module procedure dot_product_SF;            end interface
       interface dot_product;             module procedure dot_product_VF;            end interface

       public :: flux
       interface flux;                    module procedure flux_VF_SD;                end interface

       public :: subtract_physical_mean
       interface subtract_physical_mean;  module procedure subtract_phys_mean_SF;     end interface
       interface subtract_physical_mean;  module procedure subtract_phys_mean_vol_SF; end interface

       public :: physical_mean
       interface physical_mean;           module procedure phys_mean_vol_SF;          end interface
       interface physical_mean;           module procedure phys_mean_SF;              end interface

       public :: stabilityTerms
       interface stabilityTerms;          module procedure stabilityTerms_GF;         end interface
       interface stabilityTerms;          module procedure stabilityTerms_SF;         end interface
       interface stabilityTerms;          module procedure stabilityTerms_VF;         end interface

       public :: check_symmetry_x
       interface check_symmetry_x;        module procedure check_symmetry_x_SF;       end interface
       interface check_symmetry_x;        module procedure check_symmetry_x_VF;       end interface
       public :: check_symmetry_y
       interface check_symmetry_y;        module procedure check_symmetry_y_SF;       end interface
       interface check_symmetry_y;        module procedure check_symmetry_y_VF;       end interface
       public :: check_symmetry_z
       interface check_symmetry_z;        module procedure check_symmetry_z_SF;       end interface
       interface check_symmetry_z;        module procedure check_symmetry_z_VF;       end interface

       public :: treatInterface
       interface treatInterface;          module procedure treatInterface_GF;         end interface
       interface treatInterface;          module procedure treatInterface_VF;         end interface
       interface treatInterface;          module procedure treatInterface_SF;         end interface

       public :: displayPhysicalMinMax
       interface displayPhysicalMinMax;   module procedure displayPhysicalMinMax_SF;  end interface
       interface displayPhysicalMinMax;   module procedure displayPhysicalMinMax_VF;  end interface

       public :: displayGlobalMinMax
       interface displayGlobalMinMax;     module procedure displayGlobalMinMax_SF;    end interface
       interface displayGlobalMinMax;     module procedure displayGlobalMinMax_VF;    end interface

       public :: unitVector
       interface unitVector;              module procedure unitVector_SF;             end interface

       public :: deleteUnitVector
       interface deleteUnitVector;        module procedure deleteUnitVector_SF;       end interface

       contains

       ! *********************************************************************************
       ! *********************************************************************************
       ! ********************************* REAL ROUTINES *********************************
       ! *********************************************************************************
       ! *********************************************************************************

       subroutine stabilityTerms_GF(fo,fi,g,n,dir) ! Finished
         ! Computes
         !                     |  fi  |
         !    fo =  max( fo  , | ---- | )
         !                     | dh^n |
         !
         implicit none
         type(grid_field),intent(inout) :: fo
         type(grid_field),intent(in) :: fi
         type(grid),intent(in) :: g
         integer,intent(in) :: n,dir
         integer,dimension(3) :: p
         integer :: i,j,k,t
         p = eye_given_dir(dir)
         !$OMP PARALLEL DO
         do k=1,fo%s(3); do j=1,fo%s(2); do i=1,fo%s(1)
           t = i*p(1) + j*p(2) + k*p(3)
           fo%f(i,j,k) = maxval((/fo%f(i,j,k),abs(fi%f(i,j,k)/g%c(dir)%dhn%f(t)**real(n,cp))/))
         enddo; enddo; enddo
         !$OMP END PARALLEL DO
       end subroutine

       subroutine subtract_phys_mean_SF(u)
         ! Subtracts the physical mean from scalar field u
         !      u = u - mean(u)
         ! Where this mean operation is only in the interior
         implicit none
         type(SF),intent(inout) :: u
         real(cp) :: meanU
         meanU = physical_mean(u)
         call subtract(u,meanU)
         call assign_ghost_XPeriodic(u,0.0_cp)
       end subroutine

       subroutine subtract_phys_mean_vol_SF(u,vol,temp)
         ! Subtracts the physical mean from scalar field u
         !      u = u - mean(u)
         ! Where this mean operation is only in the interior
         implicit none
         type(SF),intent(inout) :: u,temp
         type(SF),intent(in) :: vol
         real(cp) :: meanU
         meanU = physical_mean(u,vol,temp)
         call subtract(u,meanU)
         call assign_ghost_XPeriodic(u,0.0_cp)
       end subroutine

       function phys_mean_vol_SF(u,vol,temp) result(meanU)
         ! Computes physical mean from scalar field u: mean(u*volume)
         implicit none
         type(SF),intent(inout) :: u,temp
         type(SF),intent(in) :: vol
         real(cp) :: meanU
         call multiply(temp,u,vol)
         meanU = sum(temp,1)/vol%vol
       end function

       function phys_mean_SF(u) result(meanU)
         ! Computes physical mean from scalar field u: mean(u)
         implicit none
         type(SF),intent(in) :: u
         real(cp) :: meanU
         meanU = sum(u,1)/real(u%numPhysEl,cp)
       end function

       subroutine treatInterface_GF(f,s,take_high_value)
         implicit none
         real(cp),dimension(:,:,:),intent(inout) :: f
         integer,dimension(3),intent(in) :: s
         logical,intent(in) :: take_high_value
         integer :: i,j,k
         real(cp) :: low_value,high_value,tol
         low_value = minval(f); high_value = maxval(f)
         ! Make interface property the min/max of
         ! fluid / wall depending on treatment
         tol = 10.0_cp**(-10.0_cp)
         !$OMP PARALLEL DO
         do k=1,s(3); do j=1,s(2); do i=1,s(1)
         if ((f(i,j,k).gt.low_value+tol).and.(f(i,j,k).lt.high_value-tol)) then
           if (take_high_value) then;  f(i,j,k) = high_value
           else;                       f(i,j,k) = low_value
           endif
         endif
         enddo; enddo; enddo
         !$OMP END PARALLEL DO
       end subroutine

      function dot_product_VF(A,B,x,temp) result(dot)
        implicit none
        type(VF),intent(in) :: A,B,x
        type(VF),intent(inout) :: temp
        real(cp) :: dot
        call multiply(temp,A,B)
        call assign_wall_Dirichlet(temp,0.0_cp,x)
        dot = sum(temp%x,1) + sum(temp%y,1) + sum(temp%z,1)
      end function

      function dot_product_SF(A,B,x,temp) result(dot)
        implicit none
        type(SF),intent(in) :: A,B,x
        type(SF),intent(inout) :: temp
        real(cp) :: dot
        call multiply(temp,A,B)
        call assign_wall_Dirichlet(temp,0.0_cp,x)
        dot = sum(temp,1)
      end function

       ! *********************************************************************************
       ! *********************************************************************************
       ! ******************************* SCALAR ROUTINES *********************************
       ! *********************************************************************************
       ! *********************************************************************************

        subroutine check_symmetry_x_SF(m,u,dir,name,pad)
          implicit none
          type(SF),intent(in) :: u
          type(mesh),intent(in) :: m
          character(len=*),intent(in) :: dir,name
          integer,intent(in) :: pad
          type(SF) :: temp
          real(cp) :: tol,e
          call init(temp,u)
          call assign(temp,u)
          call abs(temp) ! optional
          call symmetry_local_x(temp)
          tol = 10.0_cp**(-15.0_cp); e = amax(temp)
          if (e.gt.tol) then
            call export_raw(m,u,dir,name,pad)
            call export_raw(m,temp,dir,name//'_symm',pad)
            write(*,*) 'Symmetry broken in ',name, ' in check_symmetry_x_SF in SF.f90'
            write(*,*) 'Symmetry error,tol = ',e,tol
            call delete(temp)
            stop 'Done'
          else; call delete(temp)
          endif
        end subroutine

        subroutine check_symmetry_y_SF(m,u,dir,name,pad)
          implicit none
          type(SF),intent(in) :: u
          type(mesh),intent(in) :: m
          character(len=*),intent(in) :: dir,name
          integer,intent(in) :: pad
          type(SF) :: temp
          real(cp) :: tol,e
          call init(temp,u)
          call assign(temp,u)
          call abs(temp) ! optional
          call symmetry_local_y(temp)
          tol = 10.0_cp**(-15.0_cp); e = amax(temp)
          if (e.gt.tol) then
            call export_raw(m,u,dir,name,pad)
            call export_raw(m,temp,dir,name//'_symm',pad)
            write(*,*) 'Symmetry broken in ',name, ' in check_symmetry_y_SF in SF.f90'
            write(*,*) 'Symmetry error,tol = ',e,tol
            call delete(temp)
            stop 'Done'
          else; call delete(temp)
          endif
        end subroutine

        subroutine check_symmetry_z_SF(m,u,dir,name,pad)
          implicit none
          type(SF),intent(in) :: u
          type(mesh),intent(in) :: m
          character(len=*),intent(in) :: dir,name
          integer,intent(in) :: pad
          type(SF) :: temp
          real(cp) :: tol,e
          call init(temp,u)
          call assign(temp,u)
          call abs(temp) ! optional
          call symmetry_local_z(temp)
          tol = 10.0_cp**(-15.0_cp); e = amax(temp)
          if (e.gt.tol) then
            call export_raw(m,u,dir,name,pad)
            call export_raw(m,temp,dir,name//'_symm',pad)
            write(*,*) 'Symmetry broken in ',name, ' in check_symmetry_z_SF in SF.f90'
            write(*,*) 'Symmetry error,tol = ',e,tol
            call delete(temp)
            stop 'Done'
          else; call delete(temp)
          endif
        end subroutine

        subroutine check_symmetry_x_VF(m,A,dir,name,pad)
          implicit none
          type(mesh),intent(in) :: m
          type(VF),intent(in) :: A
          character(len=*),intent(in) :: dir,name
          integer,intent(in) :: pad
          call check_symmetry_x(m,A%x,dir,name//'_x',pad)
          call check_symmetry_x(m,A%y,dir,name//'_y',pad)
          call check_symmetry_x(m,A%z,dir,name//'_z',pad)
        end subroutine

        subroutine check_symmetry_y_VF(m,A,dir,name,pad)
          implicit none
          type(mesh),intent(in) :: m
          type(VF),intent(in) :: A
          character(len=*),intent(in) :: dir,name
          integer,intent(in) :: pad
          call check_symmetry_y(m,A%x,dir,name//'_x',pad)
          call check_symmetry_y(m,A%y,dir,name//'_y',pad)
          call check_symmetry_y(m,A%z,dir,name//'_z',pad)
        end subroutine

        subroutine check_symmetry_z_VF(m,A,dir,name,pad)
          implicit none
          type(mesh),intent(in) :: m
          type(VF),intent(in) :: A
          character(len=*),intent(in) :: dir,name
          integer,intent(in) :: pad
          call check_symmetry_z(m,A%x,dir,name//'_x',pad)
          call check_symmetry_z(m,A%y,dir,name//'_y',pad)
          call check_symmetry_z(m,A%z,dir,name//'_z',pad)
        end subroutine

       subroutine treatInterface_SF(f,take_high_value)
         implicit none
         type(SF),intent(inout) :: f
         logical,intent(in) :: take_high_value
         integer :: i
         do i=1,f%s; call treatInterface(f%BF(i)%GF%f,f%BF(i)%GF%s,take_high_value); enddo
       end subroutine

       subroutine displayPhysicalMinMax_SF(U,name,un)
         implicit none
         type(SF),intent(in) :: U
         character(len=*),intent(in) :: name
         integer,intent(in) :: un
         write(un,*) 'Min/Max ('//name//') = ',min(u,1),max(u,1)
       end subroutine

       subroutine displayGlobalMinMax_SF(U,name,un)
         implicit none
         type(SF),intent(in) :: U
         character(len=*),intent(in) :: name
         integer,intent(in) :: un
         write(un,*) 'Min/Max ('//name//') = ',min(u),max(u)
       end subroutine

       subroutine unitVector_SF(U,un)
         implicit none
         type(SF),intent(inout) :: U
         integer,intent(in) :: un
         integer :: i,j,k,t
         if (un.lt.1) stop 'Error: un must > 0 in unitVector_SF in ops_aux.f90'
         if (un.gt.U%numEl) stop 'Error: un must < U%numEl in unitVector_SF in ops_aux.f90'
         call get_3D_index(i,j,k,t,U,un)
         u%BF(t)%GF%f(i,j,k) = 1.0_cp
       end subroutine

       subroutine deleteUnitVector_SF(U,un)
         implicit none
         type(SF),intent(inout) :: U
         integer,intent(in) :: un
         integer :: i,j,k,t
         if (un.lt.1) stop 'Error: un must > 0 in unitVector_consecutive_SF in ops_aux.f90'
         if (un.gt.U%numEl) stop 'Error: un must < U%numEl in unitVector_consecutive_SF in ops_aux.f90'
         call get_3D_index(i,j,k,t,U,un)
         u%BF(t)%GF%f(i,j,k) = 0.0_cp
       end subroutine

       subroutine stabilityTerms_SF(fo,fi,m,n,dir)
         implicit none
         type(SF),intent(inout) :: fo
         type(SF),intent(in) :: fi
         type(mesh),intent(in) :: m
         integer,intent(in) :: n,dir
         integer :: i
         call assign(fo,0.0_cp)
         do i=1,fi%s; call stabilityTerms(fo%BF(i)%GF,fi%BF(i)%GF,m%B(i)%g,n,dir); enddo
         call assign_ghost_XPeriodic(fo,0.0_cp)
       end subroutine

       ! *********************************************************************************
       ! *********************************************************************************
       ! ******************************* VECTOR ROUTINES *********************************
       ! *********************************************************************************
       ! *********************************************************************************

       subroutine stabilityTerms_VF(fo,fi,m,n)
         implicit none
         type(SF),intent(inout) :: fo
         type(VF),intent(in) :: fi
         type(mesh),intent(in) :: m
         integer,intent(in) :: n
         call stabilityTerms(fo,fi%x,m,n,1)
         call stabilityTerms(fo,fi%y,m,n,2)
         call stabilityTerms(fo,fi%z,m,n,3)
       end subroutine

       subroutine flux_VF_SD(BF,f,m,MD,f_temp)
         implicit none
         real(cp),intent(inout) :: BF
         type(VF),intent(in) :: f
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         type(VF),intent(inout) :: f_temp
         type(mesh) :: m_temp
         type(VF) :: temp
         if (.not.is_Face(f)) stop 'Error: bad DL in flux_VF_SD in ops_aux.f90'
         call init_other(m_temp,m,MD)
         call init_Face(temp,m_temp)
         call extractFace(temp,f,MD)
         call boundary_flux(BF,temp,m_temp,f_temp)
         call delete(temp)
         call delete(m_temp)
       end subroutine

       subroutine treatInterface_VF(f,take_high_value)
         implicit none
         type(VF),intent(inout) :: f
         logical,intent(in) :: take_high_value
         call treatInterface(f%x,take_high_value)
         call treatInterface(f%y,take_high_value)
         call treatInterface(f%z,take_high_value)
       end subroutine

       subroutine displayPhysicalMinMax_VF(U,name,un)
         implicit none
         type(VF),intent(in) :: U
         character(len=*),intent(in) :: name
         integer,intent(in) :: un
         call displayPhysicalMinMax(U%x,name//'_x',un)
         call displayPhysicalMinMax(U%y,name//'_y',un)
         call displayPhysicalMinMax(U%z,name//'_z',un)
       end subroutine

       subroutine displayGlobalMinMax_VF(U,name,un)
         implicit none
         type(VF),intent(in) :: U
         character(len=*),intent(in) :: name
         integer,intent(in) :: un
         call displayGlobalMinMax(U%x,name//'_x',un)
         call displayGlobalMinMax(U%y,name//'_y',un)
         call displayGlobalMinMax(U%z,name//'_z',un)
       end subroutine

       end module
       module time_statistics_extend_mod
       use time_statistics_SF_mod
       use time_statistics_VF_mod
       use current_precision_mod
       use sim_params_mod
       use ops_interp_mod
       use time_marching_params_mod
       use string_mod
       use datatype_conversion_mod
       use mesh_extend_mod
       use probe_extend_mod
       use probe_mod
       use ops_norms_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use stats_period_mod
       use stats_period_extend_mod
       use time_statistics_params_mod
       use time_statistics_params_extend_mod
       use export_raw_processed_mod

       implicit none
       private

       public :: time_statistics_SF
       public :: time_statistics_VF
       public :: init,delete,display,print,export,import ! Essentials

       public :: update

       interface init;     module procedure init_TS_SF;      end interface
       interface init;     module procedure init_TS_VF;      end interface
       interface update;   module procedure update_TS_SF;    end interface
       interface update;   module procedure update_TS_VF;    end interface

       contains

       subroutine init_TS_SF(TS,m,U,TSP,TMP,dir,name)
         implicit none
         type(time_statistics_SF),intent(inout) :: TS
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: U
         type(time_statistics_params),intent(in) :: TSP
         type(time_marching_params),intent(in) :: TMP
         character(len=*),intent(in) :: dir,name
         call init(TS%TSP,TSP)
         call init(TS%mean_energy,dir,'mean_energy',.false.,.true.,TMP)
         call init(TS%U_sum,m,get_DL(U))
         call init(TS%U_ave,m,get_DL(U))
         call init(TS%RMS,m,get_DL(U))
         call init(TS%dir,dir)
         call init(TS%name,name)
         call assign(TS%U_sum,0.0_cp)
         call assign(TS%U_ave,0.0_cp)
         call assign(TS%RMS,0.0_cp)
       end subroutine

       subroutine init_TS_VF(TS,m,U,TSP,TMP,dir,name)
         implicit none
         type(time_statistics_VF),intent(inout) :: TS
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U
         type(time_statistics_params),intent(in) :: TSP
         type(time_marching_params),intent(in) :: TMP
         character(len=*),intent(in) :: dir,name
         call init(TS%TSP,TSP)
         call init(TS%mean_energy,dir,'mean_energy',.false.,.true.,TMP)
         call init(TS%L2_stresses,dir,'L2_stresses',.false.,.true.,TMP)
         call init(TS%U_sum,m,get_DL(U))
         call init(TS%U_ave,m,get_DL(U))
         call init(TS%RMS,m,get_DL(U))
         call init_CC(TS%stresses_sum,m)
         call init_CC(TS%stresses,m)
         call init(TS%dir,dir)
         call init(TS%name,name)
         call assign(TS%U_sum,0.0_cp)
         call assign(TS%U_ave,0.0_cp)
         call assign(TS%RMS,0.0_cp)
         call assign(TS%stresses_sum,0.0_cp)
         call assign(TS%stresses,0.0_cp)
       end subroutine

       subroutine update_TS_SF(TS,m,U,TMP,temp,compute_export_norms)
         implicit none
         type(time_statistics_SF),intent(inout) :: TS
         type(time_marching_params),intent(in) :: TMP
         type(mesh),intent(in) :: m
         type(SF),intent(in) :: U
         type(SF),intent(inout) :: temp
         logical,intent(in) :: compute_export_norms
         real(cp) :: temp_cp
         if (TS%TSP%collect) then
           call update(TS%TSP,TMP)

           if (TS%TSP%O1_stats%compute_stats) then ! Compute 1st order statistics (ubar)
             call add_product(TS%U_sum,U,TMP%TS%dt)

             call assign(TS%U_ave,TS%U_sum)
             call multiply(TS%U_ave,get_coeff(TS%TSP%O1_stats,TMP))

             if (compute_export_norms) then
               call compute_Ln(temp_cp,TS%U_ave,2.0_cp,m)
               temp_cp = 0.5_cp*temp_cp
               call export(TS%mean_energy,TMP,temp_cp)
             endif

             call assign(temp,U)
             call square(temp)
             call add_product(TS%RMS,temp,TMP%TS%dt)
           endif

           if (TS%TSP%O1_stats%export_stats) then
             call square_root(TS%RMS)
             call subtract(temp,U,TS%U_ave)
             call export_processed(m,TS%RMS  ,str(TS%dir),str(TS%name)//'_RMS'         ,1,TMP)
             call export_processed(m,TS%U_ave,str(TS%dir),str(TS%name)//'_time_average',1,TMP)
             call export_processed(m,U       ,str(TS%dir),str(TS%name)//'_instant'     ,1,TMP)
             call export_processed(m,temp    ,str(TS%dir),str(TS%name)//'_fluctuating' ,1,TMP)
             call set_exported_stats(TS%TSP%O1_stats)
           endif
         endif
       end subroutine

       subroutine update_TS_VF(TS,m,U,TMP,temp_VF,temp_CC,TF_CC,compute_export_norms)
         implicit none
         type(time_statistics_VF),intent(inout) :: TS
         type(time_marching_params),intent(in) :: TMP
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U
         type(VF),intent(inout) :: temp_VF,temp_CC
         type(TF),intent(inout) :: TF_CC
         logical,intent(in) :: compute_export_norms
         real(cp) :: temp_cp
         if (TS%TSP%collect) then

           call update(TS%TSP,TMP)
           if (TS%TSP%O1_stats%compute_stats) then ! Compute 1st order statistics (ubar)
             call add_product(TS%U_sum,U,TMP%TS%dt)

             ! call add(temp_VF,U,Unm1)
             call multiply(TS%U_ave,get_coeff(TS%TSP%O1_stats,TMP))
             call assign(TS%U_ave,TS%U_sum)
             call multiply(TS%U_ave,get_coeff(TS%TSP%O1_stats,TMP))

             if (compute_export_norms) then
               call face2cellcenter(temp_CC,TS%U_ave,m)
               call compute_Ln(temp_cp,temp_CC,2.0_cp,m)
               temp_cp = 0.5_cp*temp_cp
               call export(TS%mean_energy,TMP,temp_cp)
             endif

             call assign(temp_VF,U)
             call square(temp_VF)
             call add_product(TS%RMS,temp_VF,TMP%TS%dt)
             call add_stat(TS%TSP%O1_stats)
           endif

           if (TS%TSP%O2_stats%compute_stats) then ! 2nd order statistics (Reynolds stresses)
             call subtract(temp_VF,U,TS%U_ave) ! fluctuating
             call face2cellcenter(temp_CC,temp_VF,m)
             call multiply(TF_CC%x%x,temp_CC%x,temp_CC%x)
             call multiply(TF_CC%x%y,temp_CC%x,temp_CC%y)
             call multiply(TF_CC%x%z,temp_CC%x,temp_CC%z)
             call multiply(TF_CC%y%x,temp_CC%y,temp_CC%x)
             call multiply(TF_CC%y%y,temp_CC%y,temp_CC%y)
             call multiply(TF_CC%y%z,temp_CC%y,temp_CC%z)
             call multiply(TF_CC%z%x,temp_CC%z,temp_CC%x)
             call multiply(TF_CC%z%y,temp_CC%z,temp_CC%y)
             call multiply(TF_CC%z%z,temp_CC%z,temp_CC%z)
             call add_product(TS%stresses_sum,TF_CC,TMP%TS%dt)

             call assign(TS%stresses,TS%stresses_sum)
             call multiply(TS%stresses,get_coeff(TS%TSP%O2_stats,TMP))

             if (compute_export_norms) then
               call compute_Ln(temp_cp,TS%stresses,2.0_cp,m)
               call export(TS%L2_stresses,TMP,temp_cp)
             endif

             call add_stat(TS%TSP%O2_stats)
           endif

           if (TS%TSP%O1_stats%export_stats) then
             call square_root(TS%RMS)
             call subtract(temp_VF,U,TS%U_ave)
             call export_processed(m,TS%RMS  ,str(TS%dir),str(TS%name)//'_RMS'         ,1,TMP)
             call export_processed(m,TS%U_ave,str(TS%dir),str(TS%name)//'_time_average',1,TMP)
             call export_processed(m,U       ,str(TS%dir),str(TS%name)//'_instant'     ,1,TMP)
             call export_processed(m,temp_VF    ,str(TS%dir),str(TS%name)//'_fluctuating' ,1,TMP)
             call set_exported_stats(TS%TSP%O1_stats)
           endif

           if (TS%TSP%O2_stats%export_stats) then
             call export_processed(m,TS%stresses%x,str(TS%dir),str(TS%name)//'_Rx',1,TMP)
             call export_processed(m,TS%stresses%y,str(TS%dir),str(TS%name)//'_Ry',1,TMP)
             call export_processed(m,TS%stresses%z,str(TS%dir),str(TS%name)//'_Rz',1,TMP)
             call set_exported_stats(TS%TSP%O2_stats)
           endif
         endif
       end subroutine

       function get_coeff(SP,TMP) result(coeff)
         implicit none
         type(stats_period),intent(in) :: SP
         type(time_marching_params),intent(in) :: TMP
         real(cp) :: coeff
         coeff = 1.0_cp/(TMP%t-SP%t_start)
         coeff = 1.0_cp/(TMP%t-SP%t_start+TMP%TS%dt)
       end function

       end module
       module MOONS_IO_controls_mod
       use MOONS_mod
       implicit none

       private
       public :: MOONS_export_controls
       public :: MOONS_import_controls
       interface MOONS_export_controls;  module procedure export_controls_MOONS;  end interface
       interface MOONS_import_controls;  module procedure import_controls_MOONS;  end interface

       contains

       subroutine export_controls_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         write(*,*) 'GH 1'; call export_structured(M%C%SP%DP)
         write(*,*) 'GH 2'; call export_structured(M%GE%mom%PCG_U%ISP%EC)
         write(*,*) 'GH 3'; call export_structured(M%GE%mom%PCG_P%ISP%EC)
         write(*,*) 'GH 4'; call export_structured(M%GE%ind%PCG_B%ISP%EC)
         write(*,*) 'GH 5'; call export_structured(M%GE%ind%PCG_B%ISP%EC)
         write(*,*) 'GH 6'; call export_structured(M%GE%ind%PCG_cleanB%ISP%EC)
         write(*,*) 'GH 7'; call export_exit_criteria(M%C%SP%VS)
         write(*,*) 'GH 8'; call export_TMP_dt(M%C%SP%VS)
         write(*,*) 'GH 9'; call export_structured(M%C%SP%coupled%TS)
         write(*,*) 'GH 10'; if (M%C%SP%SCP%couple_time_steps) call couple_time_step(M%C%SP%VS,M%C%SP%coupled)
         write(*,*) 'GH 11'; call export_structured(M%C%EN)
       end subroutine

       subroutine import_controls_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         call import_structured(M%C%SP%DP)
         call import_structured(M%GE%mom%PCG_U%ISP%EC)
         call import_structured(M%GE%mom%PCG_P%ISP%EC)
         call import_structured(M%GE%ind%PCG_B%ISP%EC)
         call import_structured(M%GE%ind%PCG_B%ISP%EC)
         call import_structured(M%GE%ind%PCG_cleanB%ISP%EC)
         call import_exit_criteria(M%C%SP%VS)
         call import_TMP_dt(M%C%SP%VS)
         call import_structured(M%C%SP%coupled%TS)
         if (M%C%SP%SCP%couple_time_steps) call couple_time_step(M%C%SP%VS,M%C%SP%coupled)
         call import_structured(M%C%EN)
       end subroutine

       end module
       module MOONS_export_full_restart_mod
       use string_mod
       use path_extend_mod
       use MOONS_mod
       implicit none

       private
       public :: MOONS_export_full_restart
       public :: MOONS_prep_full_restart
       interface MOONS_export_full_restart; module procedure MOONS_export_full_restart_M; end interface
       interface MOONS_prep_full_restart; module procedure MOONS_prep_full_restart_M; end interface

       contains

       subroutine MOONS_prep_full_restart_M(M)
         implicit none
         type(MOONS),intent(inout) :: M
#ifdef EXPORT_FOR_AUTO_RESTART
         call export_structured(M%C,str(M%C%DT%restart))
         call export_structured(M%GE,str(M%C%DT%restart))
         call alternate_restart_path_MOONS(M)
         call set_IO_dir(M%C,str(M%C%DT%restart))
         call set_IO_dir(M%GE,str(M%C%DT%restart))
         call make_IO_dir(M%C,str(M%C%DT%restart))
         call make_IO_dir(M%GE,str(M%C%DT%restart))
         call MOONS_export_full_restart(M)
#endif
       end subroutine

       subroutine MOONS_export_full_restart_M(M)
         implicit none
         type(MOONS),intent(inout) :: M
#ifdef EXPORT_FOR_AUTO_RESTART
         write(*,*) 'Exporting entire MOONS restart to ',str(M%C%DT%restart)
         write(*,*) 'This may take a few minutes...'
         call export_structured(M%C,str(M%C%DT%restart))
         call export_structured(M%GE,str(M%C%DT%restart))
         call alternate_restart_path_MOONS(M)
         call set_IO_dir(M%C,str(M%C%DT%restart))
         call set_IO_dir(M%GE,str(M%C%DT%restart))
#endif
       end subroutine

       subroutine alternate_restart_path_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         write(*,*) 'alternating path: '
         write(*,*) 'From M%C%DT%restart = ',str(M%C%DT%restart)
         if (identical(M%C%DT%restart%relative,M%C%DT%restart1%relative)) then
           call init(M%C%DT%restart,M%C%DT%restart2)
         elseif (identical(M%C%DT%restart%relative,M%C%DT%restart2%relative)) then
           call init(M%C%DT%restart,M%C%DT%restart1)
         else
           write(*,*) 'Warning: alternate_restart_path_MOONS'
           write(*,*) 'is not alternating the restart path.'
         endif
         write(*,*) 'To   M%C%DT%restart = ',str(M%C%DT%restart)
       end subroutine

       end module
       module MOONS_simulate_crash_mod
       use MOONS_mod
       implicit none

       private
       public :: simulate_crash
       interface simulate_crash;   module procedure simulate_crash_MOONS;    end interface

       contains

       subroutine simulate_crash_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         if (M%C%SP%FCL%simulate_crash) then
         if (M%C%SP%coupled%n_step.eq.447) then ! crash simulator
           stop 'Done in MOONS_solver'
         endif
         endif
         if (M%C%SP%FCL%restart_simulated_crash) then
         if (M%C%SP%coupled%n_step.eq.947) then ! after crash simulator
           stop 'Done in MOONS_solver'
         endif
         endif
       end subroutine
       end module
       module export_mesh_aux_mod
       use current_precision_mod
       use IO_tools_mod
       use IO_import_mod
       use IO_export_mod

       use mesh_extend_mod
       use mesh_domain_extend_mod
       use mesh_block_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use string_mod
       use path_extend_mod
       use dir_tree_mod
       use mirror_props_mod

       use sim_params_mod
       use export_raw_processed_symmetry_mod
       use export_raw_processed_mod
       use ops_mirror_field_mod

       implicit none

       private
       public :: export_mesh_aux

       contains

       subroutine export_mesh_aux(SP,DT,m_mom,m_ind)
         implicit none
         type(mesh),intent(in) :: m_mom,m_ind
         type(sim_params),intent(in) :: SP
         type(dir_tree),intent(in) :: DT
         type(mesh_block) :: MB
         type(mesh) :: m_temp
         type(SF) :: vol_CC

         if (SP%EL%export_cell_volume) then
           if (SP%VS%U%SS%initialize) then
             call init(m_temp,m_mom)
             call init_CC(vol_CC,m_temp); call volume(vol_CC,m_temp)
             call export_raw(m_temp,vol_CC,str(DT%meshes),'cell_volume_mom',0)
             call delete(vol_CC); call delete(m_temp)
           endif
           if (SP%VS%B%SS%initialize) then
             call init(m_temp,m_ind)
             call init_CC(vol_CC,m_temp); call volume(vol_CC,m_temp)
             call export_raw(m_temp,vol_CC,str(DT%meshes),'cell_volume_ind',0)
             call delete(vol_CC); call delete(m_temp)
           endif
         endif
         if (SP%EL%export_mesh_block) then
           if (SP%VS%U%SS%initialize) then
             call init(MB,m_mom%B(1))
             call export_mesh(MB%m,str(DT%meshes),'mesh_block_mom',0)
             call delete(MB)
           endif
           if (SP%VS%B%SS%initialize) then
             call init(MB,m_ind%B(1))
             call export_mesh(MB%m,str(DT%meshes),'mesh_block_ind',0)
             call delete(MB)
           endif
         endif
       end subroutine

       end module
       module ops_discrete_mod
       !
       ! Directions are frequently used in this code.
       ! For clarity, some diagrams here show how the
       ! directions are defined.
       !
       ! faceDir = 1 (x)
       !
       !                       z
       !                y      |
       !                 \   __|____
       !                  \ |\ |     \
       !                   \| \|______\
       !      faceDir --->  \  |      |
       !                     \ |      |
       !                      \|______|_____ x
       !
       !
       !
       ! edgeDir = 1 (x)
       !
       !                       z
       !                y      |
       !                 \   __|____
       !                  \ |\ |     \
       !                   \| \|______\
       !                    \  |      |
       !                     \ |      |
       !                      \|______|_____ x
       !                        -------> edgeDir
       !
       !
       use current_precision_mod
       use ops_del_mod
       use mesh_extend_mod
       use data_location_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use ops_interp_mod
       use ops_aux_mod

       implicit none

       private
       public :: lap
       interface lap;            module procedure lapUniformCoeff_SF;      end interface
       interface lap;            module procedure lapUniformCoeff_VF;      end interface
       interface lap;            module procedure lapVarCoeff_SF;          end interface
       interface lap;            module procedure lapVarCoeff_VF;          end interface

       public :: lap_centered
       interface lap_centered;   module procedure lap_centered_SF_new;     end interface
       interface lap_centered;   module procedure lap_centered_VF_new;     end interface

       public :: div
       interface div;            module procedure div_SF;                  end interface
       interface div;            module procedure div_VF;                  end interface
       interface div;            module procedure div_TF;                  end interface

       public :: grad
       interface grad;           module procedure grad_SF;                 end interface
       interface grad;           module procedure grad_VF;                 end interface
       interface grad;           module procedure grad_TF;                 end interface

       public :: grad_no_diag
       interface grad_no_diag;   module procedure grad_no_diag_TF;         end interface

       public :: divGrad
       interface divGrad;        module procedure divGrad_VF;              end interface

       public :: curl
       interface curl;           module procedure curl_SF;                 end interface
       interface curl;           module procedure curl_VF;                 end interface
       interface curl;           module procedure curl_TF;                 end interface

       public :: curl_parallel
       interface curl_parallel;  module procedure curl_TF_Parallel;        end interface

       public :: curlcurl
       interface curlcurl;       module procedure curlcurlCoeff_VF;        end interface
       interface curlcurl;       module procedure curlcurlUniform_VF;      end interface

       public :: mixed
       interface mixed;          module procedure mixed_uniformCoeff_SF;   end interface
       interface mixed;          module procedure mixed_uniformCoeff_VF;   end interface
       interface mixed;          module procedure mixed_variableCoeff_SF;  end interface
       interface mixed;          module procedure mixed_variableCoeff_VF;  end interface

       public :: surface_power
       interface surface_power;  module procedure surface_power_VF;        end interface

       contains

       ! *********************************************************************************
       ! *********************************************************************************
       ! *************************** SCALAR FIELD ROUTINES *******************************
       ! *********************************************************************************
       ! *********************************************************************************

       subroutine lapUniformCoeff_SF(lapU,u,m)
         implicit none
         type(SF),intent(inout) :: lapU
         type(SF),intent(in) :: u
         type(mesh),intent(in) :: m
         type(del) :: d
         call d%assign(lapU,u,m,2,1,0)
            call d%add(lapU,u,m,2,2,0)
            call d%add(lapU,u,m,2,3,0)
       end subroutine

       subroutine lap_centered_SF_given_both(lapU,U,m,temp)
         implicit none
         type(SF),intent(inout) :: lapU
         type(SF),intent(in) :: U
         type(mesh),intent(in) :: m
         type(VF),intent(inout) :: temp
         type(del) :: d
         call d%assign(temp%x,U,m,1,1,0); call d%assign(lapU,temp%x,m,1,1,0)
         call d%assign(temp%y,U,m,1,2,0); call d%add   (lapU,temp%y,m,1,2,0)
         call d%assign(temp%z,U,m,1,3,0); call d%add   (lapU,temp%z,m,1,3,0)
       end subroutine

       subroutine lap_centered_SF_new(lapU,U,m,VF_temp)
         implicit none
         type(SF),intent(inout) :: lapU
         type(SF),intent(in) :: U
         type(mesh),intent(in) :: m
         type(VF),intent(inout) :: VF_temp
         call grad(VF_temp,U,m)
         call div(lapU,VF_temp,m)
       end subroutine

       subroutine lap_centered_VF_new(lapU,U,m,TF_temp)
         implicit none
         type(VF),intent(inout) :: lapU
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         type(TF),intent(inout) :: TF_temp
         call lap_centered_SF_given_both(lapU%x,U%x,m,TF_temp%x)
         call lap_centered_SF_given_both(lapU%y,U%y,m,TF_temp%y)
         call lap_centered_SF_given_both(lapU%z,U%z,m,TF_temp%z)
       end subroutine

       subroutine lapVarCoeff_SF(lapU,u,k,m,temp,dir)
         implicit none
         type(SF),intent(inout) :: lapU
         type(SF),intent(in) :: u,k
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: temp
         integer,intent(in) :: dir
         type(del) :: d
         call d%assign(temp,u,m,1,dir,1)
         call multiply(temp,k)
         call d%assign(lapU,temp,m,1,dir,1)
       end subroutine

       subroutine div_SF(divU,u,v,w,m)
         implicit none
         type(SF),intent(inout) :: divU
         type(SF),intent(in) :: u,v,w
         type(mesh),intent(in) :: m
         type(del) :: d
         call d%assign(divU,u,m,1,1,0) ! Padding avoids calcs on fictive cells
            call d%add(divU,v,m,1,2,0) ! Padding avoids calcs on fictive cells
            call d%add(divU,w,m,1,3,0) ! Padding avoids calcs on fictive cells

         ! Note that padding above does not zero wall normal values
         ! from being calculated. Removing ghost nodes is still necessary:
         call assign_ghost_XPeriodic(divU,0.0_cp) ! padding avoids boundaries
       end subroutine

       subroutine grad_SF(gradx,grady,gradz,u,m)
         implicit none
         type(SF),intent(inout) :: gradx,grady,gradz
         type(SF),intent(in) :: u
         type(mesh),intent(in) :: m
         type(del) :: d
         call d%assign(gradx,u,m,1,1,0) ! Padding avoids calcs on fictive cells
         call d%assign(grady,u,m,1,2,0) ! Padding avoids calcs on fictive cells
         call d%assign(gradz,u,m,1,3,0) ! Padding avoids calcs on fictive cells
       end subroutine

       subroutine curl_SF(curlU,u,v,w,m,dir)
         ! curl_GF computes curlU (component dir) of
         ! the collocated u,v,w field.
         implicit none
         type(SF),intent(inout) :: curlU
         type(SF),intent(in) :: u,v,w
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir
         type(del) :: d
         select case (dir)
         case (1); call d%assign(curlU,w,m,1,2,0)
                 call d%subtract(curlU,v,m,1,3,0)
         case (2); call d%assign(curlU,u,m,1,3,0)
                 call d%subtract(curlU,w,m,1,1,0)
         case (3); call d%assign(curlU,v,m,1,1,0)
                 call d%subtract(curlU,u,m,1,2,0)
         case default; stop 'Error: dir must = 1,2,3 in curl_SF in ops_discrete.f90'
         end select
       end subroutine

       subroutine mixed_uniformCoeff_SF(mix,f,m,temp,dir1,dir2)
         ! Computes
         !     mix =  d/dxj (df/dxi)
         !               ^       ^
         !               |       |
         !              dir2    dir1
         !
         !     if dir1 == dir2  --> Error (call Laplacian instead)
         !     if dir1 ≠ dir2   --> see below
         !
         implicit none
         type(SF),intent(inout) :: mix,temp
         type(SF),intent(in) :: f
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir1,dir2
         type(del) :: d
#if _DEBUG_DISCRETE_OPS_
         if (dir1.eq.dir2) then
           write(*,*) 'Error: dir1=dir2 in mixed_uniformCoeff_GF in ops_discrete.f90'
           stop 'Call laplacian operator instead.'
         endif
#endif
         call d%assign(temp,f,m,1,dir1,1)
         call d%assign(mix,temp,m,1,dir2,1)
       end subroutine

       subroutine mixed_variableCoeff_SF(mix,f,k,m,temp,dir1,dir2)
         ! Computes
         !     mix =  d/dxj (k df/dxi)
         !               ^         ^
         !               |         |
         !              dir2      dir1
         !
         !     if dir1 == dir2  --> Error (call laplacian instead)
         !     if dir1 ≠ dir2   --> see below
         !
         ! NOTE: k must live in same domain as df/dxi
         !
         implicit none
         type(SF),intent(inout) :: mix,temp
         type(SF),intent(in) :: f,k
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir1,dir2
         type(del) :: d
#if _DEBUG_DISCRETE_OPS_
         if (dir1.eq.dir2) then
           write(*,*) 'Error: dir1=dir2 in mixed_variableCoeff_GF in ops_discrete.f90'
           stop 'Call laplacian operator instead.'
         endif
#endif
         call d%assign(temp,f,m,1,dir1,1)
         call multiply(temp,k)
         call d%assign(mix,temp,m,1,dir2,1)
       end subroutine

       ! *********************************************************************************
       ! *********************************************************************************
       ! ******************************* VECTOR ROUTINES *********************************
       ! *********************************************************************************
       ! *********************************************************************************

       subroutine lapUniformCoeff_VF(lapU,u,m)
         implicit none
         type(VF),intent(inout) :: lapU
         type(VF),intent(in) :: u
         type(mesh),intent(in) :: m
         call lap(lapU%x,U%x,m)
         call lap(lapU%y,U%y,m)
         call lap(lapU%z,U%z,m)
       end subroutine

       subroutine lapVarCoeff_VF(lapU,u,k,m,tempk)
         implicit none
         type(SF),intent(inout) :: lapU
         type(SF),intent(in) :: u
         type(VF),intent(in) :: k
         type(mesh),intent(in) :: m
         type(VF),intent(inout) :: tempk
         call grad(tempk,u,m)
         call multiply(tempk,k)
         call div(lapU,tempk,m)
       end subroutine

       subroutine div_VF(divU,U,m)
         implicit none
         type(SF),intent(inout) :: divU
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         call div(divU,U%x,U%y,U%z,m)
       end subroutine

       subroutine div_TF(divU,U,m)
         implicit none
         type(VF),intent(inout) :: divU
         type(TF),intent(in) :: U
         type(mesh),intent(in) :: m
         call div(divU%x,U%x,m)
         call div(divU%y,U%y,m)
         call div(divU%z,U%z,m)
       end subroutine

       subroutine grad_VF(gradU,U,m)
         implicit none
         type(VF),intent(inout) :: gradU
         type(SF),intent(in) :: U
         type(mesh),intent(in) :: m
         call grad(gradU%x,gradU%y,gradU%z,U,m)
       end subroutine

       subroutine grad_TF(gradU,U,m)
         implicit none
         type(TF),intent(inout) :: gradU
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         call grad(gradU%x,U%x,m)
         call grad(gradU%y,U%y,m)
         call grad(gradU%z,U%z,m)
       end subroutine

       subroutine grad_no_diag_TF(gradU,U,m)
         implicit none
         type(TF),intent(inout) :: gradU
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         type(del) :: d
         call d%assign(gradU%x%y,U%x,m,1,2,0)
         call d%assign(gradU%x%z,U%x,m,1,3,0)
         call d%assign(gradU%y%x,U%y,m,1,1,0)
         call d%assign(gradU%y%z,U%y,m,1,3,0)
         call d%assign(gradU%z%x,U%z,m,1,1,0)
         call d%assign(gradU%z%y,U%z,m,1,2,0)
       end subroutine

       subroutine divGrad_VF(divGradU,U,m,temp_TF)
         ! This routine achieves consecutive staggered derivatives
         ! to compute lap(U). If U lives on the cell face, then
         !
         !            _          _
         !           |  CC E  E   |
         ! temp_TF = |  E  CC E   |
         !           |_ E  E  CC _|
         !
         implicit none
         type(VF),intent(inout) :: divGradU
         type(VF),intent(in) :: U
         type(TF),intent(inout) :: temp_TF
         type(mesh),intent(in) :: m
         call grad(temp_TF,U,m)
         call div(divGradU%x,temp_TF%x,m)
         call div(divGradU%y,temp_TF%y,m)
         call div(divGradU%z,temp_TF%z,m)
       end subroutine

       subroutine curl_VF(curlU,U,m)
         implicit none
         type(VF),intent(inout) :: curlU
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         call curl(curlU%x,U%x,U%y,U%z,m,1)
         call curl(curlU%y,U%x,U%y,U%z,m,2)
         call curl(curlU%z,U%x,U%y,U%z,m,3)
       end subroutine

       subroutine curl_TF_Parallel(curlU,U,m)
         ! For a staggered implementation, this curl performs:
         !           U  = {CC}
         !      curl(U) = {F}
         ! Or
         !           U  = {F}
         !      curl(U) = {CC}
         ! In other words, the curl lands PARALLEL TO
         ! the plane of the cell face
         implicit none
         type(VF),intent(inout) :: curlU
         type(TF),intent(in) :: U
         type(mesh),intent(in) :: m
         call curl(curlU%x,U%x%x,U%y%z,U%z%y,m,1) ! Note the diagonal input does not matter
         call curl(curlU%y,U%x%z,U%y%y,U%z%x,m,2) ! Note the diagonal input does not matter
         call curl(curlU%z,U%x%y,U%y%x,U%z%z,m,3) ! Note the diagonal input does not matter
       end subroutine

       subroutine curl_TF(curlU,U,m)
         ! For a staggered implementation, this curl performs:
         !           U  = {E}
         !      curl(U) = {F}
         ! Or
         !           U  = {F}
         !      curl(U) = {E}
         ! In other words, the curl lands NORMAL TO
         ! the plane of the cell face
         implicit none
         type(VF),intent(inout) :: curlU
         type(TF),intent(in) :: U
         type(mesh),intent(in) :: m
         call curl(curlU%x,U%x%x,U%y%y,U%z%z,m,1) ! Note the diagonal input does not matter
         call curl(curlU%y,U%x%x,U%y%y,U%z%z,m,2) ! Note the diagonal input does not matter
         call curl(curlU%z,U%x%x,U%y%y,U%z%z,m,3) ! Note the diagonal input does not matter
       end subroutine

       subroutine curlcurlCoeff_VF(curlcurlU,U,k,temp,m)
         ! Computes
         !     ∇x(k∇x)
         !
         ! NOTE: curl(U) will live at the same location as k
         !
         implicit none
         type(VF),intent(inout) :: curlcurlU
         type(VF),intent(inout) :: temp
         type(VF),intent(in) :: U,k
         type(mesh),intent(in) :: m
         call curl(temp,U,m)
         call multiply(temp,k)
         call curl(curlcurlU,temp,m)
       end subroutine

       subroutine curlcurlUniform_VF(curlcurlU,U,temp,m)
         ! Computes
         !     ∇x∇x
         !
         ! NOTE: curl(U) will live at the same location as k
         !
         implicit none
         type(VF),intent(inout) :: curlcurlU
         type(VF),intent(inout) :: temp
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         call curl(temp,U,m)
         call curl(curlcurlU,temp,m)
       end subroutine

       subroutine mixed_uniformCoeff_VF(mix,f,m,temp)
         implicit none
         type(VF),intent(inout) :: mix
         type(VF),intent(inout) :: temp
         type(SF),intent(in) :: f
         type(mesh),intent(in) :: m
         call mixed(mix%x,f,m,temp%x,2,3)
         call mixed(mix%y,f,m,temp%y,1,3)
         call mixed(mix%z,f,m,temp%z,1,2)
       end subroutine

       subroutine mixed_variableCoeff_VF(mix,f,k,m,temp)
         implicit none
         type(VF),intent(inout) :: mix
         type(VF),intent(inout) :: temp
         type(VF),intent(in) :: k
         type(SF),intent(in) :: f
         type(mesh),intent(in) :: m
         call mixed(mix%x,f,k%y,m,temp%y,2,3) ! Shape of k must match dir1
         call mixed(mix%y,f,k%x,m,temp%x,1,3) ! Shape of k must match dir1
         call mixed(mix%z,f,k%x,m,temp%x,1,2) ! Shape of k must match dir1
       end subroutine

       subroutine surface_power_VF(Q,u,m,temp_F1,temp_F2,temp_CC,temp_TF)
         ! Computes: BF = ∫∫ u_tangent•grad(u_tangent) dA
         implicit none
         real(cp),intent(inout) :: Q
         type(VF),intent(in) :: u
         type(VF),intent(inout) :: temp_F1,temp_F2,temp_CC
         type(TF),intent(inout) :: temp_TF
         type(mesh),intent(in) :: m
         real(cp) :: temp
         Q = 0.0_cp; temp = 0.0_cp
         call face2CellCenter(temp_CC,u,m)
         call grad_no_diag(temp_TF,temp_CC,m)
         call extrap(temp_TF,m)
         ! x-faces
         call surface_power_component(temp,temp_TF%y%x,temp_CC%y,m,temp_F1%x,temp_F2%x,1); Q=Q+temp
         call surface_power_component(temp,temp_TF%z%x,temp_CC%z,m,temp_F1%x,temp_F2%x,1); Q=Q+temp
         ! y-faces
         call surface_power_component(temp,temp_TF%x%y,temp_CC%x,m,temp_F1%y,temp_F2%y,2); Q=Q+temp
         call surface_power_component(temp,temp_TF%z%y,temp_CC%z,m,temp_F1%y,temp_F2%y,2); Q=Q+temp
         ! z-faces
         call surface_power_component(temp,temp_TF%x%z,temp_CC%x,m,temp_F1%z,temp_F2%z,3); Q=Q+temp
         call surface_power_component(temp,temp_TF%y%z,temp_CC%y,m,temp_F1%z,temp_F2%z,3); Q=Q+temp
       end subroutine

       subroutine surface_power_component(Q,CC1,CC2,m,temp_F1,temp_F2,dir)
         ! Computes: BF = ∫∫ u•tau_wall dA
         implicit none
         real(cp),intent(inout) :: Q
         type(SF),intent(inout) :: temp_F1,temp_F2
         type(SF),intent(in) :: CC1,CC2
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir
         call cellcenter2Face(temp_F1,CC1,m,dir)
         call cellcenter2Face(temp_F2,CC2,m,dir)
         call multiply(temp_F1,temp_F2)
         call boundary_flux(Q,temp_F1,m,temp_F2)
       end subroutine

       end module
      module preconditioners_mod
      use current_precision_mod
      use preconditioner_interfaces_mod
      use GF_diagonals_mod
      use data_location_extend_mod
      use diagonals_mod
      use mesh_extend_mod
      use SF_extend_mod
      use VF_extend_mod
      use TF_extend_mod
      use ops_aux_mod
      implicit none

      private
      public :: preconditioner_SF
      public :: preconditioner_VF

      public :: prec_Identity_SF
      public :: prec_Identity_VF
      public :: prec_Lap_SF
      public :: prec_Lap_VF
      public :: prec_mom_VF
      public :: prec_ind_VF

      contains

      subroutine prec_Identity_SF(Minv,m,sig,c,temp_Minv)
        ! Computes Identity preconditioner (no preconditioning): Minv = I
        implicit none
        type(SF),intent(inout) :: Minv,temp_Minv
        type(mesh),intent(in) :: m
        type(TF),intent(in) :: sig
        real(cp),intent(in) :: c
        real(cp) :: suppress_warn
        logical :: suppress_warning
        suppress_warn = c
        suppress_warning = defined(sig%x%x%DL)
        suppress_warning = defined(temp_Minv%DL)
        suppress_warning = m%defined
        call assign(Minv,1.0_cp)
      end subroutine

      subroutine prec_Identity_VF(Minv,m,sig,c,temp_Minv)
        ! Computes Identity preconditioner (no preconditioning): Minv = I
        implicit none
        type(VF),intent(inout) :: Minv,temp_Minv
        type(TF),intent(in) :: sig
        type(mesh),intent(in) :: m
        real(cp),intent(in) :: c
        call prec_Identity_SF(Minv%x,m,sig,c,temp_Minv%x)
        call prec_Identity_SF(Minv%y,m,sig,c,temp_Minv%y)
        call prec_Identity_SF(Minv%z,m,sig,c,temp_Minv%z)
      end subroutine

      subroutine prec_Lap_SF(Minv,m,sig,c,temp_Minv)
        ! Computes Laplacian diagonal preconditioner: Minv = diag( V ∇•(∇) )⁻¹, V = cell volume
        implicit none
        type(SF),intent(inout) :: Minv,temp_Minv
        type(mesh),intent(in) :: m
        type(TF),intent(in) :: sig
        real(cp),intent(in) :: c
        real(cp) :: suppress_warn
        logical :: suppress_warning
        suppress_warn = c
        suppress_warning = defined(sig%x%x%DL)
        call diag_Lap(Minv,m)
        call volume(temp_Minv,m)
        call multiply(Minv,temp_Minv)
        call invert(Minv)
        call assign_ghost_XPeriodic(Minv,0.0_cp)
      end subroutine

      subroutine prec_Lap_VF(Minv,m,sig,c,temp_Minv)
        ! Computes Laplacian diagonal preconditioner: Minv = diag( V ∇•(∇) )⁻¹, V = cell volume
        implicit none
        type(VF),intent(inout) :: Minv,temp_Minv
        type(TF),intent(in) :: sig
        type(mesh),intent(in) :: m
        real(cp),intent(in) :: c
        call prec_Lap_SF(Minv%x,m,sig,c,temp_Minv%x)
        call prec_Lap_SF(Minv%y,m,sig,c,temp_Minv%y)
        call prec_Lap_SF(Minv%z,m,sig,c,temp_Minv%z)
      end subroutine

      subroutine prec_mom_SF(Minv,m,sig,c,temp_Minv)
        ! Computes Laplacian diagonal preconditioner, Minv = diag( I + c∇•(∇) )⁻¹, V = cell volume
        implicit none
        type(SF),intent(inout) :: Minv,temp_Minv
        type(mesh),intent(in) :: m
        type(TF),intent(in) :: sig
        real(cp),intent(in) :: c
        logical :: suppress_warning
        suppress_warning = defined(sig%x%x%DL)
        call assign(Minv,0.0_cp)
        call diag_Lap(Minv,m)
        call multiply(Minv,c)
        call add(Minv,1.0_cp)
        call volume(temp_Minv,m)
        call multiply(Minv,temp_Minv)
        call invert(Minv)
        call assign_ghost_XPeriodic(Minv,0.0_cp)
      end subroutine

      subroutine prec_mom_VF(Minv,m,sig,c,temp_Minv)
        implicit none
        type(VF),intent(inout) :: Minv,temp_Minv
        type(TF),intent(in) :: sig
        type(mesh),intent(in) :: m
        real(cp),intent(in) :: c
        call prec_mom_SF(Minv%x,m,sig,c,temp_Minv%x)
        call prec_mom_SF(Minv%y,m,sig,c,temp_Minv%y)
        call prec_mom_SF(Minv%z,m,sig,c,temp_Minv%z)
      end subroutine

      subroutine prec_ind_VF(Minv,m,sig,c,temp_Minv) ! Verified 1/3/2016
        ! Computes curl-curl diagonal preconditioner: Minv = diag( V(I + c∇x(σ∇x)) )⁻¹, V = cell volume
        implicit none
        type(VF),intent(inout) :: Minv,temp_Minv
        type(TF),intent(in) :: sig
        type(mesh),intent(in) :: m
        real(cp),intent(in) :: c
        call diag_curl_curl(Minv,m,sig)
        call multiply(Minv,c)
        call add(Minv,1.0_cp)
        call volume(temp_Minv,m)
        call multiply(Minv,temp_Minv)
        call invert(Minv)
        call assign_ghost_XPeriodic(Minv,0.0_cp)
      end subroutine

      end module
       module E_K_budget_terms_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use dir_tree_mod
       use path_extend_mod
       use path_extend_mod
       use string_mod
       use export_raw_processed_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use ops_norms_mod
       use norms_extend_mod

       implicit none

       private
       public :: Unsteady,                 export_Unsteady
       public :: E_K_Convection,           export_E_K_Convection
       public :: E_K_Diffusion,            export_E_K_Diffusion
       public :: E_K_Pressure,             export_E_K_Pressure
       public :: Total_Viscous_Dissipation,export_Total_Viscous_Dissipation
       public :: Viscous_Dissipation,      export_Viscous_Dissipation
       public :: E_M_Convection,           export_E_M_Convection
       public :: E_M_Tension,              export_E_M_Tension
       public :: Lorentz,                  export_Lorentz

       contains

       subroutine Unsteady(e,U,Unm1,dTime,m,scale,VF_CC1,VF_CC2)
         ! Computes: e = scale 0.5 ∂_t u • u = 0.5 (u_{n+1}^2 - u_{n}^2)/dTime
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: U,Unm1
         real(cp),intent(in) :: dTime
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC1,VF_CC2
         call face2CellCenter(VF_CC1,U   ,m); call square(VF_CC1)
         call face2CellCenter(VF_CC2,Unm1,m); call square(VF_CC2)
         call subtract(VF_CC1,VF_CC2)
         call add(e,VF_CC1)
         call multiply(e,scale*0.5_cp/dTime)
       end subroutine
       subroutine export_Unsteady(e_integral,e,U,Unm1,dTime,m,scale,VF_CC1,VF_CC2,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: U,Unm1
         real(cp),intent(in) :: dTime
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC1,VF_CC2
         type(dir_tree),intent(in) :: DT
         call Unsteady(e,U,Unm1,dTime,m,scale,VF_CC1,VF_CC2)
         call export_raw      (m,e,str(DT%e_budget_C),'U_Unsteady',0)
         call export_processed(m,e,str(DT%e_budget_N),'U_Unsteady',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       subroutine E_K_Convection(e,U,U_CC,m,scale,VF_F1,VF_F2,VF_CC,SF_CC)
         ! Computes: e = scale 0.5 (u • ∇) (u • u)
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: U,U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_F1,VF_F2,VF_CC
         type(SF),intent(inout) :: SF_CC
         call dot(SF_CC,U_CC,U_CC,VF_CC)
         call grad(VF_F1,SF_CC,m)
         call multiply(VF_F2,VF_F1,U)
         call face2CellCenter(VF_CC,VF_F2,m)
         call add(e,VF_CC)
         call multiply(e,scale*0.5_cp)
       end subroutine
       subroutine export_E_K_Convection(e_integral,e,U,U_CC,m,scale,VF_F1,VF_F2,VF_CC,SF_CC,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: U,U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_F1,VF_F2,VF_CC
         type(SF),intent(inout) :: SF_CC
         type(dir_tree),intent(in) :: DT
         call E_K_Convection(e,U,U_CC,m,scale,VF_F1,VF_F2,VF_CC,SF_CC)
         call export_raw      (m,e,str(DT%e_budget_C),'E_K_Convection',0)
         call export_processed(m,e,str(DT%e_budget_N),'E_K_Convection',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       subroutine E_K_Diffusion(e,U_CC,m,scale,VF_CC)
         ! Computes: e = scale 0.5 ∇² (u • u)
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC
         call dot(e,U_CC,U_CC,VF_CC)
         call assign(VF_CC%x,e)
         call lap(e,VF_CC%x,m)
         call multiply(e,scale*0.5_cp)
       end subroutine
       subroutine export_E_K_Diffusion(e_integral,e,U_CC,m,scale,VF_CC,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC
         type(dir_tree),intent(in) :: DT
         call E_K_Diffusion(e,U_CC,m,scale,VF_CC)
         call export_raw      (m,e,str(DT%e_budget_C),'E_K_Diffusion',0)
         call export_processed(m,e,str(DT%e_budget_N),'E_K_Diffusion',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       subroutine E_K_Pressure(e,U,p,m,scale,VF_F)
         ! Computes: e = scale ∇•(pu)
         implicit none
         type(SF),intent(inout) :: e
         type(SF),intent(in) :: p
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_F
         call cellCenter2Face(VF_F,p,m)
         call multiply(VF_F,U)
         call div(e,VF_F,m)
         call multiply(e,scale)
       end subroutine
       subroutine export_E_K_Pressure(e_integral,e,U,p,m,scale,VF_F,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(SF),intent(in) :: p
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_F
         type(dir_tree),intent(in) :: DT
         call E_K_pressure(e,U,p,m,scale,VF_F)
         call export_raw      (m,e,str(DT%e_budget_C),'E_K_Pressure',0)
         call export_processed(m,e,str(DT%e_budget_N),'E_K_Pressure',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       subroutine Viscous_Dissipation(e,U_CC,m,scale,TF_CC1,TF_CC2)
         ! Computes: e = scale ∇u • ∇u = ∂_i u_j ∂_j u_i = ∂_i u_x ∂_x u_i +
         !                                                   ∂_i u_y ∂_y u_i +
         !                                                   ∂_i u_z ∂_z u_i
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(TF),intent(inout) :: TF_CC1,TF_CC2
         call grad(TF_CC1,U_CC,m)
         call transpose(TF_CC2,TF_CC1)
         call multiply( TF_CC2,TF_CC1)
         call add(TF_CC1%x%x,TF_CC2%x)
         call add(TF_CC1%x%y,TF_CC2%y)
         call add(TF_CC1%x%z,TF_CC2%z)
         call add(e,TF_CC1%x)
         call multiply(e,scale)
       end subroutine
       subroutine export_Viscous_Dissipation(e_integral,e,U_CC,m,scale,TF_CC1,TF_CC2,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(TF),intent(inout) :: TF_CC1,TF_CC2
         type(dir_tree),intent(in) :: DT
         call Viscous_Dissipation(e,U_CC,m,scale,TF_CC1,TF_CC2)
         call export_raw      (m,e,str(DT%e_budget_C),'Viscous_Dissipation',0)
         call export_processed(m,e,str(DT%e_budget_N),'Viscous_Dissipation',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       subroutine Total_Viscous_Dissipation(e,U_CC,m,scale,TF_CC1,TF_CC2)
         ! Computes: e = scale S_ij S_ij,    S_ij = 0.5(∇u + ∇u^T)
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(TF),intent(inout) :: TF_CC1,TF_CC2
         call grad(TF_CC1,U_CC,m)
         call transpose(TF_CC2,TF_CC1)
         call add(TF_CC2,TF_CC1)
         call multiply(TF_CC2,0.5_cp)
         call square(TF_CC2)
         call add(e,TF_CC2)
         call multiply(e,scale)
       end subroutine
       subroutine export_Total_Viscous_Dissipation(e_integral,e,U_CC,m,scale,TF_CC1,TF_CC2,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(TF),intent(inout) :: TF_CC1,TF_CC2
         type(dir_tree),intent(in) :: DT
         call Total_Viscous_Dissipation(e,U_CC,m,scale,TF_CC1,TF_CC2)
         call export_raw      (m,e,str(DT%e_budget_C),'Total_Viscous_Dissipation',0)
         call export_processed(m,e,str(DT%e_budget_N),'Total_Viscous_Dissipation',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       subroutine E_M_Convection(e,B,U,m,scale,VF_CC1,VF_CC2,VF_F)
         ! Computes: e = scale 0.5 (u•∇) (B•B)
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: B,U
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC1,VF_CC2,VF_F
         call face2CellCenter(VF_CC2,B,m)
         call dot(e,VF_CC2,VF_CC2,VF_CC1)
         call grad(VF_F,e,m)
         call multiply(VF_F,U)
         call face2CellCenter(VF_CC1,VF_F,m)
         call add(e,VF_CC1)
         call multiply(e,scale*0.5_cp)
       end subroutine
       subroutine export_E_M_Convection(e_integral,e,B,U,m,scale,VF_CC1,VF_CC2,VF_F,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: B,U
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC1,VF_CC2,VF_F
         type(dir_tree),intent(in) :: DT
         call E_M_Convection(e,B,U,m,scale,VF_CC1,VF_CC2,VF_F)
         call export_raw      (m,e,str(DT%e_budget_C),'E_M_Convection',0)
         call export_processed(m,e,str(DT%e_budget_N),'E_M_Convection',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       subroutine E_M_Tension(e,B,U_CC,m,scale,VF_CC1,VF_CC2,VF_CC3,TF_CC)
         ! Computes: e = scale u•(B•(∇B)) = u_j (B_i (∂_j B_i))
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: B,U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC1,VF_CC2,VF_CC3
         type(TF),intent(inout) :: TF_CC
         call face2CellCenter(VF_CC2,B,m)
         call grad(TF_CC,VF_CC2,m)
         call dot(VF_CC1%x,TF_CC%x,VF_CC2,VF_CC3)
         call dot(VF_CC1%y,TF_CC%y,VF_CC2,VF_CC3)
         call dot(VF_CC1%z,TF_CC%z,VF_CC2,VF_CC3)
         call multiply(VF_CC1,U_CC)
         call add(e,VF_CC1)
         call multiply(e,scale)
       end subroutine
       subroutine export_E_M_Tension(e_integral,e,B,U_CC,m,scale,VF_CC1,VF_CC2,VF_CC3,TF_CC,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: B,U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC1,VF_CC2,VF_CC3
         type(TF),intent(inout) :: TF_CC
         type(dir_tree),intent(in) :: DT
         call E_M_Tension(e,B,U_CC,m,scale,VF_CC1,VF_CC2,VF_CC3,TF_CC)
         call export_raw      (m,e,str(DT%e_budget_C),'E_M_Tension',0)
         call export_processed(m,e,str(DT%e_budget_N),'E_M_Tension',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       subroutine Lorentz(e,J,B,U_CC,m,scale,VF_CC1,VF_CC2,VF_CC3,VF_F)
         ! Computes: e = scale u•(jxB)
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: J,B,U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC1,VF_CC2,VF_CC3,VF_F
         call edge2CellCenter(VF_CC1,J,m,VF_F)
         call face2CellCenter(VF_CC2,B,m)
         call cross_product(VF_CC3,VF_CC1,VF_CC2)
         call multiply(VF_CC3,U_CC)
         call add(e,VF_CC3)
         call multiply(e,scale)
       end subroutine
       subroutine export_Lorentz(e_integral,e,J,B,U_CC,m,scale,VF_CC1,VF_CC2,VF_CC3,VF_F,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: J,B,U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC1,VF_CC2,VF_CC3,VF_F
         type(dir_tree),intent(in) :: DT
         call Lorentz(e,J,B,U_CC,m,scale,VF_CC1,VF_CC2,VF_CC3,VF_F)
         call export_raw      (m,e,str(DT%e_budget_C),'Lorentz',0)
         call export_processed(m,e,str(DT%e_budget_N),'Lorentz',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       end module
       module E_M_budget_terms_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use dir_tree_mod
       use path_extend_mod
       use string_mod
       use export_raw_processed_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use ops_norms_mod
       use ops_embedExtract_mod
       use norms_extend_mod

       implicit none

       private
       public :: unsteady,  export_Unsteady
       public :: Joule_Heat,export_Joule_Heat
       public :: Poynting,  export_Poynting

       contains

       subroutine Unsteady(e,B,Bnm1,dTime,m,scale,VF_CC1,VF_CC2)
         ! Computes: e = scale 0.5 ∂_t B•B = 0.5 (B_{n+1}^2 - B_{n}^2)/dTime
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: B,Bnm1
         real(cp),intent(in) :: dTime
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC1,VF_CC2
         call face2CellCenter(VF_CC1,B   ,m); call square(VF_CC1)
         call face2CellCenter(VF_CC2,Bnm1,m); call square(VF_CC2)
         call subtract(VF_CC1,VF_CC2)
         call add(e,VF_CC1)
         call multiply(e,0.5_cp/dTime*scale)
       end subroutine
       subroutine export_Unsteady(e_integral,e,B,Bnm1,dTime,m,scale,VF_CC1,VF_CC2,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: B,Bnm1
         real(cp),intent(in) :: dTime
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC1,VF_CC2
         type(dir_tree),intent(in) :: DT
         call Unsteady(e,B,Bnm1,dTime,m,scale,VF_CC1,VF_CC2)
         call export_raw      (m,e,str(DT%e_budget_C),'B_Unsteady',0)
         call export_processed(m,e,str(DT%e_budget_N),'B_Unsteady',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       subroutine Joule_Heat(e,J,sigmaInv_CC,m,scale,VF_CC,VF_F)
         ! Computes: scale j•j/σ
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: J
         type(SF),intent(in) :: sigmaInv_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC,VF_F
         call edge2CellCenter(VF_CC,J,m,VF_F)
         call square(VF_CC)
         call multiply(VF_CC,sigmaInv_CC)
         call add(e,VF_CC)
         call multiply(e,scale)
       end subroutine
       subroutine export_Joule_Heat(e_integral,e,J,sigmaInv_CC,m,scale,VF_CC,VF_F,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: J
         type(SF),intent(in) :: sigmaInv_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC,VF_F
         type(dir_tree),intent(in) :: DT
         call Joule_Heat(e,J,sigmaInv_CC,m,scale,VF_CC,VF_F)
         call export_raw      (m,e,str(DT%e_budget_C),'Joule_Heat',0)
         call export_processed(m,e,str(DT%e_budget_N),'Joule_Heat',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       subroutine Poynting(e,B,J,U,sigmaInv_F,m,scale,SF_CC,VF_F,TF_F1,TF_F2,TF_F3)
         ! Computes: e = scale ∇ • ( [U x B - j/σ] x B )
         implicit none
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: B,J,U
         type(VF),intent(in) :: sigmaInv_F
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(SF),intent(inout) :: SF_CC
         type(VF),intent(inout) :: VF_F
         type(TF),intent(inout) :: TF_F1,TF_F2,TF_F3
         ! Compute uxB in E = j/sig - uxB
         call face2Face(TF_F1,U,m,SF_CC) ! U to tensor field
         call face2Face(TF_F2,B,m,SF_CC) ! B to tensor field
         call cross_product(VF_F,TF_F1,TF_F2) ! uxB
         call face2Face(TF_F1,VF_F,m,SF_CC) ! uxB to tensor field
         call edge2Face_no_diag(TF_F3,J,m) ! J to tensor field
         call multiply(TF_F3%x,sigmaInv_F) ! J/sig
         call multiply(TF_F3%y,sigmaInv_F) ! J/sig
         call multiply(TF_F3%z,sigmaInv_F) ! J/sig
         call subtract(TF_F3,TF_F1) ! E = j/sig - uxB
         call cross_product(VF_F,TF_F3,TF_F2) ! F = E x B
         call div(e,VF_F,m)
         call multiply(e,scale)
       end subroutine
       subroutine export_Poynting(e_integral,e,B,J,U,sigmaInv_F,m,scale,&
         SF_CC,VF_F,TF_F1,TF_F2,TF_F3,DT)
         implicit none
         real(cp),intent(inout) :: e_integral
         type(SF),intent(inout) :: e
         type(VF),intent(in) :: B,J,U
         type(VF),intent(in) :: sigmaInv_F
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(SF),intent(inout) :: SF_CC
         type(VF),intent(inout) :: VF_F
         type(TF),intent(inout) :: TF_F1,TF_F2,TF_F3
         type(dir_tree),intent(in) :: DT
         call Poynting(e,B,J,U,sigmaInv_F,m,scale,SF_CC,VF_F,TF_F1,TF_F2,TF_F3)
         call export_raw      (m,e,str(DT%e_budget_C),'Poynting',0)
         call export_processed(m,e,str(DT%e_budget_N),'Poynting',1)
         call compute_Ln(e_integral,e,1.0_cp,m)
       end subroutine

       end module
      module FFT_algorithm_mod
      ! Flags: (_PARALLELIZE_FFT_)
      use current_precision_mod
      use mesh_extend_mod
      use apply_BCs_mod
      use norms_extend_mod
      use SF_extend_mod
      use ops_discrete_mod
      use ops_aux_mod
      use ops_dct_mod
      use ops_idct_mod
      use constants_mod
      implicit none

      private
      public :: solve_FFT_SF

      ! interface solve;  module procedure solve_FFT_SF;   end interface

      contains

      subroutine solve_FFT_SF(u,f_in,vol,coeff,m,norm,compute_norms,f,res,dir,name)
        implicit none
        type(SF),intent(inout) :: u
        type(SF),intent(in) :: f_in,vol,coeff
        type(SF),intent(inout) :: f,res
        type(mesh),intent(in) :: m
        type(norms),intent(inout) :: norm
        logical,intent(in) :: compute_norms
        character(len=*),intent(in) :: name
        integer,intent(in) :: dir
        select case (dir)
        case (1); call solve_FFT_SF_x(u,f_in,vol,coeff,m,norm,compute_norms,f,res,name)
        case (2); call solve_FFT_SF_y(u,f_in,vol,coeff,m,norm,compute_norms,f,res,name)
        case (3); call solve_FFT_SF_z(u,f_in,vol,coeff,m,norm,compute_norms,f,res,name)
        case default
        stop 'Error: dir must = 1,2,3 in solve_FFT_SF in FFT_algorithm.f90'
        end select
      end subroutine

      subroutine solve_FFT_SF_x(u,f_in,vol,coeff,m,norm,compute_norms,f,res,name)
        implicit none
        type(SF),intent(inout) :: u
        type(SF),intent(in) :: f_in,vol,coeff
        type(SF),intent(inout) :: f,res
        type(mesh),intent(in) :: m
        type(norms),intent(inout) :: norm
        logical,intent(in) :: compute_norms
        character(len=*),intent(in) :: name
        integer :: i,j,k,t
        integer,dimension(3) :: s

        call assign(f,f_in)

        do t=1,u%s
          s = u%BF(t)%GF%s
          call dct(f%BF(t)%GF%f(:,2:s(2)-1,:),2,1)
          call dct(f%BF(t)%GF%f(:,:,2:s(3)-1),3,1)
        enddo

        do t=1,u%s
          !$OMP PARALLEL DO
          do k=1,s(3); do j=2,s(2)-1; do i=2,s(1)-1
            u%BF(t)%GF%f(i,j,k) = f%BF(t)%GF%f(i,j,k)*coeff%BF(t)%GF%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
        enddo

        ! 'Pin down pressure' in Fourier space
        do t=1,u%s
          u%BF(t)%GF%f(:,2,2) = 0.0_cp
        enddo

        do t=1,u%s
          call idct(u%BF(t)%GF%f(:,2:s(2)-1,:),2,1)
          call idct(u%BF(t)%GF%f(:,:,2:s(3)-1),3,1)
        enddo

        call apply_BCs(u)

        if (.true.) then
          call lap(res,u,m)
          call subtract(res,f_in)
          call assign_ghost_XPeriodic(res,0.0_cp)
          call compute(norm,res,vol,m%MP%volume)
          call print(norm,'FFT_x_'//name)
        endif
      end subroutine

      subroutine solve_FFT_SF_y(u,f_in,vol,coeff,m,norm,compute_norms,f,res,name)
        implicit none
        type(SF),intent(inout) :: u
        type(SF),intent(in) :: f_in,vol,coeff
        type(SF),intent(inout) :: f,res
        type(mesh),intent(in) :: m
        type(norms),intent(inout) :: norm
        logical,intent(in) :: compute_norms
        character(len=*),intent(in) :: name
        integer :: i,j,k,t
        integer,dimension(3) :: s

        call assign(f,f_in)

        do t=1,u%s
          s = u%BF(t)%GF%s
          call dct(f%BF(t)%GF%f(2:s(1)-1,:,:),1,1)
          call dct(f%BF(t)%GF%f(:,:,2:s(3)-1),3,1)
        enddo

        do t=1,u%s
          !$OMP PARALLEL DO
          do k=2,s(3)-1; do j=1,s(2); do i=2,s(1)-1
            u%BF(t)%GF%f(i,j,k) = f%BF(t)%GF%f(i,j,k)*coeff%BF(t)%GF%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
        enddo

        ! 'Pin down pressure' in Fourier space
        do t=1,u%s
          u%BF(t)%GF%f(2,:,2) = 0.0_cp
        enddo

        do t=1,u%s
          call idct(u%BF(t)%GF%f(2:s(1)-1,:,:),1,1)
          call idct(u%BF(t)%GF%f(:,:,2:s(3)-1),3,1)
        enddo

        call apply_BCs(u)

        if (compute_norms) then
          call lap(res,u,m)
          call subtract(res,f_in)
          call assign_ghost_XPeriodic(res,0.0_cp)
          call compute(norm,res,vol,m%MP%volume)
          call print(norm,'FFT_y_'//name)
        endif
      end subroutine

      subroutine solve_FFT_SF_z(u,f_in,vol,coeff,m,norm,compute_norms,f,res,name)
        implicit none
        type(SF),intent(inout) :: u
        type(SF),intent(in) :: f_in,vol,coeff
        type(SF),intent(inout) :: f,res
        type(mesh),intent(in) :: m
        type(norms),intent(inout) :: norm
        logical,intent(in) :: compute_norms
        character(len=*),intent(in) :: name
        integer :: i,j,k,t
        integer,dimension(3) :: s

        call assign(f,f_in)

        do t=1,u%s
          s = u%BF(t)%GF%s
          call dct(f%BF(t)%GF%f(2:s(1)-1,:,:),1,1)
          call dct(f%BF(t)%GF%f(:,2:s(2)-1,:),2,1)
        enddo

        do t=1,u%s
          !$OMP PARALLEL DO
          do k=1,s(3); do j=2,s(2)-1; do i=2,s(1)-1
            u%BF(t)%GF%f(i,j,k) = f%BF(t)%GF%f(i,j,k)*coeff%BF(t)%GF%f(i,j,k)
          enddo; enddo; enddo
          !$OMP END PARALLEL DO
        enddo

        ! 'Pin down pressure' in Fourier space
        do t=1,u%s
          u%BF(t)%GF%f(2,2,:) = 0.0_cp
        enddo

        do t=1,u%s
          call idct(u%BF(t)%GF%f(2:s(1)-1,:,:),1,1)
          call idct(u%BF(t)%GF%f(:,2:s(2)-1,:),2,1)
        enddo

        call apply_BCs(u)

        if (compute_norms) then
          call lap(res,u,m)
          call subtract(res,f_in)
          call assign_ghost_XPeriodic(res,0.0_cp)
          call compute(norm,res,vol,m%MP%volume)
          call print(norm,'FFT_z_'//name)
        endif
      end subroutine

      end module
      module FFT_poisson_mod
      ! call FFT_poisson(u,f,u_bcs,g,gridType,displayTF)
      ! solves the poisson equation:
      !     u_xx + u_yy + u_zz = f
      ! for a given f, boundary conditions for u (u_bcs), grid (g)
      ! and using a Fast Fourier Transform (FFT) method.
      !
      ! Although grids may have different spacing in each direction,
      ! grid sizes along each direction are assumed uniform.
      !
      ! Input:
      !     u            = initial guess for u
      !     f            = RHS of above equation
      !     u_bcs        = boundary conditions for u. Refer to boundary_conditions_mod for more info.
      !     g            = contains grid information (dhc,dhn)
      !
      ! Flags: (_PARALLELIZE_FFT_)
      use current_precision_mod
      use mesh_extend_mod
      use apply_BCs_mod
      use norms_extend_mod
      use SF_extend_mod
      use ops_discrete_mod
      use ops_aux_mod
      use ops_dct_mod
      use ops_idct_mod
      use constants_mod
      implicit none

      private
      public :: FFTSolver,solve
      private :: init,delete

      type FFTSolver
        real(cp),dimension(3) :: dh2 ! Grid spacing (assumed uniform)
        integer :: Nx,Ny,Nz ! Number of cells
        type(SF) :: f,res
        type(SF) :: coeff_x,coeff_y,coeff_z
        integer,dimension(3) :: s
      end type

      interface init;        module procedure initFFT;       end interface
      interface delete;      module procedure deleteFFT;     end interface
      interface solve;       module procedure solveFFT_SF;   end interface

      contains

      subroutine initFFT(FFT,u,m)
        implicit none
        type(FFTSolver),intent(inout) :: FFT
        type(SF),intent(in) :: u
        type(mesh),intent(in) :: m
        integer :: i,j,k,t
        real(cp) :: cosi,cosj,cosk
        FFT%s = u%BF(1)%GF%s
        FFT%dh2(1) = m%B(1)%g%c(1)%dhn%f(1)**2.0_cp
        FFT%dh2(2) = m%B(1)%g%c(2)%dhn%f(1)**2.0_cp
        FFT%dh2(3) = m%B(1)%g%c(3)%dhn%f(1)**2.0_cp
        FFT%Nx = m%B(1)%g%c(1)%sc-2
        FFT%Ny = m%B(1)%g%c(2)%sc-2
        FFT%Nz = m%B(1)%g%c(3)%sc-2
        call init(FFT%f,u)
        call init(FFT%coeff_x,u)
        call init(FFT%coeff_y,u)
        call init(FFT%coeff_z,u)
        call init(FFT%res,u)

        ! THESE FORMULAS ARE ONLY VALID WHEN DX1 = DX2 WHERE DIR = 3
        do t=1,m%s; do k=1,FFT%s(3); do j=2,FFT%s(2)-1; do i=2,FFT%s(1)-1
        cosj = cos(PI*real(j-2,cp)/real(FFT%Ny,cp))
        cosk = cos(PI*real(k-2,cp)/real(FFT%Nz,cp))
        if (.not.((i.eq.2).and.(j.eq.2))) then
              FFT%coeff_x%BF(t)%GF%f(i,j,k) = 0.5_cp*1.0_cp/(cosj+cosk-2.0_cp)*FFT%dh2(1)
        else; FFT%coeff_x%BF(t)%GF%f(i,j,k) = 1.0_cp
        endif
        enddo; enddo; enddo; enddo
        do t=1,m%s; do k=2,FFT%s(3)-1; do j=1,FFT%s(2); do i=2,FFT%s(1)-1
        cosi = cos(PI*real(i-2,cp)/real(FFT%Nx,cp))
        cosk = cos(PI*real(k-2,cp)/real(FFT%Nz,cp))
        if (.not.((i.eq.2).and.(k.eq.2))) then
              FFT%coeff_y%BF(t)%GF%f(i,j,k) = 0.5_cp*1.0_cp/(cosi+cosk-2.0_cp)*FFT%dh2(2)
        else; FFT%coeff_y%BF(t)%GF%f(i,j,k) = 1.0_cp
        endif
        enddo; enddo; enddo; enddo

        do t=1,m%s; do k=1,FFT%s(3); do j=2,FFT%s(2)-1; do i=2,FFT%s(1)-1
        cosi = cos(PI*real(i-2,cp)/real(FFT%Nx,cp))
        cosj = cos(PI*real(j-2,cp)/real(FFT%Ny,cp))
        if (.not.((i.eq.2).and.(j.eq.2))) then
              FFT%coeff_z%BF(t)%GF%f(i,j,k) = 0.5_cp*1.0_cp/(cosi+cosj-2.0_cp)*FFT%dh2(3)
        else; FFT%coeff_z%BF(t)%GF%f(i,j,k) = 1.0_cp
        endif
        enddo; enddo; enddo; enddo

      end subroutine

      subroutine deleteFFT(FFT)
        implicit none
        type(FFTSolver),intent(inout) :: FFT
        call delete(FFT%res)
        call delete(FFT%f)
        call delete(FFT%coeff_x)
        call delete(FFT%coeff_y)
        call delete(FFT%coeff_z)
      end subroutine

      subroutine solveFFT_SF(FFT,u,f,vol,m,norm,displayTF,dir)
        implicit none
        type(FFTSolver),intent(inout) :: FFT
        type(SF),intent(inout) :: u
        type(SF),intent(in) :: f,vol
        type(mesh),intent(in) :: m
        type(norms),intent(inout) :: norm
        logical,intent(in) :: displayTF
        integer,intent(in) :: dir
        integer :: i,j,k,t
        integer,dimension(3) :: s

        call assign(FFT%f,f)
        do t=1,u%s
          s = u%BF(t)%GF%s
          call init(FFT,U,m)

          select case (dir)
          case (1); call dct(FFT%f%BF(t)%GF%f(:,2:s(2)-1,:),2,1)
                    call dct(FFT%f%BF(t)%GF%f(:,:,2:s(3)-1),3,1)
          case (2); call dct(FFT%f%BF(t)%GF%f(2:s(1)-1,:,:),1,1)
                    call dct(FFT%f%BF(t)%GF%f(:,:,2:s(3)-1),3,1)
          case (3); call dct(FFT%f%BF(t)%GF%f(2:s(1)-1,:,:),1,1)
                    call dct(FFT%f%BF(t)%GF%f(:,2:s(2)-1,:),2,1)
          case default
          stop 'Error: dir must = 1,2,3 in solveFFT in FFT_poisson.f90'
          end select

          select case (dir)
          case (1)
            !$OMP PARALLEL DO
            do k=1,s(3); do j=2,s(2)-1; do i=2,s(1)-1
              u%BF(t)%GF%f(i,j,k) = FFT%f%BF(t)%GF%f(i,j,k)*FFT%coeff_x%BF(t)%GF%f(i,j,k)
            enddo; enddo; enddo
            !$OMP END PARALLEL DO
          case (2)
            !$OMP PARALLEL DO
            do k=2,s(3)-1; do j=1,s(2); do i=2,s(1)-1
              u%BF(t)%GF%f(i,j,k) = FFT%f%BF(t)%GF%f(i,j,k)*FFT%coeff_x%BF(t)%GF%f(i,j,k)
            enddo; enddo; enddo
            !$OMP END PARALLEL DO
          case (3)
            !$OMP PARALLEL DO
            do k=1,s(3); do j=2,s(2)-1; do i=2,s(1)-1
              u%BF(t)%GF%f(i,j,k) = FFT%f%BF(t)%GF%f(i,j,k)*FFT%coeff_x%BF(t)%GF%f(i,j,k)
            enddo; enddo; enddo
            !$OMP END PARALLEL DO
          case default
          stop 'Error: dir must = 1,2,3 in solveFFT in FFT_poisson.f90'
          end select

          ! 'Pin down pressure'
          select case (dir)
          case (1); u%BF(t)%GF%f(:,2,2) = 0.0_cp
          case (2); u%BF(t)%GF%f(2,:,2) = 0.0_cp
          case (3); u%BF(t)%GF%f(2,2,:) = 0.0_cp
          case default
          stop 'Error: dir must = 1,2,3 in solveFFT in FFT_poisson.f90'
          end select

          select case (dir)
          case (1); call idct(u%BF(t)%GF%f(:,2:s(2)-1,:),2,1)
                    call idct(u%BF(t)%GF%f(:,:,2:s(3)-1),3,1)
          case (2); call idct(u%BF(t)%GF%f(2:s(1)-1,:,:),1,1)
                    call idct(u%BF(t)%GF%f(:,:,2:s(3)-1),3,1)
          case (3); call idct(u%BF(t)%GF%f(2:s(1)-1,:,:),1,1)
                    call idct(u%BF(t)%GF%f(:,2:s(2)-1,:),2,1)
          case default
          stop 'Error: dir must = 1,2,3 in solveFFT in FFT_poisson.f90'
          end select

          call apply_BCs(u)

          if (displayTF) then
            call lap(FFT%res,u,m)
            call subtract(FFT%res,f)
            call assign_ghost_XPeriodic(FFT%res,0.0_cp)
            call compute(norm,FFT%res,vol,m%MP%volume)
            call print(norm,'FFT Residuals')
          endif
          call delete(FFT)
        enddo
      end subroutine

      end module
      module GS_solver_mod
      ! call GS_poisson(GS,u,f,m,n,compute_norm)
      ! solves the poisson equation:
      !     u_xx + u_yy + u_zz = f
      ! for a given f, mesh (m) using the Gauss-Seidel (GS) method
      !
      ! Note that the variant of Gauss-Seidel/GS called
      ! "red-black" Gauss-Seidel is used, where the fields are
      ! traversed in a 3D checkerboarding manner.
      !
      ! Input:
      !     u            = initial guess for u
      !     f            = RHS of above equation
      !     m            = contains mesh information (dhc,dhn)
      !     compute_norm = print residuals to screen (T,F)
      !
      ! Flags: (_PARALLELIZE_GS_,_EXPORT_GS_SF_CONVERGENCE_)
      use current_precision_mod
      use mesh_extend_mod
      use apply_BCs_mod
      use boundary_conditions_mod
      use norms_extend_mod
      use ops_discrete_mod
      use ops_aux_mod
      use SF_extend_mod
      use VF_extend_mod
      use TF_extend_mod
      use IO_tools_mod
      implicit none

      real(cp) :: tol_abs = 10.0_cp**(-12.0_cp)

      private
      public :: solve_GS
      ! public :: solve_GS_SF
      interface solve_GS;     module procedure solve_GS_SF;      end interface
      interface solve_GS;     module procedure solve_GS_VF;      end interface

      interface redBlack;     module procedure redBlack_SF;      end interface
      interface redBlack;     module procedure redBlack_VF;      end interface

      interface innerloop;    module procedure innerloop_SF;     end interface
      interface innerloop;    module procedure innerloop_VF;     end interface

      contains

      subroutine solve_GS_SF(u,f_in,D_inv,m,p,d,vol,gt,n,tol,norm,compute_norm,&
        N_iter,un,lapu,res,f,tempk,name,n_skip_check_res)
        implicit none
        type(SF),intent(inout) :: u,f,lapu,res
        type(SF),intent(in) :: D_inv,vol,f_in
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m,p,d
        integer,intent(in) :: n,un
        real(cp),intent(in) :: tol
        logical,intent(in) :: compute_norm
        type(norms),intent(inout) :: norm
        integer,intent(inout) :: N_iter,n_skip_check_res
        integer,dimension(3),intent(in) :: gt
        character(len=*),intent(in) :: name
        type(norms) :: norm0
        logical :: skip_loop
        integer :: i,i_earlyExit
        call assign(f,f_in)
        if (u%all_Neumann) call subtract_physical_mean(f)

        if (compute_norm) then
          call lap_centered(lapu,u,m,tempk%x)
          call subtract(res,lapu,f)
          call assign_ghost_XPeriodic(res,0.0_cp)
          call compute(norm0,res,vol,m%MP%volume)
        endif

        call apply_BCs(u)
        i_earlyExit=0
        if (.not.sqrt(norm0%L2).lt.tol_abs) then ! Only do PCG if necessary!
          skip_loop = .false.
          do i=1,n
            !$OMP PARALLEL
            call innerLoop(u,f,m,p,d,D_inv,gt,(/0,0,0/)) ! Even in odd plane
            call innerLoop(u,f,m,p,d,D_inv,gt,(/1,0,0/)) ! Even in even plane
            call innerLoop(u,f,m,p,d,D_inv,gt,(/0,1,0/)) ! Even in even plane
            call innerLoop(u,f,m,p,d,D_inv,gt,(/0,0,1/)) ! Even in even plane
            !$OMP END PARALLEL
            !$OMP PARALLEL
            call innerLoop(u,f,m,p,d,D_inv,gt,(/1,1,1/)) ! Odd in odd plane
            call innerLoop(u,f,m,p,d,D_inv,gt,(/0,1,1/)) ! Odd in even plane
            call innerLoop(u,f,m,p,d,D_inv,gt,(/1,0,1/)) ! Odd in even plane
            call innerLoop(u,f,m,p,d,D_inv,gt,(/1,1,0/)) ! Odd in even plane
            !$OMP END PARALLEL
            call apply_BCs(u)
            N_iter = N_iter + 1

            if (mod(i,n_skip_check_res).eq.0) then
              call lap_centered(lapu,u,m,tempk%x)
              call subtract(res,lapu,f)
              call assign_ghost_XPeriodic(res,0.0_cp)
              call compute(norm,res,vol,m%MP%volume)
#ifdef _EXPORT_GS_SF_CONVERGENCE_
              write(un,*) N_iter,norm%L1,norm%L2 ,norm%Linf ,&
                                       norm0%L1,norm0%L2,norm0%Linf,i-1
#endif
              if ((norm%L2/norm0%L2.lt.tol).or.(norm%L2.lt.tol_abs)) then; i_earlyExit=1; exit; endif
            endif
          enddo
        else; i=1; skip_loop = .true.
        endif

#ifdef _EXPORT_GS_SF_CONVERGENCE_
        flush(un)
#endif

        ! if (u%all_Neumann) call subtract(u,mean(u))
        if (compute_norm) then
          if (.not.skip_loop) then
            call lap_centered(lapu,u,m,tempk%x)
            call subtract(res,lapu,f)
            call assign_ghost_XPeriodic(res,0.0_cp)
            call compute(norm,res,vol,m%MP%volume)
            call print(norm,'GS_SF Residuals for '//name)
            write(un,*) N_iter,norm%L1,norm%L2 ,norm%Linf ,&
                                     norm0%L1,norm0%L2,norm0%Linf,i-1+i_earlyExit
            write(*,*) 'GS_SF iterations (executed/max) = ',i-1+i_earlyExit,n
            write(*,*) 'GS_SF exit condition = ',norm%L2/norm0%L2
          else
            write(*,*) 'GS_SF skip_loop = ',skip_loop
          endif
          write(*,*) ''

        endif
      end subroutine

      subroutine solve_GS_VF(u,f_in,D_inv,m,p,d,vol,gtx,gty,gtz,n,tol,norm,compute_norm,&
        N_iter,un,lapu,res,f,tempk,name,n_skip_check_res)
        implicit none
        type(VF),intent(inout) :: u,f,lapu,res
        type(VF),intent(in) :: vol,D_inv,f_in
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m,p,d
        integer,intent(in) :: n,un
        real(cp),intent(in) :: tol
        logical,intent(in) :: compute_norm
        type(norms),intent(inout) :: norm
        integer,intent(inout) :: N_iter,n_skip_check_res
        integer,dimension(3),intent(in) :: gtx,gty,gtz
        character(len=*),intent(in) :: name
        type(norms) :: norm0
        logical :: skip_loop
        integer :: i,i_earlyExit
        call assign(f,f_in)
        ! if (u%all_Neumann) call subtract_physical_mean(f)

        if (compute_norm) then
          call lap_centered(lapu,u,m,tempk)
          call subtract(res,lapu,f)
          call assign_ghost_XPeriodic(res,0.0_cp)
          call compute(norm0,res,vol,m%MP%volume)
        endif

        call apply_BCs(u)
        i_earlyExit=0
        if (.not.sqrt(norm0%L2).lt.tol_abs) then ! Only do PCG if necessary!
          skip_loop = .false.
          do i=1,n
            !$OMP PARALLEL
            call innerLoop(u,f,m,p,d,D_inv,gtx,gty,gtz,(/0,0,0/)) ! Even in odd plane
            call innerLoop(u,f,m,p,d,D_inv,gtx,gty,gtz,(/1,0,0/)) ! Even in even plane
            call innerLoop(u,f,m,p,d,D_inv,gtx,gty,gtz,(/0,1,0/)) ! Even in even plane
            call innerLoop(u,f,m,p,d,D_inv,gtx,gty,gtz,(/0,0,1/)) ! Even in even plane
            !$OMP END PARALLEL
            !$OMP PARALLEL
            call innerLoop(u,f,m,p,d,D_inv,gtx,gty,gtz,(/1,1,1/)) ! Odd in odd plane
            call innerLoop(u,f,m,p,d,D_inv,gtx,gty,gtz,(/0,1,1/)) ! Odd in even plane
            call innerLoop(u,f,m,p,d,D_inv,gtx,gty,gtz,(/1,0,1/)) ! Odd in even plane
            call innerLoop(u,f,m,p,d,D_inv,gtx,gty,gtz,(/1,1,0/)) ! Odd in even plane
            !$OMP END PARALLEL
            call apply_BCs(u)
            N_iter = N_iter + 1

            if (mod(i,n_skip_check_res).eq.0) then
              call lap_centered(lapu,u,m,tempk)
              call subtract(res,lapu,f)
              call assign_ghost_XPeriodic(res,0.0_cp)
              call compute(norm,res,vol,m%MP%volume)
#ifdef _EXPORT_GS_SF_CONVERGENCE_
              write(un,*) N_iter,norm%L1,norm%L2,norm%Linf,&
                                 norm0%L1,norm0%L2,norm0%Linf,i-1
#endif
              if ((norm%L2/norm0%L2.lt.tol).or.(norm%L2.lt.tol_abs)) then; i_earlyExit=1; exit; endif
            endif
          enddo
        else; i=1; skip_loop = .true.
        endif

#ifdef _EXPORT_GS_SF_CONVERGENCE_
        flush(un)
#endif

        ! if (u%all_Neumann) call subtract(u,mean(u))
        if (compute_norm) then
          if (.not.skip_loop) then
            call lap_centered(lapu,u,m,tempk)
            call subtract(res,lapu,f)
            call assign_ghost_XPeriodic(res,0.0_cp)
            call compute(norm,res,vol,m%MP%volume)
            call print(norm,'GS_SF Residuals for '//name)
              write(un,*) N_iter,norm%L1,norm%L2,norm%Linf,&
                                 norm0%L1,norm0%L2,norm0%Linf,i-1
            write(*,*) 'GS_VF iterations (executed/max) = ',i-1+i_earlyExit,n
            write(*,*) 'GS_VF exit condition = ',norm%L2/norm0%L2
          else
            write(*,*) 'GS_VF skip_loop = ',skip_loop
          endif
          write(*,*) ''

        endif
      end subroutine

      subroutine innerLoop_SF(u,f,m,p,d,D_inv,gt,odd)
        implicit none
        type(SF),intent(inout) :: u
        type(SF),intent(in) :: f,D_inv
        type(mesh),intent(in) :: m,p,d
        integer,dimension(3),intent(in) :: odd
        integer,dimension(3),intent(in) :: gt
        integer :: i
        do i=1,m%s
          call redBlack(u%BF(i)%GF%f,f%BF(i)%GF%f,D_inv%BF(i)%GF%f,u%BF(i)%GF%s,&
          p%B(i)%g%c(1)%dhn%f,&
          p%B(i)%g%c(2)%dhn%f,&
          p%B(i)%g%c(3)%dhn%f,&
          d%B(i)%g%c(1)%dhn%f,&
          d%B(i)%g%c(2)%dhn%f,&
          d%B(i)%g%c(3)%dhn%f,&
          gt,odd)
          call apply_BCs(u)
        enddo
      end subroutine

      subroutine innerLoop_VF(u,f,m,p,d,D_inv,gtx,gty,gtz,odd)
        implicit none
        type(VF),intent(inout) :: u
        type(VF),intent(in) :: f,D_inv
        type(mesh),intent(in) :: m,p,d
        integer,dimension(3),intent(in) :: odd
        integer,dimension(3),intent(in) :: gtx,gty,gtz
        integer :: i
        do i=1,m%s
          call redBlack(u%x%BF(i)%GF%f,u%y%BF(i)%GF%f,u%z%BF(i)%GF%f,&
                        f%x%BF(i)%GF%f,f%y%BF(i)%GF%f,f%z%BF(i)%GF%f,&
                        D_inv%x%BF(i)%GF%f,D_inv%y%BF(i)%GF%f,D_inv%z%BF(i)%GF%f,&
                        u%x%BF(i)%GF%s,u%y%BF(i)%GF%s,u%z%BF(i)%GF%s,&
          p%B(i)%g%c(1)%dhn%f,&
          p%B(i)%g%c(2)%dhn%f,&
          p%B(i)%g%c(3)%dhn%f,&
          d%B(i)%g%c(1)%dhn%f,&
          d%B(i)%g%c(2)%dhn%f,&
          d%B(i)%g%c(3)%dhn%f,&
          gtx,gty,gtz,odd)
          call apply_BCs(u)
        enddo
      end subroutine

      subroutine redBlack_SF(u,f,D_inv,s,dxp,dyp,dzp,dxd,dyd,dzd,gt,odd)
        implicit none
        real(cp),dimension(:,:,:),intent(inout) :: u
        real(cp),dimension(:,:,:),intent(in) :: f,D_inv
        integer,dimension(3),intent(in) :: s,odd
        real(cp),dimension(:),intent(in) :: dxp,dyp,dzp,dxd,dyd,dzd
        integer,dimension(3),intent(in) :: gt
        integer :: i,j,k
#ifdef _PARALLELIZE_GS_
        !$OMP PARALLEL DO

#endif
        do k=2+odd(3),s(3)-1,2; do j=2+odd(2),s(2)-1,2; do i=2+odd(1),s(1)-1,2
        u(i,j,k) = ( u(i-1,j,k)/(dxp(i-1) * dxd(i-1+gt(1))) + &
                     u(i+1,j,k)/(dxp( i ) * dxd(i-1+gt(1))) + &
                     u(i,j-1,k)/(dyp(j-1) * dyd(j-1+gt(2))) + &
                     u(i,j+1,k)/(dyp( j ) * dyd(j-1+gt(2))) + &
                     u(i,j,k-1)/(dzp(k-1) * dzd(k-1+gt(3))) + &
                     u(i,j,k+1)/(dzp( k ) * dzd(k-1+gt(3))) &
                   - f(i,j,k) )*D_inv(i,j,k)
        enddo; enddo; enddo
#ifdef _PARALLELIZE_GS_
        !$OMP END PARALLEL DO

#endif
      end subroutine

      subroutine redBlack_VF(u,v,w,fx,fy,fz,Dx_inv,Dy_inv,Dz_inv,sx,sy,sz,&
        dxp,dyp,dzp,dxd,dyd,dzd,gtx,gty,gtz,odd)
        implicit none
        real(cp),dimension(:,:,:),intent(inout) :: u,v,w
        real(cp),dimension(:,:,:),intent(in) :: fx,fy,fz,Dx_inv,Dy_inv,Dz_inv
        integer,dimension(3),intent(in) :: sx,sy,sz,odd
        real(cp),dimension(:),intent(in) :: dxp,dyp,dzp,dxd,dyd,dzd
        integer,dimension(3),intent(in) :: gtx,gty,gtz
        integer :: i,j,k
#ifdef _PARALLELIZE_GS_
        !$OMP PARALLEL DO

#endif
        do k=2+odd(3),sx(3)-1,2; do j=2+odd(2),sx(2)-1,2; do i=2+odd(1),sx(1)-1,2
        u(i,j,k) = ( u(i-1,j,k)/(dxp(i-1) * dxd(i-1+gtx(1))) + &
                     u(i+1,j,k)/(dxp( i ) * dxd(i-1+gtx(1))) + &
                     u(i,j-1,k)/(dyp(j-1) * dyd(j-1+gtx(2))) + &
                     u(i,j+1,k)/(dyp( j ) * dyd(j-1+gtx(2))) + &
                     u(i,j,k-1)/(dzp(k-1) * dzd(k-1+gtx(3))) + &
                     u(i,j,k+1)/(dzp( k ) * dzd(k-1+gtx(3))) &
                   - fx(i,j,k) )*Dx_inv(i,j,k)
        enddo; enddo; enddo
        do k=2+odd(3),sy(3)-1,2; do j=2+odd(2),sy(2)-1,2; do i=2+odd(1),sy(1)-1,2
        v(i,j,k) = ( v(i-1,j,k)/(dxp(i-1) * dxd(i-1+gty(1))) + &
                     v(i+1,j,k)/(dxp( i ) * dxd(i-1+gty(1))) + &
                     v(i,j-1,k)/(dyp(j-1) * dyd(j-1+gty(2))) + &
                     v(i,j+1,k)/(dyp( j ) * dyd(j-1+gty(2))) + &
                     v(i,j,k-1)/(dzp(k-1) * dzd(k-1+gty(3))) + &
                     v(i,j,k+1)/(dzp( k ) * dzd(k-1+gty(3))) &
                   - fy(i,j,k) )*Dy_inv(i,j,k)
        enddo; enddo; enddo
        do k=2+odd(3),sz(3)-1,2; do j=2+odd(2),sz(2)-1,2; do i=2+odd(1),sz(1)-1,2
        w(i,j,k) = ( w(i-1,j,k)/(dxp(i-1) * dxd(i-1+gtz(1))) + &
                     w(i+1,j,k)/(dxp( i ) * dxd(i-1+gtz(1))) + &
                     w(i,j-1,k)/(dyp(j-1) * dyd(j-1+gtz(2))) + &
                     w(i,j+1,k)/(dyp( j ) * dyd(j-1+gtz(2))) + &
                     w(i,j,k-1)/(dzp(k-1) * dzd(k-1+gtz(3))) + &
                     w(i,j,k+1)/(dzp( k ) * dzd(k-1+gtz(3))) &
                   - fz(i,j,k) )*Dz_inv(i,j,k)
        enddo; enddo; enddo
#ifdef _PARALLELIZE_GS_
        !$OMP END PARALLEL DO

#endif

      end subroutine

      end module
       module curl_curl_B_mod
       use current_precision_mod
       use mesh_extend_mod
       use VF_extend_mod
       use ops_discrete_mod

       implicit none

       private
       public :: curl_curl_B_matrix_free

       contains

       subroutine curl_curl_B_matrix_free(curl_curl_B,J,B,sigmaInv_E,m,temp_E)
         implicit none
         type(VF),intent(inout) :: curl_curl_B,J
         type(VF),intent(in) :: B
         type(VF),intent(in) :: sigmaInv_E
         type(VF),intent(inout) :: temp_E
         type(mesh),intent(in) :: m
         call curl(J,B,m)
         call multiply(temp_E,J,sigmaInv_E)
         call curl(curl_curl_B,temp_E,m)
       end subroutine

       end module
       module energy_aux_mod
       use current_precision_mod
       use SF_extend_mod
       use VF_extend_mod

       use ops_embedExtract_mod
       use mesh_domain_extend_mod
       use mesh_extend_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod

       implicit none

       private
       public :: compute_Q
       public :: volumetric_heating_intro
       public :: volumetric_heating_equation
       public :: compute_divQ

       contains

       subroutine compute_Q(Q,T,k,m)
         implicit none
         type(VF),intent(inout) :: Q
         type(SF),intent(in) :: T
         type(VF),intent(in) :: k
         type(mesh),intent(in) :: m
         call grad(Q,T,m)
         call multiply(Q,k)
         call multiply(Q,-1.0_cp)
       end subroutine

       subroutine compute_divQ(divQ,Q,m)
         implicit none
         type(SF),intent(inout) :: divQ
         type(VF),intent(in) :: Q
         type(mesh),intent(in) :: m
         call div(divQ,Q,m)
       end subroutine

       subroutine volumetric_heating_intro(Q_CC,m)
         implicit none
         type(SF),intent(inout) :: Q_CC
         type(mesh),intent(in) :: m
         integer :: t,i,j,k
         real(cp) :: q_flux,a,L
         q_flux = 1.0_cp
         a = 1.0_cp
         L = 1.0_cp
         !$OMP PARALLEL DO
         do t=1,m%s; do k=1,Q_CC%BF(t)%GF%s(3); do j=1,Q_CC%BF(t)%GF%s(2); do i=1,Q_CC%BF(t)%GF%s(1)
         Q_CC%BF(t)%GF%f(i,j,k) = q_flux*exp(-(m%B(t)%g%c(2)%hc%f(j)+a)/L)
         enddo; enddo; enddo; enddo
         !$OMP END PARALLEL DO
       end subroutine

       subroutine volumetric_heating_equation(Q_CC,m,Pe)
         implicit none
         type(SF),intent(inout) :: Q_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: Pe
         integer :: t,i,j,k
         real(cp) :: a,L,m_,F
         a = 1.0_cp
         L = 1.0_cp
         m_ = a/L
         F = 2.0_cp*m_/(1.0_cp-exp(-2.0_cp*m_)) /Pe
         !$OMP PARALLEL DO
         do t=1,m%s; do k=1,Q_CC%BF(t)%GF%s(3); do j=1,Q_CC%BF(t)%GF%s(2); do i=1,Q_CC%BF(t)%GF%s(1)
         Q_CC%BF(t)%GF%f(i,j,k) = F*exp(-m_*(m%B(t)%g%c(2)%hc%f(j)+1.0_cp))
         enddo; enddo; enddo; enddo
         !$OMP END PARALLEL DO
       end subroutine

       end module
       module induction_aux_mod
       use current_precision_mod
       use GF_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use ops_embedExtract_mod
       use time_marching_params_mod
       use mesh_domain_extend_mod
       use mesh_extend_mod
       use apply_BCs_mod
       use export_raw_processed_mod
       use IO_export_mod
       use norms_extend_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use probe_mod
       use probe_extend_mod
       use ops_norms_mod
       use dimensionless_params_mod
       use data_location_extend_mod

       implicit none

       private
       public :: compute_divBJ
       public :: compute_Lorentz_stresses
       public :: compute_J
       public :: compute_Total_Energy_Domain
       public :: compute_Total_Energy
       public :: compute_Energy_Component
       public :: embedVelocity_E
       public :: embedVelocity_F
       public :: embedVelocity_CC
       public :: set_sigma_inv_SF
       public :: set_sigma_inv_VF
       public :: set_insulating_above_lid

       contains

       subroutine compute_Lorentz_stresses(stresses,B,m,scale,VF_CC)
         ! Computes: sigma_{ij} = B_j B_i = B bun B
         implicit none
         type(TF),intent(inout) :: stresses
         type(VF),intent(in) :: B
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: VF_CC
         call face2CellCenter(VF_CC,B,m)

         call multiply(stresses%x%x,VF_CC%x,VF_CC%x)
         call multiply(stresses%x%y,VF_CC%x,VF_CC%y)
         call multiply(stresses%x%z,VF_CC%x,VF_CC%z)

         call multiply(stresses%y%x,VF_CC%y,VF_CC%x)
         call multiply(stresses%y%y,VF_CC%y,VF_CC%y)
         call multiply(stresses%y%z,VF_CC%y,VF_CC%z)

         call multiply(stresses%z%x,VF_CC%z,VF_CC%x)
         call multiply(stresses%z%y,VF_CC%z,VF_CC%y)
         call multiply(stresses%z%z,VF_CC%z,VF_CC%z)

         call multiply(stresses%x%x,0.5_cp)
         call multiply(stresses%y%y,0.5_cp)
         call multiply(stresses%z%z,0.5_cp)

         call multiply(stresses,scale)
       end subroutine

       subroutine compute_divBJ(divB,divJ,B,J,m)
         implicit none
         type(SF),intent(inout) :: divB,divJ
         type(VF),intent(in) :: B,J
         type(mesh),intent(in) :: m
         call div(divB,B,m)
         call div(divJ,J,m)
       end subroutine

       subroutine compute_J(J,B,scale,m)
         implicit none
         type(VF),intent(inout) :: B
         type(VF),intent(inout) :: J
         real(cp),intent(in) :: scale
         type(mesh),intent(in) :: m
         call curl(J,B,m)
         call multiply(J,scale)
       end subroutine

       subroutine compute_Total_Energy_Domain(energy,field,field_domain,TMP,m,scale,MD)
         implicit none
         type(probe),intent(inout) :: energy
         type(VF),intent(in) :: field
         type(VF),intent(inout) :: field_domain
         type(time_marching_params),intent(in) :: TMP
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         real(cp),intent(in) :: scale
         real(cp) :: temp
         call extractCC(field_domain,field,MD)
         call assign_ghost_XPeriodic(field_domain,0.0_cp)
         call compute_Ln(temp,field_domain,2.0_cp,m,MD)
         temp = scale*0.5_cp*temp
         call export(energy,TMP,temp)
       end subroutine

       subroutine compute_Total_Energy(energy,field,TMP,m,scale)
         implicit none
         type(probe),intent(inout) :: energy
         type(VF),intent(inout) :: field
         type(time_marching_params),intent(in) :: TMP
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         real(cp) :: temp
         call assign_ghost_XPeriodic(field,0.0_cp) ! norms now includes ghost points
         call compute_Ln(temp,field,2.0_cp,m)
         temp = scale*0.5_cp*temp
         call export(energy,TMP,temp)
       end subroutine

       subroutine compute_Energy_Component(energy,field,TMP,m,scale)
         implicit none
         type(probe),intent(inout) :: energy
         type(SF),intent(inout) :: field
         type(time_marching_params),intent(in) :: TMP
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         real(cp) :: temp
         call assign_ghost_XPeriodic(field,0.0_cp) ! norms now includes ghost points
         call compute_Ln(temp,field,2.0_cp,m)
         temp = scale*0.5_cp*temp
         call export(energy,TMP,temp)
       end subroutine

       subroutine embedVelocity_E(U_E_tot,U_E_in,D_fluid)
         implicit none
         type(TF),intent(inout) :: U_E_tot
         type(TF),intent(in) :: U_E_in ! Momentum edge velocity
         type(mesh_domain),intent(in) :: D_fluid
         call embedEdge(U_E_tot%x,U_E_in%x,D_fluid)
         call embedEdge(U_E_tot%y,U_E_in%y,D_fluid)
         call embedEdge(U_E_tot%z,U_E_in%z,D_fluid)
       end subroutine

       subroutine embedVelocity_F(U_Ft,U_F,D_fluid)
         implicit none
         type(VF),intent(inout) :: U_Ft
         type(VF),intent(in) :: U_F ! Momentum edge velocity
         type(mesh_domain),intent(in) :: D_fluid
         call embedFace(U_Ft,U_F,D_fluid)
       end subroutine

       subroutine embedVelocity_CC(U_cct,U_CC,D_fluid)
         implicit none
         type(VF),intent(inout) :: U_cct
         type(VF),intent(in) :: U_CC ! Momentum edge velocity
         type(mesh_domain),intent(in) :: D_fluid
         call embedCC(U_cct,U_CC,D_fluid)
       end subroutine

       subroutine set_sigma_inv_SF(sigma_inv,m_ind,MD_sigma,DP)
         implicit none
         type(SF),intent(inout) :: sigma_inv
         type(mesh),intent(in) :: m_ind
         type(mesh_domain),intent(in) :: MD_sigma
         type(dimensionless_params),intent(in) :: DP
         type(SF) :: sigma_inv_temp
         type(mesh) :: m_other
         call init_other(m_other,m_ind,MD_sigma)
         call init(sigma_inv_temp,m_other,get_DL(sigma_inv))
         call assign(sigma_inv_temp,1.0_cp)
         call assign(sigma_inv,1.0_cp/DP%sig_local_over_sig_f)
         call embed(sigma_inv,sigma_inv_temp,MD_sigma)
         call delete(sigma_inv_temp)
         call delete(m_other)
       end subroutine

       subroutine set_sigma_inv_VF(sigma_inv,m_ind,MD_sigma,DP)
         implicit none
         type(VF),intent(inout) :: sigma_inv
         type(mesh),intent(in) :: m_ind
         type(mesh_domain),intent(in) :: MD_sigma
         type(dimensionless_params),intent(in) :: DP
         type(VF) :: sigma_inv_temp
         type(mesh) :: m_other
         call init_other(m_other,m_ind,MD_sigma)
         call init(sigma_inv_temp,m_other,get_DL(sigma_inv))
         call assign(sigma_inv_temp,1.0_cp)
         call assign(sigma_inv,1.0_cp/DP%sig_local_over_sig_f)
         ! call set_insulating_above_lid(sigma_inv_temp,m_other,1.0_cp/DP%sig_local_over_sig_f,1.0_cp)
         call embed(sigma_inv,sigma_inv_temp,MD_sigma)
         call delete(sigma_inv_temp)
         call delete(m_other)
       end subroutine

       subroutine set_insulating_above_lid(sigma_inv,m,sigma_inv_lid,y_lid)
         implicit none
         type(VF),intent(inout) :: sigma_inv
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: y_lid,sigma_inv_lid
         integer,dimension(3) :: s
         logical,dimension(4) :: L
         integer :: j,t
         real(cp) :: tol
         tol = m%MP%dhmin_min*10.0_cp**(-3.0_cp)
         do t=1,m%s
         s = sigma_inv%x%BF(t)%GF%s
         do j=1,s(2)
         L(1) =  N_along(sigma_inv%x%DL,2)
         L(2) = CC_along(sigma_inv%x%DL,2)
         if (L(1)) L(3) = (m%B(t)%g%c(2)%hn%f(j).gt.y_lid-tol)
         if (L(2)) L(4) = (m%B(t)%g%c(2)%hc%f(j).gt.y_lid-tol)
         if ((L(1).and.L(3)).or.(L(2).and.L(4))) call assign_plane(sigma_inv%x%BF(t)%GF,sigma_inv_lid,j,2)
         enddo
         s = sigma_inv%y%BF(t)%GF%s
         do j=1,s(2)
         L(1) =  N_along(sigma_inv%y%DL,2)
         L(2) = CC_along(sigma_inv%y%DL,2)
         if (L(1)) L(3) = (m%B(t)%g%c(2)%hn%f(j).gt.y_lid-tol)
         if (L(2)) L(4) = (m%B(t)%g%c(2)%hc%f(j).gt.y_lid-tol)
         if ((L(1).and.L(3)).or.(L(2).and.L(4))) call assign_plane(sigma_inv%y%BF(t)%GF,sigma_inv_lid,j,2)
         enddo
         s = sigma_inv%z%BF(t)%GF%s
         do j=1,s(2)
         L(1) =  N_along(sigma_inv%z%DL,2)
         L(2) = CC_along(sigma_inv%z%DL,2)
         if (L(1)) L(3) = (m%B(t)%g%c(2)%hn%f(j).gt.y_lid-tol)
         if (L(2)) L(4) = (m%B(t)%g%c(2)%hc%f(j).gt.y_lid-tol)
         if ((L(1).and.L(3)).or.(L(2).and.L(4))) call assign_plane(sigma_inv%z%BF(t)%GF,sigma_inv_lid,j,2)
         enddo
         enddo
       end subroutine

       end module
       module init_P_field_mod
       use current_precision_mod
       use IO_import_mod
       use grid_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use GF_mod
       use boundary_conditions_extend_mod
       use ops_discrete_mod
       use sim_params_mod
       implicit none

       private
       public :: init_P_field

       contains

       subroutine init_P_field(p,m,SP)
         implicit none
         type(SF),intent(inout) :: p
         type(mesh),intent(in) :: m
         type(sim_params),intent(in) :: SP
         integer :: preset_ID

         call assign(P,0.0_cp)

         preset_ID = SP%VS%P%IC
         ! preset_ID = 0 ! manual override

         select case(preset_ID)
         case (0)
         case (1); call initUserPfield(p)
         case (2); call Taylor_Green_Vortex(p,m,SP%DP%Re)
         case default; stop 'Error: bad preset_ID in init_P_field.f90'
         end select
       end subroutine

       subroutine initUserPfield(p)
         implicit none
         type(SF),intent(inout) :: p
         call assign(p,0.0_cp)
       end subroutine

       subroutine Taylor_Green_Vortex(p,m,Re)
         implicit none
         type(SF),intent(inout) :: p
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: Re
         call Taylor_Green_Vortex_P(P%BF(1)%GF  ,m%B(1)%g,P%DL  ,Re,0.0_cp)
       end subroutine

       end module
       module init_U_field_mod
       use current_precision_mod
       use IO_import_mod
       use IO_export_mod
       use grid_mod
       use mesh_extend_mod
       use data_location_extend_mod
       use array_mod
       use GF_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use boundary_conditions_extend_mod
       use ops_aux_mod
       use ops_discrete_mod
       use export_raw_processed_mod
       use constants_mod
       use sim_params_mod
       implicit none

       private
       public :: init_U_field

       contains

       subroutine init_U_field(U,m,SP)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         type(sim_params),intent(in) :: SP
         integer :: preset_ID
         call assign(U,0.0_cp)
         preset_ID = SP%VS%U%IC
         ! preset_ID = 0 ! manual override

         select case(preset_ID)
         case (0)
         case (1); call FD_duct(U,m,1,1)
         case (2); call isolated_eddy_2D(U,m,3,1)    ! Isolated Eddy (Weiss)
         case (3); call single_eddy_2D(U,m,3,1)      ! Single Eddy (Weiss)
         case (4); call cylinder2D(U,m,3,1)          ! Cylinder
         case (5); call parabolic1D(U,m,1,2,1)       ! Bandaru (SS of Ha=0)
         case (6); call Taylor_Green_Vortex(U,m,SP%DP%Re)  !
         case default; stop 'Error: bad preset_ID in init_P_field.f90'
         end select
       end subroutine

       ! **************************************************************************
       ! ************************ REAL FIELD FUNCTIONS ****************************
       ! **************************************************************************

       subroutine FD_duct(U,m,dir,posNeg)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir,posNeg
         integer :: i
         do i=1,m%s
           select case(dir)
           case (1); call fully_developed_duct_velocity(U%x%BF(i)%GF,m%B(i)%g,U%x%DL,dir,posNeg)
           case (2); call fully_developed_duct_velocity(U%y%BF(i)%GF,m%B(i)%g,U%y%DL,dir,posNeg)
           case (3); call fully_developed_duct_velocity(U%z%BF(i)%GF,m%B(i)%g,U%z%DL,dir,posNeg)
           case default; stop 'Error: dir must = 1:3 in FD_duct in distribution_funcs.f90'
           end select
         enddo
       end subroutine

       subroutine parabolic1D(U,m,flow_dir,vary_dir,posNeg)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         integer,intent(in) :: flow_dir,vary_dir,posNeg
         integer :: i
         real(cp) :: Re
         Re = 200.0_cp
         if (flow_dir.eq.vary_dir) then
           stop 'Error: flow_dir=vary_dir in parabolic1D in init_U_field.f90'
         endif
         do i=1,m%s
           select case (flow_dir)
           case (1); call parabolic_1D(U%x%BF(i)%GF,m%B(i)%g,U%x%DL,vary_dir)
           case (2); call parabolic_1D(U%y%BF(i)%GF,m%B(i)%g,U%y%DL,vary_dir)
           case (3); call parabolic_1D(U%z%BF(i)%GF,m%B(i)%g,U%z%DL,vary_dir)
           case default; stop 'Error: dir must = 1:3 in parabolic1D in distribution_funcs.f90'
           end select
         enddo
         call multiply(U,Re*real(posNeg,cp))
       end subroutine

       subroutine Taylor_Green_Vortex(U,m,Re)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: Re
         call Taylor_Green_Vortex_U(U%x%BF(1)%GF,m%B(1)%g,U%x%DL,Re,0.0_cp)
         call Taylor_Green_Vortex_V(U%y%BF(1)%GF,m%B(1)%g,U%y%DL,Re,0.0_cp)
         call assign(U%z,0.0_cp)
       end subroutine

       subroutine isolated_eddy_2D(U,m,dir,posNeg)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir,posNeg
         integer :: i
         do i=1,m%s
           select case(dir)
           case (1); call isolated_2D_eddy(U%y%BF(i)%GF,U%z%BF(i)%GF,U%y%DL,U%z%DL,m%B(i)%g,dir,posNeg)
           case (2); call isolated_2D_eddy(U%x%BF(i)%GF,U%z%BF(i)%GF,U%x%DL,U%z%DL,m%B(i)%g,dir,posNeg)
           case (3); call isolated_2D_eddy(U%x%BF(i)%GF,U%y%BF(i)%GF,U%x%DL,U%y%DL,m%B(i)%g,dir,posNeg)
           case default; stop 'Error: dir must = 1:3 in isolated_eddy_2D in distribution_funcs.f90'
           end select
         enddo
       end subroutine

       subroutine single_eddy_2D(U,m,dir,posNeg)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir,posNeg
         integer :: i
         do i=1,m%s
           select case(dir)
           case (1); call single_2D_eddy(U%y%BF(i)%GF,U%z%BF(i)%GF,m%B(i)%g,U%y%DL,U%z%DL,dir,posNeg)
           case (2); call single_2D_eddy(U%x%BF(i)%GF,U%z%BF(i)%GF,m%B(i)%g,U%x%DL,U%z%DL,dir,posNeg)
           case (3); call single_2D_eddy(U%x%BF(i)%GF,U%y%BF(i)%GF,m%B(i)%g,U%x%DL,U%y%DL,dir,posNeg)
           case default; stop 'Error: dir must = 1:3 in single_eddy_2D in distribution_funcs.f90'
           end select
         enddo
       end subroutine

       subroutine cylinder2D(U,m,dir,posNeg)
         implicit none
         type(VF),intent(inout) :: U
         type(mesh),intent(in) :: m
         integer,intent(in) :: dir,posNeg
         integer :: i
         do i=1,m%s
           select case(dir)
           case (1); call cylinder_2D_velocity(U%y%BF(i)%GF,U%z%BF(i)%GF,m%B(i)%g,U%y%DL,U%z%DL,dir,posNeg)
           case (2); call cylinder_2D_velocity(U%x%BF(i)%GF,U%z%BF(i)%GF,m%B(i)%g,U%x%DL,U%z%DL,dir,posNeg)
           case (3); call cylinder_2D_velocity(U%x%BF(i)%GF,U%y%BF(i)%GF,m%B(i)%g,U%x%DL,U%y%DL,dir,posNeg)
           case default; stop 'Error: dir must = 1:3 in cylinder2D in distribution_funcs.f90'
           end select
         enddo
       end subroutine

       end module
      module matrix_free_operators_mod
      use matrix_free_operators_interfaces_mod
      ! NOTES:
      !      ONLY CENTERED DERIVATIVES SHOULD BE USED IN THIS
      !      FILE SINCE IMPLICIT SOLVERS IN MOONS DEPEND ON BC
      !      IMPLICIT DERIVATIVES. SEE DOCUMENTATION.
      !
      use current_precision_mod
      use mesh_extend_mod
      use data_location_extend_mod
      use SF_extend_mod
      use VF_extend_mod
      use TF_extend_mod
      use ops_discrete_mod
      use ops_aux_mod
      use ops_interp_mod
      use apply_BCs_mod
      use apply_BCs_implicit_mod
      use matrix_free_params_mod
      implicit none

      private
      public :: Lap_uniform_SF_explicit,Lap_uniform_SF
      public :: Lap_uniform_VF_explicit,Lap_uniform_VF
      public :: Lap_nonuniform_props_explicit,Lap_nonuniform_props
      public :: ind_diffusion_explicit,ind_diffusion
      public :: nrg_diffusion_explicit,nrg_diffusion
      public :: mom_diffusion_explicit,mom_diffusion

      public :: op_SF,op_SF_explicit
      public :: op_VF,op_VF_explicit

      contains

      subroutine Lap_uniform_SF_explicit(Ax,x,k,m,MFP,tempk)
        ! COMPUTES:
        !        A = ∇•(∇)
        implicit none
        type(SF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        logical :: suppress_warning
        suppress_warning = MFP%suppress_warning
        suppress_warning = is_CC(k%x)
        call lap_centered(Ax,x,m,tempk%x)
        ! call grad(tempk,x,m)
        ! call div(Ax,tempk,m)
      end subroutine
      subroutine Lap_uniform_SF(Ax,x,k,m,MFP,tempk)
        ! COMPUTES:
        !        A = ∇•(∇)
        implicit none
        type(SF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        call apply_BCs_implicit(x)
        call Lap_uniform_SF_explicit(Ax,x,k,m,MFP,tempk)
      end subroutine

      subroutine Lap_uniform_VF_explicit(Ax,x,k,m,MFP,tempk)
        ! COMPUTES:
        !        A = ∇•(∇)
        implicit none
        type(VF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        logical :: suppress_warning
        suppress_warning = MFP%suppress_warning
        suppress_warning = is_CC(k%x)
        call lap_centered(Ax,x,m,tempk)
        ! call lap(Ax,x,m)
      end subroutine
      subroutine Lap_uniform_VF(Ax,x,k,m,MFP,tempk)
        ! COMPUTES:
        !        A = ∇•(∇)
        implicit none
        type(VF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        call apply_BCs_implicit(x)
        call Lap_uniform_VF_explicit(Ax,x,k,m,MFP,tempk)
      end subroutine

      subroutine Lap_nonuniform_props_explicit(Ax,x,k,m,MFP,tempk)
        ! COMPUTES:
        !        A = ∇•(k∇)
        implicit none
        type(SF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        logical :: suppress_warning
        suppress_warning = MFP%suppress_warning
        call grad(tempk%x,x,m)
        call multiply(tempk%x,k%x)
        call div(Ax,tempk%x,m)
      end subroutine
      subroutine Lap_nonuniform_props(Ax,x,k,m,MFP,tempk)
        ! COMPUTES:
        !        A = ∇•(k∇)
        implicit none
        type(SF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        call apply_BCs_implicit(x)
        call Lap_nonuniform_props_explicit(Ax,x,k,m,MFP,tempk)
      end subroutine

      subroutine ind_diffusion_explicit(Ax,x,k,m,MFP,tempk)
        ! COMPUTES:
        !        A = {I + coeff ∇x(k∇x)}
        implicit none
        type(VF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        call curl(tempk%x,x,m)
        call multiply(tempk%x,k%x)
        call curl(Ax,tempk%x,m)
        call multiply(Ax,MFP%coeff_implicit_time_split)
        call add(Ax,x)
      end subroutine
      subroutine ind_diffusion(Ax,x,k,m,MFP,tempk)
        ! COMPUTES:
        !        A = {I + coeff ∇x(k∇x)}
        implicit none
        type(VF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        call apply_BCs_implicit(x)
        call ind_diffusion_explicit(Ax,x,k,m,MFP,tempk)
      end subroutine

      subroutine nrg_diffusion_explicit(Ax,x,k,m,MFP,tempk)
        ! Computes:
        !        A = {I + coeff ∇•(k∇)}
        implicit none
        type(SF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        call grad(tempk%x,x,m)
        call multiply(tempk%x,k%x)
        call div(Ax,tempk%x,m)
        call multiply(Ax,MFP%coeff_implicit_time_split)
        call add(Ax,x)
      end subroutine
      subroutine nrg_diffusion(Ax,x,k,m,MFP,tempk)
        ! Computes:
        !        A = {I + coeff ∇•(k∇)}
        implicit none
        type(SF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        call apply_BCs_implicit(x)
        call nrg_diffusion_explicit(Ax,x,k,m,MFP,tempk)
      end subroutine

      subroutine mom_diffusion_explicit(Ax,x,k,m,MFP,tempk)
        ! Computes:
        !        A = {I + coeff ∇•(∇)}
        implicit none
        type(VF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        logical :: suppress_warning
        suppress_warning = is_CC(k)
        call lap_centered(Ax,x,m,tempk)
        call multiply(Ax,MFP%coeff_implicit_time_split)
        call add(Ax,x)
      end subroutine
      subroutine mom_diffusion(Ax,x,k,m,MFP,tempk)
        ! Computes:
        !        A = {I + coeff ∇•(∇)}
        implicit none
        type(VF),intent(inout) :: Ax,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        call apply_BCs_implicit(x)
        call mom_diffusion_explicit(Ax,x,k,m,MFP,tempk)
      end subroutine

      end module
       module momentum_aux_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use ops_norms_mod

       implicit none
       private

       public :: compute_TKE
       public :: compute_TKE_2C
       public :: compute_CoFoRe_grid
       public :: addMeanPressureGrad

       contains

       subroutine compute_TKE(K_energy,U_CC,m,scale)
         implicit none
         real(cp),intent(inout) :: K_energy
         type(VF),intent(inout) :: U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         call assign_ghost_XPeriodic(U_CC,0.0_cp) ! norms now includes ghost points
         call compute_Ln(K_energy,U_CC,2.0_cp,m)
         K_energy = scale*0.5_cp*K_energy ! KE = 1/2 int(u^2) dV
       end subroutine

       subroutine compute_TKE_2C(K_energy,A,B,m,scale,temp)
         implicit none
         real(cp),intent(inout) :: K_energy
         type(SF),intent(inout) :: temp
         type(SF),intent(in) :: A,B
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         call add(temp,A,B)
         call assign_ghost_XPeriodic(temp,0.0_cp) ! norms now includes ghost points
         call compute_Ln(K_energy,temp,2.0_cp,m)
         K_energy = scale*0.5_cp*K_energy ! KE = 1/2 int(u^2) dV
       end subroutine

       subroutine compute_CoFoRe_grid(Co_grid,Fo_grid,Re_grid,U_CC,m,dt,Re)
         implicit none
         type(SF),intent(inout) :: Co_grid,Fo_grid,Re_grid
         type(VF),intent(in) :: U_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: dt,Re
         call stabilityTerms(Co_grid,U_CC,m,1)
         call multiply(Co_grid,dt)
         call stabilityTerms(Fo_grid,U_CC,m,2)
         call multiply(Fo_grid,dt)
         call stabilityTerms(Re_grid,U_CC,m,-1)
         call multiply(Re_grid,Re)
       end subroutine

       subroutine addMeanPressureGrad(f,mpg,dir)
         implicit none
         type(VF),intent(inout) :: f
         real(cp),intent(in) :: mpg
         integer,intent(in) :: dir
         select case (dir)
         case (1); call subtract(f%x,mpg)
         case (2); call subtract(f%y,mpg)
         case (3); call subtract(f%z,mpg)
         case default; stop 'Error: dir must = 1,2,3 in addMeanPressureGrad in momentum_aux.f90'
         end select
       end subroutine

       end module
       module ops_advect_mod
       use current_precision_mod
       use ops_del_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use ops_interp_mod
       use ops_discrete_mod
       use ops_aux_mod

       implicit none

       private
       public :: advect_U_divergence
       public :: advect_U_convection
       public :: advect_B

       interface advect_U_convection; module procedure advect_U_convection1; end interface
       interface advect_U_convection; module procedure advect_U_convection2; end interface

       contains

       subroutine advect_U_divergence(div,U,U_E,m,compute_U_E,temp_E,temp_CC)
         ! Computes
         !           d
         !  div_i = --- (u_j u_i)
         !          dx_j
         ! While minimizing interpolations.
         !           div_i, U, Ui          --> cell face.
         !           tempE and U_E         --> cell edge.
         !           temp_CC               --> cell center.
         implicit none
         type(VF),intent(inout) :: div
         type(VF),intent(in) :: U
         type(TF),intent(inout) :: U_E
         type(VF),intent(inout) :: temp_E
         type(SF),intent(inout) :: temp_CC
         type(mesh),intent(in) :: m
         logical,intent(in) :: compute_U_E
         type(del) :: d
         ! d/dxj (uj ui) for i=j
         call face2CellCenter(temp_CC,U%x,m,1)
         call square(temp_CC)
         call d%assign(div%x,temp_CC,m,1,1,0) ! zero pad needed for Neumann BCs
         call face2CellCenter(temp_CC,U%y,m,2)
         call square(temp_CC)
         call d%assign(div%y,temp_CC,m,1,2,0) ! zero pad needed for Neumann BCs
         call face2CellCenter(temp_CC,U%z,m,3)
         call square(temp_CC)
         call d%assign(div%z,temp_CC,m,1,3,0) ! zero pad needed for Neumann BCs
         if (compute_U_E) call face2Edge_no_diag(U_E,U,m)
         ! d/dxj (uj ui) for i≠j,  note that Ui must be included
         call multiply(temp_E%y,U_E%x%y,U_E%z%y) ! x (y edge)
         call multiply(temp_E%z,U_E%x%z,U_E%y%z) ! x (z edge)
         call d%add(div%x,temp_E%y,m,1,3,0) ! zero pad needed for Neumann BCs
         call d%add(div%x,temp_E%z,m,1,2,0) ! zero pad needed for Neumann BCs

         call multiply(temp_E%x,U_E%y%x,U_E%z%x) ! y (x edge)
         call multiply(temp_E%z,U_E%y%z,U_E%x%z) ! y (z edge)
         call d%add(div%y,temp_E%x,m,1,3,0) ! zero pad needed for Neumann BCs
         call d%add(div%y,temp_E%z,m,1,1,0) ! zero pad needed for Neumann BCs

         call multiply(temp_E%x,U_E%z%x,U_E%y%x) ! z (x edge)
         call multiply(temp_E%y,U_E%z%y,U_E%x%y) ! z (y edge)
         call d%add(div%z,temp_E%x,m,1,2,0) ! zero pad needed for Neumann BCs
         call d%add(div%z,temp_E%y,m,1,1,0) ! zero pad needed for Neumann BCs
         ! call assign_ghost_XPeriodic(div,0.0_cp)
       end subroutine

       subroutine advect_U_convection1(div,U,U_E,m,compute_U_E,temp_F1,temp_F2,temp_CC)
         ! Computes
         !               d
         !  div_i = u_j --- u_i
         !              dx_j
         ! While minimizing interpolations.
         !           div_i, U, Ui          --> cell face.
         !           tempE and U_E         --> cell edge.
         !           temp_CC               --> cell center.
         implicit none
         type(VF),intent(inout) :: div,temp_F1,temp_F2
         type(VF),intent(in) :: U
         type(TF),intent(inout) :: U_E
         type(SF),intent(inout) :: temp_CC
         type(mesh),intent(in) :: m
         logical,intent(in) :: compute_U_E
         type(del) :: d
         ! d/dxj (uj ui) for i=j
         call face2CellCenter(temp_CC,U%x,m,1)
         call d%assign(div%x,temp_CC,m,1,1,0)
         call multiply(div%x,U%x)
         call face2CellCenter(temp_CC,U%y,m,2)
         call d%assign(div%y,temp_CC,m,1,2,0)
         call multiply(div%y,U%y)
         call face2CellCenter(temp_CC,U%z,m,3)
         call d%assign(div%z,temp_CC,m,1,3,0)
         call multiply(div%z,U%z)
         if (compute_U_E) call face2Edge_no_diag(U_E,U,m)
         ! d/dxj (uj ui) for i≠j,  note that Ui must be included
         call d%assign( temp_F1%x,    U_E%x%z,m,1      ,2,0)
         call face2Face(temp_F2%x,        U%y,m,temp_CC,2,1)
         call multiply( temp_F1%x,temp_F2%x)
         call add(div%x,temp_F1%x)
         call d%assign( temp_F1%x,    U_E%x%y,m,1      ,3,0)
         call face2Face(temp_F2%x,        U%z,m,temp_CC,3,1)
         call multiply( temp_F1%x,temp_F2%x)
         call add(div%x,temp_F1%x)

         call d%assign( temp_F1%y,    U_E%y%z,m,1      ,1,0)
         call face2Face(temp_F2%y,        U%x,m,temp_CC,1,2)
         call multiply( temp_F1%y,temp_F2%y)
         call add(div%y,temp_F1%y)
         call d%assign( temp_F1%y,    U_E%y%x,m,1      ,3,0)
         call face2Face(temp_F2%y,        U%z,m,temp_CC,3,2)
         call multiply( temp_F1%y,temp_F2%y)
         call add(div%y,temp_F1%y)

         call d%assign( temp_F1%z,    U_E%z%y,m,1      ,1,0)
         call face2Face(temp_F2%z,        U%x,m,temp_CC,1,3)
         call multiply( temp_F1%z,temp_F2%z)
         call add(div%z,temp_F1%z)
         call d%assign( temp_F1%z,    U_E%z%x,m,1      ,2,0)
         call face2Face(temp_F2%z,        U%y,m,temp_CC,2,3)
         call multiply( temp_F1%z,temp_F2%z)
         call add(div%z,temp_F1%z)
         ! call assign_ghost_XPeriodic(div,0.0_cp)
       end subroutine

       subroutine advect_U_convection2(div,U_adv,U,U_E,m,temp_F1,temp_F2,temp_CC)
         ! Computes
         !                   d
         !  div_i = u_adv_j --- u_i
         !                  dx_j
         ! While minimizing interpolations.
         !           div_i, U, Ui          --> cell face.
         !           tempE and U_E         --> cell edge.
         !           temp_CC               --> cell center.
         implicit none
         type(VF),intent(inout) :: div,temp_F1,temp_F2
         type(VF),intent(in) :: U,U_adv
         type(TF),intent(inout) :: U_E
         type(SF),intent(inout) :: temp_CC
         type(mesh),intent(in) :: m
         type(del) :: d
         ! d/dxj (uj ui) for i=j
         call face2CellCenter(temp_CC,U%x,m,1)
         call d%assign(div%x,temp_CC,m,1,1,0)
         call multiply(div%x,U_adv%x)
         call face2CellCenter(temp_CC,U%y,m,2)
         call d%assign(div%y,temp_CC,m,1,2,0)
         call multiply(div%y,U_adv%y)
         call face2CellCenter(temp_CC,U%z,m,3)
         call d%assign(div%z,temp_CC,m,1,3,0)
         call multiply(div%z,U_adv%z)
         call face2Edge_no_diag(U_E,U,m)
         ! d/dxj (uj ui) for i≠j,  note that Ui must be included
         call d%assign( temp_F1%x,    U_E%x%z,m,1      ,2,0)
         call face2Face(temp_F2%x,    U_adv%y,m,temp_CC,2,1)
         call multiply( temp_F1%x,temp_F2%x)
         call add(div%x,temp_F1%x)
         call d%assign( temp_F1%x,    U_E%x%y,m,1      ,3,0)
         call face2Face(temp_F2%x,    U_adv%z,m,temp_CC,3,1)
         call multiply( temp_F1%x,temp_F2%x)
         call add(div%x,temp_F1%x)

         call d%assign( temp_F1%y,    U_E%y%z,m,1      ,1,0)
         call face2Face(temp_F2%y,    U_adv%x,m,temp_CC,1,2)
         call multiply( temp_F1%y,temp_F2%y)
         call add(div%y,temp_F1%y)
         call d%assign( temp_F1%y,    U_E%y%x,m,1      ,3,0)
         call face2Face(temp_F2%y,    U_adv%z,m,temp_CC,3,2)
         call multiply( temp_F1%y,temp_F2%y)
         call add(div%y,temp_F1%y)

         call d%assign( temp_F1%z,    U_E%z%y,m,1      ,1,0)
         call face2Face(temp_F2%z,    U_adv%x,m,temp_CC,1,3)
         call multiply( temp_F1%z,temp_F2%z)
         call add(div%z,temp_F1%z)
         call d%assign( temp_F1%z,    U_E%z%x,m,1      ,2,0)
         call face2Face(temp_F2%z,    U_adv%y,m,temp_CC,2,3)
         call multiply( temp_F1%z,temp_F2%z)
         call add(div%z,temp_F1%z)
         call assign_ghost_XPeriodic(div,0.0_cp)
       end subroutine

       subroutine advect_B(adv,U_E,B_F,m,temp_E_TF,temp_E)
         ! Computes
         !
         !      (∇ x ( u_edge x B_face )_edge)_face
         !
         ! While minimizing interpolations.
         implicit none
         type(VF),intent(inout) :: adv,temp_E
         type(TF),intent(inout) :: temp_E_TF
         type(TF),intent(in) :: U_E
         type(VF),intent(in) :: B_F
         type(mesh),intent(in) :: m
         call edgeCrossFace_E(temp_E,U_E,B_F,m,temp_E_TF)
         call curl(adv,temp_E,m)
       end subroutine

       subroutine edgeCrossFace_E(AcrossB_E,A_E,B_F,m,temp_B_E)
         ! Computes
         !
         !      ( u_edge x B_face )_edge
         !
         ! While minimizing interpolations.
         ! There is some memory abuse here however,
         ! since the diagonals are not used..
         implicit none
         type(VF),intent(inout) :: AcrossB_E
         type(TF),intent(in) :: A_E
         type(VF),intent(in) :: B_F
         type(mesh),intent(in) :: m
         type(TF),intent(inout) :: temp_B_E
         call face2Edge_no_diag(temp_B_E,B_F,m)
         call cross_product(AcrossB_E,A_E,temp_B_E)
       end subroutine

       end module
       module E_K_budget_mod
       use current_precision_mod
       use string_mod
       use path_extend_mod
       use dir_tree_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use IO_tools_mod
       use E_K_budget_terms_mod
       use mesh_domain_extend_mod
       use ops_discrete_mod
       use ops_interp_mod
       use ops_embedExtract_mod
       use ops_mirror_field_mod
       use time_marching_params_mod
       use dimensionless_params_mod
       use mirror_props_extend_mod
       implicit none

       private
       public :: E_K_Budget_wrapper
       public :: E_K_Budget_no_dummies
       public :: compute_E_K_budget_fields
       public :: export_integral_E_K_budget

       contains

       subroutine E_K_Budget_wrapper(DT,U,Unm1,B,B0,J,p,m,TMP,DP,MP,MD_fluid)
         implicit none
         type(dir_tree),intent(in) :: DT
         type(VF),intent(in) :: U,Unm1,B,B0,J
         type(SF),intent(in) :: p
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD_fluid
         type(dimensionless_params),intent(in) :: DP
         type(mirror_props),intent(in) :: MP
         type(time_marching_params),intent(in) :: TMP
         type(mesh_domain) :: MD_fluid_temp,temp
         type(mesh) :: m_temp
         type(VF) :: U_temp,Unm1_temp,B_temp,B0_temp,J_temp
         type(SF) :: p_temp
         if (MP%mirror) then
          call mirror_field(m_temp,U_temp,m,U,MP)
          call mirror_field(m_temp,Unm1_temp,m,Unm1,MP)
          call mirror_field(m_temp,p_temp,m,p,MP)
          call mirror_field(m_temp,B_temp,m,B,anti_mirror(MP))
          call mirror_field(m_temp,B0_temp,m,B0,MP)
          call mirror_field(m_temp,J_temp,m,J,MP)
          call mirror_mesh(temp%m_R1,MD_fluid%m_R1,MP)
          call mirror_mesh(temp%m_R2,MD_fluid%m_R2,MP)
          call init(MD_fluid_temp,temp%m_R1,temp%m_R1)
          call E_K_Budget_no_dummies(DT,U_temp,Unm1_temp,B_temp,B0_temp,&
          J_temp,p_temp,m_temp,TMP,DP,MD_fluid_temp)
          call delete(MD_fluid_temp)
          call delete(temp)
          call delete(m_temp)
          call delete(U_temp)
          call delete(Unm1_temp)
          call delete(p_temp)
          call delete(B_temp)
          call delete(B0_temp)
          call delete(J_temp)
         else
          call E_K_Budget_no_dummies(DT,U,Unm1,B,B0,J,p,m,TMP,DP,MD_fluid)
         endif
       end subroutine

       subroutine E_K_Budget_no_dummies(DT,U,Unm1,B,B0,J,p,m,TMP,DP,MD_fluid)
         implicit none
         type(dir_tree),intent(in) :: DT
         type(VF),intent(in) :: U,Unm1,B,B0,J
         type(SF),intent(in) :: p
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD_fluid
         type(dimensionless_params),intent(in) :: DP
         type(time_marching_params),intent(in) :: TMP
         real(cp),dimension(8) :: e_budget
         type(SF) :: e
         type(VF) :: VF_F1,VF_F2,temp_B,temp_B0,temp_J,U_CC
         type(TF) :: TF_CC1,TF_CC2
         call init_CC(e,m)
         call init_CC(U_CC,m)
         call face2CellCenter(U_CC,U,m)

         call init_CC(TF_CC1,m)
         call init_CC(TF_CC2,m)
         call init_Face(VF_F1,m)
         call init_Face(VF_F2,m)

         call init_Face(temp_B,m)
         call init_Face(temp_B0,m)
         call init_Edge(temp_J,m)

         call extractFace(temp_B,B,MD_fluid)
         call extractFace(temp_B0,B0,MD_fluid)
         call extractEdge(temp_J,J,MD_fluid)

         call compute_E_K_budget_fields(DT,e_budget,U,Unm1,U_CC,&
         temp_B,temp_B0,temp_J,p,m,TMP%TS%dt,DP,&
         VF_F1,VF_F2,TF_CC1,TF_CC2)

         call export_integral_E_K_budget(DT,TMP,e_budget)

         call delete(e)
         call delete(VF_F1)
         call delete(VF_F2)
         call delete(temp_B)
         call delete(temp_B0)
         call delete(temp_J)
         call delete(U_CC)
         call delete(TF_CC1)
         call delete(TF_CC2)
       end subroutine

       subroutine compute_E_K_budget_fields(DT,e_int,U,Unm1,U_CC,B,B0,J,p,m,dTime,DP,&
         VF_F1,VF_F2,TF_CC1,TF_CC2)
         implicit none
         type(dir_tree),intent(in) :: DT
         type(VF),intent(in) :: U,Unm1,U_CC,B,B0,J
         type(SF),intent(in) :: p
         type(VF),intent(inout) :: VF_F1,VF_F2
         type(TF),intent(inout) :: TF_CC1,TF_CC2
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: dTime
         type(dimensionless_params),intent(in) :: DP
         real(cp),dimension(8),intent(inout) :: e_int
         type(SF) :: e
         real(cp) :: scale,Al,Re_inv
         integer :: i
         call init(e,TF_CC1%x%x)
         i = 1
         Al = DP%Al
         Re_inv = 1.0_cp/DP%Re
         scale=1.0_cp;call export_Unsteady(e_int(i),e,U,Unm1,dTime,m,scale,TF_CC1%x,TF_CC2%x,DT); i=i+1
         scale=1.0_cp;call export_E_K_Convection(e_int(i),e,U,U_CC,m,scale,VF_F1,VF_F2,TF_CC1%x,TF_CC2%x%x,DT); i=i+1
         scale=Re_inv;call export_E_K_Diffusion(e_int(i),e,U_CC,m,scale,TF_CC1%x,DT); i=i+1
         scale=1.0_cp;call export_E_K_Pressure(e_int(i),e,U,p,m,scale,VF_F1,DT); i=i+1
         scale=Re_inv;call export_Viscous_Dissipation(e_int(i),e,U_CC,m,scale,TF_CC1,TF_CC2,DT); i=i+1

         call add(VF_F2,B,B0)
         scale=Al;call export_E_M_Convection(e_int(i),e,VF_F2,U,m,scale,TF_CC1%x,TF_CC2%x,VF_F1,DT); i=i+1
         scale=Al;call export_E_M_Tension(e_int(i),e,VF_F2,U_CC,m,scale,TF_CC1%x,TF_CC1%y,TF_CC1%z,TF_CC2,DT); i=i+1
         scale=Al;call export_Lorentz(e_int(i),e,J,VF_F2,U_CC,m,scale,TF_CC1%x,TF_CC1%y,TF_CC1%z,VF_F1,DT); i=i+1
         call delete(e)
       end subroutine

       subroutine export_integral_E_K_budget(DT,TMP,e_budget)
         implicit none
         type(time_marching_params),intent(in) :: TMP
         real(cp),dimension(8),intent(in) :: e_budget
         type(dir_tree),intent(in) :: DT
         type(string),dimension(8) :: vars
         integer :: un,i
         un = new_and_open(str(DT%e_budget),'E_K_budget_terms')
         i=1
         call init(vars(i),'Unsteady = '); i=i+1
         call init(vars(i),'E_K_Convection = '); i=i+1
         call init(vars(i),'E_K_Diffusion = '); i=i+1
         call init(vars(i),'E_K_Pressure = '); i=i+1
         call init(vars(i),'Viscous_Dissipation = '); i=i+1
         call init(vars(i),'E_M_Convection = '); i=i+1
         call init(vars(i),'E_M_Tension = '); i=i+1
         call init(vars(i),'Lorentz = '); i=i+1

         write(un,*) 'kinetic energy budget at t=',TMP%t
         do i=1,size(vars)
         write(un,*) str(vars(i)),e_budget(i)
         call delete(vars(i))
         enddo
         flush(un)
         call close_and_message(un,str(DT%e_budget),'E_K_budget_terms')
       end subroutine

       end module
       module E_M_budget_mod
       use current_precision_mod
       use string_mod
       use path_extend_mod
       use dir_tree_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use IO_tools_mod
       use E_M_budget_terms_mod
       use mesh_domain_extend_mod
       use ops_discrete_mod
       use induction_aux_mod
       use ops_interp_mod
       use ops_embedExtract_mod
       use ops_mirror_field_mod
       use time_marching_params_mod
       use dimensionless_params_mod
       use mirror_props_mod
       use export_raw_processed_mod
       implicit none

       private
       public :: E_M_Budget_wrapper
       public :: E_M_Budget_no_dummies
       public :: compute_E_M_Budget_fields
       public :: export_integral_E_M_budget

       contains

       subroutine E_M_Budget_wrapper(DT,U,B,Bnm1,B0,B0nm1,J,m,MD_fluid,MD_sigma,DP,TMP,MP)
         implicit none
         type(VF),intent(in) :: U,B,Bnm1,B0,B0nm1,J
         type(mesh_domain),intent(in) :: MD_fluid,MD_sigma
         type(dimensionless_params),intent(in) :: DP
         type(time_marching_params),intent(in) :: TMP
         type(dir_tree),intent(in) :: DT
         type(mesh),intent(in) :: m
         type(mirror_props),intent(in) :: MP
         type(mesh_domain) :: MD_fluid_temp,MD_sigma_temp,temp
         type(mesh) :: m_temp
         type(VF) :: U_temp,B_temp,Bnm1_temp,B0_temp,B0nm1_temp,J_temp
         if (MP%mirror) then
          call mirror_field(m_temp,U_temp,m,U,MP)
          call mirror_field(m_temp,B_temp,m,B,MP)
          call mirror_field(m_temp,Bnm1_temp,m,Bnm1,MP)
          call mirror_field(m_temp,B0_temp,m,B0,MP)
          call mirror_field(m_temp,B0nm1_temp,m,B0nm1,MP)
          call mirror_field(m_temp,J_temp,m,J,MP)

          call mirror_mesh(temp%m_R1,MD_fluid%m_R1,MP)
          call mirror_mesh(temp%m_R2,MD_fluid%m_R2,MP)
          call init(MD_fluid_temp,temp%m_R1,temp%m_R2)

          call mirror_mesh(temp%m_R1,MD_sigma%m_R1,MP)
          call mirror_mesh(temp%m_R2,MD_sigma%m_R2,MP)
          call init(MD_sigma_temp,temp%m_R1,temp%m_R2)

          call E_M_Budget_no_dummies(DT,U_temp,B_temp,Bnm1_temp,B0_temp,B0nm1_temp,&
          J_temp,m_temp,MD_fluid_temp,MD_sigma_temp,DP,TMP)
          call delete(MD_fluid_temp)
          call delete(MD_sigma_temp)
          call delete(temp)
          call delete(m_temp)
          call delete(U_temp)
          call delete(B_temp)
          call delete(Bnm1_temp)
          call delete(B0_temp)
          call delete(B0nm1_temp)
          call delete(J_temp)
         else
          call E_M_Budget_no_dummies(DT,U,B,Bnm1,B0,B0nm1,J,m,MD_fluid,MD_sigma,DP,TMP)
         endif
       end subroutine

       subroutine E_M_Budget_no_dummies(DT,U,B,Bnm1,B0,B0nm1,J,m,MD_fluid,MD_sigma,DP,TMP)
         implicit none
         type(VF),intent(in) :: U,B,Bnm1,B0,B0nm1,J
         type(mesh_domain),intent(in) :: MD_fluid,MD_sigma
         type(dimensionless_params),intent(in) :: DP
         type(time_marching_params),intent(in) :: TMP
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         real(cp),dimension(3) :: e_budget
         type(mesh) :: m_conduct
         type(SF) :: sigInv_CC,sigInv_CC_conduct,sigInv_CC_ideal
         type(VF) :: sigInv_F,sigInv_F_conduct,sigInv_F_ideal
         type(VF) :: temp_F1,temp_U,temp_CC_VF,B_temp,Bnm1_temp
         type(TF) :: temp_CC_TF,temp_F1_TF,temp_F2_TF,temp_F3_TF

         call init_other(m_conduct,m,MD_sigma)
         call init_CC(temp_CC_TF,m)
         call init_CC(temp_CC_VF,m)
         call init_Face(temp_F1,m)
         call init_Face(temp_F1_TF,m)
         call init_Face(temp_F2_TF,m)
         call init_Face(temp_F3_TF,m)
         call init_Face(temp_U,m)
         call init_CC(sigInv_CC_conduct,m_conduct)
         call init_CC(sigInv_CC_ideal,m)
         call init_CC(sigInv_CC,m)
         call init_Face(sigInv_F_conduct,m_conduct)
         call init_Face(sigInv_F_ideal,m)
         call init_Face(sigInv_F,m)

         call init(B_temp,B)
         call init(Bnm1_temp,Bnm1)
         call assign(B_temp,B)
         call assign(Bnm1_temp,Bnm1)
         call add(B_temp,B0)
         call add(Bnm1_temp,B0nm1)

         call set_sigma_inv_VF(sigInv_F,m,MD_sigma,DP)
         call set_sigma_inv_SF(sigInv_CC,m,MD_sigma,DP)

         call assign(     sigInv_F_ideal,   0.0_cp)
         call assign(     sigInv_CC_ideal,  0.0_cp)
         call extractFace(sigInv_F_conduct, sigInv_F,         MD_sigma)
         call extractCC(  sigInv_CC_conduct,sigInv_CC,        MD_sigma)
         call embedFace(  sigInv_F_ideal,   sigInv_F_conduct, MD_sigma)
         call embedCC(    sigInv_CC_ideal,  sigInv_CC_conduct,MD_sigma)

         call embedFace(temp_U,U,MD_fluid)

         call compute_E_M_Budget_fields(DT,e_budget,B_temp,Bnm1_temp,J,&
         sigInv_F_ideal,sigInv_CC_ideal,temp_U,m,TMP%TS%dt,DP,&
         temp_CC_TF,temp_CC_VF,temp_F1,&
         temp_F1_TF,temp_F2_TF,temp_F3_TF)

         call export_integral_E_M_budget(DT,TMP,e_budget)

         call delete(m_conduct)
         call delete(B_temp)
         call delete(Bnm1_temp)
         call delete(temp_CC_TF)
         call delete(temp_CC_VF)
         call delete(temp_F1)
         call delete(temp_F1_TF)
         call delete(temp_F2_TF)
         call delete(temp_F3_TF)
         call delete(temp_U)
         call delete(sigInv_CC_ideal)
         call delete(sigInv_CC_conduct)
         call delete(sigInv_F)
         call delete(sigInv_CC)
         call delete(sigInv_F_conduct)
         call delete(sigInv_F_ideal)
       end subroutine

       subroutine compute_E_M_Budget_fields(DT,e_int,B,Bnm1,J,sigInv_F,&
         sigInv_CC,U,m,dTime,DP,TF_CC,VF_CC,VF_F1,TF_F1,TF_F2,TF_F3)
         implicit none
         type(dir_tree),intent(in) :: DT
         type(VF),intent(in) :: B,Bnm1,J,sigInv_F,U
         type(SF),intent(in) :: sigInv_CC
         type(VF),intent(inout) :: VF_F1,VF_CC
         type(TF),intent(inout) :: TF_CC,TF_F1,TF_F2,TF_F3
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: dTime
         type(dimensionless_params),intent(in) :: DP
         real(cp),dimension(3),intent(inout) :: e_int
         integer :: i
         real(cp) :: scale,Al,N
         type(SF) :: e
         call init(e,sigInv_CC)
         i = 1
         Al = DP%Al
         N = DP%N
         scale=1.0_cp;call export_Unsteady(e_int(i),e,B,Bnm1,dTime,m,scale,TF_CC%x,TF_CC%y,DT); i=i+1
         scale=N; call export_Joule_Heat(e_int(i),e,J,sigInv_CC,m,scale,TF_CC%x,VF_F1,DT); i=i+1
         scale=Al;call export_Poynting(e_int(i),e,B,J,U,sigInv_F,m,scale,VF_CC%x,VF_F1,TF_F1,TF_F2,TF_F3,DT); i=i+1
         call delete(e)
       end subroutine

       subroutine export_integral_E_M_budget(DT,TMP,e_budget)
         implicit none
         type(time_marching_params),intent(in) :: TMP
         real(cp),dimension(3),intent(in) :: e_budget
         type(dir_tree),intent(in) :: DT
         type(string),dimension(3) :: vars
         integer :: un,i
         un = new_and_open(str(DT%e_budget),'E_M_budget_terms')
         call init(vars(1),'Unsteady = ')
         call init(vars(2),'Joule_Heat = ')
         call init(vars(3),'Poynting = ')

         write(un,*) 'magnetic energy budget at t=',TMP%t
         do i=1,3
         write(un,*) str(vars(i)),e_budget(i)
         call delete(vars(i))
         enddo
         call close_and_message(un,str(DT%e_budget),'E_M_budget_terms')
       end subroutine

       end module
      module FFT_solver_extend_mod
      ! call FFT_poisson(u,f,u_bcs,g,gridType,displayTF)
      ! solves the poisson equation:
      !     u_xx + u_yy + u_zz = f
      ! for a given f, boundary conditions for u (u_bcs), grid (g)
      ! and using a Fast Fourier Transform (FFT) method.
      !
      ! Although grids may have different spacing in each direction,
      ! grid sizes along each direction are assumed uniform.
      !
      ! Input:
      !     u            = initial guess for u
      !     f            = RHS of above equation
      !     u_bcs        = boundary conditions for u. Refer to boundary_conditions_mod for more info.
      !     g            = contains grid information (dhc,dhn)
      !
      ! Flags: (_PARALLELIZE_FFT_)
      use current_precision_mod
      use mesh_extend_mod
      use FFT_Solver_SF_mod
      use FFT_algorithm_mod
      use apply_BCs_mod
      use norms_extend_mod
      use string_mod
      use SF_extend_mod
      use ops_discrete_mod
      use ops_aux_mod
      use ops_dct_mod
      use ops_idct_mod
      use constants_mod
      implicit none

      private
      public :: FFT_Solver_SF
      public :: init
      public :: solve

      interface init;  module procedure init_FFT;             end interface
      interface solve; module procedure solve_FFT_SF_wrapper; end interface

      contains

      subroutine init_FFT(FFT,u,m,direction,var_name)
        implicit none
        type(FFT_Solver_SF),intent(inout) :: FFT
        type(SF),intent(in) :: u
        type(mesh),intent(in) :: m
        integer,intent(in) :: direction
        character(len=*),intent(in) :: var_name
        integer :: i,j,k,t
        real(cp) :: cosi,cosj,cosk
        real(cp) :: dx,dy,dz
        real(cp) :: Nx,Ny,Nz

        call init(FFT%f,u)
        call init(FFT%var_name,var_name)
        call init(FFT%coeff,u)
        call init(FFT%res,u)
        call init(FFT%vol,u)
        call volume(FFT%vol,m)
        FFT%direction = direction

        ! THESE FORMULAS ARE ONLY VALID WHEN DX1 = DX2 WHERE DIR = 3
        select case(direction)
        case (1)
          do t=1,m%s;
          dy = m%B(t)%g%c(2)%dhn%f(1)
          dz = m%B(t)%g%c(3)%dhn%f(1)
          Ny = real(m%B(t)%g%c(2)%sc-2,cp)
          Nz = real(m%B(t)%g%c(3)%sc-2,cp)
          do k=1,u%BF(t)%GF%s(3); do j=2,u%BF(t)%GF%s(2)-1; do i=2,u%BF(t)%GF%s(1)-1
          cosj = cos(PI*real(j-2,cp)/Ny)
          cosk = cos(PI*real(k-2,cp)/Nz)
          if (.not.((i.eq.2).and.(j.eq.2))) then
                FFT%coeff%BF(t)%GF%f(i,j,k) = 0.5_cp*dy*dz/(cosj+cosk-2.0_cp)
          else; FFT%coeff%BF(t)%GF%f(i,j,k) = 1.0_cp
          endif
          enddo; enddo; enddo
          enddo
        case (2)
          do t=1,m%s;
          dx = m%B(t)%g%c(1)%dhn%f(1)
          dz = m%B(t)%g%c(3)%dhn%f(1)
          Nx = real(m%B(t)%g%c(1)%sc-2,cp)
          Nz = real(m%B(t)%g%c(3)%sc-2,cp)
          do k=2,u%BF(t)%GF%s(3)-1; do j=1,u%BF(t)%GF%s(2); do i=2,u%BF(t)%GF%s(1)-1
          cosi = cos(PI*real(i-2,cp)/Nx)
          cosk = cos(PI*real(k-2,cp)/Nz)
          if (.not.((i.eq.2).and.(k.eq.2))) then
                FFT%coeff%BF(t)%GF%f(i,j,k) = 0.5_cp*dx*dz/(cosi+cosk-2.0_cp)
          else; FFT%coeff%BF(t)%GF%f(i,j,k) = 1.0_cp
          endif
          enddo; enddo; enddo
          enddo
        case(3)
          do t=1,m%s;
          dx = m%B(t)%g%c(1)%dhn%f(1)
          dy = m%B(t)%g%c(2)%dhn%f(1)
          Nx = real(m%B(t)%g%c(1)%sc-2,cp)
          Ny = real(m%B(t)%g%c(2)%sc-2,cp)
          do k=1,u%BF(t)%GF%s(3); do j=2,u%BF(t)%GF%s(2)-1; do i=2,u%BF(t)%GF%s(1)-1
          cosi = cos(PI*real(i-2,cp)/Nx)
          cosj = cos(PI*real(j-2,cp)/Ny)
          if (.not.((i.eq.2).and.(j.eq.2))) then
                FFT%coeff%BF(t)%GF%f(i,j,k) = 0.5_cp*dx*dy/(cosi+cosj-2.0_cp)
          else; FFT%coeff%BF(t)%GF%f(i,j,k) = 1.0_cp
          endif
          enddo; enddo; enddo
          enddo
        end select
      end subroutine

      subroutine solve_FFT_SF_wrapper(FFT,u,f_in,m,compute_norms)
        implicit none
        type(FFT_Solver_SF),intent(inout) :: FFT
        type(SF),intent(inout) :: u
        type(SF),intent(in) :: f_in
        type(mesh),intent(in) :: m
        logical,intent(in) :: compute_norms
        call solve_FFT_SF(u,f_in,FFT%vol,FFT%coeff,m,FFT%norm,&
        compute_norms,FFT%f,FFT%res,FFT%direction,str(FFT%var_name))
      end subroutine

      end module
      module Jacobi_solver_mod
      use current_precision_mod
      use mesh_extend_mod
      use mesh_domain_extend_mod
      use apply_BCs_mod
      use norms_extend_mod
      use ops_discrete_mod
      use ops_aux_mod
      use SF_extend_mod
      use VF_extend_mod
      use TF_extend_mod
      use IO_export_mod
      use ops_embedExtract_mod
      use matrix_free_params_mod
      use matrix_free_operators_mod

      implicit none

      real(cp) :: tol_abs = 10.0_cp**(-12.0_cp)

      private
      public :: solve_Jacobi
      interface solve_Jacobi;   module procedure solve_Jacobi_SF;         end interface
      interface solve_Jacobi;   module procedure solve_Jacobi_VF;         end interface

      contains

      subroutine solve_Jacobi_SF(operator,x,x_interior,f,vol,k,Dinv,Diag,m,MD_interior,MFP,n,N_iter,&
        norm,compute_norm,un,n_skip_check_res,tol,name,Ax,res,tempk)
        implicit none
        procedure(op_SF_explicit) :: operator
        type(SF),intent(inout) :: x
        type(SF),intent(in) :: f,x_interior,Dinv,Diag,vol
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh_domain),intent(in) :: MD_interior
        type(mesh),intent(in) :: m
        real(cp),intent(in) :: tol
        character(len=*),intent(in) :: name
        type(matrix_free_params),intent(in) :: MFP
        integer,intent(in) :: n,un,n_skip_check_res
        integer,intent(inout) :: N_iter
        type(norms),intent(inout) :: norm
        logical,intent(in) :: compute_norm
        type(SF),intent(inout) :: Ax,res
        type(norms) :: norm0
        integer :: i,i_earlyExit
        logical :: skip_loop,suppress_warning
        suppress_warning = is_Face(x_interior%DL)
        suppress_warning = MD_interior%D%s.eq.0
        call apply_BCs(x) ! Boundaries

        call operator(Ax,x,k,m,MFP,tempk)
        call multiply(res,x,Diag)
        call subtract(Ax,res) ! LU = Ax - Dx
        call subtract(res,f,Ax)
        call compute(norm0,res,vol,m%MP%volume)

        i_earlyExit=0
        if (.not.sqrt(norm0%L2).lt.tol_abs) then ! Only do iterations if necessary!
          skip_loop = .false.
          do i=1,n
            call operator(Ax,x,k,m,MFP,tempk)
            call multiply(res,x,Diag)
            call subtract(Ax,res) ! LU = Ax - Dx
            call subtract(res,f,Ax)
            call multiply(x,Dinv,res)
            call apply_BCs(x)
            N_iter = N_iter + 1
            if (mod(i,n_skip_check_res).eq.0) then
              call compute(norm,res,vol,m%MP%volume)
#ifdef _EXPORT_JAC_SF_CONVERGENCE_
              write(un,*) N_iter,norm%L1,norm%L2,norm%Linf,&
                                 norm0%L1,norm0%L2,norm0%Linf,i-1
              flush(un)
#endif
              if ((norm%L2/norm0%L2.lt.tol).or.(norm%L2.lt.tol_abs)) then; i_earlyExit=1; exit; endif
            endif
          enddo
        else; i=1; skip_loop = .true.
        endif

        if (x%all_neumann) call subtract(x,mean(x))
        if (compute_norm) then
          if (.not.skip_loop) then
            call assign_ghost_XPeriodic(res,0.0_cp)
            call compute(norm,res,vol,m%MP%volume)
            call print(norm,'Jacobi_SF Residuals for '//name)
            write(un,*) N_iter,norm%L1,norm%L2,norm%Linf,&
                               norm0%L1,norm0%L2,norm0%Linf,i-1
            write(*,*) 'Jacobi_SF iterations (executed/max) = ',i-1+i_earlyExit,n
            write(*,*) 'Jacobi_SF exit condition = ',norm%L2/norm0%L2
          else
            write(*,*) 'Jacobi_SF skip_loop = ',skip_loop
          endif
          write(*,*) ''
        endif
      end subroutine

      subroutine solve_Jacobi_VF(operator,x,x_interior,f,vol,k,Dinv,Diag,m,MD_interior,MFP,n,N_iter,&
        norm,compute_norm,un,n_skip_check_res,tol,name,Ax,res,tempk)
        implicit none
        procedure(op_VF_explicit) :: operator
        type(VF),intent(inout) :: x
        type(VF),intent(in) :: f,x_interior,Dinv,Diag,vol
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(mesh_domain),intent(in) :: MD_interior
        real(cp),intent(in) :: tol
        character(len=*),intent(in) :: name
        type(matrix_free_params),intent(in) :: MFP
        integer,intent(in) :: n,un,n_skip_check_res
        integer,intent(inout) :: N_iter
        type(norms),intent(inout) :: norm
        logical,intent(in) :: compute_norm
        type(VF),intent(inout) :: Ax,res
        type(norms) :: norm0
        integer :: i,i_earlyExit
        logical :: skip_loop
        if (is_Face(x)) call embedFace(x,x_interior,MD_interior)
        call apply_BCs(x) ! Boundaries

        call operator(Ax,x,k,m,MFP,tempk)
        call multiply(res,x,Diag)
        call subtract(Ax,res) ! LU = Ax - Dx
        call subtract(res,f,Ax)
        call compute(norm0,res,vol,m%MP%volume)

        i_earlyExit=0
        if (.not.sqrt(norm0%L2).lt.tol_abs) then ! Only do iterations if necessary!
          skip_loop = .false.
          do i=1,n
            call operator(Ax,x,k,m,MFP,tempk)
            call multiply(res,x,Diag) ! = Dx
            call subtract(Ax,res)     ! = LUx
            call subtract(res,f,Ax)   ! = (b - LUx)
            call multiply(res,Dinv)   ! = Dinv (b - LUx)
            call multiply(x,0.1_cp)
            call multiply(res,(1.0_cp-0.1_cp))
            call add(x,res) ! x^n+1 = x^n w + (1-w) Dinv (b - LUx)
            call apply_BCs(x)
            if (is_Face(x)) call embedFace(x,x_interior,MD_interior)

            N_iter = N_iter + 1
            if (mod(i,n_skip_check_res).eq.0) then
              call compute(norm,res,vol,m%MP%volume)
#ifdef _EXPORT_JAC_VF_CONVERGENCE_
              write(un,*) N_iter,norm%L1,norm%L2,norm%Linf,&
                                 norm0%L1,norm0%L2,norm0%Linf,i-1
              flush(un)
#endif
              if ((norm%L2/norm0%L2.lt.tol).or.(norm%L2.lt.tol_abs)) then; i_earlyExit=1; exit; endif
            endif
          enddo
        else; i=1; skip_loop = .true.
        endif

        ! if (x%all_neumann) call subtract(x,mean(x))
        if (compute_norm) then
          if (.not.skip_loop) then
            call assign_ghost_XPeriodic(res,0.0_cp)
            call compute(norm,res,vol,m%MP%volume)
            call print(norm,'Jacobi_VF Residuals for '//name)
            write(un,*) N_iter,norm%L1,norm%L2,norm%Linf,&
                               norm0%L1,norm0%L2,norm0%Linf,i-1
            write(*,*) 'Jacobi_VF iterations (executed/max) = ',i-1+i_earlyExit,n
            write(*,*) 'Jacobi_VF exit condition = ',norm%L2/norm0%L2
          else
            write(*,*) 'Jacobi_VF skip_loop = ',skip_loop
          endif
          write(*,*) ''
        endif
      end subroutine

      end module
      module PCG_aux_mod
      use current_precision_mod
      use mesh_extend_mod
      use apply_BCs_mod
      use ops_discrete_mod
      use ops_aux_mod
      use bctype_extend_mod
      use export_raw_processed_mod
      use SF_extend_mod
      use VF_extend_mod
      use TF_extend_mod
      use matrix_free_params_mod
      use matrix_free_operators_mod
      implicit none

      private
      public :: modify_RHS
      interface modify_RHS; module procedure modify_RHS_SF; end interface
      interface modify_RHS; module procedure modify_RHS_VF; end interface

      public :: compute_Ax_BC
      interface compute_Ax_BC; module procedure compute_Ax_BC_MF_SF; end interface
      interface compute_Ax_BC; module procedure compute_Ax_BC_MF_VF; end interface

      interface compute_x_BC; module procedure compute_x_BC_SF; end interface
      interface compute_x_BC; module procedure compute_x_BC_VF; end interface

      contains

      subroutine modify_RHS_SF(operator,operator_explicit,x,x_BC,b,vol,k,m,&
        MFP,tempx,tempk,Ax,r)
        implicit none
        procedure(op_SF) :: operator
        procedure(op_SF_explicit) :: operator_explicit
        type(SF),intent(inout) :: x,x_BC
        type(SF),intent(in) :: b,vol
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        type(SF),intent(inout) :: tempx,Ax,r
        call assign(r,b)                              ! r = b
        if (x%all_Neumann) call subtract_physical_mean(r,vol,tempx) ! Not sure correct loc
        call compute_Ax_BC(operator_explicit,tempx,x,x_BC,k,m,MFP,tempk)
        call subtract(r,tempx)                        ! r = (b_mod - Ax_BC - Ax)
        call operator(Ax,x,k,m,MFP,tempk)
        call subtract(r,Ax)                           ! r = (b_mod - Ax_BC - Ax_mod)
        call multiply(r,vol)                          ! r = vol*(b_mod - Ax_BC - Ax_mod)
        if (.not.is_CC(x)) then
          call assign_wall_Periodic_single(r,0.0_cp,x_BC)
          call assign_wall_Dirichlet(r,0.0_cp,x_BC)
          call multiply_wall_Neumann(r,0.5_cp,x_BC)     ! To make A symmetric
        endif
      end subroutine

      subroutine modify_RHS_VF(operator,operator_explicit,x,x_BC,b,vol,k,m,&
        MFP,tempx,tempk,Ax,r)
        implicit none
        procedure(op_VF) :: operator
        procedure(op_VF_explicit) :: operator_explicit
        type(VF),intent(inout) :: x,x_BC
        type(VF),intent(in) :: b,vol
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        type(VF),intent(inout) :: tempx,Ax,r
        call assign(r,b)                              ! r = b
        call compute_Ax_BC(operator_explicit,tempx,x,x_BC,k,m,MFP,tempk)
        call subtract(r,tempx)                        ! r = (b_mod - Ax_BC - Ax)
        call operator(Ax,x,k,m,MFP,tempk)
        call subtract(r,Ax)                           ! r = (b_mod - Ax_BC - Ax_mod)
        call multiply(r,vol)                          ! r = vol*(b_mod - Ax_BC - Ax_mod)
        if (.not.is_CC(x)) then
          call assign_wall_Periodic_single(r,0.0_cp,x_BC)
          call assign_wall_Dirichlet(r,0.0_cp,x_BC)
          call multiply_wall_Neumann(r,0.5_cp,x_BC)     ! To make A symmetric
        endif
      end subroutine

      subroutine compute_Ax_BC_MF_SF(operator_explicit,Ax_BC,x,x_BC,k,m,MFP,tempk)
        implicit none
        procedure(op_SF_explicit) :: operator_explicit
        type(SF),intent(inout) :: Ax_BC,x_BC
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(SF),intent(in) :: x
        type(matrix_free_params),intent(in) :: MFP
        type(mesh),intent(in) :: m
        call compute_x_BC(x_BC)
        call operator_explicit(Ax_BC,x_BC,k,m,MFP,tempk)
        call assign_ghost_XPeriodic(Ax_BC,0.0_cp,x)
      end subroutine

      subroutine compute_Ax_BC_MF_VF(operator_explicit,Ax_BC,x,x_BC,k,m,MFP,tempk)
        implicit none
        procedure(op_VF_explicit) :: operator_explicit
        type(VF),intent(inout) :: Ax_BC,x_BC
        type(VF),intent(in) :: x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(matrix_free_params),intent(in) :: MFP
        type(mesh),intent(in) :: m
        call compute_x_BC(x_BC)
        call operator_explicit(Ax_BC,x_BC,k,m,MFP,tempk)
        call assign_ghost_XPeriodic(Ax_BC,0.0_cp,x)
      end subroutine

      subroutine compute_x_BC_SF(x_BC)
        implicit none
        type(SF),intent(inout) :: x_BC
        call assign(x_BC,0.0_cp)
        call apply_BCs(x_BC)
        call assign_ghost_N_XPeriodic(x_BC,0.0_cp)
      end subroutine

      subroutine compute_x_BC_VF(x_BC)
        implicit none
        type(VF),intent(inout) :: x_BC
        call assign(x_BC,0.0_cp)
        call apply_BCs(x_BC)
        call assign_ghost_N_XPeriodic(x_BC,0.0_cp)
      end subroutine

      end module
       module induction_sources_mod
       use current_precision_mod
       use sim_params_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use mesh_domain_extend_mod
       use ops_interp_mod
       use IO_tools_mod
       use induction_aux_mod
       use ops_advect_mod
       use ops_discrete_mod
       use assign_B0_vs_t_mod
       use time_marching_params_mod
       implicit none

       private
       public :: add_curl_U_cross_B
       public :: add_curl_J
       public :: add_unsteady_B0
       public :: add_constant_dB0dt
       public :: compute_JCrossB
       public :: compute_B_dot_gradB

       contains

       subroutine add_curl_U_cross_B(F,m,U_E,B,curlUCrossB,scale,temp_E_TF,temp_E)
         implicit none
         type(VF),intent(inout) :: F,curlUCrossB,temp_E
         type(VF),intent(in) :: B
         type(TF),intent(in) :: U_E
         type(TF),intent(inout) :: temp_E_TF
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         call advect_B(curlUCrossB,U_E,B,m,temp_E_TF,temp_E)
         call add_product(F,curlUCrossB,scale)
       end subroutine

       subroutine add_curl_J(F,m,J,sigmaInv_edge,scale,temp_F2,temp_E)
         implicit none
         type(VF),intent(inout) :: F,temp_F2,temp_E
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: J,sigmaInv_edge
         real(cp),intent(in) :: scale
         call multiply(temp_E,J,sigmaInv_edge)
         call curl(temp_F2,temp_E,m)
         call add_product(F,temp_F2,scale)
       end subroutine

       subroutine add_unsteady_B0(F,B0,dB0dt,scale_B0,scale_dB0_dt,TMP)
         implicit none
         type(VF),intent(inout) :: F,B0,dB0dt
         type(time_marching_params),intent(in) :: TMP
         real(cp),intent(in) :: scale_B0,scale_dB0_dt
         call assign_B0_vs_t(B0,TMP)
         call multiply(B0,scale_B0)
         call assign_dB0_dt_vs_t(dB0dt,TMP)
         call add_product(F,dB0dt,scale_dB0_dt) ! (-) since added to RHS
       end subroutine

       subroutine add_constant_dB0dt(F,dB0dt,scale_dB0_dt)
         implicit none
         type(SF),intent(inout) :: F,dB0dt
         real(cp),intent(in) :: scale_dB0_dt
         call assign(dB0dt,scale_dB0_dt)
         call add(F,dB0dt)
       end subroutine

       subroutine compute_JCrossB(jCrossB,B,J,m,scale,&
         temp_CC,temp_F1_TF,temp_F2_TF)
         ! computes:  scale J x B
         implicit none
         type(VF),intent(inout) :: jCrossB
         type(VF),intent(in) :: B,J
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(SF),intent(inout) :: temp_CC
         type(TF),intent(inout) :: temp_F1_TF,temp_F2_TF
         call edge2Face_no_diag(temp_F1_TF,J,m)
         call face2Face_no_diag(temp_F2_TF,B,m,temp_CC)
         call cross_product(jCrossB,temp_F1_TF,temp_F2_TF)
         call multiply(jCrossB,scale) ! Since J includes Rem
       end subroutine

       subroutine compute_B_dot_gradB(B_dot_gradB,B,m,scale,&
         temp_CC,temp_F1,temp_F2,temp_E_TF)
         ! computes:  scale J x B
         implicit none
         type(VF),intent(inout) :: B_dot_gradB
         type(VF),intent(in) :: B
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(SF),intent(inout) :: temp_CC
         type(VF),intent(inout) :: temp_F1,temp_F2
         type(TF),intent(inout) :: temp_E_TF
         call advect_U_convection(B_dot_gradB,B,temp_E_TF,m,.true.,temp_F1,temp_F2,temp_CC)
         call multiply(B_dot_gradB,scale)
       end subroutine

       end module
      module matrix_mod
      use current_precision_mod
      use IO_tools_mod
      use IO_export_mod
      use mesh_extend_mod
      use ops_discrete_mod
      use ops_aux_mod
      use apply_BCs_mod
      use SF_extend_mod
      use VF_extend_mod
      use TF_extend_mod
      use index_mapping_mod
      use ops_interp_mod
      use matrix_free_params_mod
      use matrix_free_operators_mod
      implicit none

      private

      integer,parameter :: un_max = 10**5 ! Largest allowable matrix to EXPORT
      integer :: px = 1  ! Include/Exclude ghost points along x = (0,1)
      integer :: py = 1  ! Include/Exclude ghost points along y = (0,1)
      integer :: pz = 1  ! Include/Exclude ghost points along z = (0,1)

      public :: test_symmetry
      interface test_symmetry;    module procedure test_symmetry_SF;    end interface
      interface test_symmetry;    module procedure test_symmetry_VF;    end interface

      public :: export_operator
      interface export_operator;  module procedure export_operator_SF;  end interface
      interface export_operator;  module procedure export_operator_VF;  end interface

      public :: export_matrix
      interface export_matrix;    module procedure export_matrix_SF;    end interface
      interface export_matrix;    module procedure export_matrix_VF;    end interface

      public :: get_diagonal
      interface get_diagonal;     module procedure get_diagonal_SF;     end interface
      interface get_diagonal;     module procedure get_diagonal_VF;     end interface

      interface define_ith_diag;  module procedure define_ith_diag_SF;  end interface
      interface define_ith_diag;  module procedure define_ith_diag_VF;  end interface

      interface export_transpose; module procedure export_transpose_SF; end interface
      interface export_transpose; module procedure export_transpose_VF; end interface

      contains

      ! *********************************************************************
      ! ******************* TEST MATRIX OPERATOR SYMMETRY *******************
      ! *********************************************************************

      subroutine test_symmetry_SF(operator,name,x,k,vol,m,MFP,tempk)
        implicit none
        procedure(op_SF) :: operator
        type(SF),intent(in) :: x,vol
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        character(len=*),intent(in) :: name
        type(SF) :: u,v,Au,Av,temp
        real(cp) :: dot_vAu,dot_uAv
        call init(u,x); call init(Au,x)
        call init(v,x); call init(Av,x)
        call init(temp,x)
        write(*,*) ' ---------------- SYMMETRY TEST --------------- '//name
        write(*,*) 'System size = ',x%numEl
        call random_noise(u); call assign_ghost_XPeriodic(u,0.0_cp)
        call random_noise(v); call assign_ghost_XPeriodic(v,0.0_cp)
        call init_BCs(u,x)
        call init_BCs(v,x)
        call operator(Au,u,k,m,MFP,tempk)
        call multiply(Au,vol)
        call operator(Av,v,k,m,MFP,tempk)
        call multiply(Av,vol)
        dot_vAu = dot_product(v,Au,x,temp)
        dot_uAv = dot_product(u,Av,x,temp)
        write(*,*) 'amax(v),amax(Au) = ',amax(v),amax(Au)
        write(*,*) 'amax(u),amax(Av) = ',amax(u),amax(Av)
        write(*,*) '(v,Au) = ',dot_vAu
        write(*,*) '(u,Av) = ',dot_uAv
        write(*,*) 'Symmetry error = ',abs(dot_vAu-dot_uAv)
        write(*,*) 'Symmetry error/size = ',abs(dot_vAu-dot_uAv)/real(x%numEl,cp)
        write(*,*) ' ---------------------------------------------- '
        call delete(u); call delete(Au)
        call delete(v); call delete(Av)
        call delete(temp)
      end subroutine

      subroutine test_symmetry_VF(operator,name,x,k,vol,m,MFP,tempk)
        implicit none
        procedure(op_VF) :: operator
        type(VF),intent(in) :: x,vol
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        character(len=*),intent(in) :: name
        type(VF) :: u,v,Au,Av,temp
        real(cp) :: dot_vAu,dot_uAv
        call init(u,x); call init(Au,x)
        call init(v,x); call init(Av,x)
        call init(temp,x)
        write(*,*) ' ---------------- SYMMETRY TEST --------------- '//name
        write(*,*) 'System size = ',x%x%numEl+x%y%numEl+x%z%numEl
        call random_noise(u); call assign_ghost_XPeriodic(u,0.0_cp)
        call random_noise(v); call assign_ghost_XPeriodic(v,0.0_cp)
        call init_BCs(u,x)
        call init_BCs(v,x)
        call operator(Au,u,k,m,MFP,tempk)
        call multiply(Au,vol)
        call operator(Av,v,k,m,MFP,tempk)
        call multiply(Av,vol)
        dot_vAu = dot_product(v,Au,x,temp)
        dot_uAv = dot_product(u,Av,x,temp)
        write(*,*) 'amax(v),amax(Au) = ',amax(v),amax(Au)
        write(*,*) 'amax(u),amax(Av) = ',amax(u),amax(Av)
        write(*,*) '(v,Au) = ',dot_vAu
        write(*,*) '(u,Av) = ',dot_uAv
        write(*,*) 'Symmetry error = ',abs(dot_vAu-dot_uAv)
        write(*,*) 'Symmetry error/size = ',abs(dot_vAu-dot_uAv)/real(x%x%numEl,cp)
        write(*,*) ' ---------------------------------------------- '
        call delete(u); call delete(Au)
        call delete(v); call delete(Av)
        call delete(temp)
      end subroutine

      ! *********************************************************************
      ! ********************** EXPORTING GIVEN MATRIX ***********************
      ! *********************************************************************

      subroutine export_matrix_SF(D,dir,name)
        implicit none
        type(SF),intent(in) :: D
        character(len=*),intent(in) :: dir,name
        type(SF) :: un
        integer :: i,newU,i_3D,j_3D,k_3D,t_3D
        call init(un,D)
        newU = new_and_open(dir,name)
        write(*,*) ' ------------- EXPORTING SF MATRIX ------------ '//name
        call assign(un,0.0_cp)
        do i=1,un%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un,i)
          if (cycle_TF_SF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/))) cycle
          call unitVector(un,i)
          call multiply(un,D)
          call export_transpose_SF(un,newU,px,py,pz) ! Export rows of A
          call deleteUnitVector(un,i)
        enddo
        close(newU); call delete(un)
        write(*,*) ' ---------------------------------------------- '
      end subroutine

      subroutine export_matrix_VF(D,dir,name)
        implicit none
        type(VF),intent(in) :: D
        character(len=*),intent(in) :: dir,name
        type(VF) :: un
        integer :: i,newU,i_3D,j_3D,k_3D,t_3D
        call init(un,D)
        newU = new_and_open(dir,name)
        write(*,*) ' ------------- EXPORTING VF MATRIX ------------ '//name
        write(*,*) 'System size = ',un%x%numEl + un%y%numEl + un%z%numEl
        call assign(un,0.0_cp)
        do i=1,un%x%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un%x,i)
          if (cycle_TF_VF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/),1)) cycle
          call unitVector(un%x,i)
          call multiply(un%x,D%x)
          call export_transpose(un,newU,px,py,pz) ! Export rows of A
          call deleteUnitVector(un%x,i)
        enddo
        call assign(un,0.0_cp)
        do i=1,un%y%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un%y,i)
          if (cycle_TF_VF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/),2)) cycle
          call unitVector(un%y,i)
          call multiply(un%y,D%y)
          call export_transpose(un,newU,px,py,pz) ! Export rows of A
          call deleteUnitVector(un%y,i)
        enddo
        call assign(un,0.0_cp)
        do i=1,un%z%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un%z,i)
          if (cycle_TF_VF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/),3)) cycle
          call unitVector(un%z,i)
          call multiply(un%z,D%z)
          call export_transpose(un,newU,px,py,pz) ! Export rows of A
          call deleteUnitVector(un%z,i)
        enddo
        close(newU); call delete(un)
        write(*,*) ' ---------------------------------------------- '
      end subroutine

      function cycle_TF_SF(U,i,t,p) result(L_any)
        implicit none
        type(SF),intent(in) :: U
        integer,intent(in) :: t
        integer,dimension(3),intent(in) :: i,p
        logical,dimension(3) :: L
        logical :: L_any
        integer :: k
        do k=1,3;L(k)=((p(k).eq.1).and.((i(k).eq.1).or.(i(k).eq.u%BF(t)%GF%s(k)))); enddo
        L_any = any(L)
      end function

      function cycle_TF_VF(U,i,t,p,comp) result(L_any)
        implicit none
        type(VF),intent(in) :: U
        integer,intent(in) :: t,comp
        integer,dimension(3),intent(in) :: i,p
        logical,dimension(3) :: L
        logical :: L_any
        integer :: k
        select case(comp)
        case(1); do k=1,3;L(k)=((p(k).eq.1).and.((i(k).eq.1).or.(i(k).eq.u%x%BF(t)%GF%s(k)))); enddo
        case(2); do k=1,3;L(k)=((p(k).eq.1).and.((i(k).eq.1).or.(i(k).eq.u%y%BF(t)%GF%s(k)))); enddo
        case(3); do k=1,3;L(k)=((p(k).eq.1).and.((i(k).eq.1).or.(i(k).eq.u%z%BF(t)%GF%s(k)))); enddo
        case default; stop 'Error: dir must =1,2,3 in cycle_TF_VF in matrix.f90'
        end select
        L_any = any(L)
      end function

      ! *********************************************************************
      ! ******************** EXPORTING MATRIX OPERATOR **********************
      ! *********************************************************************

      subroutine export_operator_SF(operator,dir,name,x,k,vol,m,MFP,tempk)
        implicit none
        procedure(op_SF) :: operator
        type(SF),intent(in) :: x,vol
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        character(len=*),intent(in) :: dir,name
        type(SF) :: un,Aun
        integer :: i,newU,i_3D,j_3D,k_3D,t_3D
        call init(un,x); call init(Aun,x)
        newU = new_and_open(dir,name)
        write(*,*) ' ------------ EXPORTING SF OPERATOR ----------- '//name
        call assign(un,0.0_cp)
        call init_BCs(un,x)
        do i=1,un%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un,i)
          if (cycle_TF_SF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/))) cycle
          call unitVector(un,i)
          call operator(Aun,un,k,m,MFP,tempk)
          call multiply(Aun,vol)
          call export_transpose(Aun,newU,px,py,pz) ! Export rows of A
          call deleteUnitVector(un,i)
        enddo
        call delete(un); call delete(Aun)
        close(newU)
      end subroutine

      subroutine export_operator_VF(operator,dir,name,x,k,vol,m,MFP,tempk)
        implicit none
        procedure(op_VF) :: operator
        type(VF),intent(in) :: x,vol
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        character(len=*),intent(in) :: dir,name
        type(VF) :: un,Aun
        integer :: i,newU,i_3D,j_3D,k_3D,t_3D
        call init(un,x); call init(Aun,x)
        newU = new_and_open(dir,name)
        write(*,*) ' ------------ EXPORTING VF OPERATOR ----------- '//name
        write(*,*) 'System size = ',un%x%numEl + un%y%numEl + un%z%numEl
        call assign(un,0.0_cp)
        call init_BCs(un,x)
        do i=1,un%x%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un%x,i)
          if (cycle_TF_VF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/),1)) cycle
          call unitVector(un%x,i)
          call operator(Aun,un,k,m,MFP,tempk)
          call multiply(Aun,vol)
          call export_transpose(Aun,newU,px,py,pz) ! Export rows of A
          call deleteUnitVector(un%x,i)
        enddo
        call assign(un,0.0_cp)
        do i=1,un%y%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un%y,i)
          if (cycle_TF_VF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/),2)) cycle
          call unitVector(un%y,i)
          call operator(Aun,un,k,m,MFP,tempk)
          call multiply(Aun,vol)
          call export_transpose(Aun,newU,px,py,pz) ! Export rows of A
          call deleteUnitVector(un%y,i)
        enddo
        call assign(un,0.0_cp)
        do i=1,un%z%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un%z,i)
          if (cycle_TF_VF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/),3)) cycle
          call unitVector(un%z,i)
          call operator(Aun,un,k,m,MFP,tempk)
          call multiply(Aun,vol)
          call export_transpose(Aun,newU,px,py,pz) ! Export rows of A
          call deleteUnitVector(un%z,i)
        enddo
        close(newU)
        call delete(un); call delete(Aun)
      end subroutine

      subroutine export_transpose_SF(U,un,px,py,pz)
        implicit none
        type(SF),intent(in) :: U
        integer,intent(in) :: un,px,py,pz
        integer :: i,j,k,t
        if (U%numEl.gt.un_max) stop 'Error: trying to export HUGE matrix in export_transpose_SF in matrix.f90'
        do t=1,U%s; do k=1+pz,u%BF(t)%GF%s(3)-pz; do j=1+py,u%BF(t)%GF%s(2)-py; do i=1+px,u%BF(t)%GF%s(1)-px
        write(un,'(F20.13,T2)',advance='no') u%BF(t)%GF%f(i,j,k)
        enddo; enddo; enddo; enddo
        write(un,*) ''
      end subroutine

      subroutine export_transpose_VF(U,un,px,py,pz)
        implicit none
        type(VF),intent(in) :: U
        integer,intent(in) :: un,px,py,pz
        integer :: i,j,k,t
        if (U%x%numEl.gt.un_max) stop 'Error: trying to export HUGE matrix in export_transpose_VF in matrix.f90'
        if (U%y%numEl.gt.un_max) stop 'Error: trying to export HUGE matrix in export_transpose_VF in matrix.f90'
        if (U%z%numEl.gt.un_max) stop 'Error: trying to export HUGE matrix in export_transpose_VF in matrix.f90'
        do t=1,U%x%s; do k=1+pz,u%x%BF(t)%GF%s(3)-pz; do j=1+py,u%x%BF(t)%GF%s(2)-py; do i=1+px,u%x%BF(t)%GF%s(1)-px
        write(un,'(F15.8,T2)',advance='no') u%x%BF(t)%GF%f(i,j,k)
        enddo; enddo; enddo; enddo
        do t=1,U%y%s; do k=1+pz,u%y%BF(t)%GF%s(3)-pz; do j=1+py,u%y%BF(t)%GF%s(2)-py; do i=1+px,u%y%BF(t)%GF%s(1)-px
        write(un,'(F15.8,T2)',advance='no') u%y%BF(t)%GF%f(i,j,k)
        enddo; enddo; enddo; enddo
        do t=1,U%z%s; do k=1+pz,u%z%BF(t)%GF%s(3)-pz; do j=1+py,u%z%BF(t)%GF%s(2)-py; do i=1+px,u%z%BF(t)%GF%s(1)-px
        write(un,'(F15.8,T2)',advance='no') u%z%BF(t)%GF%f(i,j,k)
        enddo; enddo; enddo; enddo
        write(un,*) ''
      end subroutine

      ! *********************************************************************
      ! ********************* OBTAINING MATRIX DIAGONAL *********************
      ! *********************************************************************

      subroutine get_diagonal_SF(operator,D,x,k,vol,m,MFP,tempk)
        implicit none
        procedure(op_SF_explicit) :: operator
        type(SF),intent(inout) :: D
        type(SF),intent(in) :: vol,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        type(SF) :: un,Aun
        integer :: i,n,nmax,nwrite,i_3D,j_3D,k_3D,t_3D
        call init(un,D); call init(Aun,D)
        call assign(un,0.0_cp); call assign(D,0.0_cp)
        n = 0; nmax = un%numEl
        nwrite = 100
        call init_BCs(un,x)
        do i=1,un%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un,i)
          if (cycle_TF_SF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/))) cycle
          call unitVector(un,i)
          call operator(Aun,un,k,m,MFP,tempk)
          call multiply(Aun,vol)
          call define_ith_diag(D,Aun,i)
          call deleteUnitVector(un,i)
          n = n + 1
          if (mod(n,nwrite).eq.0) then
            write(*,*) 'Percentage complete (computing diagonal) = ',real(n,cp)/real(nmax,cp)*100.0_cp
          endif
        enddo
        call delete(un); call delete(Aun)
      end subroutine

      subroutine define_ith_diag_SF(D,Aun,col)
        implicit none
        type(SF),intent(inout) :: D
        type(SF),intent(in) :: Aun
        integer,intent(in) :: col
        integer :: i,j,k,t
        call get_3D_index(i,j,k,t,D,col)
        D%BF(t)%GF%f(i,j,k) = Aun%BF(t)%GF%f(i,j,k)
      end subroutine

      subroutine get_diagonal_VF(operator,D,x,k,vol,m,MFP,tempk)
        implicit none
        procedure(op_VF_explicit) :: operator
        type(VF),intent(inout) :: D
        type(VF),intent(in) :: vol,x
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(matrix_free_params),intent(in) :: MFP
        type(VF) :: un,Aun
        integer :: i,n,nmax,nwrite,i_3D,j_3D,k_3D,t_3D
        call init(un,D); call init(Aun,D)
        call assign(un,0.0_cp); call assign(D,0.0_cp)
        n = 0; nmax = un%x%numEl + un%y%numEl + un%z%numEl
        nwrite = 500
        write(*,*) 'Computing matrix diagonal...'
        call init_BCs(un,x)
        do i=1,un%x%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un%x,i)
          if (cycle_TF_VF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/),1)) cycle
          call unitVector(un%x,i)
          call operator(Aun,un,k,m,MFP,tempk)
          call multiply(Aun,vol)
          call define_ith_diag(D,Aun,i,1)
          call deleteUnitVector(un%x,i)
          n = n + 1
          if (mod(n,nwrite).eq.0) then
            write(*,*) 'diag(x) %, un = ',real(n,cp)/real(nmax,cp)*100.0_cp,i
          endif
        enddo
        call assign(un,0.0_cp)
        do i=1,un%y%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un%y,i)
          if (cycle_TF_VF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/),2)) cycle
          call unitVector(un%y,i)
          call operator(Aun,un,k,m,MFP,tempk)
          call multiply(Aun,vol)
          call define_ith_diag(D,Aun,i,2)
          call deleteUnitVector(un%y,i)
          n = n + 1
          if (mod(n,nwrite).eq.0) then
            write(*,*) 'diag(y) %, un = ',real(n,cp)/real(nmax,cp)*100.0_cp,i
          endif
        enddo
        call assign(un,0.0_cp)
        do i=1,un%z%numEl
          call get_3D_index(i_3D,j_3D,k_3D,t_3D,un%z,i)
          if (cycle_TF_VF(un,(/i_3D,j_3D,k_3D/),t_3D,(/px,py,pz/),3)) cycle
          call unitVector(un%z,i)
          call operator(Aun,un,k,m,MFP,tempk)
          call multiply(Aun,vol)
          call define_ith_diag(D,Aun,i,3)
          call deleteUnitVector(un%z,i)
          n = n + 1
          if (mod(n,nwrite).eq.0) then
            write(*,*) 'diag(z) %, un = ',real(n,cp)/real(nmax,cp)*100.0_cp,i
          endif
        enddo
        call delete(un); call delete(Aun)
      end subroutine

      subroutine define_ith_diag_VF(D,Aun,col,component)
        implicit none
        type(VF),intent(inout) :: D
        type(VF),intent(in) :: Aun
        integer,intent(in) :: col,component
        integer :: i,j,k,t
        select case (component)
        case (1); call get_3D_index(i,j,k,t,D%x,col); D%x%BF(t)%GF%f(i,j,k) = Aun%x%BF(t)%GF%f(i,j,k)
        case (2); call get_3D_index(i,j,k,t,D%y,col); D%y%BF(t)%GF%f(i,j,k) = Aun%y%BF(t)%GF%f(i,j,k)
        case (3); call get_3D_index(i,j,k,t,D%z,col); D%z%BF(t)%GF%f(i,j,k) = Aun%z%BF(t)%GF%f(i,j,k)
        case default; stop 'Error: dir must = 1,2,3 in define_ith_diag_VF in matrix.f90'
        end select
      end subroutine

      end module
       module momentum_sources_mod
       use current_precision_mod
       use SF_extend_mod
       use VF_extend_mod
       use export_raw_processed_mod
       use TF_extend_mod
       use ops_embedExtract_mod
       use time_marching_params_mod
       use mesh_domain_extend_mod
       use mesh_extend_mod
       use apply_BCs_mod
       use IO_export_mod
       use ops_aux_mod
       use ops_advect_mod
       use ops_interp_mod
       use ops_discrete_mod
       use ops_norms_mod
       use dimensionless_params_mod
       use data_location_extend_mod
       use matrix_free_params_mod

       implicit none

       private
       public :: compute_add_pressure_grad
       public :: compute_add_advection_divergence
       public :: compute_add_advection_convection
       public :: compute_add_advection_base_flow
       public :: compute_add_diffusion
       public :: compute_add_MPG
       public :: extract_add_JCrossB
       public :: compute_add_Q2D_JCrossB
       public :: compute_add_buoyancy
       public :: compute_add_gravity

       contains

       subroutine compute_add_pressure_grad(F,m,p,scale,temp_F)
         implicit none
         type(VF),intent(inout) :: F,temp_F
         type(SF),intent(in) :: p
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         call grad(temp_F,p,m)
         call add_product(F,temp_F,scale)
       end subroutine

       subroutine compute_add_advection_divergence(F,m,U,U_E,scale,temp_F,temp_E,temp_CC)
         implicit none
         type(VF),intent(inout) :: F,temp_F
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         type(SF),intent(inout) :: temp_CC
         type(VF),intent(in) :: U
         type(VF),intent(inout) :: temp_E
         type(TF),intent(inout) :: U_E
         call advect_U_divergence(temp_F,U,U_E,m,.false.,temp_E,temp_CC)
         call add_product(F,temp_F,scale)
       end subroutine

       subroutine compute_add_advection_convection(F,m,U,U_E,scale,temp_F,temp_F1,temp_F2,temp_CC)
         implicit none
         type(VF),intent(inout) :: F,temp_F
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: temp_CC
         real(cp),intent(in) :: scale
         type(VF),intent(in) :: U
         type(VF),intent(inout) :: temp_F1,temp_F2
         type(TF),intent(inout) :: U_E
         call advect_U_convection(temp_F,U,U_E,m,.false.,temp_F1,temp_F2,temp_CC)
         call add_product(F,temp_F,scale)
       end subroutine

       subroutine compute_add_advection_base_flow(F,m,U_base,U,U_E,scale,temp_F,temp_F1,temp_F2,temp_CC)
         implicit none
         type(VF),intent(inout) :: F,temp_F
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: temp_CC
         real(cp),intent(in) :: scale
         type(VF),intent(in) :: U,U_base
         type(VF),intent(inout) :: temp_F1,temp_F2
         type(TF),intent(inout) :: U_E
         call advect_U_convection(temp_F,U_base,U,U_E,m,temp_F1,temp_F2,temp_CC)
         call add_product(F,temp_F,scale)
       end subroutine

       subroutine compute_add_diffusion(F,m,U,scale,temp_F)
         implicit none
         type(VF),intent(inout) :: F,temp_F
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U
         real(cp),intent(in) :: scale
         call lap(temp_F,U,m)
         call add_product(F,temp_F,scale)
       end subroutine

       subroutine compute_add_MPG(U,TMP,scale,dir)
         type(VF),intent(inout) :: U
         type(time_marching_params),intent(in) :: TMP
         real(cp),intent(in) :: scale
         integer,intent(in) :: dir
         select case (dir)
         case (0);
         case (1); call add(U%x,scale*TMP%TS%dt); call apply_BCs(U)
         case (2); call add(U%y,scale*TMP%TS%dt); call apply_BCs(U)
         case (3); call add(U%z,scale*TMP%TS%dt); call apply_BCs(U)
         case default; stop 'Error: dir must = 0:3 in compute_MPG in induction_aux.f90'
         end select
       end subroutine

       subroutine extract_add_JCrossB(F,jCrossB,jCrossB_ind,D_fluid,scale)
         ! computes:  scale J x B
         implicit none
         type(VF),intent(inout) :: F,jCrossB
         type(VF),intent(in) :: jCrossB_ind
         type(mesh_domain),intent(in) :: D_fluid
         real(cp),intent(in) :: scale
         call extractFace(jCrossB,jCrossB_ind,D_fluid)
         call assign_ghost_XPeriodic(jCrossB,0.0_cp)
         call add_product(F,jCrossB,scale) ! Since J includes Rem
       end subroutine

       subroutine compute_add_Q2D_JCrossB(F,Q2D_JCrossB,U,scale)
         ! computes: Q2D_JCrossB = -U/tau, tau = Re/Ha
         implicit none
         type(VF),intent(inout) :: F,Q2D_JCrossB
         type(VF),intent(in) :: U
         real(cp),intent(in) :: scale
         call assign(Q2D_JCrossB,U)
         call add_product(F,Q2D_JCrossB,scale)
       end subroutine

       subroutine compute_add_buoyancy(F,buoyancy,T,gravity,scale,m,MD,temp_F,temp_CC)
         ! Computes
         !            Gr
         !           ---  T g
         !           Re^2
         implicit none
         type(VF),intent(inout) :: F,buoyancy,temp_F,temp_CC
         type(SF),intent(in) :: T
         type(VF),intent(in) :: gravity
         real(cp),intent(in) :: scale
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         call assign(temp_CC,T)
         call multiply(temp_CC,gravity)
         call cellCenter2Face(temp_F,temp_CC,m)
         call extractFace(buoyancy,temp_F,MD)
         call add_product(F,buoyancy,scale)
       end subroutine

       subroutine compute_add_gravity(F,gravity,g,scale,m,MD,temp_F,temp_CC)
         ! Computes
         !            1
         !           --- g
         !           Fr^2
         implicit none
         type(VF),intent(inout) :: F,gravity,temp_F,temp_CC
         type(VF),intent(in) :: g
         real(cp),intent(in) :: scale
         type(mesh),intent(in) :: m
         type(mesh_domain),intent(in) :: MD
         call assign(temp_CC,g)
         call cellCenter2Face(temp_F,temp_CC,m)
         call extractFace(gravity,temp_F,MD)
         call add_product(F,gravity,scale)
       end subroutine

       end module
      module Jacobi_mod
      use current_precision_mod
      use mesh_extend_mod
      use mesh_domain_extend_mod
      use norms_extend_mod
      use ops_discrete_mod
      use ops_aux_mod
      use string_mod
      use SF_extend_mod
      use VF_extend_mod
      use TF_extend_mod
      use IO_export_mod
      use IO_tools_mod
      use matrix_free_params_mod
      use matrix_free_operators_mod
      use Jacobi_solver_mod
      use matrix_mod
      use preconditioners_mod
      use diagonals_mod

      implicit none

      private
      public :: Jacobi
      public :: init,delete
      public :: solve

      type Jacobi
        type(mesh) :: m
        type(VF) :: Ax,res,Dinv,D,vol,x_interior
        type(TF) :: k,tempk
        type(norms) :: norm
        type(mesh_domain) :: D_interior
        type(string) :: name
        type(matrix_free_params) :: MFP
        integer :: un,n_skip_check_res,N_iter ! unit to export norm
        real(cp) :: tol
        procedure(op_VF),pointer,nopass :: operator
      end type

      interface init;        module procedure init_Jacobi;       end interface
      interface solve;       module procedure solve_Jacobi_VF;   end interface
      interface delete;      module procedure delete_Jacobi;     end interface

      contains

      subroutine init_Jacobi(JAC,operator,x,x_interior,k,m,D_interior,&
        MFP,n_skip_check_res,tol,dir,name,vizualizeOperator)
        implicit none
        procedure(op_VF_explicit) :: operator
        type(Jacobi),intent(inout) :: JAC
        type(VF),intent(in) :: x,x_interior
        type(TF),intent(in) :: k
        type(mesh),intent(in) :: m
        type(mesh_domain),intent(in) :: D_interior
        type(matrix_free_params),intent(in) :: MFP
        real(cp),intent(in) :: tol
        integer,intent(in) :: n_skip_check_res
        character(len=*),intent(in) :: dir,name
        logical,intent(in) :: vizualizeOperator
        call init(JAC%m,m)
        call init(JAC%Ax,x)
        call init(JAC%res,x)
        call init(JAC%Dinv,x)
        call init(JAC%D,x)
        call init(JAC%tempk,k)
        call init(JAC%k,k)
        call assign(JAC%k,k)
        call init(JAC%vol,x)
        call init(JAC%x_interior,x_interior)
        call assign(JAC%x_interior,x_interior)
        call volume(JAC%vol,m)
        call init(JAC%name,name)
        call init(JAC%D_interior,D_interior)
        JAC%un = new_and_open(dir,'norm_JAC_VF_'//name)
        call tecHeader(name,JAC%un,.true.)
        JAC%operator => operator
        call init(JAC%norm)
        call init(JAC%MFP,MFP)
        JAC%tol = tol
        JAC%N_iter = 1
        JAC%n_skip_check_res = n_skip_check_res

        ! call get_diagonal(operator,JAC%D,x,JAC%k,JAC%vol,m,MFP,JAC%tempk)

        if (vizualizeOperator) then
          call export_operator(operator,dir,'JAC_VF_'//name,x,JAC%k,JAC%vol,m,MFP,JAC%tempk)
          call export_matrix(JAC%D,dir,'JAC_VF_diag_'//name)
        endif

        call diag_Lap(JAC%D,m)
        call assign(JAC%Dinv,JAC%D)
        call invert(JAC%Dinv)
        call assign_ghost_XPeriodic(JAC%Dinv,0.0_cp)
      end subroutine

      subroutine solve_Jacobi_VF(JAC,x,f,m,n,compute_norm)
        implicit none
        type(Jacobi),intent(inout) :: JAC
        type(VF),intent(inout) :: x
        type(VF),intent(in) :: f
        type(mesh),intent(in) :: m
        integer,intent(in) :: n
        logical,intent(in) :: compute_norm
        call solve_Jacobi(JAC%operator,x,JAC%x_interior,f,JAC%vol,JAC%k,JAC%Dinv,&
        JAC%D,m,JAC%D_interior,JAC%MFP,n,JAC%N_iter,JAC%norm,compute_norm,JAC%un,&
        JAC%n_skip_check_res,JAC%tol,str(JAC%name),JAC%Ax,JAC%res,JAC%tempk)
      end subroutine

      subroutine delete_Jacobi(JAC)
        implicit none
        type(Jacobi),intent(inout) :: JAC
        call delete(JAC%D_interior)
        call delete(JAC%m)
        call delete(JAC%vol)
        call delete(JAC%Ax)
        call delete(JAC%res)
        call delete(JAC%Dinv)
        call delete(JAC%D)
        call delete(JAC%k)
        call delete(JAC%tempk)
        call init(JAC%norm)
        JAC%un = 0
        JAC%N_iter = 1
      end subroutine

      subroutine tecHeader(name,un,VF)
        implicit none
        character(len=*),intent(in) :: name
        integer,intent(in) :: un
        logical,intent(in) :: VF
        if (VF) then; write(un,*) 'TITLE = "Jacobi_VF residuals for '//name//'"'
        else;         write(un,*) 'TITLE = "Jacobi_SF residuals for '//name//'"'
        endif
        write(un,*) 'VARIABLES = N_iter,L1,L2,Linf,L1_0,L2_0,Linf_0,i-1+i_earlyExit'
        write(un,*) 'ZONE DATAPACKING = POINT'
        flush(un)
      end subroutine


      end module
      module PCG_solver_algorithm_mod
      use current_precision_mod
      use mesh_extend_mod
      use apply_BCs_mod
      use norms_extend_mod
      use ops_discrete_mod
      use ops_aux_mod
      use boundary_conditions_mod
      use export_raw_processed_mod
      use iter_solver_params_mod
      use is_nan_mod
      use SF_extend_mod
      use VF_extend_mod
      use TF_extend_mod
      use PCG_aux_mod
      use ops_norms_mod
      use IO_tools_mod
      use IO_export_mod

      use iter_solver_params_mod
      use iter_solver_params_extend_mod
      use matrix_free_params_mod
      use matrix_free_operators_mod
      implicit none

      private
      public :: solve_PCG
      interface solve_PCG;            module procedure solve_PCG_SF;            end interface
      interface solve_PCG;            module procedure solve_PCG_VF;            end interface

      interface print_info;           module procedure print_info_PCG;          end interface
      interface compute_export_norms; module procedure compute_export_norms_SF; end interface
      interface compute_export_norms; module procedure compute_export_norms_VF; end interface

      contains

      subroutine solve_PCG_SF(operator,operator_explicit,name,x,x_BC,b,vol,k,m,&
        MFP,ISP,res_norm,compute_norms,un,un_convergence,tempx,tempk,Ax,r,p,z,Minv)
        implicit none
        procedure(op_SF) :: operator
        procedure(op_SF_explicit) :: operator_explicit
        character(len=*),intent(in) :: name
        type(SF),intent(inout) :: x,x_BC
        type(SF),intent(in) :: b,vol,Minv
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(norms),intent(inout) :: res_norm
        integer,intent(in) :: un,un_convergence
        type(iter_solver_params),intent(inout) :: ISP
        logical,intent(in) :: compute_norms
        type(matrix_free_params),intent(in) :: MFP
        type(SF),intent(inout) :: tempx,Ax,r,p,z
        type(norms) :: res_norm0
        real(cp) :: alpha,rhok,rhokp1 ! betak = rhokp1/rhok
        integer :: i
        call modify_RHS(operator,operator_explicit,x,x_BC,b,vol,k,m,MFP,tempx,tempk,Ax,r)

        ! ********************* START PCG ALGORITHM *********************
        call compute(res_norm0,r)
        call init_iter_per_call(ISP)
        call check_nans(res_norm0,res_norm,ISP,'check_nans before loop for '//name)
        if (ISP%export_convergence) call compute_export_norms(un_convergence,res_norm0,res_norm,ISP,r)
        call multiply(z,Minv,r)
        call assign(p,z)
        rhok = dot_product(r,z,x,tempx); res_norm%L2 = sqrt(abs(rhok))
        call update_exit_loop(ISP,res_norm%L2,res_norm0%L2)
        if (.not.ISP%exit_loop(2)) then ! Only do PCG if necessary!
          do i=1,ISP%EC%iter_max
            call operator(Ax,p,k,m,MFP,tempk)
            call multiply_wall_Neumann(Ax,0.5_cp,x_BC)
            call assign_wall_Dirichlet(Ax,0.0_cp,x_BC)
            call assign_wall_Periodic_single(Ax,0.0_cp,x_BC)
            call multiply(Ax,vol)
            alpha = rhok/dot_product(p,Ax,x,tempx)
            call add_product(x,p,alpha) ! x = x + alpha p
            call apply_BCs(x) ! Needed for PPE
            call update_iter(ISP)
            call add_product(r,Ax,-alpha) ! r = r - alpha Ap

            if (check_res(ISP)) then
              res_norm%L2 = sqrt(abs(dot_product(r,r,x,tempx)))
              call update_exit_loop(ISP,res_norm%L2,res_norm0%L2)
              if (any(ISP%exit_loop)) exit
            endif
            if (ISP%export_convergence) then
              call check_nans(res_norm0,res_norm,ISP,'check_nans before export for '//name)
              call compute_export_norms(un_convergence,res_norm0,res_norm,ISP,r)
            endif

            call multiply(z,Minv,r)
            rhokp1 = dot_product(z,r,x,tempx)
            call product_add(p,rhokp1/rhok,z) ! p = p beta + z
            rhok = rhokp1
            call update_exit_loop(ISP)
          enddo
        else
          call apply_BCs(x); call update_iter(ISP)
        endif

        call check_nans(res_norm0,res_norm,ISP,'check_nans after loop for '//name)

        if (compute_norms) then
          call compute_export_norms(un,res_norm0,res_norm,ISP,r)
          call print_info(name,ISP,res_norm,res_norm0)
        endif
      end subroutine

      subroutine solve_PCG_VF(operator,operator_explicit,name,x,x_BC,b,vol,k,m,&
        MFP,ISP,res_norm,compute_norms,un,un_convergence,tempx,tempk,Ax,r,p,z,Minv)
        implicit none
        procedure(op_VF) :: operator
        procedure(op_VF_explicit) :: operator_explicit
        character(len=*),intent(in) :: name
        type(VF),intent(inout) :: x,x_BC
        type(VF),intent(in) :: b,vol,Minv
        type(TF),intent(in) :: k
        type(TF),intent(inout) :: tempk
        type(mesh),intent(in) :: m
        type(norms),intent(inout) :: res_norm
        type(iter_solver_params),intent(inout) :: ISP
        integer,intent(in) :: un,un_convergence
        logical,intent(in) :: compute_norms
        type(matrix_free_params),intent(in) :: MFP
        type(VF),intent(inout) :: tempx,Ax,r,p,z
        integer :: i
        type(norms) :: res_norm0
        real(cp) :: alpha,rhok,rhokp1 ! betak = rhokp1/rhok
        call modify_RHS(operator,operator_explicit,x,x_BC,b,vol,k,m,MFP,tempx,tempk,Ax,r)

        ! ********************* START PCG ALGORITHM *********************
        call compute(res_norm0,r)
        call init_iter_per_call(ISP)
        call check_nans(res_norm0,res_norm,ISP,'check_nans before loop for '//name)
        if (ISP%export_convergence) call compute_export_norms(un_convergence,res_norm0,res_norm,ISP,r)
        call multiply(z,Minv,r)
        call assign(p,z)
        rhok = dot_product(r,z,x,tempx); res_norm%L2 = sqrt(abs(rhok))
        call update_exit_loop(ISP,res_norm%L2,res_norm0%L2)
        if (.not.ISP%exit_loop(2)) then ! Only do PCG if necessary!
          do i=1,ISP%EC%iter_max
            call operator(Ax,p,k,m,MFP,tempk)
            call multiply_wall_Neumann(Ax,0.5_cp,x_BC)
            call assign_wall_Dirichlet(Ax,0.0_cp,x_BC)
            call assign_wall_Periodic_single(Ax,0.0_cp,x_BC)
            call multiply(Ax,vol)
            alpha = rhok/dot_product(p,Ax,x,tempx)
            call add_product(x,p,alpha) ! x = x + alpha p
            call apply_BCs(x) ! Needed for PPE
            call update_iter(ISP)
            call add_product(r,Ax,-alpha) ! r = r - alpha Ap

            if (check_res(ISP)) then
              res_norm%L2 = sqrt(abs(dot_product(r,r,x,tempx)))
              call update_exit_loop(ISP,res_norm%L2,res_norm0%L2)
              if (any(ISP%exit_loop)) exit
            endif
            if (ISP%export_convergence) then
              call check_nans(res_norm0,res_norm,ISP,'check_nans before export for '//name)
              call compute_export_norms(un_convergence,res_norm0,res_norm,ISP,r)
            endif

            call multiply(z,Minv,r)
            rhokp1 = dot_product(z,r,x,tempx)
            call product_add(p,rhokp1/rhok,z) ! p = p beta + z
            rhok = rhokp1
            call update_exit_loop(ISP)
          enddo
        else
          call apply_BCs(x); call update_iter(ISP)
        endif

        call check_nans(res_norm0,res_norm,ISP,'check_nans after loop for '//name)

        if (compute_norms) then
          call compute_export_norms(un,res_norm0,res_norm,ISP,r)
          call print_info(name,ISP,res_norm,res_norm0)
        endif
      end subroutine

      subroutine compute_export_norms_SF(un,res_norm0,res_norm,ISP,r)
        implicit none
        integer,intent(in) :: un
        type(norms),intent(in) :: res_norm0
        type(norms),intent(inout) :: res_norm
        type(iter_solver_params),intent(in) :: ISP
        type(SF),intent(in) :: r
        call compute(res_norm,r)
        call export_norms(un,res_norm0,res_norm,ISP)
      end subroutine

      subroutine compute_export_norms_VF(un,res_norm0,res_norm,ISP,r)
        implicit none
        integer,intent(in) :: un
        type(norms),intent(in) :: res_norm0
        type(norms),intent(inout) :: res_norm
        type(iter_solver_params),intent(in) :: ISP
        type(VF),intent(in) :: r
        call compute(res_norm,r)
        call export_norms(un,res_norm0,res_norm,ISP)
      end subroutine

      subroutine export_norms(un,res_norm0,res_norm,ISP)
        implicit none
        integer,intent(in) :: un
        type(norms),intent(in) :: res_norm0,res_norm
        type(iter_solver_params),intent(in) :: ISP
        real(cp) :: rel
        call check_nans(res_norm0,res_norm,ISP,'export_norms')
        rel = compute_relative_norm(res_norm,res_norm0)
        write(un,*) ISP%iter_total,&
                    rel,&
                    res_norm%L1,&
                    res_norm%L2,&
                    res_norm%Linf,&
                    res_norm0%L1,&
                    res_norm0%L2,&
                    res_norm0%Linf,&
                    ISP%iter_per_call
        flush(un)
      end subroutine

      subroutine check_nans(res_norm0,res_norm,ISP,location)
        implicit none
        type(norms),intent(in) :: res_norm0,res_norm
        type(iter_solver_params),intent(in) :: ISP
        character(len=*),intent(in) :: location
        logical,dimension(7) :: L
        real(cp) :: rel
        rel = compute_relative_norm(res_norm,res_norm0)
        L(1) = is_nan(res_norm%L1)
        L(2) = is_nan(res_norm%L2)
        L(3) = is_nan(res_norm%Linf)
        L(4) = is_nan(res_norm0%L1)
        L(5) = is_nan(res_norm0%L2)
        L(6) = is_nan(res_norm0%Linf)
        L(7) = is_nan(rel)
        if (any(L)) then
          write(*,*) 'Error: NaN in ',location
          write(*,*) 'iterations_used = ',ISP%iter_per_call
          write(*,*) 'res_norm%L2 = ',res_norm%L2
          call print(res_norm,'res_norm in '//location)
          call print(res_norm0,'res_norm0 in '//location)
          call print(ISP)
          write(*,*) 'L=',L
          stop 'Done'
        endif
      end subroutine

      subroutine print_info_PCG(name,ISP,res_norm,res_norm0)
        implicit none
        type(iter_solver_params),intent(in) :: ISP
        type(norms),intent(in) :: res_norm,res_norm0
        character(len=*),intent(in) :: name
        real(cp) :: rel
        rel = compute_relative_norm(res_norm,res_norm0)
        if (ISP%export_heavy) then
          call print(res_norm0,res_norm,name//' res_norm0,res_norm')
          call print_exit_loop(ISP)
          write(*,*) 'iter_executed,rel error = ',ISP%iter_per_call,rel
          write(*,*) '----------------------------------------'
          write(*,*) ''
        else
          write(*,*) 'L2(res_norm,rel) '//name//' = ',res_norm%L2,rel
        endif
      end subroutine

      function compute_relative_norm(res_norm,res_norm0) result(rel)
        implicit none
        type(norms),intent(in) :: res_norm,res_norm0
        real(cp) :: rel
        if (equal(res_norm0%L2,0.0_cp)) then; rel = res_norm%L2
        else;                                 rel = res_norm%L2/res_norm0%L2
        endif
      end function

      end module
       module add_all_induction_sources_mod
       use current_precision_mod
       use sim_params_mod
       use VF_extend_mod
       use mesh_extend_mod
       use mesh_domain_extend_mod
       use TF_extend_mod
       use IO_tools_mod
       use time_marching_params_mod

       use energy_mod
       use momentum_mod
       use induction_mod
       use induction_terms_mod
       use induction_aux_mod
       use induction_sources_mod
       implicit none

       private
       public :: add_all_induction_sources

       contains

       subroutine add_all_induction_sources(F,Fnm1,L,ind,TMP,SP,mom)
         implicit none
         type(VF),intent(inout) :: F,Fnm1,L
         type(momentum),intent(in) :: mom
         type(induction),intent(inout) :: ind
         type(time_marching_params),intent(in) :: TMP
         type(sim_params),intent(in) :: SP

         call assign(Fnm1,F)
         call assign(L,0.0_cp)
         call assign(F,0.0_cp) ! DO NOT REMOVE THIS, FOLLOW THE COMPUTE_ADD PROCEDURE BELOW

         if (SP%IT%advection%add) then
           call embedVelocity_E(ind%U_E,mom%U_E,ind%MD_fluid)
           call add_curl_U_cross_B(F,ind%m,ind%U_E,ind%Btot,ind%curlUCrossB,&
            SP%IT%advection%scale,ind%temp_E_TF,ind%temp_E)
         endif
         if (SP%IT%diffusion_linear%add) then
           call add_curl_J(L,ind%m,ind%J,ind%sigmaInv_edge,SP%IT%diffusion%scale,ind%temp_F2,ind%temp_E)
         endif
         if (SP%IT%diffusion%add) then
           call add_curl_J(F,ind%m,ind%J,ind%sigmaInv_edge,SP%IT%diffusion%scale,ind%temp_F2,ind%temp_E)
         endif
         if (SP%IT%unsteady_B0%add) then
           call add_unsteady_B0(F,ind%B0,ind%dB0dt,SP%IT%B_applied%scale,SP%IT%unsteady_B0%scale,TMP)
         endif
         if (SP%IT%constant_dB0dt%add) then
           call add_constant_dB0dt(F%x,ind%dB0dt%x,SP%IT%constant_dB0dt%scale)
         endif

         if (SP%IT%zero_source_components_any) then
           if (SP%IT%zero_source_components(1)) call assign(F%x,0.0_cp)
           if (SP%IT%zero_source_components(2)) call assign(F%y,0.0_cp)
           if (SP%IT%zero_source_components(3)) call assign(F%z,0.0_cp)
         endif

       end subroutine

       end module
       module add_all_momentum_sources_mod
       use current_precision_mod
       use sim_params_mod
       use VF_extend_mod
       use TF_extend_mod
       use IO_tools_mod
       use time_marching_params_mod

       use energy_mod
       use momentum_mod
       use momentum_terms_mod
       use induction_mod
       use induction_sources_mod
       use momentum_sources_mod
       implicit none

       private
       public :: add_all_momentum_sources

       contains

       subroutine add_all_momentum_sources(F,Fnm1,L,mom,TMP,SP,ind,nrg)
         implicit none
         type(VF),intent(inout) :: F,Fnm1,L
         type(energy),intent(inout) :: nrg
         type(momentum),intent(inout) :: mom
         type(induction),intent(inout) :: ind
         type(time_marching_params),intent(in) :: TMP
         type(sim_params),intent(in) :: SP

         if (SP%MT%mean_pressure_grad%add) then
           call compute_add_MPG(mom%U,TMP,&
           SP%MT%mean_pressure_grad%scale,SP%SCP%mpg_dir)
         endif

         call assign(Fnm1,F)
         call assign(L,0.0_cp) ! DO NOT REMOVE THIS, FOLLOW THE COMPUTE_ADD PROCEDURE BELOW
         call assign(F,0.0_cp) ! DO NOT REMOVE THIS, FOLLOW THE COMPUTE_ADD PROCEDURE BELOW

         if (SP%MT%pressure_grad%add) then
           call compute_add_pressure_grad(F,mom%m,mom%p,&
           SP%MT%pressure_grad%scale,mom%temp_F1)
         endif
         if (SP%MT%advection_divergence%add) then
           call compute_add_advection_divergence(F,mom%m,mom%U,mom%U_E,&
           SP%MT%advection_divergence%scale,mom%temp_F1,mom%temp_E,mom%temp_CC)
         endif
         if (SP%MT%advection_convection%add) then
           call compute_add_advection_convection(F,mom%m,mom%U,mom%U_E,&
           SP%MT%advection_convection%scale,mom%temp_F1,mom%temp_F2,&
           mom%temp_F3,mom%temp_CC)
         endif
         if (SP%MT%diffusion%add) then
           call compute_add_diffusion(F,mom%m,mom%U,SP%MT%diffusion%scale,mom%temp_F1)
         endif
         if (SP%MT%diffusion_linear%add) then
           call compute_add_diffusion(L,mom%m,mom%U,SP%MT%diffusion%scale,mom%temp_F1)
         endif
         if (SP%MT%advection_base_flow%add) then ! For linear stability analysis
           call compute_add_advection_base_flow(F,mom%m,mom%TS%U_ave,mom%U,mom%U_E,&
           SP%MT%advection_base_flow%scale,mom%temp_F1,mom%temp_F2,&
           mom%temp_F3,mom%temp_CC)
         endif
         if (SP%MT%JCrossB%add) then ! scale is included in ind%jCrossB
           call extract_add_JCrossB(F,mom%temp_F1,ind%jCrossB,ind%MD_fluid,1.0_cp)
         endif
         if (SP%MT%Q2D_JCrossB%add) then
           call compute_add_Q2D_JCrossB(F,mom%temp_F1,mom%U,SP%MT%Q2D_JCrossB%scale)
         endif
         if (SP%MT%Buoyancy%add) then
           call compute_add_buoyancy(F,mom%temp_F1,nrg%T,nrg%gravity,&
                                     SP%MT%Buoyancy%scale,nrg%m,nrg%MD,&
                                     nrg%temp_F,nrg%temp_CC1_VF)
         endif
         if (SP%MT%Gravity%add) then
           call compute_add_gravity(F,mom%temp_F1,nrg%gravity,SP%MT%Gravity%scale,nrg%m,&
                                    nrg%MD,nrg%temp_F,nrg%temp_CC1_VF)
         endif

         if (SP%MT%zero_source_components_any) then
           if (SP%MT%zero_source_components(1)) call assign(F%x,0.0_cp)
           if (SP%MT%zero_source_components(2)) call assign(F%y,0.0_cp)
           if (SP%MT%zero_source_components(3)) call assign(F%z,0.0_cp)
         endif

       end subroutine

!        subroutine add_all_momentum_raw_func(F,mom_temp_F3,ind_temp_F1_TF,ind_J,ind_m,&
!          mom_temp_CC,mom_m,ind_MD_fluid,ind_temp_CC,ind_Btot,nrg_MD,mom_temp_F2,&
!          mom_p,nrg_T,mom_U,ind_temp_F2_TF,ind_temp_F1,L,mom_temp_E,nrg_temp_F,&
!          mom_U_E,mom_temp_F1,nrg_gravity,nrg_m,TMP,nrg_temp_CC1_VF,MT,SP)
!          implicit none
!          type(VF),intent(inout) :: F
!          type(VF),intent(inout) :: mom_U
!          type(TF),intent(inout) :: mom_U_E
!          type(mesh),intent(in) :: mom_m
!          type(time_marching_params),intent(in) :: TMP
!          type(sim_params),intent(in) :: SP
!          type(momentum_terms),intent(in) :: MT

!          if (MT%mean_pressure_grad%add) then
!            call compute_add_MPG(mom_U,TMP,&
!            MT%mean_pressure_grad%scale,SP%SCP%mpg_dir)
!          endif

!          call assign(F,0.0_cp) ! DO NOT REMOVE THIS, FOLLOW THE COMPUTE_ADD PROCEDURE BELOW

!          if (MT%pressure_grad%add) then
!            call compute_add_pressure_grad(F,mom_m,mom_p,&
!            MT%pressure_grad%scale,mom_temp_F1)
!          endif
!          if (MT%advection_divergence%add) then
!            call compute_add_advection_divergence(F,mom_m,mom_U,mom_U_E,&
!            MT%advection_divergence%scale,mom_temp_F1,mom_temp_E,mom_temp_CC)
!          endif
!          if (MT%advection_convection%add) then
!            call compute_add_advection_convection(F,mom_m,mom_U,mom_U_E,&
!            MT%advection_convection%scale,mom_temp_F1,mom_temp_F2,&
!            mom_temp_F3,mom_temp_CC)
!          endif
!          if (MT%diffusion%add) then
!            call compute_add_diffusion(F,mom_m,mom_U,MT%diffusion%scale,mom_temp_F1)
!          endif
!          if (MT%diffusion_linear%add) then
!            call compute_add_diffusion(L,mom_m,mom_U,MT%diffusion%scale,mom_temp_F1)
!          endif
!          ! if (MT%advection_base_flow%add) then ! For linear stability analysis
!          !   call compute_add_advection_base_flow(F,mom_m,mom%TS%U_ave,mom_U,mom_U_E,&
!          !   MT%advection_base_flow%scale,mom_temp_F1,mom_temp_F2,&
!          !   mom_temp_F3,mom_temp_CC)
!          ! endif
!          if (MT%JCrossB%add) then
!            call compute_add_JCrossB(F,mom_temp_F1,ind_Btot,ind_J,ind_m,&
!                                    ind_MD_fluid,MT%JCrossB%scale,&
!                                    ind_temp_CC,ind_temp_F1,ind_temp_F1_TF,&
!                                    ind_temp_F2_TF)
!          endif
!          if (MT%Q2D_JCrossB%add) then
!            call compute_add_Q2D_JCrossB(F,mom_temp_F1,mom_U,MT%Q2D_JCrossB%scale)
!          endif
!          if (MT%Buoyancy%add) then
!            call compute_add_buoyancy(F,mom_temp_F1,nrg_T,nrg_gravity,&
!                                      MT%Buoyancy%scale,nrg_m,nrg_MD,&
!                                      nrg_temp_F,nrg_temp_CC1_VF)
!          endif
!          if (MT%Gravity%add) then
!            call compute_add_gravity(F,mom_temp_F1,nrg_gravity,MT%Gravity%scale,nrg_m,&
!                                     nrg_MD,nrg_temp_F,nrg_temp_CC1_VF)
!          endif

!        end subroutine

       end module
      module PCG_solver_extend_mod
      use PCG_solver_SF_mod
      use PCG_solver_VF_mod
      use current_precision_mod
      use string_mod
      use IO_export_mod
      use mesh_extend_mod
      use norms_extend_mod
      use data_location_extend_mod
      use ops_discrete_mod
      use ops_aux_mod
      use SF_extend_mod
      use VF_extend_mod
      use TF_extend_mod
      use IO_tools_mod
      use export_raw_processed_mod

      use iter_solver_params_mod
      use iter_solver_params_extend_mod
      use preconditioners_mod
      use matrix_mod
      use PCG_solver_algorithm_mod
      use matrix_free_params_mod
      use matrix_free_operators_mod
      implicit none

      private
      public :: PCG_solver_SF
      public :: PCG_solver_VF
      public :: init,delete,export,import
      public :: solve
      public :: prolongate
      public :: update_MFP

      logical :: verifyPreconditioner = .false.

      interface init;       module procedure init_PCG_SF;       end interface
      interface init;       module procedure init_PCG_VF;       end interface

      interface solve;      module procedure solve_PCG_SF;      end interface
      interface solve;      module procedure solve_PCG_VF;      end interface

      interface prolongate; module procedure prolongate_PCG_SF; end interface
      interface prolongate; module procedure prolongate_PCG_VF; end interface

      interface update_MFP; module procedure update_MFP_PCG_SF; end interface
      interface update_MFP; module procedure update_MFP_PCG_VF; end interface

      contains

      subroutine init_PCG_SF(PCG,operator,operator_explicit,prec,m,ISP,MFP,&
        x,x_BC,k,var_dir,var_name,testSymmetry,exportOperator)
        implicit none
        procedure(op_SF) :: operator
        procedure(op_SF_explicit) :: operator_explicit
        procedure(preconditioner_SF) :: prec
        type(PCG_solver_SF),intent(inout) :: PCG
        type(mesh),intent(in) :: m
        type(iter_solver_params),intent(in) :: ISP
        type(SF),intent(in) :: x,x_BC
        type(TF),intent(in) :: k
        character(len=*),intent(in) :: var_dir,var_name
        logical,intent(in) :: testSymmetry,exportOperator
        type(matrix_free_params),intent(in) :: MFP
        type(SF) :: temp_Minv
              if (is_CC(x%DL)) then; call init_CC(PCG%tempx,m)   ! Does not copy BCs of x
        elseif (is_Node(x%DL)) then; call init_Node(PCG%tempx,m) ! Does not copy BCs of x
        elseif (is_Edge(x%DL)) then; call init_Edge(PCG%tempx,m,get_edge(x%DL)) ! Does not copy BCs of x
        elseif (is_Face(x%DL)) then; call init_Face(PCG%tempx,m,get_face(x%DL)) ! Does not copy BCs of x
        else; stop 'Error: bad input type into init_PCG_SF in PCG.f90'
        endif
        call init(PCG%p,x) ! Copies BCs for x
        call init(PCG%x_BC,x_BC) ! Copies BCs for x
        call init(PCG%r,PCG%tempx)
        call init(PCG%Ax,PCG%tempx)
        call init(PCG%vol,PCG%tempx)
        call init(PCG%k,k)
        call init(PCG%tempk,k)
        call init(PCG%z,PCG%tempx)
        call init(PCG%Minv,PCG%tempx)
        call init(PCG%ISP,ISP)

        call init(PCG%norm)
        call init(PCG%MFP,MFP)
        call volume(PCG%vol,m)
        call init(PCG%var_dir,var_dir)
        call init(PCG%var_name,var_name)
        PCG%un = new_and_open(var_dir,str(PCG%var_name))
        PCG%un_convergence = new_and_open(var_dir,str(PCG%var_name)//'_convergence')
        call tecHeader(str(PCG%var_name),PCG%un,.false.)
        call tecHeader(str(PCG%var_name),PCG%un_convergence,.false.)
        PCG%prec => prec
        PCG%operator => operator
        PCG%operator_explicit => operator_explicit
        call assign(PCG%k,k)
        call PCG%prec(PCG%Minv,m,k,MFP%coeff_implicit,PCG%tempx) ! MFP%coeff_implicit reasonable estimate

        if (verifyPreconditioner) then
          call init(temp_Minv,PCG%Minv)
          call assign(temp_Minv,PCG%Minv)
          call export_raw(m,temp_Minv,var_dir,'PCG_SF_prec_tec_'//str(PCG%var_name),0)
          call export_matrix(temp_Minv,var_dir,'PCG_SF_prec_mat_'//str(PCG%var_name))
          call get_diagonal(operator_explicit,temp_Minv,x,PCG%k,PCG%vol,m,MFP,PCG%tempk)
          call export_raw(m,temp_Minv,var_dir,'PCG_SF_op_tec_diag_'//str(PCG%var_name),0)
          call export_matrix(temp_Minv,var_dir,'PCG_SF_op_mat_diag_'//str(PCG%var_name))
          call delete(temp_Minv)
        endif

        if (testSymmetry) then
          call test_symmetry(operator,'PCG_SF_'//str(PCG%var_name),x,PCG%k,PCG%vol,m,MFP,PCG%tempk)
        endif
        if (exportOperator) then
          call export_operator(operator_explicit,var_dir,'PCG_SF_'//str(PCG%var_name),x,PCG%k,PCG%vol,m,MFP,PCG%tempk)
        endif
      end subroutine

      subroutine init_PCG_VF(PCG,operator,operator_explicit,prec,m,ISP,MFP,&
        x,x_BC,k,var_dir,var_name,testSymmetry,exportOperator)
        implicit none
        procedure(op_VF) :: operator
        procedure(op_VF_explicit) :: operator_explicit
        procedure(preconditioner_VF) :: prec
        type(PCG_solver_VF),intent(inout) :: PCG
        type(mesh),intent(in) :: m
        type(iter_solver_params),intent(in) :: ISP
        type(VF),intent(in) :: x,x_BC
        type(TF),intent(in) :: k
        character(len=*),intent(in) :: var_dir,var_name
        logical,intent(in) :: testSymmetry,exportOperator
        type(matrix_free_params),intent(in) :: MFP
        type(VF) :: temp_Minv
            if (is_CC(x)) then;   call init_CC(PCG%tempx,m)   ! Does not copy BCs of x
        elseif (is_Node(x)) then; call init_Node(PCG%tempx,m) ! Does not copy BCs of x
        elseif (is_Edge(x)) then; call init_Edge(PCG%tempx,m) ! Does not copy BCs of x
        elseif (is_Face(x)) then; call init_Face(PCG%tempx,m) ! Does not copy BCs of x
        else; stop 'Error: bad input type into init_PCG_VF in PCG.f90'
        endif
        call init(PCG%p,x) ! Copies BCs for x
        call init(PCG%x_BC,x_BC) ! Copies BCs for x
        call init(PCG%r,PCG%tempx)
        call init(PCG%Ax,PCG%tempx)
        call init(PCG%vol,PCG%tempx)
        call init(PCG%k,k)
        call init(PCG%tempk,k)
        call init(PCG%z,PCG%tempx)
        call init(PCG%Minv,PCG%tempx)
        call init(PCG%ISP,ISP)
        call init(PCG%norm)
        call init(PCG%MFP,MFP)
        call volume(PCG%vol,m)
        call init(PCG%var_dir,var_dir)
        call init(PCG%var_name,var_name)
        PCG%un = new_and_open(var_dir,str(PCG%var_name))
        PCG%un_convergence = new_and_open(var_dir,str(PCG%var_name)//'_convergence')
        call tecHeader(str(PCG%var_name),PCG%un,.true.)
        call tecHeader(str(PCG%var_name),PCG%un_convergence,.true.)
        PCG%prec => prec
        PCG%operator => operator
        PCG%operator_explicit => operator_explicit
        call assign(PCG%k,k)
        call PCG%prec(PCG%Minv,m,k,MFP%coeff_implicit,PCG%tempx) ! MFP%coeff_implicit reasonable estimate

        if (verifyPreconditioner) then
          call init(temp_Minv,PCG%Minv)
          call assign(temp_Minv,PCG%Minv)
          call export_raw(m,temp_Minv,var_dir,'PCG_VF_prec_tec_'//str(PCG%var_name),0)
          call export_matrix(temp_Minv,var_dir,'PCG_VF_prec_mat_'//str(PCG%var_name))
          call get_diagonal(operator_explicit,temp_Minv,x,PCG%k,PCG%vol,m,MFP,PCG%tempk)
          call export_raw(m,temp_Minv,var_dir,'PCG_VF_op_tec_diag_'//str(PCG%var_name),0)
          call export_matrix(temp_Minv,var_dir,'PCG_VF_op_mat_diag_'//str(PCG%var_name))
          call delete(temp_Minv)
        endif

        if (testSymmetry) then
          call test_symmetry(operator,'PCG_VF_'//str(PCG%var_name),x,PCG%k,PCG%vol,m,MFP,PCG%tempk)
        endif
        if (exportOperator) then
          call export_operator(operator_explicit,var_dir,'PCG_VF_'//str(PCG%var_name),x,PCG%k,PCG%vol,m,MFP,PCG%tempk)
        endif
      end subroutine

      subroutine solve_PCG_SF(PCG,x,b,m,compute_norms)
        implicit none
        type(PCG_solver_SF),intent(inout) :: PCG
        type(SF),intent(inout) :: x
        type(SF),intent(in) :: b
        type(mesh),intent(in) :: m
        logical,intent(in) :: compute_norms
        call solve_PCG(PCG%operator,PCG%operator_explicit,str(PCG%var_name),&
        x,PCG%x_BC,b,PCG%vol,PCG%k,m,PCG%MFP,PCG%ISP,PCG%norm,compute_norms,PCG%un,&
        PCG%un_convergence,PCG%tempx,PCG%tempk,PCG%Ax,PCG%r,PCG%p,&
        PCG%z,PCG%Minv)
      end subroutine

      subroutine solve_PCG_VF(PCG,x,b,m,compute_norms)
        implicit none
        type(PCG_solver_VF),intent(inout) :: PCG
        type(VF),intent(inout) :: x
        type(VF),intent(in) :: b
        type(mesh),intent(in) :: m
        logical,intent(in) :: compute_norms
        call solve_PCG(PCG%operator,PCG%operator_explicit,str(PCG%var_name),&
        x,PCG%x_BC,b,PCG%vol,PCG%k,m,PCG%MFP,PCG%ISP,PCG%norm,compute_norms,PCG%un,&
        PCG%un_convergence,PCG%tempx,PCG%tempk,PCG%Ax,PCG%r,PCG%p,&
        PCG%z,PCG%Minv)
      end subroutine

      subroutine tecHeader(var_name,un,VF)
        implicit none
        character(len=*),intent(in) :: var_name
        integer,intent(in) :: un
        logical,intent(in) :: VF
        type(string) :: s
        if (VF) then; write(un,*) 'TITLE = "PCG_VF residuals for '//var_name//'"'
        else;         write(un,*) 'TITLE = "PCG_SF residuals for '//var_name//'"'
        endif
        call init(s,'VARIABLES = iter_total,stop_criteria')
        call append(s,',res_norm_L1,res_norm_L2,res_norm_Linf')
        call append(s,',res0_norm_L1,res0_norm_L2,res0_norm_Linf')
        call append(s,',iter_per_call')
        write(un,*) str(s)
        write(un,*) 'ZONE DATAPACKING = POINT'
        call delete(s)
        flush(un)
      end subroutine

      subroutine prolongate_PCG_SF(PCG,m,k,MFP,dir)
        implicit none
        type(PCG_solver_SF),intent(inout) :: PCG
        type(mesh),intent(in) :: m
        type(TF),intent(in) :: k
        type(matrix_free_params),intent(in) :: MFP
        integer,intent(in) :: dir
        call prolongate(PCG%tempx,m,dir)
        call prolongate(PCG%p,m,dir)
        call prolongate(PCG%r,m,dir)
        call prolongate(PCG%Ax,m,dir)
        call prolongate(PCG%vol,m,dir)
        call prolongate(PCG%k,m,dir); call assign(PCG%k,k)
        call prolongate(PCG%tempk,m,dir)
        call prolongate(PCG%z,m,dir)
        call prolongate(PCG%Minv,m,dir)
        call init(PCG%MFP,MFP)
        call PCG%prec(PCG%Minv,m,PCG%k,PCG%MFP%coeff_implicit_time_split,PCG%tempx)
        call volume(PCG%vol,m)
      end subroutine

      subroutine prolongate_PCG_VF(PCG,m,k,MFP,dir)
        implicit none
        type(PCG_solver_VF),intent(inout) :: PCG
        type(mesh),intent(in) :: m
        type(TF),intent(in) :: k
        type(matrix_free_params),intent(in) :: MFP
        integer,intent(in) :: dir
        call prolongate(PCG%tempx,m,dir)
        call prolongate(PCG%p,m,dir)
        call prolongate(PCG%r,m,dir)
        call prolongate(PCG%Ax,m,dir)
        call prolongate(PCG%vol,m,dir)
        call prolongate(PCG%k,m,dir); call assign(PCG%k,k)
        call prolongate(PCG%tempk,m,dir)
        call prolongate(PCG%z,m,dir)
        call prolongate(PCG%Minv,m,dir)
        call init(PCG%MFP,MFP)
        call PCG%prec(PCG%Minv,m,PCG%k,PCG%MFP%coeff_implicit_time_split,PCG%tempx)
        call volume(PCG%vol,m)
      end subroutine

      subroutine update_MFP_PCG_SF(PCG,m,coeff_implicit_time_split,update_preconditioner)
        implicit none
        type(PCG_solver_SF),intent(inout) :: PCG
        type(mesh),intent(in) :: m
        real(cp),intent(in) :: coeff_implicit_time_split
        logical,intent(in) :: update_preconditioner
        PCG%MFP%coeff_implicit_time_split = coeff_implicit_time_split
        if (update_preconditioner) then
          call PCG%prec(PCG%Minv,m,PCG%k,PCG%MFP%coeff_implicit_time_split,PCG%tempx)
        endif
      end subroutine

      subroutine update_MFP_PCG_VF(PCG,m,coeff_implicit_time_split,update_preconditioner)
        implicit none
        type(PCG_solver_VF),intent(inout) :: PCG
        type(mesh),intent(in) :: m
        real(cp),intent(in) :: coeff_implicit_time_split
        logical,intent(in) :: update_preconditioner
        PCG%MFP%coeff_implicit_time_split = coeff_implicit_time_split
        if (update_preconditioner) then
          call PCG%prec(PCG%Minv,m,PCG%k,PCG%MFP%coeff_implicit_time_split,PCG%tempx)
        endif
      end subroutine

      end module
       module Poisson_test_mod
       use current_precision_mod
       use constants_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use dir_tree_mod
       use string_mod
       use path_extend_mod
       use path_extend_mod
       use export_raw_processed_mod
       use ops_discrete_mod
       use ops_aux_mod
       use PCG_solver_extend_mod
       use apply_BCs_mod
       use matrix_free_operators_mod
       use matrix_free_params_mod
       use preconditioners_mod
       use iter_solver_params_mod
       use ops_mirror_field_mod
       use sim_params_mod
       use BC_funcs_mod

       implicit none
       private

       public :: Poisson_test

       contains

       subroutine Poisson_test(U,p,m,DT)
         implicit none
         type(VF),intent(in) :: U
         type(SF),intent(in) :: p
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         write(*,*) ' ************************************************************ '
         write(*,*) ' ******************** BEGIN POISSON TEST ******************** '
         write(*,*) ' ************************************************************ '
         write(*,*) ' ------------------------- TEST 1 --------------------------- '
         call Poisson_test_CC(p,m,DT)     ! Tests residual drop for CC data
         write(*,*) ' ------------------------- TEST 2 --------------------------- '
         call Poisson_test_Face(U,m,DT)   ! Tests residual drop for Face data
         write(*,*) ' ************************************************************ '
         write(*,*) ' ********************** END POISSON TEST ******************** '
         write(*,*) ' ************************************************************ '
       end subroutine

       subroutine Poisson_test_CC(p,m,DT)
         implicit none
         type(SF),intent(in) :: p
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         type(SF) :: phi,temp_CC
         type(TF) :: temp_F
         type(PCG_solver_SF) :: PCG
         type(iter_solver_params) :: ISP
         type(matrix_free_params) :: MFP
         logical,parameter :: T = .true.
         call init(ISP,2000,pow(-20),pow(-18),1,T,T)
         call init(ISP%dir,str(DT%test%field))
         call init(ISP%name,'Poisson_test_CC')
         call init(phi,p)
         call assign(phi,0.0_cp)
         call init_CC(temp_CC,m)
         call init_Face(temp_F,m)
         call Neumann_BCs(phi,m)

         phi%all_Neumann = .true.
         call print_BCs(phi,'phi')

         call init(PCG,Lap_uniform_SF,Lap_uniform_SF_explicit,prec_Lap_SF,m,&
         ISP,MFP,phi,phi,temp_F,str(DT%test%residual),'Poisson_test_CC',.false.,.false.)

         call random_noise(phi) ! Does not work for periodic BCs, but does work for Dirichlet BCs
         ! call cosine_waves(phi,m,(/2.0_cp/PI,2.0_cp/PI,2.0_cp/),(/0.0_cp,0.0_cp,0.0_cp/))
         call assign(temp_CC,phi)
         call assign_ghost_XPeriodic(temp_CC,0.0_cp)
         call assign(phi,0.0_cp)
         call export_raw(m,temp_CC,str(DT%test%field),'source_CC',0)

         call solve(PCG,phi,temp_CC,m,.false.)
         call export_raw(m,PCG%r,str(DT%test%residual),'residual_CC',0)

         call export_raw(m,phi,str(DT%test%field),'phi_CC',0)
         call delete(phi)
         call delete(temp_CC)
         call delete(temp_F)
         call delete(PCG)
         call delete(ISP)
         call delete(MFP)
       end subroutine

       subroutine Poisson_test_Face(X,m,DT)
         implicit none
         type(VF),intent(in) :: X
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         type(VF) :: U,temp_F
         type(TF) :: temp_CC_edge
         type(PCG_solver_VF) :: PCG
         type(iter_solver_params) :: ISP
         type(matrix_free_params) :: MFP
         logical,parameter :: T = .true.
         call init(ISP,10000,pow(-15),pow(-15),1,T,T)
         call init(ISP%dir,str(DT%test%field))
         call init(ISP%name,'Poisson_test_Face')
         call init(U,X)
         call assign(U,0.0_cp)
         call init_CC_edge(temp_CC_edge,m)
         call init_Face(temp_F,m)

         call print_BCs(U,'Face')

         call init(PCG,Lap_uniform_VF,Lap_uniform_VF_explicit,prec_Lap_VF,m,&
         ISP,MFP,U,U,temp_CC_edge,str(DT%test%residual),'Poisson_test_Face',.false.,.false.)

         call random_noise(U) ! Does not work for periodic BCs, but does work for Dirichlet BCs
         call sine_waves(U,m,(/2.0_cp/PI,1.0_cp,2.0_cp/),(/0.0_cp,-0.5_cp,0.0_cp/))
         call apply_BCs(U)
         call assign(temp_F,U)
         call assign(U,0.0_cp)
         call export_processed(m,temp_F,str(DT%test%field),'source_Face',1)

         call solve(PCG,U,temp_F,m,.false.)

         call export_processed(m,U,str(DT%test%field),'U_Face',1)
         call export_raw(m,U,str(DT%test%field),'U_Face',0)
         call export_raw(m,PCG%r,str(DT%test%field),'Residual_Face',0)
         call delete(U)
         call delete(temp_CC_edge)
         call delete(temp_F)
         call delete(PCG)
         call delete(ISP)
         call delete(MFP)
       end subroutine

       end module
       module Taylor_Green_Vortex_test_mod
       use current_precision_mod
       use constants_mod
       use mesh_extend_mod
       use GF_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use dir_tree_mod
       use string_mod
       use path_extend_mod
       use export_raw_processed_mod
       use ops_discrete_mod
       use ops_norms_mod
       use PCG_solver_extend_mod
       use apply_BCs_mod
       use matrix_free_operators_mod
       use matrix_free_params_mod
       use preconditioners_mod
       use iter_solver_params_mod
       use ops_mirror_field_mod
       use sim_params_mod
       use BC_funcs_mod

       implicit none
       private

       public :: Taylor_Green_Vortex_test

       contains

       subroutine Taylor_Green_Vortex_test(U,p,m,DT,SP)
         implicit none
         type(VF),intent(in) :: U
         type(SF),intent(in) :: p
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         type(sim_params),intent(in) :: SP
         type(VF) :: U_analytic
         type(SF) :: P_error,P_analytic,p_actual,p_mod
         real(cp) :: e,dtime,Re
         Re = SP%DP%Re
         dtime = SP%VS%U%TMP%TS%dt
         write(*,*) ' ************************************************************ '
         write(*,*) ' ************** BEGIN TAYLOR GREEN VORTEX TEST ************** '
         write(*,*) ' ************************************************************ '
         call init(U_analytic,U)
         call init(P_analytic,p)
         call init(p_actual,p)
         call init(p_mod,p)
         call init(P_error,p)
         call export_processed(m,U,str(DT%test%field),'U_numerical',0)
         call export_processed(m,P,str(DT%test%field),'P_numerical',0)
         call export_raw(m,P,str(DT%test%field),'P_numerical',0)
         call compute_analytic_solution(U_analytic,P_analytic,m,DT,SP)
         call subtract(U_analytic,U)
         call subtract(P_error,P_analytic,p)
         call export_raw(m,U_analytic,str(DT%test%field),'U_error',0)
         call export_raw(m,P_error,str(DT%test%field),'P_error',0)
         call lap(p_mod,p,m)
         call multiply(p_mod,-SP%VS%U%MFP%alpha*dtime/Re)
         call export_raw(m,p_mod,str(DT%test%field),'P_modify',0)
         call add(p_actual,p,p_mod)
         call export_raw(m,p_actual,str(DT%test%field),'p_actual',0)
         call subtract(P_error,P_analytic,p_actual)
         call export_raw(m,P_error,str(DT%test%field),'P_error_actual',0)
         write(*,*) 't = ',SP%VS%U%TMP%t
         call compute_Ln(e,U_analytic,2.0_cp,m); write(*,*) 'dt,e(U) = ',dtime,e
         call compute_Ln(e,P_analytic,2.0_cp,m); write(*,*) 'dt,e(P) = ',dtime,e
         call delete(U_analytic)
         call delete(P_analytic)
         call delete(p_actual)
         call delete(p_mod)
         call delete(P_error)
         write(*,*) ' ************************************************************ '
         write(*,*) ' *************** END TAYLOR GREEN VORTEX TEST *************** '
         write(*,*) ' ************************************************************ '
       end subroutine

       subroutine compute_analytic_solution(U,p,m,DT,SP)
         implicit none
         type(VF),intent(inout) :: U
         type(SF),intent(inout) :: p
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         type(sim_params),intent(in) :: SP
         real(cp) :: Re,t
         Re = SP%DP%Re
         t = SP%VS%U%TMP%t
         ! Define u
         call Taylor_Green_Vortex_U(U%x%BF(1)%GF,m%B(1)%g,U%x%DL,Re,t)
         call Taylor_Green_Vortex_V(U%y%BF(1)%GF,m%B(1)%g,U%y%DL,Re,t)
         call assign(U%z,0.0_cp)
         call Taylor_Green_Vortex_P(P%BF(1)%GF  ,m%B(1)%g,P%DL  ,Re,t)
         call export_processed(m,U,str(DT%test%field),'U_TGV_analytic',0)
         call export_processed(m,P,str(DT%test%field),'P_TGV_analytic',0)
       end subroutine

       end module
       module clean_divergence_mod
       ! Computes:
       !      ∇²φ_{n+1} = ∇•K_{n}
       !      X_{n+1} = X_{*} - ∇φ_{n+1}
       ! Where:
       !      X* = dt*(F_{n} + θ*AX_{n} + explicit terms) + X_{n}
       !
       ! According to:
       !        Kim, J. & Moin, P. Application of a Fractional-Step
       !        Method to Incompressible Naview-Stokes Equations.
       !        J. Comput. Phys. 323, 308–323 (1985).
       !
       ! 2nd order time marching is achieved using fully
       ! implicit time marching for pressure.
       ! See section 2, after Eq. 5 and before Fig. 1.
       !
       ! We prefer this over trapezoidal method as this
       ! method requires the simplest interface.
       use current_precision_mod
       use mesh_extend_mod
       use string_mod
       use SF_extend_mod
       use VF_extend_mod
       use ops_discrete_mod
       use apply_BCs_mod
       use PCG_solver_extend_mod
       use FFT_solver_extend_mod

       implicit none
       private
       public :: clean_div
       interface clean_div;    module procedure clean_div_PCG;    end interface
       interface clean_div;    module procedure clean_div_FFT;    end interface

       contains

       subroutine clean_div_PCG(PCG,X,Xstar,phi,scale,m,temp_F,temp_CC,compute_norms)
         ! Computes:
         !      ∇²φ_{n+1} = scale ∇•K_{n}
         !      X_{n+1} = X_{*} - scale^{-1} ∇φ_{n+1}
         ! Where:
         !      X* = dt*(F_{n} + θ*AX_{n} + explicit terms) + X_{n}
         implicit none
         type(PCG_solver_SF),intent(inout) :: PCG
         type(SF),intent(inout) :: phi
         type(VF),intent(in) :: Xstar
         type(VF),intent(inout) :: X,temp_F
         real(cp),intent(in) :: scale
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: temp_CC
         logical,intent(in) :: compute_norms
         call div(temp_CC,Xstar,m)
         call multiply(temp_CC,scale)
         call solve(PCG,phi,temp_CC,m,compute_norms)
         call grad(temp_F,phi,m)
         call multiply(temp_F,1.0_cp/scale)
         call subtract(X,Xstar,temp_F)
         call apply_BCs(X)
       end subroutine

       subroutine clean_div_FFT(FFT,X,Xstar,phi,scale,m,temp_F,temp_CC,compute_norms)
         ! Computes:
         !      ∇²φ_{n+1} = scale ∇•K_{n}
         !      X_{n+1} = X_{*} - scale^{-1} ∇φ_{n+1}
         ! Where:
         !      X* = dt*(F_{n} + θ*AX_{n} + explicit terms) + X_{n}
         implicit none
         type(FFT_solver_SF),intent(inout) :: FFT
         type(SF),intent(inout) :: phi
         type(VF),intent(in) :: Xstar
         type(VF),intent(inout) :: X,temp_F
         real(cp),intent(in) :: scale
         type(mesh),intent(in) :: m
         type(SF),intent(inout) :: temp_CC
         logical,intent(in) :: compute_norms
         call div(temp_CC,Xstar,m)
         call multiply(temp_CC,scale)
         call solve(FFT,phi,temp_CC,m,compute_norms)
         call grad(temp_F,phi,m)
         call multiply(temp_F,1.0_cp/scale)
         call subtract(X,Xstar,temp_F)
         call apply_BCs(X)
       end subroutine

       end module
       module energy_solver_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use norms_extend_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use apply_BCs_mod
       use PCG_solver_extend_mod

       implicit none

       private
       public :: explicitEuler
       public :: explicitEuler_with_source
       public :: CN_with_source
       public :: diffusion_implicit
       public :: all_terms_explicit

       contains

       subroutine explicitEuler(T,U_F,dt,Pe,m,temp_CC1,temp_CC2,temp_F)
         ! Solves
         !             ∂T/∂t + (u • ∇)T = ∇²T
         implicit none
         type(SF),intent(inout) :: T,temp_CC1,temp_CC2
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U_F
         real(cp),intent(in) :: dt,Pe
         type(VF),intent(inout) :: temp_F
         call cellCenter2Face(temp_F,T,m)
         call multiply(temp_F,U_F)
         call div(temp_CC1,temp_F,m)
         call multiply(temp_CC1,-1.0_cp)
         call lap(temp_CC2,T,m)
         call multiply(temp_CC2,1.0_cp/Pe)
         call add(temp_CC1,temp_CC2)
         call multiply(temp_CC1,dt)
         call add(T,temp_CC1)
         call apply_BCs(T)
       end subroutine

       subroutine explicitEuler_with_source(T,U_F,dt,Pe,m,Q_CC,temp_CC1,temp_CC2,temp_F)
         ! Solves
         !             ∂T/∂t + (u • ∇)T = ∇²T + Q
         implicit none
         type(SF),intent(inout) :: T,temp_CC1,temp_CC2
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U_F
         type(SF),intent(in) :: Q_CC
         real(cp),intent(in) :: dt,Pe
         type(VF),intent(inout) :: temp_F
         call cellCenter2Face(temp_F,T,m)
         call multiply(temp_F,U_F)
         call div(temp_CC1,temp_F,m)
         call multiply(temp_CC1,-1.0_cp)
         call lap(temp_CC2,T,m)
         call multiply(temp_CC2,1.0_cp/Pe)
         call add(temp_CC1,temp_CC2)
         call add(temp_CC1,Q_CC)
         call multiply(temp_CC1,dt)
         call add(T,temp_CC1)
         call apply_BCs(T)
         call subtract_mean_along_dir(T,m,1,temp_CC1)
       end subroutine

       subroutine CN_with_source(PCG,T,U_F,dt,Pe,m,Q_source,compute_norms,&
         temp_CC1,temp_CC2,temp_F)
         ! Solves
         !             ∂T/∂t + (u • ∇)T = ∇²T + j²/σ + Φ
         implicit none
         type(PCG_solver_SF),intent(inout) :: PCG
         type(SF),intent(inout) :: T,temp_CC1,temp_CC2
         type(SF),intent(inout) :: Q_source
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U_F
         real(cp),intent(in) :: dt,Pe
         type(VF),intent(inout) :: temp_F
         logical,intent(in) :: compute_norms
         call cellCenter2Face(temp_F,T,m)
         call multiply(temp_F,U_F)
         call div(temp_CC1,temp_F,m)
         call multiply(temp_CC1,-1.0_cp)
         call lap(temp_CC2,T,m)
         call multiply(temp_CC2,0.5_cp/Pe)
         call add(temp_CC1,temp_CC2)
         call add(temp_CC1,Q_source)
         call multiply(temp_CC1,dt)
         call solve(PCG,T,temp_CC1,m,compute_norms)
         call subtract_mean_along_dir(T,m,1,temp_CC1)
       end subroutine

       subroutine diffusion_implicit(PCG,T,U_F,dt,Pe,m,compute_norms,temp_CC1,temp_CC2,temp_F)
         ! Solves
         !             ∂T/∂t + (u • ∇)T = ∇²T + j²/σ + Φ
         implicit none
         type(PCG_solver_SF),intent(inout) :: PCG
         type(SF),intent(inout) :: T,temp_CC1,temp_CC2
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U_F
         real(cp),intent(in) :: dt,Pe
         type(VF),intent(inout) :: temp_F
         logical,intent(in) :: compute_norms
         call cellCenter2Face(temp_F,T,m)
         call multiply(temp_F,U_F)
         call div(temp_CC1,temp_F,m)
         call multiply(temp_CC1,-1.0_cp)
         call lap(temp_CC2,T,m)
         call multiply(temp_CC2,0.5_cp/Pe)
         call add(temp_CC1,temp_CC2)
         call multiply(temp_CC1,dt)
         call solve(PCG,T,temp_CC1,m,compute_norms)
       end subroutine

       subroutine all_terms_explicit(T,U_F,U_CC,J_CC,sigmaInv_CC,dt,Pe,m,&
         temp_CC1,temp_CC2,temp_F,temp_CC_TF1,temp_CC_TF2)
         ! Solves
         !             ∂T/∂t + (u • ∇)T = ∇²T + j²/σ + Φ
         !
         implicit none
         type(SF),intent(inout) :: T,temp_CC1,temp_CC2
         type(SF),intent(in) :: sigmaInv_CC
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U_F,U_CC,J_CC
         TYPE(TF),intent(inout) :: temp_CC_TF1,temp_CC_TF2
         real(cp),intent(in) :: dt,Pe
         type(VF),intent(inout) :: temp_F
         ! Convection
         call cellCenter2Face(temp_F,T,m)
         call multiply(temp_F,U_F)
         call div(temp_CC1,temp_F,m)
         call multiply(temp_CC1,-1.0_cp)
         ! Thermal diffusion
         call lap(temp_CC2,T,m)
         call multiply(temp_CC2,1.0_cp/Pe)
         call add(temp_CC1,temp_CC2)
          ! Joule dissipation
         call multiply(temp_CC_TF2%x,J_CC,sigmaInv_CC)
         call add(temp_CC1,temp_CC_TF2%x)
         ! Viscous dissipation
         call grad(temp_CC_TF1,U_CC,m)
         call transpose(temp_CC_TF2,temp_CC_TF1)
         call add(temp_CC_TF2,temp_CC_TF1)
         call square(temp_CC_TF2) ! S_ij S_ij in tensor format
         call add(temp_CC2,temp_CC_TF2) ! S_ij S_ij in scalar format
         call multiply(temp_CC2,0.5_cp) ! temp_CC1 = 0.5 (∂_j u_i + ∂_i u_j) (∂_j u_i + ∂_i u_j)
         call add(temp_CC1,temp_CC2)
         ! Explicit Euler
         call multiply(temp_CC1,dt)
         call add(T,temp_CC1)
         call apply_BCs(T)
       end subroutine

       end module
       module energy_sources_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use norms_extend_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use apply_BCs_mod
       use PCG_solver_extend_mod

       implicit none

       private
       public :: add_advection
       public :: add_diffusion
       public :: add_KE_diffusion
       public :: add_viscous_dissipation
       public :: add_joule_heating
       public :: add_volumetric_heating_Nuclear

       contains

       subroutine add_advection(S_CC,T,U_F,scale,m,temp_CC1,temp_F)
         ! Adds S_CC = S_CC + scale ∇•(uT)
         implicit none
         type(SF),intent(inout) :: S_CC,T,temp_CC1
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U_F
         real(cp),intent(in) :: scale
         type(VF),intent(inout) :: temp_F
         call cellCenter2Face(temp_F,T,m)
         call multiply(temp_F,U_F)
         call div(temp_CC1,temp_F,m)
         call multiply(temp_CC1,-1.0_cp)
         call add_product(S_CC,temp_CC1,scale)
       end subroutine

       subroutine add_diffusion(S_CC,T,scale,m,temp_CC1)
         ! Adds S_CC = S_CC + scale ∇²T
         implicit none
         type(SF),intent(inout) :: S_CC,T,temp_CC1
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         call lap(temp_CC1,T,m)
         call add_product(S_CC,temp_CC1,scale)
       end subroutine

       subroutine add_KE_diffusion(S_CC,U_CC,scale,m,temp_CC1,temp_CC2,temp_CC_VF)
         ! Adds S_CC = S_CC + scale J•J/sigma
         implicit none
         type(SF),intent(inout) :: S_CC,temp_CC1,temp_CC2
         type(VF),intent(inout) :: temp_CC_VF
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U_CC
         real(cp),intent(in) :: scale
         call assign(temp_CC_VF,U_CC)
         call square(temp_CC_VF)
         call add(temp_CC1,temp_CC_VF)
         call lap(temp_CC2,temp_CC1,m)
         call add_product(S_CC,temp_CC2,scale)
       end subroutine

       subroutine add_viscous_dissipation(S_CC,U_CC,scale,m,temp_CC,temp_CC_TF)
         ! Adds S_CC = S_CC + scale (∇u)•(∇u)
         implicit none
         type(SF),intent(inout) :: S_CC,temp_CC
         type(mesh),intent(in) :: m
         type(VF),intent(in) :: U_CC
         TYPE(TF),intent(inout) :: temp_CC_TF
         real(cp),intent(in) :: scale
         call grad(temp_CC_TF,U_CC,m)
         call square(temp_CC_TF)
         call add(temp_CC,temp_CC_TF)
         call add_product(S_CC,temp_CC,scale)
       end subroutine

       subroutine add_joule_heating(S_CC,J,sigmaInv_CC,scale,m,temp_CC,temp_F,temp_CC_VF)
         ! Adds S_CC = S_CC + scale J•J/sigma
         implicit none
         type(SF),intent(inout) :: S_CC,temp_CC
         type(VF),intent(in) :: J
         type(SF),intent(in) :: sigmaInv_CC
         type(VF),intent(inout) :: temp_F,temp_CC_VF
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         call edge2CellCenter(temp_CC_VF,J,m,temp_F)
         call square(temp_CC_VF)
         call add(temp_CC,temp_CC_VF)
         call multiply(temp_CC,sigmaInv_CC)
         call add_product(S_CC,temp_CC,scale)
       end subroutine

       subroutine add_volumetric_heating_Nuclear(S_CC,m,scale,temp_CC)
         implicit none
         type(SF),intent(inout) :: S_CC,temp_CC
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: scale
         integer :: t,i,j,k
         real(cp) :: a,L,m_,F
         a = 1.0_cp
         L = 1.0_cp
         m_ = a/L
         F = scale*2.0_cp*m_/(1.0_cp-exp(-2.0_cp*m_))
         !$OMP PARALLEL DO
         do t=1,m%s; do k=1,temp_CC%BF(t)%GF%s(3); do j=1,temp_CC%BF(t)%GF%s(2); do i=1,temp_CC%BF(t)%GF%s(1)
         temp_CC%BF(t)%GF%f(i,j,k) = F*exp(-m_*(m%B(t)%g%c(2)%hc%f(j)+1.0_cp))
         enddo; enddo; enddo; enddo
         !$OMP END PARALLEL DO
         call add_product(S_CC,temp_CC,scale)
       end subroutine

       end module
       module matrix_visualization_mod
       use current_precision_mod
       use mesh_extend_mod
       use grid_mod
       use grid_init_mod
       use mesh_quality_params_extend_mod
       use IO_export_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use dir_tree_mod
       use string_mod
       use path_extend_mod
       use export_raw_processed_mod
       use ops_discrete_mod
       use PCG_solver_extend_mod
       use matrix_free_operators_mod
       use matrix_free_params_mod
       use preconditioners_mod
       use iter_solver_params_mod
       use ops_mirror_field_mod
       use sim_params_mod
       use BC_funcs_mod

       implicit none
       private

       public :: export_matrix_visualization

       contains

       subroutine export_matrix_visualization(DT)
         implicit none
         type(dir_tree),intent(in) :: DT
         type(mesh) :: m
         type(TF) :: temp_dummy
         type(iter_solver_params) :: ISP
         type(matrix_free_params) :: MFP
         logical :: test_symmetry,export_operator
         export_operator = .true.
         test_symmetry = .true.
         call init(ISP,10000,pow(-15),pow(-15),1,.true.,.true.)
         call init(ISP%dir,str(DT%ISP))
         call init(ISP%name,'matrix_visualization')
         call matrix_visualization_mesh(m)
         MFP%coeff_implicit_time_split = 0.1_cp
         call export_mesh(m,str(DT%matrix_visualization),'m',1)

         call export_laplacian_CC_SF(DT,m,temp_dummy,ISP,MFP,test_symmetry,export_operator)

         call export_laplacian_CC_VF(DT,m,temp_dummy,ISP,MFP,test_symmetry,export_operator)
         call export_laplacian_Face_VF(DT,m,temp_dummy,ISP,MFP,test_symmetry,export_operator)

         call export_curlcurl_CC_VF(DT,m,temp_dummy,ISP,MFP,test_symmetry,export_operator)
         call export_curlcurl_Face_VF(DT,m,temp_dummy,ISP,MFP,test_symmetry,export_operator)

         call delete(m)
         call delete(temp_dummy)
         call delete(ISP)
         call delete(MFP)
         stop 'exported matrix visualization. Done in matrix_vis.f90'
       end subroutine

       subroutine matrix_visualization_mesh(m)
         implicit none
         type(mesh),intent(inout) :: m
         type(mesh_quality_params) :: MQP
         type(grid) :: g
         real(cp),dimension(3) :: hmin,hmax,beta
         integer,dimension(3) :: N
         integer :: i
         call init(MQP,.false.,2.0_cp,50)
         call delete(m)
         N = 3; hmin = -0.5_cp; hmax = 0.5_cp
         beta = 1.1_cp
         i = 1; call grid_Roberts_B(g,hmin(i),hmax(i),N(i),beta(i),i,MQP)
         i = 2; call grid_Roberts_B(g,hmin(i),hmax(i),N(i),beta(i),i,MQP)
         i = 3; call grid_Roberts_B(g,hmin(i),hmax(i),N(i),beta(i),i,MQP)
         call add(m,g)
         call init_props(m)
         call patch(m)
         call delete(g)
       end subroutine

       subroutine prep_BCs_SF(X,m)
         implicit none
         type(SF),intent(inout) :: X
         type(mesh),intent(inout) :: m
         call init_BC_mesh(X,m)
         call Dirichlet_BCs(X,m)
       end subroutine

       subroutine prep_BCs_VF(X,m)
         implicit none
         type(VF),intent(inout) :: X
         type(mesh),intent(inout) :: m
         call init_BC_mesh(X,m)
         call Dirichlet_BCs(X,m)
       end subroutine

       subroutine export_laplacian_CC_SF(DT,m,temp_dummy,ISP,MFP,test_symmetry,export_operator)
         implicit none
         type(dir_tree),intent(in) :: DT
         type(mesh),intent(inout) :: m
         type(TF),intent(inout) :: temp_dummy
         type(iter_solver_params),intent(inout) :: ISP
         type(matrix_free_params),intent(inout) :: MFP
         logical,intent(in) :: test_symmetry,export_operator
         type(PCG_solver_SF) :: PCG
         type(SF) :: X
         call init_CC(X,m); call assign(X,1.0_cp)
         call init_Face(temp_dummy,m); call assign(temp_dummy,1.0_cp)
         call prep_BCs_SF(X,m)
         call init(PCG,Lap_uniform_SF,Lap_uniform_SF_explicit,prec_Lap_SF,m,&
         ISP,MFP,X,X,temp_dummy,str(DT%matrix_visualization),'Lap_CC',&
         test_symmetry,export_operator)
         call delete(temp_dummy)
         call delete(X)
         call delete(PCG)
       end subroutine

       subroutine export_laplacian_CC_VF(DT,m,temp_dummy,ISP,MFP,test_symmetry,export_operator)
         implicit none
         type(dir_tree),intent(in) :: DT
         type(mesh),intent(inout) :: m
         type(TF),intent(inout) :: temp_dummy
         type(iter_solver_params),intent(inout) :: ISP
         type(matrix_free_params),intent(inout) :: MFP
         logical,intent(in) :: test_symmetry,export_operator
         type(PCG_solver_VF) :: PCG
         type(VF) :: X
         call init_CC(X,m); call assign(X,1.0_cp)
         call init_Face(temp_dummy,m); call assign(temp_dummy,1.0_cp)
         call prep_BCs_VF(X,m)
         call init(PCG,Lap_uniform_VF,Lap_uniform_VF_explicit,prec_Lap_VF,m,&
         ISP,MFP,X,X,temp_dummy,str(DT%matrix_visualization),'Lap_CC',&
         test_symmetry,export_operator)
         call delete(temp_dummy)
         call delete(X)
         call delete(PCG)
       end subroutine

       subroutine export_laplacian_Face_VF(DT,m,temp_dummy,ISP,MFP,test_symmetry,export_operator)
         implicit none
         type(dir_tree),intent(in) :: DT
         type(mesh),intent(inout) :: m
         type(TF),intent(inout) :: temp_dummy
         type(iter_solver_params),intent(inout) :: ISP
         type(matrix_free_params),intent(inout) :: MFP
         logical,intent(in) :: test_symmetry,export_operator
         type(PCG_solver_VF) :: PCG
         type(VF) :: X
         call init_Face(X,m); call assign(X,1.0_cp)
         call init_CC_Edge(temp_dummy,m); call assign(temp_dummy,1.0_cp)
         call prep_BCs_VF(X,m)
         call init(PCG,mom_diffusion,mom_diffusion_explicit,prec_mom_VF,m,&
         ISP,MFP,X,X,temp_dummy,str(DT%matrix_visualization),'Lap_Face',&
         test_symmetry,export_operator)
         call delete(temp_dummy)
         call delete(X)
         call delete(PCG)
       end subroutine

       subroutine export_curlcurl_CC_VF(DT,m,temp_dummy,ISP,MFP,test_symmetry,export_operator)
         implicit none
         type(dir_tree),intent(in) :: DT
         type(mesh),intent(inout) :: m
         type(TF),intent(inout) :: temp_dummy
         type(iter_solver_params),intent(inout) :: ISP
         type(matrix_free_params),intent(inout) :: MFP
         logical,intent(in) :: test_symmetry,export_operator
         type(PCG_solver_VF) :: PCG
         type(VF) :: X
         call init_CC(X,m); call assign(X,1.0_cp)
         call init_CC(temp_dummy,m); call assign(temp_dummy,1.0_cp)
         call prep_BCs_VF(X,m)
         call init(PCG,ind_diffusion,ind_diffusion_explicit,prec_ind_VF,m,&
         ISP,MFP,X,X,temp_dummy,str(DT%matrix_visualization),'curlcurl_CC',&
         test_symmetry,export_operator)
         call delete(temp_dummy)
         call delete(X)
         call delete(PCG)
       end subroutine

       subroutine export_curlcurl_Face_VF(DT,m,temp_dummy,ISP,MFP,test_symmetry,export_operator)
         implicit none
         type(dir_tree),intent(in) :: DT
         type(mesh),intent(inout) :: m
         type(TF),intent(inout) :: temp_dummy
         type(iter_solver_params),intent(inout) :: ISP
         type(matrix_free_params),intent(inout) :: MFP
         logical,intent(in) :: test_symmetry,export_operator
         type(PCG_solver_VF) :: PCG
         type(VF) :: X
         call init_Face(X,m); call assign(X,1.0_cp)
         call init_Edge(temp_dummy,m); call assign(temp_dummy,1.0_cp)
         call prep_BCs_VF(X,m)
         call init(PCG,ind_diffusion,ind_diffusion_explicit,prec_ind_VF,m,&
         ISP,MFP,X,X,temp_dummy,str(DT%matrix_visualization),'curlcurl_Face',&
         test_symmetry,export_operator)
         call delete(temp_dummy)
         call delete(X)
         call delete(PCG)
       end subroutine

       end module
       module operator_commute_test_mod
       use current_precision_mod
       use constants_mod
       use mesh_extend_mod
       use GF_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use dir_tree_mod
       use string_mod
       use path_extend_mod
       use path_extend_mod
       use export_raw_processed_mod
       use ops_discrete_mod
       use ops_norms_mod
       use PCG_solver_extend_mod
       use apply_BCs_mod
       use matrix_free_operators_mod
       use matrix_free_params_mod
       use preconditioners_mod
       use iter_solver_params_mod
       use ops_mirror_field_mod
       use sim_params_mod
       use BC_funcs_mod

       implicit none
       private

       public :: operator_commute_test

       contains

       subroutine operator_commute_test(U,p,m,DT)
         ! This performs the test to ensure that
         ! G(L(X)) = L(G(X))
         ! where G,L are the gradient and linear (laplacian/curl-curl) operators
         implicit none
         type(VF),intent(in) :: U
         type(SF),intent(in) :: p
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         write(*,*) ' ************************************************************* '
         write(*,*) ' *********** BEGIN OPERATOR INTERCHANGABILITY TEST *********** '
         write(*,*) ' ************************************************************* '
         call grad_laplacian(U,p,m,DT)
         call curl_grad_equal_zero(U,p,m,DT) ! Just need to make sure zero by identity
         write(*,*) ' ************************************************************ '
         write(*,*) ' ************ END OPERATOR INTERCHANGABILITY TEST *********** '
         write(*,*) ' ************************************************************ '
       end subroutine

       subroutine grad_laplacian(U,p,m,DT)
         implicit none
         type(VF),intent(in) :: U
         type(SF),intent(in) :: p
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         type(SF) :: phi,temp_SF
         type(VF) :: temp_VF,temp_LG,temp_GL
         type(TF) :: temp_TF
         real(cp) :: e
         call init(phi,P);             call assign(phi,0.0_cp)
         call init(temp_SF,P);         call assign(temp_SF,0.0_cp)
         call init(temp_VF,U);         call assign(temp_VF,0.0_cp)
         call init(temp_LG,U);         call assign(temp_LG,0.0_cp)
         call init(temp_GL,U);         call assign(temp_GL,0.0_cp)
         call init_CC_Edge(temp_TF,m); call assign(temp_TF,0.0_cp)
         call random_noise(phi)
         call assign_ghost_XPeriodic(phi,0.0_cp)

         call lap_centered(temp_SF,phi,m,temp_VF)
         call grad(temp_LG,temp_SF,m)

         call grad(temp_VF,phi,m)
         call lap_centered(temp_GL,temp_VF,m,temp_TF)

         call subtract(temp_GL,temp_LG)
         call assign_ghost_XPeriodic(temp_GL,0.0_cp)

         call export_raw(m,temp_GL,str(DT%test%field),'temp_GL',0)

         call compute_Ln(e,temp_GL,2.0_cp,m)
         write(*,*) 'error grad_laplacian = ',e
         call delete(phi)
         call delete(temp_SF)
         call delete(temp_VF)
         call delete(temp_LG)
         call delete(temp_GL)
         call delete(temp_TF)
       end subroutine

       subroutine curl_grad_equal_zero(U,p,m,DT)
         implicit none
         type(VF),intent(in) :: U
         type(SF),intent(in) :: p
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         type(SF) :: phi
         type(VF) :: temp_F,temp_E
         real(cp) :: e
         call init(phi,P);         call assign(phi,0.0_cp)
         call init(temp_F,U);      call assign(temp_F,0.0_cp)
         call init_Edge(temp_E,m); call assign(temp_E,0.0_cp)

         call random_noise(phi)

         call grad(temp_F,phi,m)
         call curl(temp_E,temp_F,m)
         call assign_ghost_XPeriodic(temp_E,0.0_cp)

         call export_raw(m,temp_E,str(DT%test%field),'temp_E',0)

         call compute_Ln(e,temp_E,2.0_cp,m)
         write(*,*) 'error curl_grad_equal_zero = ',e
         call delete(phi)
         call delete(temp_F)
         call delete(temp_E)
       end subroutine

       end module
       module temporal_convergence_test_mod
       use current_precision_mod
       use constants_mod
       use mesh_extend_mod
       use GF_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use dir_tree_mod
       use string_mod
       use path_extend_mod
       use export_raw_processed_mod
       use ops_discrete_mod
       use ops_norms_mod
       use PCG_solver_extend_mod
       use apply_BCs_mod
       use matrix_free_operators_mod
       use matrix_free_params_mod
       use preconditioners_mod
       use iter_solver_params_mod
       use ops_mirror_field_mod
       use sim_params_mod
       use BC_funcs_mod

       implicit none
       private

       public :: temporal_convergence_test

       contains

       subroutine temporal_convergence_test(U,P,m,DT,SP)
         implicit none
         type(VF),intent(in) :: U
         type(SF),intent(in) :: P
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         type(sim_params),intent(in) :: SP
         real(cp) :: e,dtime
         dtime = SP%VS%U%TMP%TS%dt
         write(*,*) ' *********************************************************** '
         write(*,*) ' ************* BEGIN TEMPORAL CONVERGENCE TEST ************* '
         write(*,*) ' *********************************************************** '
         write(*,*) 'DT%params = ',str(DT%params)
         write(*,*) 't = ',SP%VS%U%TMP%t
         call compute_Ln(e,U,2.0_cp,m); write(*,*) 'dt,e(U) = ',dtime,e
         call compute_Ln(e,P,2.0_cp,m); write(*,*) 'dt,e(P) = ',dtime,e
         write(*,*) ' *********************************************************** '
         write(*,*) ' ************** END TEMPORAL CONVERGENCE TEST ************** '
         write(*,*) ' *********************************************************** '
       end subroutine

       end module
       module vorticity_streamfunction_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use dir_tree_mod
       use string_mod
       use path_extend_mod
       use path_extend_mod
       use export_raw_processed_mod
       use ops_discrete_mod
       use PCG_solver_extend_mod
       use matrix_free_operators_mod
       use matrix_free_params_mod
       use preconditioners_mod
       use iter_solver_params_mod
       use ops_mirror_field_mod
       use sim_params_mod
       use BC_funcs_mod

       implicit none
       private

       public :: export_vorticity_streamfunction

       contains

       subroutine compute_vorticity_streamfunction(PCG,psi,omega,U,m,compute_norms)
         implicit none
         type(PCG_solver_VF),intent(inout) :: PCG
         type(VF),intent(inout) :: psi,omega
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         logical,intent(in) :: compute_norms
         call curl(omega,U,m)
         call multiply(omega,-1.0_cp)
         call solve(PCG,psi,omega,m,compute_norms)
       end subroutine

       subroutine export_vorticity_streamfunction(U,m,DT,SP)
         implicit none
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         type(sim_params),intent(in) :: SP
         type(VF) :: U_temp
         type(mesh) :: m_temp
         write(*,*) ' COMPUTING VORTICITY-STREAMFUNCTION:'
         if (SP%EL%export_symmetric) then
         call mirror_field(m_temp,U_temp,m,U,SP%MP)
         call export_vorticity_streamfunction_wrapper(U_temp,m_temp,DT,SP)
         call delete(U_temp)
         call delete(m_temp)
         else; call export_vorticity_streamfunction_wrapper(U,m,DT,SP)
         endif
       end subroutine

       subroutine export_vorticity_streamfunction_wrapper(U,m,DT,SP)
         implicit none
         type(VF),intent(in) :: U
         type(mesh),intent(in) :: m
         type(dir_tree),intent(in) :: DT
         type(sim_params),intent(in) :: SP
         type(VF) :: psi,omega
         type(TF) :: temp_dummy
         type(PCG_solver_VF) :: PCG
         type(iter_solver_params) :: ISP
         type(matrix_free_params) :: MFP
         real(cp),dimension(6) :: c_w,Robin_coeff
         call init(ISP,10000,pow(-15),pow(-15),1,.true.,.true.)
         call init(ISP%dir,str(DT%ISP))
         call init(ISP%name,'vorticity_streamfunction')

         call init_Edge(omega,m)
         call init_Edge(psi,m)
         call init_Node_Face(temp_dummy,m)
         call init_BC_mesh(psi%x,m)
         call init_BC_mesh(psi%y,m)
         call init_BC_mesh(psi%z,m)
         call Dirichlet_BCs(psi,m)
         Robin_coeff = 0.0_cp
         c_w = 0.0_cp
         call init_BC_props(psi,c_w,Robin_coeff)
         call make_periodic(psi,m,SP%GP%periodic_dir)

         ! Make sure that Lap_uniform_VF does not
         call init(PCG,Lap_uniform_VF,Lap_uniform_VF_explicit,prec_Lap_VF,m,&
         ISP,MFP,psi,psi,temp_dummy,str(DT%U%residual),'streamfunction',.false.,.false.)

         call compute_vorticity_streamfunction(PCG,psi,omega,U,m,.true.)

         call export_processed(m,psi  ,str(DT%U%field),'streamfunction',1)
         call export_processed(m,omega,str(DT%U%field),'vorticity'     ,1)

         call delete(omega)
         call delete(temp_dummy)
         call delete(psi)
         call delete(PCG)
         call delete(ISP)
         call delete(MFP)
       end subroutine

       end module
       module add_all_energy_sources_mod
       use current_precision_mod
       use sim_params_mod
       use SF_extend_mod
       use IO_tools_mod
       use time_marching_params_mod
       use ops_embedExtract_mod

       use energy_mod
       use momentum_mod
       use induction_mod
       use energy_aux_mod
       use energy_sources_mod
       implicit none

       private
       public :: add_all_energy_sources

       contains

       subroutine add_all_energy_sources(F,Fnm1,L,nrg,TMP,SP,ind,mom)
         implicit none
         type(SF),intent(inout) :: F,Fnm1,L
         type(energy),intent(inout) :: nrg
         type(momentum),intent(in) :: mom
         type(induction),intent(inout) :: ind
         type(time_marching_params),intent(in) :: TMP
         type(sim_params),intent(in) :: SP

         if (SP%ET%KE_diffusion%add.or.SP%ET%viscous_dissipation%add) then
           call embedCC(nrg%U_CC,mom%U_CC,nrg%MD)
         endif

         call assign(Fnm1,F)
         if (TMP%RKP%RK_active) call assign(L,0.0_cp)
         call assign(F,0.0_cp) ! DO NOT REMOVE THIS, FOLLOW THE COMPUTE_ADD PROCEDURE BELOW

         if (SP%ET%advection%add) then
           call embedFace(nrg%U_F,mom%U,nrg%MD)
           call add_advection(F,nrg%T,nrg%U_F,SP%ET%advection%scale,&
           nrg%m,nrg%temp_CC1,nrg%temp_F)
         endif
         if (SP%ET%diffusion%add) then
           if (TMP%RKP%RK_active) then
             call add_diffusion(L,nrg%T,SP%ET%diffusion%scale,nrg%m,nrg%temp_CC1)
           else
             call add_diffusion(F,nrg%T,SP%ET%diffusion%scale,nrg%m,nrg%temp_CC1)
           endif
         endif

         if (SP%ET%KE_diffusion%add) then
           call add_KE_diffusion(F,nrg%U_CC,SP%ET%KE_diffusion%scale,&
           nrg%m,nrg%temp_CC1,nrg%temp_CC2,nrg%temp_CC1_VF)
         endif
         if (SP%ET%viscous_dissipation%add) then
           call add_viscous_dissipation(F,nrg%U_CC,SP%ET%viscous_dissipation%scale,&
           nrg%m,nrg%temp_CC1,nrg%temp_CC_TF)
         endif
         if (SP%ET%joule_heating%add) then
           call add_joule_heating(F,ind%J,ind%sigmaInv_CC,SP%ET%joule_heating%scale,&
           nrg%m,nrg%temp_CC1,nrg%temp_F,nrg%temp_CC1_VF)
         endif
         if (SP%ET%volumetric_heating%add) then
           call add_volumetric_heating_Nuclear(F,nrg%m,&
           SP%ET%volumetric_heating%scale,nrg%temp_CC1)
         endif

       end subroutine

       end module
       module induction_solver_mod
       ! Constrained Transport (CT) Method reference:
       ! "Tóth, G. The divergence Constraint in Shock-Capturing
       ! MHD Codes. J. Comput. Phys. 161, 605–652 (2000)."
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use curl_curl_B_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use ops_advect_mod
       use ops_norms_mod
       use apply_BCs_mod
       use norms_extend_mod
       use AB2_mod
       use compute_energy_mod
       use matrix_free_params_mod
       use PCG_solver_extend_mod
       use Jacobi_mod
       use induction_aux_mod
       use export_raw_processed_mod
       use clean_divergence_mod
       use mesh_domain_extend_mod
       use ops_embedExtract_mod
       use time_marching_params_mod

       implicit none

       private

       ! Explicit time marching methods (CT methods)
       public :: CT_Finite_Rem_perfect_vacuum
       public :: CT_Finite_Rem_interior_solved
       public :: JAC_interior_solved

       contains

       subroutine CT_Finite_Rem_interior_solved(PCG_cleanB,B,B0,Bstar,J,B_interior,U_E,curlE,&
         phi,m,MD_sigma,TMP,Rem,compute_norms,SF_CC,temp_F1,temp_F2,curlUCrossB,temp_E,temp_E_TF)
         ! Solves:  ∂B/∂t = ∇•∇B,  in vacuum domain, where B_interior is fixed.
         ! Note:    J = Rem⁻¹∇xB    -> J ALREADY HAS Rem⁻¹ !
         ! Method:  Constrained Transport (CT)
         ! Info:    Cell face => B,cell edge => J,sigmaInv_E,U_E,Finite Rem
         implicit none
         type(PCG_solver_SF),intent(inout) :: PCG_cleanB
         type(VF),intent(inout) :: B,Bstar,J,temp_F1,temp_F2,curlUCrossB,temp_E,curlE
         type(VF),intent(in) :: B0,B_interior
         type(SF),intent(inout) :: SF_CC,phi
         type(TF),intent(in) :: U_E
         type(TF),intent(inout) :: temp_E_TF
         type(mesh_domain),intent(in) :: MD_sigma
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         logical,intent(in) :: compute_norms
         real(cp),intent(in) :: Rem
         integer :: i
         if (TMP%n_step.le.1) then
           call compute_J(J,B,Rem,m)
           call add(temp_F2,B,B0)
           call advect_B(curlUCrossB,U_E,temp_F2,m,temp_E_TF,temp_E)
           call curl(curlE,J,m)
           call subtract(curlE,curlUCrossB)
         endif
         do i=1,TMP%multistep_iter
           call multiply(temp_F1,curlE,-TMP%TS%dt)
           call add(B,temp_F1)
           call apply_BCs(B)
           call embedFace(B,B_interior,MD_sigma)
         enddo
         call clean_div(PCG_cleanB,B,Bstar,phi,1.0_cp/TMP%TS%dt,m,temp_F1,SF_CC,compute_norms)
         call embedFace(B,B_interior,MD_sigma)
       end subroutine

       subroutine JAC_interior_solved(JAC,PCG_cleanB,B,Bstar,RHS,phi,m,&
         N_multistep,N_induction,dt,compute_norms,SF_CC,temp_F1)
         ! Solves: ∇•(∇B) = 0 using Jacobi method + cleaning procedure
         implicit none
         type(Jacobi),intent(inout) :: JAC
         type(PCG_solver_SF),intent(inout) :: PCG_cleanB
         type(VF),intent(inout) :: B,Bstar
         type(VF),intent(in) :: RHS
         type(SF),intent(inout) :: SF_CC,phi
         type(VF),intent(inout) :: temp_F1
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: dt
         integer,intent(in) :: N_multistep,N_induction
         logical,intent(in) :: compute_norms
         integer :: i
         do i=1,N_multistep
           call solve(JAC,B,RHS,m,N_induction,.true.)
           call clean_div(PCG_cleanB,B,Bstar,phi,1.0_cp/dt,m,temp_F1,SF_CC,compute_norms)
         enddo
       end subroutine

       subroutine CT_Finite_Rem_perfect_vacuum(PCG_B,PCG_cleanB,B,Bstar,B0,U_E,J,m,&
         D_conductor,dt,compute_norms,temp_CC,temp_F1,&
         temp_F2,temp_E,temp_E_TF,phi)
         ! This has not yet been tested and is likely flawed currently.
         !
         ! Solves:    ∂B/∂t = ∇x(ux(B⁰+B)) - Rem⁻¹∇x(σ⁻¹∇xB)
         ! Computes:  B (above)
         ! Note:      J = Rem⁻¹∇xB    -> J ALREADY HAS Rem⁻¹ !
         ! Method:    Constrained Transport (CT)
         ! Info:      cell face => B,B0,cell edge => J,sigmaInv_E,U_E,Finite Rem
         implicit none
         type(PCG_solver_VF),intent(inout) :: PCG_B
         type(PCG_solver_SF),intent(inout) :: PCG_cleanB
         type(VF),intent(inout) :: B,Bstar,temp_E,temp_F1,temp_F2
         type(SF),intent(inout) :: temp_CC,phi
         type(VF),intent(in) :: B0,J
         type(TF),intent(inout) :: temp_E_TF
         type(TF),intent(in) :: U_E
         type(mesh),intent(in) :: m
         real(cp),intent(in) :: dt
         type(mesh_domain),intent(in) :: D_conductor
         logical,intent(in) :: compute_norms
         type(VF) :: temp
         call add(temp_F2,B,B0) ! Since finite Rem
         call advect_B(temp_F1,U_E,temp_F2,m,temp_E_TF,temp_E)
         call assign(temp_E,J)
         call curl(temp_F2,temp_E,m)
         call subtract(temp_F1,temp_F2)
         call multiply(temp_F1,dt)
         call add(B,temp_F1)
         ! Solve for B in vacuum by Poisson equation:
         call div(temp_CC,B,m)
         call grad(temp_F1,temp_CC,m)
         call assign(temp_F2,B)
         call solve(PCG_B,B,temp_F1,m,compute_norms)
         call init_Face(temp,m,D_conductor)
         call extractFace(temp,temp_F2,D_conductor)
         call embedFace(B,temp,D_conductor)
         call delete(temp)
         call clean_div(PCG_cleanB,B,Bstar,phi,1.0_cp/dt,m,temp_F1,temp_CC,compute_norms)
       end subroutine

       end module
       module time_marching_methods_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use norms_extend_mod
       use string_mod
       use AB2_mod
       use compute_energy_mod
       use export_raw_processed_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use ops_advect_mod
       use ops_norms_mod
       use apply_BCs_mod
       use PCG_solver_extend_mod
       use FFT_solver_extend_mod
       use matrix_free_operators_mod
       use matrix_free_params_mod
       use RK_Params_mod
       use clean_divergence_mod
       use time_marching_params_mod

       implicit none
       private

       public :: Euler_time_Euler_sources
       public :: O2_BDF_time_AB2_sources
       public :: Euler_time_AB2_sources
       public :: Euler_time_AB2_sources_FFT
       public :: Euler_time_RK_sources

       public :: Euler_time_no_diff_AB2_sources
       public :: Euler_time_no_diff_AB2_sources_no_correction
       public :: Euler_time_no_diff_Euler_sources
       public :: Euler_time_no_diff_Euler_sources_no_correction

       real(cp),parameter :: two_thirds = 2.0_cp/3.0_cp
       real(cp),parameter :: four_thirds = 4.0_cp/3.0_cp
       real(cp),parameter :: neg_one_third = -1.0_cp/3.0_cp
       real(cp),parameter :: three_halfs = 3.0_cp/2.0_cp

       contains

       subroutine Euler_time_Euler_sources(PCG_VF,PCG_SF,X,Xstar,Xnm1,phi,F,m,&
         TMP,temp_F1,temp_CC,compute_norms)
         ! Solves:
         !
         !  X^{*} - X^{n}
         ! -------------- + AX^{*} = F^{n}
         !        dt
         !
         ! -->  (I + dt 1 A)X^{*} = X^{n} + dt F^{n}
         !
         ! lap(phi^{n+1}) = 1/dt div(X^{*})
         ! X^{n+1} = X^{*} - dt grad(phi^{n+1})
         !
         implicit none
         type(PCG_solver_VF),intent(inout) :: PCG_VF
         type(PCG_solver_SF),intent(inout) :: PCG_SF
         type(SF),intent(inout) :: phi,temp_CC
         type(VF),intent(inout) :: X,Xstar,Xnm1
         type(VF),intent(in) :: F
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         type(VF),intent(inout) :: temp_F1
         logical,intent(in) :: compute_norms
         call assign(temp_F1,F)
         call multiply(temp_F1,TMP%TS%dt)
         call assign_wall_Dirichlet(temp_F1,0.0_cp,X)
         call add(temp_F1,X)
         call assign(Xnm1,X)
         call update_MFP(PCG_VF,m,TMP%TS%dt*1.0_cp*PCG_VF%MFP%coeff_implicit,TMP%n_step.le.2)
         call solve(PCG_VF,Xstar,temp_F1,m,compute_norms) ! Solve for X*
         ! call clean_div(PCG_SF,X,Xstar,phi,1.0_cp/TMP%TS%dt,m,temp_F1,temp_CC,compute_norms)
         call clean_div(PCG_SF,X,Xstar,phi,1.0_cp,m,temp_F1,temp_CC,compute_norms)
       end subroutine

       subroutine O2_BDF_time_AB2_sources(PCG_VF,PCG_SF,X,Xstar,Xnm1,phi,F,Fnm1,m,&
         TMP,temp_F1,temp_CC,compute_norms)
         ! Solves:
         !
         !  3X^{*} - 4X^{n} + X^{n-1}
         ! -------------------------- + AX^{*} = AB2(F^{n},F^{n-1})
         !            2 dt
         !
         ! -->  (I + 2/3*dt A)X^{*} = 4/3X^{n} - 1/3 X^{n-1} + 2/3 dt AB2(F^{n},F^{n-1})
         !
         ! lap(phi^{n+1}) = 3/(2 dt) div(X^{*})
         ! X^{n+1} = X^{*} - 2/3 dt grad(phi^{n+1})
         !
         implicit none
         type(PCG_solver_VF),intent(inout) :: PCG_VF
         type(PCG_solver_SF),intent(inout) :: PCG_SF
         type(SF),intent(inout) :: phi
         type(VF),intent(inout) :: X,Xstar,Xnm1
         type(VF),intent(in) :: F,Fnm1
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         type(VF),intent(inout) :: temp_F1
         type(SF),intent(inout) :: temp_CC
         logical,intent(in) :: compute_norms
         call AB2(temp_F1,F,Fnm1)
         call multiply(temp_F1,two_thirds*TMP%TS%dt)
         call assign_wall_Dirichlet(temp_F1,0.0_cp,X)
         call add_product(temp_F1,X,four_thirds)
         call add_product(temp_F1,Xnm1,neg_one_third)
         call assign(Xnm1,X)
         call update_MFP(PCG_VF,m,TMP%TS%dt*two_thirds*PCG_VF%MFP%coeff_implicit,TMP%n_step.le.2)
         call solve(PCG_VF,Xstar,temp_F1,m,compute_norms) ! Solve for X*
         ! call clean_div(PCG_SF,X,Xstar,phi,three_halfs/TMP%TS%dt,m,temp_F1,temp_CC,compute_norms)
         call clean_div(PCG_SF,X,Xstar,phi,1.0_cp,m,temp_F1,temp_CC,compute_norms)
       end subroutine

       subroutine Euler_time_AB2_sources(PCG_VF,PCG_SF,X,Xstar,Xnm1,phi,F,Fnm1,m,&
         TMP,temp_F1,L,temp_CC,compute_norms)
         ! Solves:
         !
         !  X^{*} - X^{n}
         ! -------------- + AX^{*} = AB2(F^{n},F^{n-1})
         !        dt
         !
         ! -->  (I + dt 1 A)X^{*} = X^{n} + dt AB2(F^{n},F^{n-1})
         !
         ! lap(phi^{n+1}) = 1/dt div(X^{*})
         ! X^{n+1} = X^{*} - dt grad(phi^{n+1})
         !
         implicit none
         type(PCG_solver_VF),intent(inout) :: PCG_VF
         type(PCG_solver_SF),intent(inout) :: PCG_SF
         type(SF),intent(inout) :: phi
         type(VF),intent(inout) :: X,Xstar,Xnm1,L
         type(VF),intent(in) :: F,Fnm1
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         type(VF),intent(inout) :: temp_F1
         type(SF),intent(inout) :: temp_CC
         logical,intent(in) :: compute_norms
         call AB2(temp_F1,F,Fnm1)
         call add(temp_F1,L)
         call multiply(temp_F1,TMP%TS%dt)
         call assign_wall_Dirichlet(temp_F1,0.0_cp,X)
         call add(temp_F1,X)
         call assign(Xnm1,X)
         call update_MFP(PCG_VF,m,TMP%TS%dt*1.0_cp*PCG_VF%MFP%coeff_implicit,.true.)
         call solve(PCG_VF,Xstar,temp_F1,m,compute_norms) ! Solve for X*
         call clean_div(PCG_SF,X,Xstar,phi,1.0_cp/TMP%TS%dt,m,temp_F1,temp_CC,compute_norms)
       end subroutine

       subroutine Euler_time_AB2_sources_FFT(PCG_VF,FFT_SF,X,Xstar,Xnm1,phi,F,Fnm1,m,&
         TMP,temp_F1,L,temp_CC,compute_norms)
         ! Solves:
         !
         !  X^{*} - X^{n}
         ! -------------- + AX^{*} = AB2(F^{n},F^{n-1})
         !        dt
         !
         ! -->  (I + dt 1 A)X^{*} = X^{n} + dt AB2(F^{n},F^{n-1})
         !
         ! lap(phi^{n+1}) = 1/dt div(X^{*})
         ! X^{n+1} = X^{*} - dt grad(phi^{n+1})
         !
         implicit none
         type(PCG_solver_VF),intent(inout) :: PCG_VF
         type(FFT_solver_SF),intent(inout) :: FFT_SF
         type(SF),intent(inout) :: phi
         type(VF),intent(inout) :: X,Xstar,Xnm1,L
         type(VF),intent(in) :: F,Fnm1
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         type(VF),intent(inout) :: temp_F1
         type(SF),intent(inout) :: temp_CC
         logical,intent(in) :: compute_norms
         call AB2(temp_F1,F,Fnm1)
         call add(temp_F1,L)
         call multiply(temp_F1,TMP%TS%dt)
         call assign_wall_Dirichlet(temp_F1,0.0_cp,X)
         call add(temp_F1,X)
         call assign(Xnm1,X)
         call update_MFP(PCG_VF,m,TMP%TS%dt*1.0_cp*PCG_VF%MFP%coeff_implicit,.true.)
         call solve(PCG_VF,Xstar,temp_F1,m,compute_norms) ! Solve for X*
         call clean_div(FFT_SF,X,Xstar,phi,1.0_cp/TMP%TS%dt,m,temp_F1,temp_CC,compute_norms)
       end subroutine

       subroutine Euler_time_RK_sources(PCG_VF,PCG_SF,X,Xstar,Xnm1,phi,F,Fnm1,L,m,&
         TMP,RKP,temp_F1,temp_CC,compute_norms)
         ! Time discretization adopted from:
         ! Lundbladh, Anders, et al. "An efficient spectral method for
         ! simulation of incompressible flow over a flat plate."
         ! Trita-mek. Tech. Rep 11 (1999).
         !
         ! Solves:
         !
         !  X^{*} - X^{n}
         ! -------------- + AX^{*} = RK(F^{n})
         !        dt
         !
         ! -->  (I + dt 1 A)X^{*} = X^{n} + dt RK(F^{n})
         !
         ! lap(phi^{n+1}) = 1/dt div(X^{*})
         ! X^{n+1} = X^{*} - dt grad(phi^{n+1})
         !
         implicit none
         type(PCG_solver_VF),intent(inout) :: PCG_VF
         type(PCG_solver_SF),intent(inout) :: PCG_SF
         type(SF),intent(inout) :: phi
         type(VF),intent(inout) :: X,Xstar,Xnm1
         type(VF),intent(in) :: F,Fnm1,L
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         type(RK_Params),intent(in) :: RKP
         type(VF),intent(inout) :: temp_F1
         type(SF),intent(inout) :: temp_CC
         logical,intent(in) :: compute_norms
         call multiply(temp_F1,F      ,TMP%TS%dt*RKP%gamma%f(RKP%n))
         call add_product(temp_F1,Fnm1,TMP%TS%dt*RKP%zeta%f(RKP%n))
         ! call add_product(temp_F1,L   ,TMP%TS%dt*RKP%alpha%f(RKP%n))
         call add_product(temp_F1,L   ,TMP%TS%dt*2.0_cp*RKP%alpha%f(RKP%n))
         call assign_wall_Dirichlet(temp_F1,0.0_cp,X)
         call add(temp_F1,X)
         call assign(Xnm1,X)
         ! call update_MFP(PCG_VF,m,TMP%TS%dt*RKP%d%f(RKP%n)*PCG_VF%MFP%coeff_implicit,.true.)
         call update_MFP(PCG_VF,m,TMP%TS%dt*2.0_cp*RKP%beta%f(RKP%n)*PCG_VF%MFP%coeff_implicit,.true.)
         call solve(PCG_VF,Xstar,temp_F1,m,compute_norms) ! Solve for X*
         ! call clean_div(PCG_SF,X,Xstar,phi,1.0_cp/TMP%TS%dt,m,temp_F1,temp_CC,compute_norms)
         call clean_div(PCG_SF,X,Xstar,phi,1.0_cp,m,temp_F1,temp_CC,compute_norms)
         ! call clean_div(PCG_SF,X,Xstar,phi,1.0_cp/(TMP%TS%dt*RKP%gamma%f(RKP%n)),m,temp_F1,temp_CC,compute_norms)
       end subroutine

       subroutine RK_method_1(PCG_VF,PCG_SF,X,Xstar,Xnm1,phi,F,Fnm1,L,m,&
         TMP,RKP,temp_F1,temp_CC,compute_norms)
         implicit none
         type(PCG_solver_VF),intent(inout) :: PCG_VF
         type(PCG_solver_SF),intent(inout) :: PCG_SF
         type(SF),intent(inout) :: phi
         type(VF),intent(inout) :: X,Xstar,Xnm1
         type(VF),intent(in) :: F,Fnm1,L
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         type(RK_Params),intent(in) :: RKP
         type(VF),intent(inout) :: temp_F1
         type(SF),intent(inout) :: temp_CC
         logical,intent(in) :: compute_norms
         call multiply(temp_F1,F      ,two_thirds)
         call multiply(temp_F1,F      ,TMP%TS%dt*RKP%gamma%f(RKP%n))
         call add_product(temp_F1,Fnm1,TMP%TS%dt*RKP%zeta%f(RKP%n))
         ! call add_product(temp_F1,L   ,TMP%TS%dt*RKP%alpha%f(RKP%n))
         call add_product(temp_F1,L   ,TMP%TS%dt*2.0_cp*RKP%alpha%f(RKP%n))
         call assign_wall_Dirichlet(temp_F1,0.0_cp,X)
         call add(temp_F1,X)
         call assign(Xnm1,X)
         ! call update_MFP(PCG_VF,m,TMP%TS%dt*RKP%d%f(RKP%n)*PCG_VF%MFP%coeff_implicit,.true.)
         call update_MFP(PCG_VF,m,TMP%TS%dt*2.0_cp*RKP%beta%f(RKP%n)*PCG_VF%MFP%coeff_implicit,.true.)
         call solve(PCG_VF,Xstar,temp_F1,m,compute_norms) ! Solve for X*
         ! call clean_div(PCG_SF,X,Xstar,phi,1.0_cp/TMP%TS%dt,m,temp_F1,temp_CC,compute_norms)
         call clean_div(PCG_SF,X,Xstar,phi,1.0_cp,m,temp_F1,temp_CC,compute_norms)
         ! call clean_div(PCG_SF,X,Xstar,phi,1.0_cp/(TMP%TS%dt*RKP%gamma%f(RKP%n)),m,temp_F1,temp_CC,compute_norms)
       end subroutine

       ! **********************************************************************
       ! ******************** DIFFUSION EXPLICIT TIME MARCHING ****************
       ! **********************************************************************

       subroutine Euler_time_no_diff_AB2_sources(PCG_SF,X,Xstar,Xnm1,phi,F,Fnm1,m,TMP,&
         temp_F1,temp_CC,compute_norms)
         ! Solves:
         !
         !  X^{*} - X^{n}
         ! -------------- = AB2(F^{n},F^{n-1})
         !        dt
         !
         ! -->  X^{*} = X^{n} + dt AB2(F^{n},F^{n-1})
         !
         ! lap(phi^{n+1}) = 1/dt div(X^{*})
         ! X^{n+1} = X^{*} - dt grad(phi^{n+1})
         !
         implicit none
         type(PCG_solver_SF),intent(inout) :: PCG_SF
         type(SF),intent(inout) :: phi
         type(VF),intent(inout) :: X,Xnm1,Xstar
         type(VF),intent(in) :: F,Fnm1
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         type(VF),intent(inout) :: temp_F1
         type(SF),intent(inout) :: temp_CC
         logical,intent(in) :: compute_norms
         call AB2(Xstar,F,Fnm1)
         call multiply(Xstar,TMP%TS%dt)
         call assign_wall_Dirichlet(Xstar,0.0_cp,X)
         call add(Xstar,X)
         call assign(Xnm1,X)
         call clean_div(PCG_SF,X,Xstar,phi,1.0_cp,m,temp_F1,temp_CC,compute_norms)
         ! call clean_div(PCG_SF,X,Xstar,phi,1.0_cp/TMP%TS%dt,m,temp_F1,temp_CC,compute_norms)
       end subroutine

       subroutine Euler_time_no_diff_Euler_sources(PCG_SF,X,Xstar,Xnm1,phi,F,m,TMP,&
         temp_F1,temp_CC,compute_norms)
         ! Solves:
         !
         !  X^{*} - X^{n}
         ! -------------- = F^{n}
         !        dt
         !
         ! -->  X^{*} = X^{n} + dt AB2(F^{n},F^{n-1})
         !
         ! lap(phi^{n+1}) = 1/dt div(X^{*})
         ! X^{n+1} = X^{*} - dt grad(phi^{n+1})
         !
         implicit none
         type(PCG_solver_SF),intent(inout) :: PCG_SF
         type(SF),intent(inout) :: phi
         type(VF),intent(inout) :: X,Xnm1,Xstar
         type(VF),intent(in) :: F
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         type(VF),intent(inout) :: temp_F1
         type(SF),intent(inout) :: temp_CC
         logical,intent(in) :: compute_norms
         call multiply(Xstar,F,TMP%TS%dt)
         call assign_wall_Dirichlet(Xstar,0.0_cp,X)
         call add(Xstar,X)
         call assign(Xnm1,X)
         call clean_div(PCG_SF,X,Xstar,phi,1.0_cp,m,temp_F1,temp_CC,compute_norms)
         ! call clean_div(PCG_SF,X,Xstar,phi,1.0_cp/TMP%TS%dt,m,temp_F1,temp_CC,compute_norms)
       end subroutine

       subroutine Euler_time_no_diff_AB2_sources_no_correction(X,Xstar,F,Fnm1,TMP)
         ! Solves:
         !
         !  X^{n+1} - X^{n}
         ! ---------------- = AB2(F^{n},F^{n-1})
         !          dt
         !
         ! -->  X^{n+1} = X^{n} + dt AB2(F^{n},F^{n-1})
         !
         implicit none
         type(VF),intent(inout) :: X,Xstar
         type(VF),intent(in) :: F,Fnm1
         type(time_marching_params),intent(in) :: TMP
         call AB2(Xstar,F,Fnm1)
         call multiply(Xstar,TMP%TS%dt)
         call assign_wall_Dirichlet(Xstar,0.0_cp,X)
         call add(X,Xstar)
         call apply_BCs(X)
       end subroutine

       subroutine Euler_time_no_diff_Euler_sources_no_correction(X,Xstar,F,TMP)
         ! Solves:
         !
         !  X^{n+1} - X^{n}
         ! ---------------- = F^{n}
         !          dt
         !
         ! -->  X^{n+1} = X^{n} + dt F^{n}
         !
         implicit none
         type(VF),intent(inout) :: X,Xstar
         type(VF),intent(in) :: F
         type(time_marching_params),intent(in) :: TMP
         call multiply(Xstar,F,TMP%TS%dt)
         call assign_wall_Dirichlet(Xstar,0.0_cp,X)
         call add(X,Xstar)
         call apply_BCs(X)
       end subroutine

       end module
       module time_marching_methods_SF_mod
       use current_precision_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use norms_extend_mod
       use string_mod
       use AB2_mod
       use compute_energy_mod
       use export_raw_processed_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use ops_advect_mod
       use ops_norms_mod
       use apply_BCs_mod
       use PCG_solver_extend_mod
       use matrix_free_operators_mod
       use matrix_free_params_mod
       use RK_Params_mod
       use clean_divergence_mod
       use time_marching_params_mod

       implicit none
       private

       public :: O2_BDF_time_AB2_sources_SF
       public :: Euler_time_AB2_sources_SF
       public :: Euler_time_RK_sources_SF

       public :: Euler_time_no_diff_AB2_sources_SF
       public :: Euler_time_no_diff_Euler_sources_SF

       real(cp),parameter :: two_thirds = 2.0_cp/3.0_cp
       real(cp),parameter :: four_thirds = 4.0_cp/3.0_cp
       real(cp),parameter :: neg_one_third = -1.0_cp/3.0_cp
       real(cp),parameter :: three_halfs = 3.0_cp/2.0_cp

       contains

       subroutine O2_BDF_time_AB2_sources_SF(PCG_SF,X,Xnm1,F,Fnm1,m,&
         TMP,temp_F1,compute_norms)
         ! Solves:
         !
         !  3X^{*} - 4X^{n} + X^{n-1}
         ! -------------------------- + AX^{*} = AB2(F^{n},F^{n-1})
         !            2 dt
         !
         ! -->  (I + 2/3*dt A)X^{*} = 4/3X^{n} - 1/3 X^{n-1} + 2/3 dt AB2(F^{n},F^{n-1})
         !
         ! X^{n+1} = X^{*}
         !
         implicit none
         type(PCG_solver_SF),intent(inout) :: PCG_SF
         type(SF),intent(inout) :: X,Xnm1,temp_F1
         type(SF),intent(in) :: F,Fnm1
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         logical,intent(in) :: compute_norms
         call AB2(temp_F1,F,Fnm1)
         call multiply(temp_F1,two_thirds*TMP%TS%dt)
         call assign_wall_Dirichlet(temp_F1,0.0_cp,X)
         call add_product(temp_F1,X,four_thirds)
         call add_product(temp_F1,Xnm1,neg_one_third)
         call assign(Xnm1,X)
         call update_MFP(PCG_SF,m,TMP%TS%dt*two_thirds*PCG_SF%MFP%coeff_implicit,TMP%n_step.le.2)
         call solve(PCG_SF,X,temp_F1,m,compute_norms) ! Solve for X
       end subroutine

       subroutine Euler_time_AB2_sources_SF(PCG_SF,X,Xnm1,F,Fnm1,m,&
         TMP,temp_F1,compute_norms)
         ! Solves:
         !
         !  X^{*} - X^{n}
         ! -------------- + AX^{*} = AB2(F^{n},F^{n-1})
         !        dt
         !
         ! -->  (I + dt 1 A)X^{*} = X^{n} + dt AB2(F^{n},F^{n-1})
         !
         ! X^{n+1} = X^{*}
         !
         implicit none
         type(PCG_solver_SF),intent(inout) :: PCG_SF
         type(SF),intent(inout) :: X,Xnm1
         type(SF),intent(in) :: F,Fnm1
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         type(SF),intent(inout) :: temp_F1
         logical,intent(in) :: compute_norms
         call AB2(temp_F1,F,Fnm1)
         call multiply(temp_F1,TMP%TS%dt)
         call assign_wall_Dirichlet(temp_F1,0.0_cp,X)
         call add(temp_F1,X)
         call assign(Xnm1,X)
         call update_MFP(PCG_SF,m,TMP%TS%dt*1.0_cp*PCG_SF%MFP%coeff_implicit,TMP%n_step.le.2)
         call solve(PCG_SF,X,temp_F1,m,compute_norms) ! Solve for X
       end subroutine

       subroutine Euler_time_RK_sources_SF(PCG_SF,X,Xnm1,F,Fnm1,L,m,&
         TMP,RKP,temp_F1,compute_norms)
         ! Solves:
         !
         !  X^{*} - X^{n}
         ! -------------- + AX^{*} = AB2(F^{n},F^{n-1})
         !        dt
         !
         ! -->  (I + dt 1 A)X^{*} = X^{n} + dt AB2(F^{n},F^{n-1})
         !
         ! X^{n+1} = X^{*}
         !
         implicit none
         type(PCG_solver_SF),intent(inout) :: PCG_SF
         type(SF),intent(inout) :: X,Xnm1
         type(SF),intent(in) :: F,Fnm1,L
         type(mesh),intent(in) :: m
         type(time_marching_params),intent(in) :: TMP
         type(RK_Params),intent(in) :: RKP
         type(SF),intent(inout) :: temp_F1
         logical,intent(in) :: compute_norms
         call multiply(temp_F1,F      ,TMP%TS%dt*RKP%gamma%f(RKP%n))
         call add_product(temp_F1,Fnm1,TMP%TS%dt*RKP%zeta%f(RKP%n))
         call add_product(temp_F1,L   ,TMP%TS%dt*RKP%alpha%f(RKP%n))
         call assign_wall_Dirichlet(temp_F1,0.0_cp,X)
         call add(temp_F1,X)
         call assign(Xnm1,X)
         call update_MFP(PCG_SF,m,TMP%TS%dt*RKP%beta%f(RKP%n)*PCG_SF%MFP%coeff_implicit,.true.)
         call solve(PCG_SF,X,temp_F1,m,compute_norms) ! Solve for X
       end subroutine

       ! **********************************************************************
       ! ******************** DIFFUSION EXPLICIT TIME MARCHING ****************
       ! **********************************************************************

       subroutine Euler_time_no_diff_AB2_sources_SF(X,Xstar,F,Fnm1,TMP)
         ! Solves:
         !
         !  X^{n+1} - X^{n}
         ! ---------------- = AB2(F^{n},F^{n-1})
         !          dt
         !
         ! -->  X^{n+1} = X^{n} + dt AB2(F^{n},F^{n-1})
         !
         implicit none
         type(SF),intent(inout) :: X,Xstar
         type(SF),intent(in) :: F,Fnm1
         type(time_marching_params),intent(in) :: TMP
         call AB2(Xstar,F,Fnm1)
         call multiply(Xstar,TMP%TS%dt)
         call assign_wall_Dirichlet(Xstar,0.0_cp,X)
         call add(X,Xstar)
       end subroutine

       subroutine Euler_time_no_diff_Euler_sources_SF(X,Xstar,F,TMP)
         ! Solves:
         !
         !  X^{n+1} - X^{n}
         ! ---------------- = F^{n}
         !          dt
         !
         ! -->  X^{n+1} = X^{n} + dt F^{n}
         !
         implicit none
         type(SF),intent(inout) :: X,Xstar
         type(SF),intent(in) :: F
         type(time_marching_params),intent(in) :: TMP
         call multiply(Xstar,F,TMP%TS%dt)
         call assign_wall_Dirichlet(Xstar,0.0_cp,X)
         call add(X,Xstar)
       end subroutine

       end module
       module energy_extend_mod
       use energy_mod
       use current_precision_mod
       use sim_params_mod
       use IO_tools_mod
       use IO_export_mod
       use IO_import_mod
       use export_raw_processed_mod
       use import_raw_mod
       use export_raw_processed_symmetry_mod
       use export_processed_FPL_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use mesh_extend_mod
       use mesh_domain_extend_mod
       use dir_tree_mod
       use string_mod
       use path_extend_mod
       use path_extend_mod
       use export_frequency_mod
       use export_now_mod

       use PCG_solver_extend_mod
       use matrix_free_params_mod
       use matrix_free_operators_mod
       use preconditioners_mod

       use energy_aux_mod
       use energy_solver_mod
       use init_T_BCs_mod
       use init_T_field_mod
       use init_gravity_field_mod
       use init_K_mod

       use iter_solver_params_mod
       use time_marching_params_mod
       use time_marching_methods_SF_mod

       use ops_embedExtract_mod
       use norms_extend_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use apply_BCs_mod
       use boundary_conditions_extend_mod

       use probe_mod
       use probe_extend_mod
       use ops_norms_mod

       implicit none

       private
       public :: energy
       public :: init,delete,display,print,export,import ! Essentials
       public :: solve,export_tec
       public :: export_unsteady
       public :: set_necessary_for_restart

       interface init;                      module procedure init_energy;                   end interface
       interface display;                   module procedure display_energy;                end interface
       interface print;                     module procedure print_energy;                  end interface

       interface set_necessary_for_restart; module procedure set_necessary_for_restart_nrg; end interface

       interface solve;                     module procedure solve_energy;                  end interface
       interface export_unsteady;           module procedure export_unsteady_nrg;           end interface
       interface export_unsteady_0D;        module procedure export_unsteady_0D_nrg;        end interface
       interface export_unsteady_1D;        module procedure export_unsteady_1D_nrg;        end interface
       interface export_unsteady_2D;        module procedure export_unsteady_2D_nrg;        end interface
       interface export_unsteady_3D;        module procedure export_unsteady_3D_nrg;        end interface
       interface export_tec;                module procedure export_tec_energy;             end interface

       contains

       subroutine init_energy(nrg,SP,DT)
         implicit none
         type(energy),intent(inout) :: nrg
         type(sim_params),intent(in) :: SP
         type(dir_tree),intent(in) :: DT
         integer :: temp_unit
         type(SF) :: k_cc
         write(*,*) 'Initializing energy:'

         call init_CC(nrg%T,nrg%m,0.0_cp)
         call init_CC(nrg%Tnm1,nrg%m,0.0_cp)
         call init_CC(nrg%F,nrg%m,0.0_cp)
         call init_CC(nrg%Fnm1,nrg%m,0.0_cp)
         call init_CC(nrg%L,nrg%m,0.0_cp)
         call init_CC(nrg%Q_source,nrg%m,0.0_cp)
         call init_CC(nrg%temp_CC2,nrg%m,0.0_cp)
         call init_Face(nrg%temp_F,nrg%m,0.0_cp)

         call init_Face(nrg%k,nrg%m,0.0_cp)
         call init_Face(nrg%U_F,nrg%m,0.0_cp)
         call init_CC(nrg%U_CC,nrg%m,0.0_cp)
         call init_CC(nrg%temp_CC1,nrg%m,0.0_cp)
         call init_CC(nrg%gravity,nrg%m,0.0_cp)
         call init_CC(nrg%temp_CC1_VF,nrg%m,0.0_cp)
         call init_CC(nrg%temp_CC2_VF,nrg%m,0.0_cp)
         call init_CC(nrg%temp_CC_TF,nrg%m,0.0_cp)
         call init_Face(nrg%temp_F_TF,nrg%m,0.0_cp)

         ! --- Scalar Fields ---
         call init_CC(nrg%divQ,nrg%m)
         write(*,*) '     Fields allocated'

         ! --- Initialize Fields ---
         call init_T_BCs(nrg%T,nrg%m,SP)
         if (SP%VS%T%SS%solve) call print_BCs(nrg%T,'T')
         if (SP%VS%T%SS%solve) call export_BCs(nrg%T,str(DT%T%BCs),'T')
         write(*,*) '     BCs initialized'

         call init_T_field(nrg%T,nrg%m,SP,str(DT%T%field))
         call init_gravity_field(nrg%gravity,nrg%m,SP,str(DT%T%field))
         write(*,*) '     T-field initialized'

         call apply_BCs(nrg%T)
         call assign(nrg%Tnm1,nrg%T)
         write(*,*) '     BCs applied'

         call init_CC(k_cc,nrg%m,0.0_cp)
         call initK(k_cc,nrg%m,nrg%MD)
         call cellCenter2Face(nrg%k,k_cc,nrg%m)
         call delete(k_cc)
         write(*,*) '     Materials initialized'

         call init(nrg%PCG_T,nrg_diffusion,nrg_diffusion_explicit,prec_lap_SF,nrg%m,&
         SP%VS%T%ISP,SP%VS%T%MFP,nrg%T,nrg%T,nrg%temp_F_TF,str(DT%T%residual),'T',.false.,.false.)

         temp_unit = new_and_open(str(DT%params),'info_nrg')
         call display(nrg,SP,temp_unit)
         call close_and_message(temp_unit,str(DT%params),'info_nrg')

         write(*,*) '     Finished'
       end subroutine

       subroutine display_energy(nrg,SP,un)
         implicit none
         type(energy),intent(in) :: nrg
         type(sim_params),intent(in) :: SP
         integer,intent(in) :: un
         if (SP%FCL%export_heavy) then
           write(un,*) '**********************************************************'
           write(un,*) '************************* ENERGY *************************'
           write(un,*) '**********************************************************'
           write(un,*) 'Pe = ',SP%DP%Pe
           write(un,*) 'Ec,Ha = ',SP%DP%Ec,SP%DP%Ha
           write(un,*) 't,dt = ',SP%VS%T%TMP%t,SP%VS%T%TMP%TS%dt
           write(un,*) 'solveTMethod,N_nrg = ',SP%VS%T%SS%solve_method,SP%VS%T%ISP%EC%iter_max
           write(un,*) 'tol_nrg = ',SP%VS%T%ISP%EC%tol_rel
           call displayPhysicalMinMax(nrg%T,'T',un)
           call displayPhysicalMinMax(nrg%divQ,'divQ',un)
           write(un,*) ''
           call display(nrg%m,un)
         endif
       end subroutine

       subroutine print_energy(nrg,SP)
         implicit none
         type(energy),intent(in) :: nrg
         type(sim_params),intent(in) :: SP
         call display(nrg,SP,6)
       end subroutine

       subroutine set_necessary_for_restart_nrg(nrg)
         implicit none
         type(energy),intent(inout) :: nrg
         call set_necessary_for_restart(nrg%T)
         call set_necessary_for_restart(nrg%Tnm1)
         call set_necessary_for_restart(nrg%F)
         call set_necessary_for_restart(nrg%Fnm1)
         call set_necessary_for_restart(nrg%L)
       end subroutine

       ! **********************************************************
       ! **********************************************************
       ! **********************************************************

       subroutine export_tec_energy(nrg,SP,DT)
         implicit none
         type(energy),intent(inout) :: nrg
         type(sim_params),intent(in) :: SP
         type(dir_tree),intent(in) :: DT
         if (SP%VS%T%SS%solve) then
           write(*,*) 'export_tec_energy at SP%VS%T%TMP%n_step = ',SP%VS%T%TMP%n_step
           call export_processed(nrg%m,nrg%T,str(DT%T%field),'T',0)
           call export_raw(nrg%m,nrg%divQ,str(DT%T%field),'divQ',0)
           write(*,*) '     finished'
         endif
       end subroutine

       subroutine export_unsteady_0D_nrg(nrg,SP,TMP)
         implicit none
         type(energy),intent(inout) :: nrg
         type(sim_params),intent(inout) :: SP
         type(time_marching_params),intent(in) :: TMP
         real(cp) :: temp,scale
         scale = SP%DP%KE_scale
         call compute_Q(nrg%temp_F,nrg%T,nrg%k,nrg%m)
         call compute_divQ(nrg%divQ,nrg%temp_F,nrg%m)
         call assign_ghost_XPeriodic(nrg%divQ,0.0_cp)
         call compute_Ln(temp,nrg%divQ,2.0_cp,nrg%m)
         temp = temp*scale
         call export(SP%PS_nrg%probe_divQ,TMP,temp)
       end subroutine

       subroutine export_unsteady_1D_nrg(nrg,SP,TMP,DT)
         implicit none
         type(energy),intent(inout) :: nrg
         type(sim_params),intent(in) :: SP
         type(time_marching_params),intent(in) :: TMP
         type(dir_tree),intent(in) :: DT
         call export_processed(nrg%m,nrg%T,str(DT%T%unsteady),'T',1,TMP,SP%VS%T%unsteady_lines)
       end subroutine

       subroutine export_unsteady_2D_nrg(nrg,SP,TMP,DT)
         implicit none
         type(energy),intent(inout) :: nrg
         type(sim_params),intent(in) :: SP
         type(time_marching_params),intent(in) :: TMP
         type(dir_tree),intent(in) :: DT
         call export_processed(nrg%m,nrg%T,str(DT%T%unsteady),'T',1,TMP,SP%VS%T%unsteady_planes)
       end subroutine

       subroutine export_unsteady_3D_nrg(nrg,SP,TMP,DT)
         implicit none
         type(energy),intent(inout) :: nrg
         type(sim_params),intent(in) :: SP
         type(time_marching_params),intent(in) :: TMP
         type(dir_tree),intent(in) :: DT
         call export_processed(nrg%m,nrg%T,str(DT%T%unsteady),'T',1,TMP,SP%VS%T%unsteady_field)
       end subroutine

       subroutine solve_energy(nrg,SP,F,Fnm1,L,TMP,EF)
         implicit none
         type(energy),intent(inout) :: nrg
         type(sim_params),intent(in) :: SP
         type(SF),intent(in) :: F,Fnm1,L
         type(time_marching_params),intent(inout) :: TMP
         type(export_frequency),intent(in) :: EF

         select case(SP%VS%T%SS%solve_method)
         case (1)
           call Euler_time_no_diff_Euler_sources_SF(nrg%T,nrg%temp_CC1,F,TMP)
         case (2)
           call Euler_time_no_diff_AB2_sources_SF(nrg%T,nrg%temp_CC1,F,Fnm1,TMP)
         case (3)
           call Euler_time_AB2_sources_SF(nrg%PCG_T,nrg%T,nrg%Tnm1,F,Fnm1,nrg%m,&
           TMP,nrg%temp_CC1,EF%unsteady_0D%export_now)
         case (4)
           call O2_BDF_time_AB2_sources_SF(nrg%PCG_T,nrg%T,nrg%Tnm1,F,Fnm1,nrg%m,&
           TMP,nrg%temp_CC1,EF%unsteady_0D%export_now)
         case (5)
           call Euler_time_RK_sources_SF(nrg%PCG_T,nrg%T,nrg%Tnm1,F,Fnm1,L,nrg%m,&
           TMP,TMP%RKP,nrg%temp_CC1,EF%unsteady_0D%export_now)
         case default; stop 'Error: solveTMethod must = 1:4 in energy.f90.'
         end select
         ! ********************* POST SOLUTION COMPUTATIONS *********************
         call volumetric_heating_equation(nrg%Q_source,nrg%m,SP%DP%Pe)
       end subroutine

       subroutine export_unsteady_nrg(nrg,SP,TMP,EF,EN,DT)
         implicit none
         type(energy),intent(inout) :: nrg
         type(sim_params),intent(inout) :: SP
         type(time_marching_params),intent(inout) :: TMP
         type(export_frequency),intent(in) :: EF
         type(export_now),intent(in) :: EN
         type(dir_tree),intent(in) :: DT
         if (EF%unsteady_0D%export_now) call export_unsteady_0D(nrg,SP,TMP)
         if (EF%unsteady_1D%export_now) call export_unsteady_1D(nrg,SP,TMP,DT)
         if (EF%unsteady_2D%export_now) call export_unsteady_2D(nrg,SP,TMP,DT)
         if (EF%unsteady_3D%export_now) call export_unsteady_3D(nrg,SP,TMP,DT)
         if (EF%info%export_now) call print(nrg,SP)
         if (EF%final_solution%export_now.or.EN%T%this.or.EN%all%this) then
           ! call export(nrg,str(DT%governing_equations),'nrg')
           call export_tec(nrg,SP,DT)
         endif
       end subroutine

       end module
       module induction_extend_mod
       use induction_mod
       use current_precision_mod
       use sim_params_mod
       use IO_tools_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use IO_export_mod
       use IO_import_mod
       use dir_tree_mod
       use string_mod
       use path_extend_mod
       use path_extend_mod
       use export_raw_processed_mod
       use export_raw_processed_symmetry_mod
       use import_raw_mod
       use export_processed_FPL_mod
       use export_frequency_mod
       use export_now_mod
       use induction_sources_mod
       use assign_B0_vs_t_mod
       use datatype_conversion_mod
       use RK_Params_mod

       use init_B_BCs_mod
       use init_Bstar_field_mod
       use init_phi_BCs_mod
       use init_B_field_mod
       use init_phi_field_mod
       use init_B0_field_mod
       use init_B_interior_mod
       use init_J_interior_mod
       use init_Sigma_mod
       use ops_embedExtract_mod
       use clean_divergence_mod
       use BC_funcs_mod

       use iter_solver_params_mod
       use time_marching_params_mod

       use probe_mod
       use probe_extend_mod
       use ops_norms_mod
       use var_set_mod
       use mirror_props_mod
       use mirror_props_extend_mod

       use mesh_domain_extend_mod
       use grid_mod
       use mesh_extend_mod
       use norms_extend_mod
       use ops_del_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use boundary_conditions_extend_mod
       use apply_BCs_mod
       use ops_advect_mod
       use time_marching_methods_mod
       use induction_solver_mod
       use preconditioners_mod
       use PCG_solver_extend_mod
       use FFT_solver_extend_mod
       use matrix_free_params_mod
       use matrix_free_operators_mod
       use induction_aux_mod
       use E_M_Budget_mod

       implicit none

       private
       public :: induction
       public :: init,delete,display,print,export,import ! Essentials
       public :: solve,export_tec,compute_export_E_M_budget
       public :: export_unsteady
       public :: compute_J_ind
       public :: set_necessary_for_restart

       interface init;                      module procedure init_induction;                end interface
       interface display;                   module procedure display_induction;             end interface
       interface print;                     module procedure print_induction;               end interface
       interface set_necessary_for_restart; module procedure set_necessary_for_restart_ind; end interface

       interface solve;                     module procedure solve_induction;               end interface
       interface export_tec;                module procedure export_tec_induction;          end interface

       interface set_sigma_inv;             module procedure set_sigma_inv_ind;             end interface

       interface export_unsteady;           module procedure export_unsteady_ind;           end interface
       interface export_unsteady_0D;        module procedure export_unsteady_0D_ind;        end interface
       interface export_unsteady_1D;        module procedure export_unsteady_1D_ind;        end interface
       interface export_unsteady_2D;        module procedure export_unsteady_2D_ind;        end interface
       interface export_unsteady_3D;        module procedure export_unsteady_3D_ind;        end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_induction(ind,SP,DT)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         type(dir_tree),intent(in) :: DT
         type(TF) :: TF_face,sigmaInv_edge_TF
         integer :: temp_unit
         write(*,*) 'Initializing induction:'

         write(*,*) '     Domains copied'
         call init_CC(ind%CC_VF_fluid,ind%m,ind%MD_fluid); call assign(ind%CC_VF_fluid,0.0_cp)
         call init_CC(ind%CC_VF_sigma,ind%m,ind%MD_sigma); call assign(ind%CC_VF_sigma,0.0_cp)
         ! --- tensor,vector and scalar fields ---
         call init_Face(ind%B_interior     ,ind%m,ind%MD_sigma); call assign(ind%B_interior,0.0_cp)
         call init_Edge(ind%J_interior     ,ind%m,ind%MD_sigma); call assign(ind%J_interior,0.0_cp)
         call init_Edge(ind%U_E            ,ind%m,0.0_cp)
         call init_Edge(ind%temp_E_TF      ,ind%m,0.0_cp)
         call init_Face(ind%temp_F1_TF     ,ind%m,0.0_cp)
         call init_Face(ind%temp_F2_TF     ,ind%m,0.0_cp)
         call init_Face(ind%F              ,ind%m,0.0_cp)
         call init_Face(ind%jCrossB        ,ind%m,0.0_cp)
         call init_Face(ind%Fnm1           ,ind%m,0.0_cp)
         call init_Face(ind%L              ,ind%m,0.0_cp)
         call init_Face(ind%B              ,ind%m,0.0_cp)
         call init_Face(ind%Btot           ,ind%m,0.0_cp)
         call init_Face(ind%Bnm1           ,ind%m,0.0_cp)
         call init_Face(ind%B0             ,ind%m,0.0_cp)
         call init_Face(ind%dB0dt          ,ind%m,0.0_cp)
         call init_CC(ind%temp_CC_VF       ,ind%m,0.0_cp)
         call init_Edge(ind%J              ,ind%m,0.0_cp)
         call init_Face(ind%curlUCrossB    ,ind%m,0.0_cp)
         call init_Edge(ind%temp_E         ,ind%m,0.0_cp)
         call init_Edge(ind%sigmaInv_edge  ,ind%m,0.0_cp)
         call init_Face(ind%temp_F1        ,ind%m,0.0_cp)
         call init_Face(ind%temp_F2        ,ind%m,0.0_cp)
         call init_CC(ind%phi              ,ind%m,0.0_cp)
         call init_CC(ind%temp_CC          ,ind%m,0.0_cp)
         call init_CC(ind%divB             ,ind%m,0.0_cp)
         call init_Node(ind%divJ           ,ind%m,0.0_cp)
         call init_CC(ind%sigmaInv_CC      ,ind%m,0.0_cp)
         call init_CC(ind%cell_volume      ,ind%m,0.0_cp)
         call init_CC(ind%cell_inverse_area,ind%m,0.0_cp)
         call init_CC(ind%stresses         ,ind%m,0.0_cp)
         call init_CC(ind%temp_CC_TF       ,ind%m,0.0_cp)

         write(*,*) '     Fields allocated'

         call volume(ind%cell_volume,ind%m)
         call inverse_area(ind%cell_inverse_area,ind%m)
         ! --- Initialize Fields ---
         call init_B_BCs(ind%B,ind%m,SP);     write(*,*) '     B BCs initialized'
         call update_BC_vals(ind%B)
         call init_phi_BCs(ind%phi,ind%m,SP); write(*,*) '     phi BCs initialized'
         call update_BC_vals(ind%phi)

         call init_B0_field(ind%B0,ind%m,SP)
         call init_B_field(ind%B,SP)
         call init_phi_field(ind%phi,SP)
         call assign(ind%Bnm1,ind%B)

         if (SP%IT%unsteady_B0%add) call assign_B0_vs_t(ind%B0,SP%VS%B%TMP)
         call multiply(ind%B0,SP%IT%B_applied%scale)

         write(*,*) '     B-field initialized'
         ! call initB_interior(ind%B_interior,ind%m,ind%MD_sigma,str(DT%B%restart))
         ! call initJ_interior(ind%J_interior,ind%m,ind%MD_sigma,str(DT%J%restart))
         call assign_ghost_XPeriodic(ind%B_interior,0.0_cp)
         call apply_BCs(ind%B);                           write(*,*) '     BCs applied'

         call init(ind%Bstar,ind%B)
         if (SP%VS%B%SS%prescribed_BCs) call set_prescribed_BCs(ind%Bstar)
         call set_BCs_homogeneous(ind%Bstar)
         call init_Bstar_field(ind%Bstar,ind%B)

         write(*,*) '     Intermediate B-field initialized'

         if (SP%VS%B%SS%solve) call export_BCs(ind%B,str(DT%B%BCs),'B')
         if (SP%VS%B%SS%solve) call export_BCs(ind%phi,str(DT%phi%BCs),'phi')
         ! if (SP%VS%B%SS%solve) call print_BCs(ind%B,'B')
         ! if (SP%VS%B%SS%solve) call print_BCs(ind%phi,'phi')

         ! ******************** MATERIAL PROPERTIES ********************
         call set_sigma_inv(ind,SP)
         write(*,*) '     Materials initialized'
         if (SP%EL%export_mat_props) call export_raw(ind%m,ind%sigmaInv_edge,str(DT%mat),'sigmaInv',0)

         ! *************************************************************

         call compute_J_ind(ind,SP)
         call compute_Btot(ind,SP)
         call compute_JCrossB_ind(ind,SP)
         call compute_stresses_ind(ind,SP)

         ! ********** SET CLEANING PROCEDURE SOLVER SETTINGS *************

         ! Initialize multigrid
         temp_unit = new_and_open(str(DT%params),'info_ind')
         call display(ind,SP,temp_unit)
         call close_and_message(temp_unit,str(DT%params),'info_ind')

         write(*,*) '     About to assemble curl-curl matrix'

         call init_Edge(sigmaInv_edge_TF%x,ind%m,0.0_cp) ! x-component used in matrix_free_operators.f90
         call assign(sigmaInv_edge_TF%x,ind%sigmaInv_edge)
         call init(ind%PCG_B,ind_diffusion,ind_diffusion_explicit,prec_ind_VF,ind%m,&
         SP%VS%B%ISP,SP%VS%B%MFP,ind%Bstar,ind%B,sigmaInv_edge_TF,str(DT%B%residual),'B',.false.,.false.)
         call delete(sigmaInv_edge_TF)
         write(*,*) '     PCG Solver initialized for B'

         call init_Face(TF_face%x,ind%m,0.0_cp) ! x-component used in matrix_free_operators.f90
         call init(ind%PCG_cleanB,Lap_uniform_SF,Lap_uniform_SF_explicit,prec_lap_SF,&
         ind%m,SP%VS%phi%ISP,SP%VS%phi%MFP,ind%phi,ind%phi,TF_face,str(DT%phi%residual),'phi',.false.,.false.)
         call delete(TF_face)
         write(*,*) '     PCG Solver initialized for phi'

         call init(ind%FFT_cleanB,ind%phi,ind%m,SP%GP%FFT_dir,'FFT_phi')
         write(*,*) '     FFT Solver initialized for phi'

         write(*,*) '     Finished'
       end subroutine

       subroutine display_induction(ind,SP,un)
         implicit none
         type(induction),intent(in) :: ind
         type(sim_params),intent(in) :: SP
         integer,intent(in) :: un
         if (SP%FCL%export_heavy) then
           write(un,*) '**********************************************************'
           write(un,*) '************************ MAGNETIC ************************'
           write(un,*) '**********************************************************'
           write(un,*) 'Rem,finite_Rem,include_vacuum = ',SP%DP%Rem,SP%SCP%finite_Rem,SP%SCP%include_vacuum
           write(un,*) 't,dt = ',SP%VS%B%TMP%t,SP%VS%B%TMP%TS%dt
           write(un,*) 'solveBMethod,N_ind,N_cleanB = ',SP%VS%B%SS%solve_method,&
           SP%VS%B%ISP%EC%iter_max,SP%VS%phi%ISP%EC%iter_max
           write(un,*) 'tol_ind,tol_cleanB = ',SP%VS%B%ISP%EC%tol_rel,SP%VS%phi%ISP%EC%tol_rel
           write(un,*) 'nstep,ME = ',SP%VS%B%TMP%n_step,get_data(SP%PS_ind%ME(1))
           ! call displayPhysicalMinMax(ind%dB0dt,'dB0dt',un)
           ! call displayPhysicalMinMax(ind%B0,'B0',un)
           call displayPhysicalMinMax(ind%divB,'divB',un)
           call displayPhysicalMinMax(ind%divJ,'divJ',un)
           write(un,*) ''
           ! call display(ind%m,un)
         endif
       end subroutine

       subroutine print_induction(ind,SP)
         implicit none
         type(induction),intent(in) :: ind
         type(sim_params),intent(in) :: SP
         call display(ind,SP,6)
       end subroutine

       subroutine set_necessary_for_restart_ind(ind)
         implicit none
         type(induction),intent(inout) :: ind
         call set_necessary_for_restart(ind%B)
         call set_necessary_for_restart(ind%Bnm1)
         call set_necessary_for_restart(ind%B0)
         call set_necessary_for_restart(ind%dB0dt)
         call set_necessary_for_restart(ind%F)
         call set_necessary_for_restart(ind%Fnm1)
         call set_necessary_for_restart(ind%L)
         call set_necessary_for_restart(ind%Bstar)
         call set_necessary_for_restart(ind%phi)
         call set_necessary_for_restart(ind%J)
         call set_necessary_for_restart(ind%PCG_B%r)
         call set_necessary_for_restart(ind%PCG_cleanB%r)
         call set_necessary_for_restart(ind%PCG_B%p)
         call set_necessary_for_restart(ind%PCG_cleanB%p)
         call set_necessary_for_restart(ind%PCG_B%x_BC)
         call set_necessary_for_restart(ind%PCG_cleanB%x_BC)
       end subroutine

       ! **********************************************************
       ! **********************************************************
       ! **********************************************************

       subroutine export_tec_induction(ind,SP,DT)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         type(dir_tree),intent(in) :: DT
         if (SP%FCL%restart_all.and.(.not.SP%VS%B%SS%solve)) then
           ! This preserves the initial data
         else
           if (SP%VS%B%SS%solve) then
             write(*,*) 'export_tec_induction at n_step = ',SP%VS%B%TMP%n_step
             call export_processed(ind%m,ind%B,str(DT%B%field),'B',1)
             call export_processed(ind%m,ind%B0,str(DT%B%field),'B0',1)
             call export_processed(ind%m,ind%phi ,str(DT%phi%field),'phi',1)
             call export_processed(ind%m,ind%J ,str(DT%J%field),'J',1)
             call export_raw(ind%m,ind%divB ,str(DT%B%field),'divB',0)
             call export_raw(ind%m,ind%phi ,str(DT%phi%field),'phi',0)

             call export_raw(ind%m,ind%U_E%x,str(DT%B%field),'U_E_x',1)
             call export_raw(ind%m,ind%U_E%y,str(DT%B%field),'U_E_y',1)
             call export_raw(ind%m,ind%U_E%z,str(DT%B%field),'U_E_z',1)

             call export_raw(ind%m,ind%jCrossB ,str(DT%jCrossB%field),'jCrossB',0)
             call export_processed(ind%m,ind%jCrossB ,str(DT%jCrossB%field),'jCrossB',1)

             call export_raw(ind%m,ind%stresses%x,str(DT%stresses%field),'stresses_x',0)
             call export_processed(ind%m,ind%stresses%x,str(DT%stresses%field),'stresses_x',1)
             call export_processed(ind%m,ind%stresses%y,str(DT%stresses%field),'stresses_y',1)
             call export_processed(ind%m,ind%stresses%z,str(DT%stresses%field),'stresses_z',1)

             if (SP%EL%export_symmetric) then
             call export_processed(ind%m,ind%B,str(DT%B%field),'B',1,anti_mirror(SP%MP))
             call export_processed(ind%m,ind%J,str(DT%J%field),'J',1,SP%MP)
             endif
             write(*,*) '     finished'
           endif
         endif
       end subroutine

       subroutine export_unsteady_0D_ind(ind,SP,TMP)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(inout) :: SP
         type(time_marching_params),intent(in) :: TMP
         real(cp) :: temp,scale
         integer :: i
         call compute_divBJ(ind%divB,ind%divJ,ind%B,ind%J,ind%m)
         call compute_Ln(temp,ind%divB,2.0_cp,ind%m); call export(SP%PS_ind%probe_divB,TMP,temp)
         call compute_Ln(temp,ind%divJ,2.0_cp,ind%m); call export(SP%PS_ind%probe_divJ,TMP,temp)

         call export(SP%PS_ind%probe_dB0dt(1),TMP,amax(ind%dB0dt%x))
         call export(SP%PS_ind%probe_dB0dt(2),TMP,amax(ind%dB0dt%y))
         call export(SP%PS_ind%probe_dB0dt(3),TMP,amax(ind%dB0dt%z))
         call export(SP%PS_ind%probe_B0(1),TMP,amax(ind%B0%x))
         call export(SP%PS_ind%probe_B0(2),TMP,amax(ind%B0%y))
         call export(SP%PS_ind%probe_B0(3),TMP,amax(ind%B0%z))
         call export(SP%PS_ind%probe_B1(1),TMP,amax(ind%B%x))
         call export(SP%PS_ind%probe_B1(2),TMP,amax(ind%B%y))
         call export(SP%PS_ind%probe_B1(3),TMP,amax(ind%B%z))
         call export(SP%PS_ind%probe_Btot(1),TMP,amax(ind%Btot%x))
         call export(SP%PS_ind%probe_Btot(2),TMP,amax(ind%Btot%y))
         call export(SP%PS_ind%probe_Btot(3),TMP,amax(ind%Btot%z))

         scale = SP%DP%ME_scale

         do i=1,3
           if (i.eq.1) then
             call face2cellCenter(ind%temp_CC_VF,ind%Btot,ind%m)
           elseif (i.eq.2) then
             call face2cellCenter(ind%temp_CC_VF,ind%B0,ind%m)
           elseif (i.eq.3) then
             call face2cellCenter(ind%temp_CC_VF,ind%B,ind%m)
           endif
           call compute_Total_Energy(SP%PS_ind%ME(i),ind%temp_CC_VF,TMP,ind%m,scale)
           call compute_Total_Energy_Domain(SP%PS_ind%ME_fluid(i),ind%temp_CC_VF,ind%CC_VF_fluid,TMP,ind%m,scale,ind%MD_fluid)
           call compute_Total_Energy_Domain(SP%PS_ind%ME_conductor(i),ind%temp_CC_VF,ind%CC_VF_sigma,TMP,ind%m,scale,ind%MD_sigma)
           call compute_Energy_Component(SP%PS_ind%Bx(i),ind%temp_CC_VF%x,TMP,ind%m,scale)
           call compute_Energy_Component(SP%PS_ind%By(i),ind%temp_CC_VF%y,TMP,ind%m,scale)
           call compute_Energy_Component(SP%PS_ind%Bz(i),ind%temp_CC_VF%z,TMP,ind%m,scale)
         enddo

         call face2cellCenter(ind%temp_CC_VF,ind%jCrossB,ind%m)
         call multiply(ind%temp_CC_VF,ind%cell_volume)
         call magnitude(ind%temp_CC,ind%temp_CC_VF)
         call export(SP%PS_ind%amax_JxB  ,TMP,amax(ind%temp_CC))
         call export(SP%PS_ind%amax_JxB_x,TMP,amax(ind%temp_CC_VF%x))
         call export(SP%PS_ind%amax_JxB_y,TMP,amax(ind%temp_CC_VF%y))
         call export(SP%PS_ind%amax_JxB_z,TMP,amax(ind%temp_CC_VF%z))

         call export(SP%PS_ind%amax_stress_xx,TMP,amax(ind%stresses%x%x))
         call export(SP%PS_ind%amax_stress_xy,TMP,amax(ind%stresses%x%y))
         call export(SP%PS_ind%amax_stress_xz,TMP,amax(ind%stresses%x%z))
         call export(SP%PS_ind%amax_stress_yx,TMP,amax(ind%stresses%y%x))
         call export(SP%PS_ind%amax_stress_yy,TMP,amax(ind%stresses%y%y))
         call export(SP%PS_ind%amax_stress_yz,TMP,amax(ind%stresses%y%z))
         call export(SP%PS_ind%amax_stress_zx,TMP,amax(ind%stresses%z%x))
         call export(SP%PS_ind%amax_stress_zy,TMP,amax(ind%stresses%z%y))
         call export(SP%PS_ind%amax_stress_zz,TMP,amax(ind%stresses%z%z))

         call assign(ind%CC_VF_fluid,0.0_cp)
         call assign(ind%temp_CC_TF,ind%stresses)
         call embedCC(ind%temp_CC_TF%x,ind%CC_VF_fluid,ind%MD_fluid)
         call embedCC(ind%temp_CC_TF%y,ind%CC_VF_fluid,ind%MD_fluid)
         call embedCC(ind%temp_CC_TF%z,ind%CC_VF_fluid,ind%MD_fluid)

         call export(SP%PS_ind%amax_stress_walls_xx,TMP,amax(ind%temp_CC_TF%x%x))
         call export(SP%PS_ind%amax_stress_walls_xy,TMP,amax(ind%temp_CC_TF%x%y))
         call export(SP%PS_ind%amax_stress_walls_xz,TMP,amax(ind%temp_CC_TF%x%z))
         call export(SP%PS_ind%amax_stress_walls_yx,TMP,amax(ind%temp_CC_TF%y%x))
         call export(SP%PS_ind%amax_stress_walls_yy,TMP,amax(ind%temp_CC_TF%y%y))
         call export(SP%PS_ind%amax_stress_walls_yz,TMP,amax(ind%temp_CC_TF%y%z))
         call export(SP%PS_ind%amax_stress_walls_zx,TMP,amax(ind%temp_CC_TF%z%x))
         call export(SP%PS_ind%amax_stress_walls_zy,TMP,amax(ind%temp_CC_TF%z%y))
         call export(SP%PS_ind%amax_stress_walls_zz,TMP,amax(ind%temp_CC_TF%z%z))

         scale = SP%DP%JE_scale
         call edge2cellCenter(ind%temp_CC_VF,ind%J,ind%m,ind%temp_F1)
         call compute_Total_Energy(SP%PS_ind%JE,ind%temp_CC_VF,TMP,ind%m,scale)
         call compute_Total_Energy_Domain(SP%PS_ind%JE_fluid,ind%temp_CC_VF,ind%CC_VF_fluid,TMP,ind%m,scale,ind%MD_fluid)
       end subroutine

       subroutine export_unsteady_1D_ind(ind,SP,TMP,DT)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         type(time_marching_params),intent(in) :: TMP
         type(dir_tree),intent(in) :: DT
         call export_processed(ind%m,ind%B,str(DT%B%unsteady),'B',1,TMP,SP%VS%B%unsteady_lines)
         call export_processed(ind%m,ind%J,str(DT%J%unsteady),'J',1,TMP,SP%VS%B%unsteady_lines)
       end subroutine

       subroutine export_unsteady_2D_ind(ind,SP,TMP,DT)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         type(time_marching_params),intent(in) :: TMP
         type(dir_tree),intent(in) :: DT
         call export_processed(ind%m,ind%jCrossB,&
          str(DT%jCrossB%unsteady),'jCrossB',1,TMP,SP%VS%jCrossB%unsteady_planes)
         call export_processed(ind%m,ind%B%x,str(DT%B%unsteady),'B_x',1,TMP,SP%VS%B%unsteady_planes)
         call export_processed(ind%m,ind%Btot%x,str(DT%B%unsteady),'Btot_x',1,TMP,SP%VS%B%unsteady_planes)
         ! call export_processed(ind%m,ind%stresses%x,str(DT%stresses%unsteady),'stresses_x',1,TMP,SP%VS%stresses%unsteady_planes)
         ! call export_processed(ind%m,ind%stresses%y,str(DT%stresses%unsteady),'stresses_y',1,TMP,SP%VS%stresses%unsteady_planes)
         call export_processed(ind%m,ind%stresses%z,&
          str(DT%stresses%unsteady),'stresses_z',1,TMP,SP%VS%stresses%unsteady_planes)
         call export_processed(ind%m,ind%temp_CC_TF%z,&
          str(DT%stresses%unsteady),'stresses_walls_z',1,TMP,SP%VS%stresses%unsteady_planes)
         call export_processed(ind%m,ind%J,str(DT%J%unsteady),'J',1,TMP,SP%VS%B%unsteady_planes)

         ! call export_processed(ind%m,ind%B,str(DT%B%unsteady),'B',1,TMP,SP%VS%B%unsteady_planes)
         ! call export_processed(ind%m,ind%J,str(DT%J%unsteady),'J',1,TMP,SP%VS%B%unsteady_planes)
       end subroutine

       subroutine export_unsteady_3D_ind(ind,SP,TMP,DT)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         type(time_marching_params),intent(in) :: TMP
         type(dir_tree),intent(in) :: DT
         call export_processed(ind%m,ind%B,str(DT%B%unsteady),'B',1,TMP,SP%VS%B%unsteady_field)
         call export_processed(ind%m,ind%J,str(DT%J%unsteady),'J',1,TMP,SP%VS%B%unsteady_field)
       end subroutine

       subroutine compute_J_ind(ind,SP)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         ! call assign(ind%J,0.0_cp)
         ! call embedEdge(ind%J,ind%J_interior,ind%MD_sigma)
         call compute_J(ind%J,ind%B,SP%IT%current%scale,ind%m)
       end subroutine

       subroutine compute_JCrossB_ind(ind,SP)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         call compute_JCrossB(ind%jCrossB,ind%Btot,ind%J,ind%m,SP%MT%JCrossB%scale,&
         ind%temp_CC,ind%temp_F1_TF,ind%temp_F2_TF)
         ! call compute_B_dot_gradB(ind%jCrossB,ind%B,ind%m,SP%MT%JCrossB%scale,&
         ! ind%temp_CC,ind%temp_F1,ind%temp_F2,ind%temp_E_TF)
       end subroutine

       subroutine compute_stresses_ind(ind,SP)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         call compute_Lorentz_stresses(ind%stresses,ind%Btot,ind%m,&
         SP%DP%Al,ind%temp_CC_VF)
       end subroutine

       subroutine set_sigma_inv_ind(ind,SP)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         call set_sigma_inv_VF(ind%sigmaInv_edge,ind%m,ind%MD_sigma,SP%DP)
       end subroutine

       subroutine solve_induction(ind,SP,F,Fnm1,L,TMP,EF)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         type(VF),intent(in) :: F,Fnm1,L
         type(time_marching_params),intent(inout) :: TMP
         type(export_frequency),intent(in) :: EF
         integer :: i
         do i=1,TMP%multistep_iter
         select case (SP%VS%B%SS%solve_method)
         case (1)
           call Euler_time_no_diff_Euler_sources_no_correction(ind%B,ind%Bstar,F,TMP)
         case (2)
           call Euler_time_no_diff_AB2_sources_no_correction(ind%B,ind%Bstar,F,Fnm1,TMP)
         case (3)
           call Euler_time_no_diff_Euler_sources(ind%PCG_cleanB,ind%B,ind%Bstar,&
           ind%Bnm1,ind%phi,F,ind%m,TMP,ind%temp_F2,ind%temp_CC,EF%unsteady_0D%export_now)
         case (4)
          call Euler_time_no_diff_AB2_sources(ind%PCG_cleanB,ind%B,ind%Bstar,&
           ind%Bnm1,ind%phi,F,Fnm1,ind%m,TMP,ind%temp_F1,ind%temp_CC,&
           EF%unsteady_0D%export_now)
         case (5)
           call Euler_time_Euler_sources(ind%PCG_B,ind%PCG_cleanB,ind%B,ind%Bstar,ind%Bnm1,&
           ind%phi,F,ind%m,TMP,ind%temp_F1,ind%temp_CC,&
           EF%unsteady_0D%export_now)
         case (6)
           call Euler_time_AB2_sources(ind%PCG_B,ind%PCG_cleanB,ind%B,ind%Bstar,ind%Bnm1,&
           ind%phi,F,Fnm1,ind%m,TMP,ind%temp_F1,ind%L,ind%temp_CC,&
           EF%unsteady_0D%export_now)
         case (7)
           call O2_BDF_time_AB2_sources(ind%PCG_B,ind%PCG_cleanB,ind%B,ind%Bstar,&
           ind%Bnm1,ind%phi,F,Fnm1,ind%m,TMP,ind%temp_F1,ind%temp_CC,&
           EF%unsteady_0D%export_now)
         case (8)
           call Euler_time_RK_sources(ind%PCG_B,ind%PCG_cleanB,ind%B,ind%Bstar,ind%Bnm1,&
           ind%phi,F,Fnm1,L,ind%m,TMP,TMP%RKP,ind%temp_F1,ind%temp_CC,&
           EF%unsteady_0D%export_now)
         case (9)
           call Euler_time_AB2_sources_FFT(ind%PCG_B,ind%FFT_cleanB,ind%B,ind%Bstar,ind%Bnm1,&
           ind%phi,F,Fnm1,ind%m,TMP,ind%temp_F1,ind%L,ind%temp_CC,&
           EF%unsteady_0D%export_now)
         case default; stop 'Error: bad solveBMethod input solve_induction in induction.f90'
         end select
         if (SP%SCP%embed_B_interior) call embedFace(ind%B,ind%B_interior,ind%MD_sigma)
         enddo
         ! ********************* POST SOLUTION COMPUTATIONS *********************
         call compute_J_ind(ind,SP)
         call compute_Btot(ind,SP)
         call compute_JCrossB_ind(ind,SP)
         call compute_stresses_ind(ind,SP)
       end subroutine

       subroutine compute_Btot(ind,SP)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         if (SP%SCP%finite_Rem) then
           call add(ind%Btot,ind%B0,ind%B)
         else
           call assign(ind%Btot,ind%B0)
         endif
       end subroutine

       subroutine export_unsteady_ind(ind,SP,TMP,EF,EN,DT)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(inout) :: SP
         type(time_marching_params),intent(inout) :: TMP
         type(export_frequency),intent(in) :: EF
         type(export_now),intent(in) :: EN
         type(dir_tree),intent(in) :: DT
         if (EF%unsteady_0D%export_now) call export_unsteady_0D(ind,SP,TMP)
         if (EF%unsteady_1D%export_now) call export_unsteady_1D(ind,SP,TMP,DT)
         if (EF%unsteady_2D%export_now) call export_unsteady_2D(ind,SP,TMP,DT)
         if (EF%unsteady_3D%export_now) call export_unsteady_3D(ind,SP,TMP,DT)
         if (EF%info%export_now) call print(ind,SP)
         if (EF%final_solution%export_now.or.EN%B%this.or.EN%all%this) then
           ! call export(ind,str(DT%governing_equations),'ind')
           call export_tec(ind,SP,DT)
         endif
       end subroutine

       subroutine compute_export_E_M_budget(ind,SP,U,DT)
         implicit none
         type(induction),intent(inout) :: ind
         type(sim_params),intent(in) :: SP
         type(VF),intent(in) :: U
         type(dir_tree),intent(in) :: DT
         write(*,*) '       MAGNETIC ENERGY BUDGET - STARTED'
         call E_M_Budget_wrapper(DT,U,ind%B,ind%Bnm1,ind%B0,ind%B0,ind%J,ind%m,&
         ind%MD_fluid,ind%MD_sigma,SP%DP,SP%VS%B%TMP,SP%MP)
         write(*,*) '       MAGNETIC ENERGY BUDGET - COMPLETE'
       end subroutine

       end module
       module momentum_extend_mod
       use momentum_mod
       use current_precision_mod

       use sim_params_mod
       use boundary_conditions_extend_mod
       use block_extend_mod
       use BC_funcs_mod
       use mesh_extend_mod
       use SF_extend_mod
       use VF_extend_mod
       use TF_extend_mod
       use mesh_domain_extend_mod
       use string_mod
       use path_extend_mod
       use path_extend_mod
       use dir_tree_mod
       use RK_Params_mod

       use time_marching_methods_mod
       use momentum_aux_mod
       use init_P_BCs_mod
       use init_Ustar_field_mod
       use init_U_BCs_mod
       use init_U_Field_mod
       use init_P_Field_mod
       use matrix_free_params_mod
       use matrix_free_operators_mod
       use datatype_conversion_mod
       use time_statistics_extend_mod

       use IO_tools_mod
       use IO_export_mod
       use IO_import_mod
       use export_raw_processed_mod
       use import_raw_mod
       use export_raw_processed_symmetry_mod
       use export_processed_FPL_mod
       use export_frequency_mod
       use export_now_mod

       use norms_extend_mod
       use ops_norms_mod
       use ops_del_mod
       use ops_aux_mod
       use ops_interp_mod
       use ops_discrete_mod
       use ops_embedExtract_mod

       use apply_BCs_mod
       use boundary_conditions_mod
       use clean_divergence_mod

       use iter_solver_params_mod
       use time_marching_params_mod

       use probe_mod
       use probe_extend_mod
       use ops_norms_mod

       use PCG_solver_extend_mod
       use FFT_solver_extend_mod
       use preconditioners_mod
       use E_K_Budget_mod


       implicit none
       private

       public :: momentum
       public :: init,delete,display,print,export,import ! Essentials

       public :: solve,export_tec,compute_export_E_K_Budget
       public :: export_unsteady
       public :: set_necessary_for_restart

       interface init;                      module procedure init_mom;                      end interface
       interface display;                   module procedure display_momentum;              end interface
       interface print;                     module procedure print_momentum;                end interface

       interface export_tec;                module procedure export_tec_momentum;           end interface
       interface solve;                     module procedure solve_momentum;                end interface

       interface export_unsteady;           module procedure export_unsteady_mom;           end interface
       interface export_unsteady_0D;        module procedure export_unsteady_0D_mom;        end interface
       interface export_unsteady_1D;        module procedure export_unsteady_1D_mom;        end interface
       interface export_unsteady_2D;        module procedure export_unsteady_2D_mom;        end interface
       interface export_unsteady_3D;        module procedure export_unsteady_3D_mom;        end interface
       interface set_necessary_for_restart; module procedure set_necessary_for_restart_mom; end interface

       contains

       ! **********************************************************
       ! ********************* ESSENTIALS *************************
       ! **********************************************************

       subroutine init_mom(mom,SP,DT)
         implicit none
         type(momentum),intent(inout) :: mom
         type(sim_params),intent(in) :: SP
         type(dir_tree),intent(in) :: DT
         type(TF) :: TF_Face
         integer :: temp_unit
         write(*,*) 'Initializing momentum:'

         call init_Edge(mom%U_E       ,mom%m,0.0_cp)
         call init_Face(mom%U         ,mom%m,0.0_cp)
         call init_Face(mom%Unm1      ,mom%m,0.0_cp)
         call init_Face(mom%temp_F1   ,mom%m,0.0_cp)
         call init_Face(mom%temp_F2   ,mom%m,0.0_cp)
         call init_Face(mom%F         ,mom%m,0.0_cp)
         call init_Face(mom%Fnm1      ,mom%m,0.0_cp)
         call init_Face(mom%L         ,mom%m,0.0_cp)
         call init_Face(mom%temp_F3   ,mom%m,0.0_cp)
         call init_Edge(mom%temp_E    ,mom%m,0.0_cp)
         call init_CC(mom%p           ,mom%m,0.0_cp)
         call init_CC(mom%divU        ,mom%m,0.0_cp)
         call init_CC(mom%U_CC        ,mom%m,0.0_cp)
         call init_CC(mom%temp_CC     ,mom%m,0.0_cp)
         call init_CC(mom%temp_CC_VF  ,mom%m,0.0_cp)
         call init_CC(mom%TF_CC       ,mom%m,0.0_cp)
         call init_CC_Edge(mom%TF_CC_edge,mom%m,0.0_cp)

         write(*,*) '     Fields allocated'
         ! Initialize U-field, P-field and all BCs
         write(*,*) '     About to define U_BCs'
         call init_U_BCs(mom%U,mom%m,SP)
         call update_BC_vals(mom%U)
         write(*,*) '     U_BCs defined'
         call init_P_BCs(mom%p,mom%m,SP)
         call update_BC_vals(mom%p)
         write(*,*) '     BCs initialized'
         if (SP%VS%U%SS%solve) call export_BCs(mom%p,str(DT%p%BCs),'p')
         if (SP%VS%U%SS%solve) call export_BCs(mom%U,str(DT%U%BCs),'U')
         write(*,*) '     BCs exported'
         ! if (SP%VS%U%SS%solve) call print_BCs(mom%U,'U')
         ! if (SP%VS%U%SS%solve) call print_BCs(mom%p,'p')

         call init_U_field(mom%U,mom%m,SP)
         call init_P_field(mom%p,mom%m,SP)
         call assign(mom%Unm1,mom%U)
         write(*,*) '     Field initialized'

         call apply_BCs(mom%p)
         write(*,*) '     P BCs applied'
         call apply_BCs(mom%U)
         write(*,*) '     U BCs applied'
         call export_processed(mom%m,mom%U,str(DT%U%field),'U_IC',1)
         call export_processed(mom%m,mom%P,str(DT%P%field),'P_IC',1)

         call init(mom%Ustar,mom%U)
         if (SP%VS%U%SS%prescribed_BCs) call set_prescribed_BCs(mom%Ustar)
         call init_Ustar_field(mom%Ustar,mom%U)
         write(*,*) '     Intermediate field initialized'

         call init(mom%TS,mom%m,mom%U,SP%TSP,SP%VS%U%TMP,str(DT%U%stats),'U')
         write(*,*) '     momentum time statistics initialized'

         ! Initialize interior solvers
         call init(mom%PCG_U,mom_diffusion,mom_diffusion_explicit,prec_mom_VF,mom%m,&
         SP%VS%U%ISP,SP%VS%U%MFP,mom%Ustar,mom%U,mom%TF_CC_edge,str(DT%U%residual),'U',.false.,.false.)
         write(*,*) '     PCG solver initialized for U'

         call delete(TF_Face)
         call init_Face(TF_Face,mom%m,0.0_cp)
         call init(mom%PCG_P,Lap_uniform_SF,Lap_uniform_SF_explicit,prec_lap_SF,mom%m,&
         SP%VS%P%ISP,SP%VS%P%MFP,mom%p,mom%p,TF_Face,str(DT%p%residual),'p',.false.,.false.)
         call delete(TF_Face)
         write(*,*) '     PCG solver initialized for p'

         call init(mom%FFT_P,mom%p,mom%m,SP%GP%FFT_dir,'FFT_p')
         write(*,*) '     FFT solver initialized for p'

         temp_unit = new_and_open(str(DT%params),'info_mom')
         call display(mom,SP,temp_unit)
         call close_and_message(temp_unit,str(DT%params),'info_mom')
         call face2CellCenter(mom%U_CC,mom%U,mom%m)  ! Needed after import
         call face2edge_no_diag(mom%U_E,mom%U,mom%m) ! Needed after import
         write(*,*) '     Solver settings initialized'
         write(*,*) '     Finished'
         write(*,*) ''
       end subroutine

       subroutine display_momentum(mom,SP,un)
         implicit none
         type(momentum),intent(in) :: mom
         type(sim_params),intent(in) :: SP
         integer,intent(in) :: un
         if (SP%FCL%export_heavy) then
           write(un,*) '**********************************************************'
           write(un,*) '************************ MOMENTUM ************************'
           write(un,*) '**********************************************************'
           write(un,*) 'Re,Ha = ',SP%DP%Re,SP%DP%Ha
           write(un,*) 'N,Gr = ',SP%DP%N,SP%DP%Gr
           ! write(un,*) 'flow_rate = ',plane_sum_x(mom%U%x%BF(1)%GF,mom%m%B(1)%g,2,1.0_cp)/SP%DP%Re
           write(un,*) 't,dt = ',SP%VS%U%TMP%t,SP%VS%U%TMP%TS%dt
           write(un,*) 'solveUMethod,N_mom,N_PPE = ',SP%VS%U%SS%solve_method,&
           SP%VS%U%ISP%EC%iter_max,SP%VS%P%ISP%EC%iter_max
           write(un,*) 'tol_mom,tol_PPE = ',SP%VS%U%ISP%EC%tol_rel,SP%VS%P%ISP%EC%tol_rel
           write(un,*) 'nstep,KE = ',SP%VS%U%TMP%n_step,get_data(SP%PS_mom%probe_KE)
           if (mom%TS%TSP%collect) call display(mom%TS%TSP,un)
           ! call displayPhysicalMinMax(mom%U,'U',un)
           call displayPhysicalMinMax(mom%divU,'divU',un)
           write(un,*) 'CFL = ',CFL_number(mom%U_CC,mom%m,SP%VS%U%TMP%TS%dt)
           write(un,*) ''
           ! call display(mom%m,un)
         endif
       end subroutine

       subroutine print_momentum(mom,SP)
         implicit none
         type(momentum),intent(in) :: mom
         type(sim_params),intent(in) :: SP
         call display(mom,SP,6)
       end subroutine

       subroutine set_necessary_for_restart_mom(mom)
         implicit none
         type(momentum),intent(inout) :: mom
         call set_necessary_for_restart(mom%U)
         call set_necessary_for_restart(mom%Ustar)
         call set_necessary_for_restart(mom%Unm1)
         call set_necessary_for_restart(mom%p)
         call set_necessary_for_restart(mom%F)
         call set_necessary_for_restart(mom%Fnm1)
         call set_necessary_for_restart(mom%L)
         call set_necessary_for_restart(mom%PCG_U%r)
         call set_necessary_for_restart(mom%PCG_P%r)
         call set_necessary_for_restart(mom%PCG_U%p)
         call set_necessary_for_restart(mom%PCG_P%p)
         call set_necessary_for_restart(mom%PCG_U%x_BC)
         call set_necessary_for_restart(mom%PCG_P%x_BC)
       end subroutine

       ! **********************************************************
       ! **********************************************************
       ! **********************************************************

       subroutine export_tec_momentum(mom,SP,DT)
         implicit none
         type(momentum),intent(inout) :: mom
         type(sim_params),intent(in) :: SP
         type(dir_tree),intent(in) :: DT
         if (SP%FCL%restart_all.and.(.not.SP%VS%U%SS%solve)) then
           ! This preserves the initial data
         else
           write(*,*) 'export_tec_momentum at n_step = ',SP%VS%U%TMP%n_step
           call export_processed(mom%m,mom%U,str(DT%U%field),'U',1)
           if (.not.SP%EL%export_soln_only) then
             call export_processed(mom%m,mom%p,str(DT%p%field),'p',1)
             call export_raw(mom%m,mom%divU,str(DT%U%field),'divU',0)
             call export_raw(mom%m,mom%p,str(DT%P%field),'p',0)
             if (SP%EL%export_symmetric) then
               call export_processed(mom%m,mom%U,str(DT%U%field),'U',1,SP%MP)
               call export_processed(mom%m,mom%p,str(DT%p%field),'p',1,SP%MP)
             endif
             write(*,*) '     finished'
           endif
         endif
       end subroutine

       subroutine export_unsteady_0D_mom(mom,SP,TMP)
         implicit none
         type(momentum),intent(inout) :: mom
         type(sim_params),intent(inout) :: SP
         type(time_marching_params),intent(in) :: TMP
         real(cp) :: temp,scale
         scale = SP%DP%KE_scale

         call compute_TKE(temp,mom%U_CC,mom%m,scale)
         call export(SP%PS_mom%probe_KE,TMP,temp)

         if (SP%FCL%compute_surface_power) then
         call surface_power(temp,mom%U,mom%m,mom%temp_F1,mom%temp_F2,mom%temp_CC_VF,mom%TF_CC)
         temp = scale*temp/SP%DP%Re
         call export(SP%PS_mom%probe_Q,TMP,temp)
         endif

         call export(SP%PS_mom%amax_U_x,TMP,amax(mom%U%x))
         call export(SP%PS_mom%amax_U_y,TMP,amax(mom%U%y))
         call export(SP%PS_mom%amax_U_z,TMP,amax(mom%U%z))

         if (mom%m%MP%plane_any) then
         if (mom%m%MP%plane(1)) call compute_TKE_2C(temp,mom%U_CC%y,mom%U_CC%z,mom%m,scale,mom%temp_CC)
         if (mom%m%MP%plane(2)) call compute_TKE_2C(temp,mom%U_CC%x,mom%U_CC%z,mom%m,scale,mom%temp_CC)
         if (mom%m%MP%plane(3)) call compute_TKE_2C(temp,mom%U_CC%x,mom%U_CC%y,mom%m,scale,mom%temp_CC)
         call export(SP%PS_mom%probe_KE_2C,TMP,temp)
         endif
         call div(mom%divU,mom%U,mom%m)
         call compute_Ln(temp,mom%divU,2.0_cp,mom%m)
         call export(SP%PS_mom%probe_divU,TMP,temp)
       end subroutine

       subroutine export_unsteady_1D_mom(mom,SP,TMP,DT)
         implicit none
         type(momentum),intent(inout) :: mom
         type(sim_params),intent(in) :: SP
         type(time_marching_params),intent(in) :: TMP
         type(dir_tree),intent(in) :: DT
         call export_processed(mom%m,mom%U,str(DT%U%unsteady),'U',1,TMP,SP%VS%U%unsteady_lines)
         call export_processed(mom%m,mom%p,str(DT%P%unsteady),'p',1,TMP,SP%VS%P%unsteady_lines)
       end subroutine

       subroutine export_unsteady_2D_mom(mom,SP,TMP,DT)
         implicit none
         type(momentum),intent(inout) :: mom
         type(sim_params),intent(in) :: SP
         type(time_marching_params),intent(in) :: TMP
         type(dir_tree),intent(in) :: DT
         call export_processed(mom%m,mom%U%x,str(DT%U%unsteady),'u',1,TMP,SP%VS%U%unsteady_planes)
         call export_processed(mom%m,mom%p,str(DT%P%unsteady),'p',1,TMP,SP%VS%P%unsteady_planes)
       end subroutine

       subroutine export_unsteady_3D_mom(mom,SP,TMP,DT)
         implicit none
         type(momentum),intent(inout) :: mom
         type(sim_params),intent(in) :: SP
         type(time_marching_params),intent(in) :: TMP
         type(dir_tree),intent(in) :: DT
         call export_processed(mom%m,mom%U,str(DT%U%unsteady),'U',1,TMP,SP%VS%U%unsteady_field)
         call export_processed(mom%m,mom%p,str(DT%P%unsteady),'p',1,TMP,SP%VS%P%unsteady_field)
       end subroutine

       ! ******************* SOLVER ****************************

       subroutine solve_momentum(mom,SP,F,Fnm1,L,TMP,EF)
         implicit none
         type(momentum),intent(inout) :: mom
         type(sim_params),intent(in) :: SP
         type(VF),intent(in) :: F,Fnm1,L
         type(export_frequency),intent(in) :: EF
         type(time_marching_params),intent(inout) :: TMP
         integer :: i
         do i=1,TMP%multistep_iter
         select case(SP%VS%U%SS%solve_method)
         case (1)
           call Euler_time_no_diff_Euler_sources_no_correction(mom%U,mom%Ustar,F,TMP)
         case (2)
           call Euler_time_no_diff_AB2_sources_no_correction(mom%U,mom%Ustar,F,Fnm1,TMP)
         case (3)
           call Euler_time_no_diff_Euler_sources(mom%PCG_P,mom%U,mom%Ustar,mom%Unm1,mom%p,&
           F,mom%m,TMP,mom%temp_F1,mom%temp_CC,EF%unsteady_0D%export_now)
         case (4)
           call Euler_time_no_diff_AB2_sources(mom%PCG_P,mom%U,mom%Ustar,mom%Unm1,mom%p,&
           F,Fnm1,mom%m,TMP,mom%temp_F1,mom%temp_CC,EF%unsteady_0D%export_now)
         case (5)
           call Euler_time_Euler_sources(mom%PCG_U,mom%PCG_P,mom%U,mom%Ustar,mom%Unm1,&
           mom%p,F,mom%m,TMP,mom%temp_F1,mom%temp_CC,&
           EF%unsteady_0D%export_now)
         case (6)
           call Euler_time_AB2_sources(mom%PCG_U,mom%PCG_P,mom%U,mom%Ustar,mom%Unm1,&
           mom%p,F,Fnm1,mom%m,TMP,mom%temp_F1,mom%L,mom%temp_CC,&
           EF%unsteady_0D%export_now)
         case (7)
           call O2_BDF_time_AB2_sources(mom%PCG_U,mom%PCG_P,mom%U,mom%Ustar,&
           mom%Unm1,mom%p,F,Fnm1,mom%m,TMP,mom%temp_F1,mom%temp_CC,&
           EF%unsteady_0D%export_now)
         case (8)
           call Euler_time_RK_sources(mom%PCG_U,mom%PCG_P,mom%U,mom%Ustar,mom%Unm1,&
           mom%p,F,Fnm1,L,mom%m,TMP,TMP%RKP,mom%temp_F1,mom%temp_CC,&
           EF%unsteady_0D%export_now)
         case (9)
           call Euler_time_AB2_sources_FFT(mom%PCG_U,mom%FFT_P,mom%U,mom%Ustar,mom%Unm1,&
           mom%p,F,Fnm1,mom%m,TMP,mom%temp_F1,mom%L,mom%temp_CC,&
           EF%unsteady_0D%export_now)
         case default; stop 'Error: solveUMethod must = 1:4 in momentum.f90.'
         end select
         enddo
         ! ********************* POST SOLUTION COMPUTATIONS *********************
         call face2CellCenter(mom%U_CC,mom%U,mom%m)
         ! U at cell edge is needed for advection term at next time step
         ! and in induction solver. Neither case requires the diagonal.
         call face2edge_no_diag(mom%U_E,mom%U,mom%m)
       end subroutine

       subroutine export_unsteady_mom(mom,SP,TMP,EF,EN,DT)
         implicit none
         type(momentum),intent(inout) :: mom
         type(sim_params),intent(inout) :: SP
         type(export_frequency),intent(in) :: EF
         type(export_now),intent(in) :: EN
         type(dir_tree),intent(in) :: DT
         type(time_marching_params),intent(inout) :: TMP
         if (EF%unsteady_0D%export_now) call export_unsteady_0D(mom,SP,TMP)
         if (EF%unsteady_1D%export_now) call export_unsteady_1D(mom,SP,TMP,DT)
         if (EF%unsteady_2D%export_now) call export_unsteady_2D(mom,SP,TMP,DT)
         if (EF%unsteady_3D%export_now) call export_unsteady_3D(mom,SP,TMP,DT)
         if (EF%info%export_now) call print(mom,SP)
         if (EF%final_solution%export_now.or.EN%U%this.or.EN%all%this) then
           call export_tec(mom,SP,DT)
         endif
       end subroutine

       subroutine compute_export_E_K_Budget(mom,SP,B,B0,J,MD_fluid,DT)
         implicit none
         type(momentum),intent(inout) :: mom
         type(sim_params),intent(in) :: SP
         type(dir_tree),intent(in) :: DT
         type(mesh_domain),intent(in) :: MD_fluid
         type(VF),intent(in) :: B,B0,J
         write(*,*) '       KINETIC ENERGY BUDGET - STARTED'
         call E_K_Budget_wrapper(DT,mom%U,mom%Unm1,&
         B,B0,J,mom%p,mom%m,SP%VS%U%TMP,SP%DP,SP%MP,MD_fluid)
         write(*,*) '       KINETIC ENERGY BUDGET - COMPLETE'
       end subroutine

       end module
       module MOONS_config_mod
       use current_precision_mod
       use IO_tools_mod
       use IO_import_mod
       use IO_export_mod
       use inquire_funcs_mod
       use matrix_visualization_mod
       use dir_manip_mod

       use version_mod
       use mesh_extend_mod
       use mesh_domain_extend_mod
       use generate_mesh_generic_mod
       use VF_extend_mod
       use string_mod
       use path_extend_mod
       use dir_tree_extend_mod
       use var_set_extend_mod
       use export_analytic_mod
       use mirror_props_mod
       use export_mesh_aux_mod

       use iter_solver_params_mod
       use time_marching_params_mod
       use sim_params_mod
       use sim_params_aux_mod
       use sim_params_extend_mod
       use export_raw_processed_symmetry_mod
       use export_raw_processed_mod
       use import_raw_mod
       use ops_mirror_field_mod

       use stop_clock_extend_mod
       use kill_switch_extend_mod
       use export_frequency_extend_mod
       use export_now_extend_mod
       use export_safe_extend_mod

       use energy_extend_mod
       use momentum_extend_mod
       use induction_extend_mod
       use MOONS_mod

       implicit none

       private
       public :: config
       interface config;         module procedure config_MOONS;         end interface

       contains

       subroutine config_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         write(*,*) ' ************** STARTED CONFIGURING MOONS ************** '
         call delete_file('','mesh_generation_error')
#ifdef fopenmp
         call omp_set_num_threads(12) ! Set number of openMP threads

#endif
         if (file_exists(str(M%C%DT%restart1),'primitives')) then
           write(*,*) 'Restarting from ',str(M%C%DT%restart1)
           call import_structured(M%C,str(M%C%DT%restart1))
           call init(M%C%DT%restart,M%C%DT%restart1)
           M%C%SP%FCL%restart_all = .true.
         elseif (file_exists(str(M%C%DT%restart2),'primitives')) then
           write(*,*) 'Restarting from ',str(M%C%DT%restart2)
           call import_structured(M%C,str(M%C%DT%restart2))
           call init(M%C%DT%restart,M%C%DT%restart2)
           M%C%SP%FCL%restart_all = .true.
         else
           call init(M%C%SP)
         endif
         call display_compiler_info(str(M%C%DT%params),'compiler_info')
         call print_version()
         call export_version(str(M%C%DT%LDC))
         call init(M%C%sc,str(M%C%DT%wall_clock),'WALL_CLOCK_TIME_INFO')
         call config_probes(M)
         write(*,*) ' ************** FINISHED CONFIGURING MOONS ************* '
       end subroutine

       subroutine config_probes(M)
         implicit none
         type(MOONS),intent(inout) :: M
         logical :: L
         logical,parameter :: T = .true.
         logical,parameter :: F = .false.
         write(*,*) ' ************* STARTED CONFIGURING PROBES ************** '
         L = M%C%SP%FCL%restart_all

         if (M%C%SP%VS%U%SS%initialize) then
           call init(M%C%SP%PS_mom%amax_U_x   ,str(M%C%DT%U%local),'amax(u)', L,T,M%C%SP%VS%U%TMP)
           call init(M%C%SP%PS_mom%amax_U_y   ,str(M%C%DT%U%local),'amax(v)', L,T,M%C%SP%VS%U%TMP)
           call init(M%C%SP%PS_mom%amax_U_z   ,str(M%C%DT%U%local),'amax(w)', L,T,M%C%SP%VS%U%TMP)
           call init(M%C%SP%PS_mom%probe_divU ,str(M%C%DT%U%residual),'probe_divU',L,.true. ,M%C%SP%VS%U%TMP)
           call init(M%C%SP%PS_mom%probe_KE   ,str(M%C%DT%U%energy)  ,'KE'        ,L,.false.,M%C%SP%VS%U%TMP)
           call init(M%C%SP%PS_mom%probe_Q    ,str(M%C%DT%U%energy)  ,'probe_Q'   ,L,.true. ,M%C%SP%VS%U%TMP)
           write(*,*) '     Momentum probes initialized'
         endif

         if (M%C%SP%VS%B%SS%initialize) then
           call init(M%C%SP%PS_ind%probe_dB0dt(1),str(M%C%DT%B%local),'amax(dB0dt)_x',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_dB0dt(2),str(M%C%DT%B%local),'amax(dB0dt)_y',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_dB0dt(3),str(M%C%DT%B%local),'amax(dB0dt)_z',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_B0(1)  ,str(M%C%DT%B%local),'amax(B0)_x',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_B0(2)  ,str(M%C%DT%B%local),'amax(B0)_y',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_B0(3)  ,str(M%C%DT%B%local),'amax(B0)_z',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_B1(1)  ,str(M%C%DT%B%local),'amax(B1)_x',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_B1(2)  ,str(M%C%DT%B%local),'amax(B1)_y',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_B1(3)  ,str(M%C%DT%B%local),'amax(B1)_z',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_Btot(1),str(M%C%DT%B%local),'amax(Btot)_x', L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_Btot(2),str(M%C%DT%B%local),'amax(Btot)_y', L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_Btot(3),str(M%C%DT%B%local),'amax(Btot)_z', L,T,M%C%SP%VS%B%TMP)

           call init(M%C%SP%PS_ind%amax_JxB     ,str(M%C%DT%jCrossB%energy),'amax(JxB)',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_JxB_x   ,str(M%C%DT%jCrossB%energy),'amax(JxB)_x', L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_JxB_y   ,str(M%C%DT%jCrossB%energy),'amax(JxB)_y', L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_JxB_z   ,str(M%C%DT%jCrossB%energy),'amax(JxB)_z', L,T,M%C%SP%VS%B%TMP)

           call init(M%C%SP%PS_ind%amax_stress_xx,str(M%C%DT%stresses%local),&
            'amax(stress)_xx',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_xy,str(M%C%DT%stresses%local),&
            'amax(stress)_xy',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_xz,str(M%C%DT%stresses%local),&
            'amax(stress)_xz',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_yx,str(M%C%DT%stresses%local),&
            'amax(stress)_yx',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_yy,str(M%C%DT%stresses%local),&
            'amax(stress)_yy',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_yz,str(M%C%DT%stresses%local),&
            'amax(stress)_yz',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_zx,str(M%C%DT%stresses%local),&
            'amax(stress)_zx',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_zy,str(M%C%DT%stresses%local),&
            'amax(stress)_zy',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_zz,str(M%C%DT%stresses%local),&
            'amax(stress)_zz',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_walls_xx,str(M%C%DT%stresses%local),&
            'amax(stress_walls)_xx',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_walls_xy,str(M%C%DT%stresses%local),&
            'amax(stress_walls)_xy',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_walls_xz,str(M%C%DT%stresses%local),&
            'amax(stress_walls)_xz',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_walls_yx,str(M%C%DT%stresses%local),&
            'amax(stress_walls)_yx',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_walls_yy,str(M%C%DT%stresses%local),&
            'amax(stress_walls)_yy',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_walls_yz,str(M%C%DT%stresses%local),&
            'amax(stress_walls)_yz',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_walls_zx,str(M%C%DT%stresses%local),&
            'amax(stress_walls)_zx',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_walls_zy,str(M%C%DT%stresses%local),&
            'amax(stress_walls)_zy',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%amax_stress_walls_zz,str(M%C%DT%stresses%local),&
            'amax(stress_walls)_zz',L,T,M%C%SP%VS%B%TMP)

           call init(M%C%SP%PS_ind%Bx(1)   ,str(M%C%DT%B%energy),'Bx',    L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%By(1)   ,str(M%C%DT%B%energy),'By',    L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%Bz(1)   ,str(M%C%DT%B%energy),'Bz',    L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%Bx(2)   ,str(M%C%DT%B%energy),'B0x',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%By(2)   ,str(M%C%DT%B%energy),'B0y',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%Bz(2)   ,str(M%C%DT%B%energy),'B0z',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%Bx(3)   ,str(M%C%DT%B%energy),'B1x',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%By(3)   ,str(M%C%DT%B%energy),'B1y',   L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%Bz(3)   ,str(M%C%DT%B%energy),'B1z',   L,T,M%C%SP%VS%B%TMP)

           call init(M%C%SP%PS_ind%probe_divB     ,str(M%C%DT%B%residual),'transient_divB',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%probe_divJ     ,str(M%C%DT%J%residual),'transient_divJ',L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%JE             ,str(M%C%DT%J%energy),'JE',            L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%JE_fluid       ,str(M%C%DT%J%energy),'JE_fluid',      L,T,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%ME(1)          ,str(M%C%DT%B%energy),'ME',           L,.false.,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%ME_fluid(1)    ,str(M%C%DT%B%energy),'ME_fluid',     L,.false.,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%ME_conductor(1),str(M%C%DT%B%energy),'ME_conductor', L,.false.,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%ME(2)          ,str(M%C%DT%B%energy),'ME0',          L,.false.,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%ME_fluid(2)    ,str(M%C%DT%B%energy),'ME0_fluid',    L,.false.,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%ME_conductor(2),str(M%C%DT%B%energy),'ME0_conductor',L,.false.,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%ME(3)          ,str(M%C%DT%B%energy),'ME1',          L,.false.,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%ME_fluid(3)    ,str(M%C%DT%B%energy),'ME1_fluid',    L,.false.,M%C%SP%VS%B%TMP)
           call init(M%C%SP%PS_ind%ME_conductor(3),str(M%C%DT%B%energy),'ME1_conductor',L,.false.,M%C%SP%VS%B%TMP)
           write(*,*) '     Induction probes initialized'
         endif

         if (M%C%SP%VS%T%SS%initialize) then
           call init(M%C%SP%PS_nrg%probe_divQ,str(M%C%DT%T%residual),'probe_divQ',L,T,M%C%SP%VS%T%TMP)
           write(*,*) '     Energy probes initialized'
         endif

         write(*,*) ' ************* FINISHED CONFIGURING PROBES ************* '
       end subroutine

       end module
       module MOONS_init_mod
       use current_precision_mod
       use IO_tools_mod
       use IO_import_mod
       use IO_export_mod
       use inquire_funcs_mod
       use matrix_visualization_mod

       use version_mod
       use mesh_extend_mod
       use mesh_domain_extend_mod
       use generate_mesh_generic_mod
       use VF_extend_mod
       use string_mod
       use path_extend_mod
       use dir_tree_extend_mod
       use var_set_extend_mod
       use export_analytic_mod
       use mirror_props_mod
       use export_mesh_aux_mod

       use iter_solver_params_mod
       use time_marching_params_mod
       use sim_params_mod
       use sim_params_aux_mod
       use sim_params_extend_mod
       use export_raw_processed_symmetry_mod
       use export_raw_processed_mod
       use import_raw_mod
       use ops_mirror_field_mod

       use stop_clock_extend_mod
       use kill_switch_extend_mod
       use export_frequency_extend_mod
       use export_now_extend_mod
       use export_safe_extend_mod

       use energy_extend_mod
       use momentum_extend_mod
       use induction_extend_mod
       use MOONS_mod

       implicit none

       private
       public :: init
       interface init;   module procedure init_MOONS;   end interface

       contains

       subroutine init_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         call init_meshes_MOONS(M)
         call init_GEs_MOONS(M)
         call re_init_procedures(M) ! Applied inside init_meshes_MOONS also.
       end subroutine

       subroutine re_init_procedures(M)
         implicit none
         type(MOONS),intent(inout) :: M
         write(*,*) ' ************** STARTED RE-INITIALIZING PROCEDURES ************* '
         if (M%C%SP%VS%U%SS%initialize) then; call init_props(M%GE%mom%m); call patch(M%GE%mom%m); endif
         if (M%C%SP%VS%B%SS%initialize) then; call init_props(M%GE%ind%m); call patch(M%GE%ind%m); endif
         if (M%C%SP%VS%U%SS%initialize) then; call init_apply_BC_order(M%GE%mom%m,M%C%SP%GP%apply_BC_order); endif
         if (M%C%SP%VS%B%SS%initialize) then; call init_apply_BC_order(M%GE%ind%m,M%C%SP%GP%apply_BC_order); endif

         if (M%C%SP%VS%U%SS%initialize.and.M%C%SP%VS%B%SS%initialize) then
           call init(M%GE%ind%MD_fluid,M%GE%mom%m,M%GE%ind%m)
           call init(M%GE%ind%MD_sigma,M%GE%ind%m_sigma,M%GE%ind%m)
           call init_props(M%GE%ind%MD_fluid%m_R1); call patch(M%GE%ind%MD_fluid%m_R1)
           call init_props(M%GE%ind%MD_fluid%m_R2); call patch(M%GE%ind%MD_fluid%m_R2)
           call init_props(M%GE%ind%MD_sigma%m_R1); call patch(M%GE%ind%MD_sigma%m_R1)
           call init_props(M%GE%ind%MD_sigma%m_R2); call patch(M%GE%ind%MD_sigma%m_R2)
         endif
         write(*,*) ' ************** FINISHED RE-INITIALIZING PROCEDURES ************ '
       end subroutine

       subroutine init_meshes_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         write(*,*) ' ***************** STARTED INITIALIZING MESHES ***************** '

         call generate_mesh_generic(M%GE%mom%m,M%C%SP%MP_mom,M%C%SP%DP,'momentum in MOONS.f90')
         call generate_mesh_generic(M%GE%ind%m_sigma,M%C%SP%MP_sigma,M%C%SP%DP,'sigma in MOONS.f90')
         call generate_mesh_generic(M%GE%ind%m,M%C%SP%MP_ind,M%C%SP%DP,'induction in MOONS.f90')

         call re_init_procedures(M)

         call export_mesh_aux(M%C%SP,M%C%DT,M%GE%mom%m,M%GE%ind%m)

         ! ******************** EXPORT GRIDS **************************** Export mesh (to plot)
         if (M%C%SP%EL%export_meshes) then
           call export_mesh(M%GE%mom%m,str(M%C%DT%meshes),'m_mom',1)
           call export_mesh(M%GE%ind%m,str(M%C%DT%meshes),'m_ind',1)
           call export_mesh(M%GE%ind%m_sigma,str(M%C%DT%meshes),'m_sigma',1)

           if (M%C%SP%MP%mirror) then
             call mirror_mesh(M%m_temp,M%GE%mom%m,M%C%SP%MP)
             call export_mesh(M%m_temp,str(M%C%DT%meshes),'m_mom_mirror',1)
             call mirror_mesh(M%m_temp,M%GE%ind%m,M%C%SP%MP)
             call export_mesh(M%m_temp,str(M%C%DT%meshes),'m_ind_mirror',1)
             call mirror_mesh(M%m_temp,M%GE%ind%m_sigma,M%C%SP%MP)
             call export_mesh(M%m_temp,str(M%C%DT%meshes),'m_sigma_mirror',1)
             call delete(M%m_temp)
           endif
         endif

         if (file_exists('','mesh_generation_error')) then
           stop 'Error: non-converged mesh, inspect mesh.'
         endif

         if (M%C%SP%FCL%stop_after_mesh_export) then
           stop 'Exported meshes. Turn off stop_after_mesh_export in sim_params.f90 to run sim.'
         endif
         write(*,*) ' ***************** FINISHED INITIALIZING MESHES **************** '
       end subroutine

       subroutine init_GEs_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         write(*,*) ' ********** STARTED INITIALIZING GOVERNING EQUATIONS *********** '

         if (M%C%SP%VS%T%SS%initialize) call init(M%GE%nrg,M%C%SP,M%C%DT)
         if (M%C%SP%VS%U%SS%initialize) call init(M%GE%mom,M%C%SP,M%C%DT)
         if (M%C%SP%VS%B%SS%initialize) call init(M%GE%ind,M%C%SP,M%C%DT)

         ! ********************* EXPORT RAW ICs *************************

         if (M%C%SP%EL%export_ICs.and.M%C%SP%VS%T%SS%initialize) call export_tec(M%GE%nrg,M%C%SP,M%C%DT)
         if (M%C%SP%EL%export_ICs.and.M%C%SP%VS%U%SS%initialize) call export_tec(M%GE%mom,M%C%SP,M%C%DT)
         if (M%C%SP%EL%export_ICs.and.M%C%SP%VS%B%SS%initialize) call export_tec(M%GE%ind,M%C%SP,M%C%DT)

         if (M%C%SP%FCL%print_mesh_before_solve) then
           if (M%C%SP%VS%T%SS%initialize) call print(M%GE%nrg%m)
           if (M%C%SP%VS%U%SS%initialize) call print(M%GE%mom%m)
           if (M%C%SP%VS%B%SS%initialize) call print(M%GE%ind%m)
         endif

         ! ******************** PREP TIME START/STOP ********************

         call init(M%C%ES,M%C%SP%SCP%export_safe_period)

         if (M%C%SP%FCL%export_heavy) then
           write(*,*) 'Working directory = ',str(M%C%DT%tar)
         endif

         if (M%C%SP%FCL%stop_before_solve) then
           stop 'Exported ICs. Turn off stop_before_solve in sim_params.f90 to run sim.'
         endif
         write(*,*) ' ********** FINISHED INITIALIZING GOVERNING EQUATIONS ********** '
       end subroutine

       end module
       module MOONS_solver_mod
       use current_precision_mod
       use sim_params_mod
       use var_set_extend_mod
       use VF_extend_mod
       use IO_tools_mod
       use string_mod
       use path_extend_mod
       use dir_tree_mod
       use stop_clock_extend_mod
       use export_frequency_mod
       use export_frequency_extend_mod
       use export_now_mod
       use export_now_extend_mod
       use export_safe_extend_mod
       use kill_switch_mod
       use kill_switch_extend_mod
       use probe_extend_mod
       use RK_Params_mod
       use time_statistics_extend_mod

       use time_marching_params_mod
       use time_marching_params_extend_mod
       use add_all_energy_sources_mod
       use add_all_momentum_sources_mod
       use add_all_induction_sources_mod
       use momentum_sources_mod
       use induction_sources_mod
       use induction_aux_mod
       use ops_interp_mod
       use energy_extend_mod
       use momentum_extend_mod
       use induction_extend_mod
       use momentum_sources_mod
       use MOONS_export_full_restart_mod
       use MOONS_simulate_crash_mod
       use MOONS_IO_controls_mod
       use MOONS_mod
       implicit none

       private
       public :: solve
       interface solve;   module procedure solve_MOONS;    end interface

       contains

       subroutine solve_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         integer :: i_RK
         call compute_J_ind(M%GE%ind,M%C%SP)
         call face2CellCenter(M%GE%mom%U_CC,M%GE%mom%U,M%GE%mom%m)
         call face2edge_no_diag(M%GE%mom%U_E,M%GE%mom%U,M%GE%mom%m)
         call update(M%C%SP%EF,M%C%SP%coupled,.false.)
         call MOONS_export_controls(M)
         if (M%C%SP%VS%T%SS%solve) call export_unsteady(M%GE%nrg,M%C%SP,M%C%SP%VS%T%TMP,M%C%SP%EF,M%C%EN,M%C%DT)
         if (M%C%SP%VS%U%SS%solve) call export_unsteady(M%GE%mom,M%C%SP,M%C%SP%VS%U%TMP,M%C%SP%EF,M%C%EN,M%C%DT)
         if (M%C%SP%VS%B%SS%solve) call export_unsteady(M%GE%ind,M%C%SP,M%C%SP%VS%B%TMP,M%C%SP%EF,M%C%EN,M%C%DT)
         write(*,*) '***************************************************************'
         write(*,*) '****************** ENTERING MAIN LOOP *************************'
         write(*,*) '***************************************************************'
         do while ((.not.M%C%KS%terminate_loop).and.(M%C%SP%coupled%t.lt.M%C%SP%coupled%TS%t_final-M%C%SP%coupled%TS%dt*0.5_cp))

           call tic(M%C%sc)

           call update(M%C%ES,M%C%sc%t_passed)

           if (M%C%SP%FCL%print_every_MHD_step) then
             write(*,*) 'M%C%SP%coupled%n_step = ',M%C%SP%coupled%n_step
           endif
           ! if (M%C%SP%EF%info%export_now) call print(M%C%SP)

           do i_RK=1,M%C%SP%coupled%RKP%n_stages
             call assign_RK_stage(M%C%SP%VS%T%TMP,i_RK)
             call assign_RK_stage(M%C%SP%VS%U%TMP,i_RK)
             call assign_RK_stage(M%C%SP%VS%B%TMP,i_RK)
             call assign_RK_stage(M%C%SP%coupled,i_RK)
             call update(M%C%SP%EF,M%C%SP%coupled,i_RK.ne.M%C%SP%coupled%RKP%n_stages)
             ! if (M%C%SP%VS%rho%SS%solve)    call solve(dens,M%GE%mom%U,  M%C%SP%EF,M%C%EN,M%C%DT)
             if (M%C%SP%VS%T%SS%solve) then
               call add_all_energy_sources(M%GE%nrg%F,M%GE%nrg%Fnm1,M%GE%nrg%L,M%GE%nrg,M%C%SP%VS%U%TMP,M%C%SP,M%GE%ind,M%GE%mom)
               call solve(M%GE%nrg,M%C%SP,M%GE%nrg%F,M%GE%nrg%Fnm1,M%GE%nrg%L,M%C%SP%VS%T%TMP,M%C%SP%EF)
             endif
             if (M%C%SP%VS%U%SS%solve) then
               call add_all_momentum_sources(M%GE%mom%F,M%GE%mom%Fnm1,M%GE%mom%L,M%GE%mom,M%C%SP%VS%U%TMP,M%C%SP,M%GE%ind,M%GE%nrg)
               call solve(M%GE%mom,M%C%SP,M%GE%mom%F,M%GE%mom%Fnm1,M%GE%mom%L,M%C%SP%VS%U%TMP,M%C%SP%EF)
             endif
             if (M%C%SP%VS%B%SS%solve) then
               call add_all_induction_sources(M%GE%ind%F,M%GE%ind%Fnm1,M%GE%ind%L,M%GE%ind,M%C%SP%VS%B%TMP,M%C%SP,M%GE%mom)
               call solve(M%GE%ind,M%C%SP,M%GE%ind%F,M%GE%ind%Fnm1,M%GE%ind%L,M%C%SP%VS%B%TMP,M%C%SP%EF)
             endif
             call iterate_RK(M%C%SP%VS%T%TMP)
             call iterate_RK(M%C%SP%VS%U%TMP)
             call iterate_RK(M%C%SP%VS%B%TMP)
             call iterate_RK(M%C%SP%coupled)
           enddo
           call update(M%C%SP%EF,M%C%SP%coupled,.false.)

           if (M%C%SP%VS%T%SS%solve) call iterate_step(M%C%SP%VS%T%TMP)
           if (M%C%SP%VS%U%SS%solve) call iterate_step(M%C%SP%VS%U%TMP)
           if (M%C%SP%VS%B%SS%solve) call iterate_step(M%C%SP%VS%B%TMP)
           call iterate_step(M%C%SP%coupled)

           if (M%C%ES%export_now) then ! Sync probes with export_structured.
             M%C%SP%EF%unsteady_0D%export_now = .true.
           endif

           if (M%C%SP%VS%T%SS%solve) call export_unsteady(M%GE%nrg,M%C%SP,M%C%SP%VS%T%TMP,M%C%SP%EF,M%C%EN,M%C%DT)
           if (M%C%SP%VS%U%SS%solve) call export_unsteady(M%GE%mom,M%C%SP,M%C%SP%VS%U%TMP,M%C%SP%EF,M%C%EN,M%C%DT)
           if (M%C%SP%VS%B%SS%solve) call export_unsteady(M%GE%ind,M%C%SP,M%C%SP%VS%B%TMP,M%C%SP%EF,M%C%EN,M%C%DT)

           ! Statistics
           call update(M%GE%mom%TS,M%GE%mom%m,M%GE%mom%U,M%C%SP%VS%U%TMP,M%GE%mom%temp_F1,&
           M%GE%mom%temp_CC_VF,M%GE%mom%TF_CC,M%C%SP%EF%unsteady_0D%export_now)

           call toc(M%C%sc,M%C%SP%coupled)

           if (M%C%ES%export_now) then
             call MOONS_export_full_restart(M)
           endif

           call simulate_crash(M)

           call MOONS_import_controls(M)

           call update(M%C%EN,M%C%ES%export_now)
           if (M%C%EN%any_next) call export_structured(M%C%EN) ! May be needed to avoid constant exporting

           if (M%C%SP%EF%info%export_now) then
             if (M%C%SP%FCL%export_heavy) then
               call print(M%C%sc,M%C%SP%coupled)
               write(*,*) 'Working directory = ',str(M%C%DT%tar)
               write(*,*) 'Restart directory = ',str(M%C%DT%restart)
             else
               call print_light(M%C%sc,M%C%SP%coupled)
             endif
             call export(M%C%sc,M%C%SP%coupled%t)
             call import_structured(M%C%KS)
           endif
         enddo
         write(*,*) '***************************************************************'
         write(*,*) '******************* EXITING MAIN LOOP *************************'
         write(*,*) '***************************************************************'
       end subroutine
       end module
       module MOONS_main_mod
       use current_precision_mod
       use IO_tools_mod
       use IO_import_mod
       use IO_export_mod
       use inquire_funcs_mod
       use matrix_visualization_mod

       use version_mod
       use mesh_extend_mod
       use var_set_extend_mod
       use mesh_domain_extend_mod
       use generate_mesh_generic_mod
       use VF_extend_mod
       use string_mod
       use path_extend_mod
       use dir_tree_mod
       use var_set_mod
       use export_analytic_mod
       use mirror_props_mod
       use stop_clock_extend_mod
       use vorticity_streamfunction_mod
       use operator_commute_test_mod
       use Poisson_test_mod
       use Taylor_Green_Vortex_test_mod
       use temporal_convergence_test_mod
       use export_mesh_aux_mod

       use iter_solver_params_mod
       use time_marching_params_mod
       use sim_params_mod
       use sim_params_aux_mod
       use sim_params_extend_mod
       use export_raw_processed_symmetry_mod
       use export_raw_processed_mod
       use import_raw_mod
       use ops_mirror_field_mod

       use energy_extend_mod
       use momentum_extend_mod
       use induction_extend_mod
       use MOONS_export_full_restart_mod
       use MOONS_solver_mod
       use MOONS_mod
       use MOONS_config_mod
       use MOONS_init_mod

       implicit none

       private
       public :: main

       interface main;         module procedure main_MOONS;         end interface
       interface post_process; module procedure post_process_MOONS; end interface
       interface final_export; module procedure final_export_MOONS; end interface

       contains

       subroutine main_MOONS(dir_target)
         implicit none
         type(MOONS) :: M
         character(len=*),intent(in) :: dir_target
         write(*,*) ' ******************** COMPUTATIONS STARTED ********************'
         write(*,*) ' ******************** COMPUTATIONS STARTED ********************'
         write(*,*) ' ******************** COMPUTATIONS STARTED ********************'
         call init(M%C%dir_target,dir_target)
         call init(M%C%DT,str(M%C%dir_target))  ! Initialize + make directory tree
         call config(M) ! The flow control should be uniquely defined after this line.
         call make_IO_dir(M%C,str(M%C%DT%restart))
         call export_structured(M%C)
         call export(M%C,str(M%C%DT%config),'config_original_DO_NOT_EDIT')
         call init(M)
         if (M%C%SP%VS%T%SS%initialize) call set_necessary_for_restart(M%GE%nrg)
         if (M%C%SP%VS%U%SS%initialize) call set_necessary_for_restart(M%GE%mom)
         if (M%C%SP%VS%B%SS%initialize) call set_necessary_for_restart(M%GE%ind)

         if (M%C%SP%FCL%restart_all) then
           call set_IO_dir(M%GE,str(M%C%DT%restart))
           write(*,*) ' ************** STARTED IMPORTING MOONS **************** may take some time...'
           call import_structured(M%GE,str(M%C%DT%restart))
           write(*,*) ' ************** FINISHED IMPORTING MOONS *************** '
         endif

         call make_IO_dir(M%GE,str(M%C%DT%restart)) ! repeat after init so that allocatables populate directory
         call export_structured(M%C)
         if (.not.M%C%SP%FCL%restart_all) then
           call MOONS_prep_full_restart(M)
         endif
         if (.not.M%C%SP%FCL%skip_solver_loop) then
           call solve(M)
         endif
         call final_export(M)
         call post_process(M)
         call delete(M)
         write(*,*) ' ******************** COMPUTATIONS COMPLETE ********************'
         write(*,*) ' ******************** COMPUTATIONS COMPLETE ********************'
         write(*,*) ' ******************** COMPUTATIONS COMPLETE ********************'
         write(*,*) ' ******************** LAST LINE EXECUTED ***********************'
       end subroutine

       subroutine final_export_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         call print(M%C%sc,M%C%SP%coupled)

         if (M%C%SP%FCL%export_final_restart) then
           call MOONS_export_full_restart(M)
         endif

         if (M%C%SP%FCL%export_final_tec) then
           if (M%C%SP%VS%T%SS%initialize) call export_tec(M%GE%nrg,M%C%SP,M%C%DT)
           if (M%C%SP%VS%U%SS%initialize) call export_tec(M%GE%mom,M%C%SP,M%C%DT)
           if (M%C%SP%VS%B%SS%initialize) call export_tec(M%GE%ind,M%C%SP,M%C%DT)
         endif
       end subroutine

       subroutine post_process_MOONS(M)
         implicit none
         type(MOONS),intent(inout) :: M
         write(*,*) ' *********************** POST PROCESSING ***********************'
         write(*,*) ' *********************** POST PROCESSING ***********************'
         write(*,*) ' *********************** POST PROCESSING ***********************'
         if (M%C%SP%FCL%matrix_visualization) then
           call export_matrix_visualization(M%C%DT)
         endif
         if (M%C%SP%FCL%Poisson_test) then
           call Poisson_test(M%GE%mom%U,M%GE%mom%p,M%GE%mom%m,M%C%DT)
         endif
         if (M%C%SP%FCL%export_vorticity_streamfunction) then
           call export_vorticity_streamfunction(M%GE%mom%U,M%GE%mom%m,M%C%DT,M%C%SP)
         endif
         if (M%C%SP%FCL%compute_export_E_K_Budget) then
           call compute_export_E_K_Budget(M%GE%mom,M%C%SP,M%GE%ind%B,M%GE%ind%B0,M%GE%ind%J,M%GE%ind%MD_fluid,M%C%DT)
         endif
         if (M%C%SP%FCL%compute_export_E_M_budget) then
           call compute_export_E_M_budget(M%GE%ind,M%C%SP,M%GE%mom%U,M%C%DT)
         endif
         if (M%C%SP%FCL%export_Shercliff_Hunt_analytic_sol) then
           call export_Shercliff_Hunt_analytic_sol(M%GE%mom%m,M%GE%mom%U%x,M%C%SP%DP%Ha,0.0_cp,-1.0_cp,1,M%C%DT)
         endif
         if (M%C%SP%FCL%export_numerical_flow_rate) then
           call export_numerical_flow_rate(M%GE%mom%m,M%GE%mom%U%x,M%C%SP%DP%Re,M%C%DT)
         endif
         if (M%C%SP%FCL%Taylor_Green_Vortex_test) then
           call Taylor_Green_Vortex_test(M%GE%mom%U,M%GE%mom%p,M%GE%mom%m,M%C%DT,M%C%SP)
         endif
         if (M%C%SP%FCL%temporal_convergence_test) then
           call temporal_convergence_test(M%GE%mom%U,M%GE%mom%p,M%GE%mom%m,M%C%DT,M%C%SP)
         endif
         if (M%C%SP%FCL%operator_commute_test) then
           call operator_commute_test(M%GE%mom%U,M%GE%mom%p,M%GE%mom%m,M%C%DT)
         endif
       end subroutine

       end module